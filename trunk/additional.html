<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>

<head>
	<title>HeidiSQL - additional information file for developers</title>
	<meta name="Content-Language" content="en" />
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
	<meta name="description" content="Additional information file for HeidiSQL developers." />
	<meta name="author" content="Ansgar Becker, David Dindorp" />
	<link rel="stylesheet" type="text/css" href="styles.css" />
</head>

<body>

	<a href="http://www.heidisql.com/" title="Go to project homepage">
		<img src="http://www.heidisql.com/images/heidisql_logo.png" alt="HeidiSQL Logo" />
	</a>

	<h1>HeidiSQL - additional information file for developers</h1>

	<hr />


	<h2 id="contents">Table of contents</h2>
	<ol>
		<li><a href="#basics">Basic information</a></li>
		<li><a href="#gettingstarted">Manual build</a></li>
		<li><a href="#furtherdevelopment">Further development</a></li>
		<li><a href="#troubleshooting">Troubleshooting</a></li>
		<li><a href="#notes">Notes</a></li>
		<li><a href="#findaddress">Finding the source line from a memory address</a></li>
		<li><a href="#thirdparty">Upgrading third-party packages</a></li>
		<li><a href="#releasing">Releasing</a></li>
	</ol>

	<hr />


	<h2 id="basics">Basic information</h2>
	<p>
		For the basics, please refer to <a href="readme.html">this document</a>.
	</p>

	<p>
		<a href="#contents">To table of contents</a>
	</p>

	<hr />


	<h2 id="gettingstarted">Manual build</h2>
	<p>
		We'll start by compiling and installing the components that HeidiSQL depends on and then HeidiSQL itself.
	</p>

	<p>
		HeidiSQL has one directory named "packages" for each component and for HeidiSQL itself, this is where
		you'll find the project files.
	</p>

	<p>
		Delphi has a distinction between "design-time components" and "run-time components".  To compile
		HeidiSQL correctly, the designtime components that it depends on needs to be "Installed" into the
		Borland environment, otherwise Delphi will fail to compile HeidiSQL.  You can Install a project
		by right-clicking the project in the "Project Manager" in Delphi and choosing "Install".
	</p>

	<p>
		Open these projects in Delphi 2007 and perform the action listed.<br />
		Note: Before you can install components into the IDE, you will also need to either (a) copy the generated BPL files from the build folders to somewhere in your path, or (b) add the build folders to your Delphi PATH environment variable override.  The override can be found under Tools --> Options --> Environment Options --> Environment Variables.
	</p>
	<table>
		<tr>
			<th>Relative path</th>
			<th>Action</th>
		</tr>
		<tr>
			<td>components/tntunictrls/packages/delphi11/TntUnicodeVcl.groupproj</td>
			<td>Build All + Install "TntUnicodeVcl_Design"</td>
		</tr>
		<tr>
			<td>components/synedit/packages/delphi11/SynEdit.groupproj</td>
			<td>Build All + Install "SynEditD"</td>
		</tr>
		<tr>
			<td>components/virtualtreeview/packages/delphi11/VirtualTrees.groupproj</td>
			<td>Build All + Install "VirtualTreesD"</td>
		</tr>
	</table>

	<p>
		Once you're done, you are ready to compile HeidiSQL itself:
	</p>
	<table>
		<tr>
			<th>Relative path</th>
			<th>Action</th>
		</tr>
		<tr>
			<td>packages/delphi11/heidisql.dproj</td>
			<td>Build All</td>
		</tr>
	</table>

	<p>
		You should end up with a "heidisql.exe" binary in the "out" folder.
	</p>
	<p>
		Ta-ta!  We're done ;-).
	</p>

	<p>
		<a href="#contents">To table of contents</a>
	</p>

	<hr />


	<h2 id="furtherdevelopment">Further development</h2>
	<p>
		Once the initial build and installation process is complete, please refer to
		<a href="readme.html#furtherdevelopment">this document</a> for more information
		regarding consequent building of the project.
	</p>

	<p>
		<a href="#contents">To table of contents</a>
	</p>

	<hr />


	<h2 id="troubleshooting">Troubleshooting</h2>

	<h3>"Error Reading Form" / "Class Not Found" error messages</h3>
	<p>
		You might have forgotten to Install some of the components.
	</p>
	<p>
		First, make sure that you choose "Cancel" in this dialog!
		If you do not, BDS will make devastating changes to the source,
		and you'll need to revert those actions (fx. with SVN) before things
		are going to work again.
	</p>
	<p>
		Go back to <a href="#gettingstarted">Getting started</a>, and remember to
		Install the components where it says so ;-).
	</p>
	<p>
		If you still have problems, you can also opt to <a href="#cleaning">start over</a>.
	</p>

	<h3 id="troubleshooting_1">"Unable to install component" error message</h3>
	<p>
		Remove the (already installed) component by going to Project --> Options --> Packages,
		selecting the relevant component and clicking "Remove".
	</p>
	<p>
		Then try installing the component again.
	</p>
	<p>
		Once you've successfully installed a design-time component, Delphi should reinstall
		it the next time you compile the package containing the component.
	</p>

	<h3>Component installation seemed to work, but components are still missing</h3>
	<p>
		Nuke all files in your package output directory, eg.
		"%ALLUSERSPROFILE%\Documents\RAD Studio\5.0\Bpl"
	</p>
	<p>
		Then repeat the <a href="#troubleshooting_1">above step</a>.
	</p>

	<h3 id="cleaning">How can I completely clean my build environment?</h3>
	<p>
		If the HeidiSQL build process has changed, or you think you might have done something
		wrong during building, you might want to clean your build environment.
		You can do like this:
		<ul>
			<li>Either close all Delphi windows and delete the registry key
				<code>HKEY_CURRENT_USER\Software\Borland</code>, or perform the next three steps:
				<ul>
					<li>Close all Delphi <strong>projects</strong>, but leave a Delphi
						<strong>window</strong> open (or open a new one).
					</li>
					<li>Choose Project --> Default Options --> Delphi for Win32</li>
					<li>Choose "Packages".  Highlight the following packages one by one and
						click the "Remove" button after highlighting each one:
						<ul>
							<li>EDBImage</li>
							<li>HeidiSQL helper components</li>
							<li>TNTWare Unicode Controls</li>
							<li>SynEdit component suite</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>Nuke all files in your package output directory, eg.
				"%ALLUSERSPROFILE%\Documents\RAD Studio\5.0\Bpl".</li>
			<li>Nuke all files from all HeidiSQL "build" directories, for
				example by performing a fresh checkout.</li>
		</ul>
	</p>
	<p>
		Now you can restart your <a href="#gettingstarted">build process</a>.
	</p>


	<h3>Compiler-error: "FOO.pas: E2225 Never-build package BAR must be recompiled"</h3>
	<p>
		If you get this error while building any component, nuke all files in the
		"build"-folder of the package which causes the problem, then try to recompile.
	</p>
	<p>
		At least for me that worked as I couldn't build the ZComponentDesign-package
		and got this message:<br />
		<cite>ZPropertyEditor.pas: E2225 Never-build package ZComponent must be recompiled</cite>
	</p>


	<h3>Compiler error F1026: "File not found: XYZ", although file exists</h3>
	<p>
		It seems that especially the file ZPlainMysql.inc in the package ZPlain
		is affected by this phenomen. This is a bug in BDS which has been reported
		in 2004, closed for version 10.0.2097.6343. 
		See also <a href="http://qc.borland.com/wc/qcmain.aspx?d=9783">http://qc.borland.com/wc/qcmain.aspx?d=9783</a>:
		<cite>
			Charles Pope: (...) It looks like Error Insight is performing some kind
			of file locking preventing the compiler from being able to access the
			file. (...)
		</cite>
	</p>
	<p>
		Workaround:
		<ol>
			<li>Go to Tools &gt; Options &gt; Editor Options &gt; Code Insight</li>
			<li>Uncheck at least "Error Insight"</li>
			<li>Restart Delphi</li>
		</ol>  
	</p>

	<p>
		<a href="#contents">To table of contents</a>
	</p>
	
	<hr />


	<h2 id="notes">Notes</h2>

	<h3>What's the difference between designtime and runtime components?</h3>
	<p>
		(Note: "a component" in this context equals "a project".)
	</p>
	<p>
		Designtime components are meant to provide functionality to the Borland environment.  For example,
		a designtime component often has a procedure named "Register", which will install the component into
		the Borland environment.
	</p>
	<p>
		The idea of separating designtime and runtime is that designtime code does not need to be linked
		into the final executable, thus saving space.  See this article for details:<br />
		<a href="http://community.borland.com/article/0,1410,27717,00.html">http://community.borland.com/article/0,1410,27717,00.html</a>
	</p>
	<p>
		If in doubt, you can always choose "designtime and runtime".  If you do designate a project as being
		"designtime only", but some code is really required at runtime, the linker seems to be clever enough
		to include the component in the final executable anyway.
	</p>
	<p>
		Runtime components are meant to be included in the final executable.  Runtime components can probably
		not be "Installed" into the Borland environment.  Runtime components can be compiled into BPL files,
		which is a sort of fancy DLL.
	</p>
	<p>
		You can Google for more information about components here:<br />
		<a href="http://groups.google.com/groups/dir?sel=33614735">borland.public.delphi.vcl usenet groups</a><br />
		<a href="http://groups.google.com/groups/dir?sel=33614713">borland.public.cppbuilder.vcl usenet groups</a>
	</p>

	<h3>How do I find out what's changed in a ".res" file?</h3>
	<p>
		I have no clue.  If you find out, please update this readme.<br />
		Supposedly, one can use textual RC files instead of binary RES files, and by adding the RC files to
		a project, Delphi should compile them into RES files on demand.  That's probably what we should do.
	</p>
	<p>
		(Hint: Delphi comes with two resource compilers, brc32.exe and brcc32.exe.  The Delphi compiler
		can be called with --drc to generate text resource files at compile time (?).)
	</p>

	<h3>What tool is practical for editing the multi-icon bitmap in /res/icons8bit.bmp?</h3>
	<p>
		While this file is a simple windows-bitmap (.bmp) with 256 colors, one way is to
		use "Paint" from within the Windows accessories - it has everything you need for this task.
		But obviously design-people would prefer a more powerful software like Photoshop or
		something similar. However, a good and free alternative for beginners and intermediate
		designers is <a href="http://www.google.com/search?q=paint.net+download">Paint.NET</a>.
	</p>

	<h3>What should I do before editing this readme?</h3>
	<p>
		You need to put yourself in the shoes of a newbie, and make
		<strong>sure</strong> that the method you're proposing actually works.
	</p>
	<ul>
		<li>
			First, go through the actions listed in <a href="#cleaning">cleaning the build environment</a> methodically.
		</li>
		<li>
			Next, try your solution step-by-step.
		</li>
		<li>
			If everything works, you're good to change the readme!
		</li>
	</ul>

	<p>
		<a href="#contents">To table of contents</a>
	</p>

	<hr />


	<h2 id="findaddress">Finding the source line from a memory address</h2>

	<h3>Preparation</h3>
	<p>
		Finding a source line from a memory address is useful when a runtime exception occurs while
		the development environment is not running, for example on a user system.  There are two methods
		to translate to a source address given a memory address, they are listed below.
	</p>
	<p>
		For either method to work, Delphi must be able to find a map of memory addresses and function names.
		With the correct project settings, these are automatically generated when the project is compiled.
	</p>
	<p>
		When debugging a problem, first svn update to the revision in which the problem occurred.
		Also run the build_everything script so that the binaries and map files are generated.
	</p>

	<h3>Using the "Modules" window</h3>
	<p>
		Activate the "Modules" window by selecting View -> Debug Windows -> Modules from the main menu.
	</p>
	<p>
		The Modules window seems functional, but is completely empty (and thus useless) until you actually start
		the program.  Only then will the relevant procedure names and addresses be filled into the otherwise void
		window.  No error message is shown, so you need to know that the program must be started for this feature
		to work correctly.  If modules are loaded on demand, it may also be necessary to progress to a certain
		point in the application, for example by opening a connection profile.
	</p>
	<p>
		In here, you can find the method responsible for an exception from a long list of methods.  First
		click the "Base Address" header to sort by base address.  Then select the module with the base address
		that is closest to, but not higher than, the memory address you're seeking.  A list of entry points
		on the right-hand side gets filled.  Select the "Address" header in this list to sort by address.  Now,
		from the list of entry points, find the function by looking for the closest match that doesn't exceed
		the memory address sought.
	</p>

	<h3>Using the "Disassembly" window</h3>
	<p>
		Activate the "Disassembly" window by selecting View -> Debug Windows -> CPU Windows -> Disassembly
		from the main menu.  In the default configuration, the CPU window also pops up when the program is
		paused.  In that case it may be enough to simply pause the running program to show this window.
	</p>
	<p>
		Before the Disassembly window can be shown, the program must be running, suspended and attached to
		the IDE debugger.  This can be accomplished by running the program from within the IDE and
		pressing the "Pause" button.
	</p>
	<p>
		Make sure that names of procedures are printed in the Disassembly view.  This is enabled by
		ticking the "mixed source" menu item in the context menu that pops up when you right-click inside
		the Disassembly window.  Note that it is easy to disable this by accident by pressing CTRL-X.
	</p>
	<p>
		The Disassembly window contains a "go to address" function, which is activated by right-clicking
		inside the window and choosing "Goto Address" from the context menu that pops up.  Enter an address
		in Pascal hexadecimal notation, for example $65C6DB, to scroll to the relevant memory address.
		Make sure that "mixed source" is enabled (see above).  Browse upwards in the disassembly view until
		a function name along with a line number is visible in the Disassembly view.  Double-click the line
		number to go directly to the source code file.
	</p>

	<p>
		<a href="#contents">To table of contents</a>
	</p>

	<hr />


	<h2 id="thirdparty">Upgrading third-party packages</h2>
	<p>
		There are two methods to do this.  One uses "svn update" purely,
		the other uses the automatic merging feature in Subversion.
	</p>

	<h3>Updating a vendor package using purely "svn update".</h3>
	<p>
		This is the old method, which was required before Subversion supported automatic merging.
	</p>
	<ol>
		<li>
			<strong>Run "svn log" on the package's top folder and find the first vendor revision.</strong><br />
    		This step finds a "base" revision where the source code in our repository matches that of the vendor"s.<br />
			<br />
		</li>
		<li>
			<strong>Run "svn update -r&lt;XXX&gt;".</strong><br />
			This step "updates" the local working copy to the revision found above.<br />
			The correct terminology would be "downdate", except that downdate is not a proper English word.<br />
			<br />
		</li>
		<li>
			<strong>Copy the updated vendor code on top of package folder.</strong><br />
			<br />
		</li>
		<li>
			<strong>Run "svn update" to update to HEAD again.</strong><br />
			This step re-applies all the changes from the HeidiSQL repository.<br />
			Files that have been deleted or renamed in HeidiSQL are deleted or renamed in the local working copy.<br />
			Subversion has an automatic merge algorithm that merges the changes already performed in the HeidiSQL
			repository (because of earlier upgrades of the vendor package) with the upgrades found in the difference
			between the current revision from step 2 and the HEAD revision.  These double updates are silently applied
			to the local working copy, so they no longer appear as changes.  Subversion also applies locally the changes
			which are specific to the HeidiSQL project's source code.  After this step, only the changes made by the
			vendor since the last upgrade of the vendor package should be visible as changes in the local working copy.<br />
			<br />
		</li>
		<li>
			<strong>Resolve conflicts if any.</strong><br />
			Subversion does not have a perfect merge algorithm.  Therefore it may be necessary to manually resolve
			some conflicts.  Knowing or figuring out why a particulate conflict occurs can be helpful in this step.
			In particular, a number of spurious conflicts may arise because Subversion cannot figure out how to
			automatically silence some upgrades that have been performed already.<br />
			<br />
		</li>
		<li>
			<strong>Run "svn commit" to commit the changes.</strong><br />
			This step creates a repository revision with the updated vendor package.<br />
			<br />
		</li>
	</ol>

	<h3>Updating a vendor package using automatic merging.</h3>
	<p>
		Historically, we've used the method above to update vendor code.
		Since version 1.5, Subversion now supports automatic merging.
		We can use this <strong>if the project is updated to have a vendor branch</strong>.
		In this example, the vendor branch will live in a folder named /3rdparty/ in the repository.
	</p>

	<p>
	<ol>
		<li>
			<strong>Copy the new vendor code on top of the old in /3rdparty/&lt;package&gt;.</strong><br />
			The new vendor code can come from a compressed source package, or via another approach:
			A script can be set up that automatically pulls the HEAD of vendor's trunk down periodically
			and commits each revision.<br />
			<br />
		</li>
		<li>
			<strong>Run "svn commit" to commit the changes.</strong><br />
			This step creates a repository revision with the updated vendor package.<br />
			If an automated script is used (see above), this is done automatically for each vendor revision.<br />
			<br />
		</li>
		<li>
			<strong>Switch to the /trunk/components/&lt;package&gt; folder.</strong><br />
			<br />
		</li>
		<li>
			<strong>Run "svn merge &lt;repository&gt;/3rdparty/&lt;package&gt; ./".</strong><br />
			This step takes the changes from the revision created above, and merges them into the project space.
			While doing this, Subversion automatically marks the revisions that has been merged, so that the
			next time around it will not attempt to merge these changes again.  Files that have already been
			deleted, moved or otherwise modified keeps their changes as a natural effect of the update(s) being
			applied on top of the HEAD revision.<br />
			<br />
		</li>
		<li>
			<strong>Resolve conflicts if any.</strong><br />
			Subversion does not have a perfect merge algorithm.  Using this method, however, is much
			less likely to produce conflicts compared to the previous method, because it is much easier for
			Subversion to figure out what actually needs to be applied.  Some resolving may be needed,
			particularly in places where the vendor has decided to modify code that has already been modified
			in HeidiSQL, but in a different way.<br />
			<br />
		</li>
		<li>
			<strong>Run "svn commit" to commit the changes.</strong><br />
			This step creates a repository revision, adding the vendor updates to the project.<br />
			<br />
		</li>
	</ol>
	</p>

	<p>
		<a href="#contents">To table of contents</a>
	</p>

	<hr />


	<h2 id="releasing">Releasing a new version</h2>

	<p>
		In order to keep version numbers in the repository and the released executables in sync,
		it is important to perform releases using an established method.
	</p>
	<p>
		Note: All steps are important!
	</p>
	<p>
		Note: Order is important!
	</p>
	<p>
		Todo:
		Extract the sed code that alters %WCVER% from build_everything.cmd and put it in a separate file.
		Run this file in a post-compile step whenever the HeidiSQL project is compiled.
	</p>
	<ol>
		<li>
			<strong>Make sure your working copy contains both "trunk" and "tags" from repository.</strong><br />
			If you need to check out "tags", you may put a tick in "checkout top folder only" to spare bandwidth.<br />
			<br />
		</li>
		<li>
			<strong>Run "svn update -rHEAD" on the trunk folder.</strong><br />
    		This step ensures that all files copied in the next step are at the same source revision.<br />
		   Using the TortoiseSVN "svn update" command is fine too.<br />
			<br />
		</li>
		<li>
			<strong>Run "svn copy trunk tags/4.0rc1".</strong><br />
			This step creates an exact duplicate of the current HEAD revision of trunk.<br />
			<br />
		</li>
		<li>
			<strong>Edit the release code variable "appversion" in tags/4.0rc1/main.pas.</strong><br />
			This step modifies above duplicate so it is now different from trunk.<br />
			<br />
		</li>
		<li>
			<strong>Edit the AppVerName, AppVersion, VersionInfoVersion and OutputBaseFilename variables in tags/4.0rc1/out/heidisql.iss.</strong><br />
			(TODO: At some point, the ISS file should be modified to only contain one version number variable.)<br />
			(TODO: Get the revision number in there somewhere.)<br />
			<br />
		</li>
		<li>
			<strong>Edit the MajorVer, MinorVer, FileVersion and ProductVersion variables in tags/4.0rc1/packages/heidisql.dproj.</strong><br />
			(TODO: Find out if there is a way to automate this.)<br />
			(TODO: Get the revision number in there somewhere.)<br />
			<br />
		</li>
		<li>
			<strong>Edit the FILEVERSION variable in tags/4.0rc1/res/version.rc.</strong><br />
			(TODO: Find out if it is really necessary to do both this and the above step; both looks like they will end up in the final exe.)<br />
			(TODO: Get the revision number in there somewhere.)<br />
			<br />
		</li>
		<li>
			<strong>Run "svn commit tags" to commit "tags" and all subitems.</strong><br />
			This step creates a repository revision containing the copy with the new appversion.<br />
			This step also writes the new revision number of this change into $Revision$ in main.pas.<br />
			<i>Point of no return!</i>  After this step, the version number is final.<br />
			<br />
		</li>
		<li><strong><a href="#cleaning">Clean</a> your build environment.</strong><br />
			This step prevents old binary components from being included in the new version.<br />
			<br />
		</li>
		<li><strong><a href="#gettingstarted">Build HeidiSQL</a> from tags/4.0rc1.</strong><br />
			(Under some circumstances it is OK to use the superpackage instead of this and the previous step.  If in doubt, don"t ;-).)<br />
			<br />
		</li>
		<li>
			<strong>Build installer in the tags/4.0rc1 directory.</strong><br />
			Use the build_everything.cmd script for this, so the version number in main.pas is updated correctly.<br />
			Make sure that the version number does not end in "M" for "Mixed", if it does then you did something wrong further up.<br />
			<br />
		</li>
		<li>
			<strong>Upload!</strong><br />
			Please the file in the download section on the Google Code site as the preferred version, deprecate older versions.<br />
			<br />
		</li>
		<li>
			<strong>Update the autoupdater configuration that www.heidisql.com publishes.</strong><br />
			Clients configured to automatically update HeidiSQL will pull down a new client when they see the changed version from here.
			Publish a new version by creating a new row in a MySQL database in the table heidisql_versions.
		</li>
	</ol>

	<p>
		<a href="#contents">To table of contents</a>
	</p>

	<hr />


	<p>
		Revision of this file: <em>$Rev$</em><br />
		Last changed: <em>$Date$</em><br />
		Last author: <em>$Author$</em>
	</p>


</body>

</html>
