[ABS]
declaration=X
category=Numeric Functions
description=Returns the absolute (non-negative) value of X. If X is not\na number, it is converted to a numeric type.\n \n\nSELECT ABS(42);\n+---------+\n| ABS(42) |\n+---------+\n| 42 |\n+---------+\n \nSELECT ABS(-42);\n+----------+\n| ABS(-42) |\n+----------+\n| 42 |\n+----------+\n \nSELECT ABS(DATE ''1994-01-01'');\n+------------------------+\n| ABS(DATE ''1994-01-01'') |\n+------------------------+\n| 19940101 |\n+------------------------+
[ACOS]
declaration=X
category=Numeric Functions
description=Returns the arc cosine of X, that is, the value whose cosine\nis X.\nReturns NULL if X is not in the range -1 to 1.\n \n\nSELECT ACOS(1);\n+---------+\n| ACOS(1) |\n+---------+\n| 0 |\n+---------+\n \nSELECT ACOS(1.0001);\n+--------------+\n| ACOS(1.0001) |\n+--------------+\n| NULL |\n+--------------+\n \nSELECT ACOS(0);\n+-----------------+\n| ACOS(0) |\n+-----------------+\n| 1.5707963267949 |\n+-----------------+\n \nSELECT ACOS(0.234);\n+------------------+\n| ACOS(0.234) |\n+------------------+\n| 1.33460644244679 |\n+------------------+
[ADDDATE1]
name=ADDDATE
declaration=date,INTERVAL expr unit
category=Date and Time Functions
description=When invoked with the INTERVAL form of the second argument,\nADDDATE()\nis a synonym for DATE_ADD(). The related function\nSUBDATE() is a synonym for DATE_SUB(). For\ninformation on the INTERVAL unit argument, see the\ndiscussion for\nDATE_ADD().\n \nWhen invoked with the days form of the second argument,\nMariaDB treats it as an\ninteger number of days to be added to expr.\n \n\nSELECT DATE_ADD(''2008-01-02'', INTERVAL 31 DAY);\n+-----------------------------------------+\n| DATE_ADD(''2008-01-02'', INTERVAL 31 DAY) |\n+-----------------------------------------+\n| 2008-02-02 |\n+-----------------------------------------+\n \nSELECT ADDDATE(''2008-01-02'', INTERVAL 31 DAY);\n+----------------------------------------+\n| ADDDATE(''2008-01-02'', INTERVAL 31 DAY) |\n+----------------------------------------+\n| 2008-02-02 |\n+----------------------------------------+\n \nSELECT ADDDATE(''2008-01-02'', 31);\n+---------------------------+\n| ADDDATE(''2008-01-02'', 31) |\n+---------------------------+\n| 2008-02-02 |\n+---------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d, ADDDATE(d, 10) from t1;\n \n+---------------------+---------------------+\n| d | ADDDATE(d, 10) |\n+---------------------+---------------------+\n| 2007-01-30 21:31:07 | 2007-02-09 21:31:07 |\n| 1983-10-15 06:42:51 | 1983-10-25 06:42:51 |\n| 2011-04-21 12:34:56 | 2011-05-01 12:34:56 |\n| 2011-10-30 06:31:41 | 2011-11-09 06:31:41 |\n| 2011-01-30 14:03:25 | 2011-02-09 14:03:25 |\n| 2004-10-07 11:19:34 | 2004-10-17 11:19:34 |\n+---------------------+---------------------+\n \nSELECT d, ADDDATE(d, INTERVAL 10 HOUR) from t1;\n \n+---------------------+------------------------------+\n| d | ADDDATE(d, INTERVAL 10 HOUR) |\n+---------------------+------------------------------+\n| 2007-01-30 21:31:07 | 2007-01-31 07:31:07 |\n| 1983-10-15 06:42:51 | 1983-10-15 16:42:51 |\n| 2011-04-21 12:34:56 | 2011-04-21 22:34:56 |\n| 2011-10-30 06:31:41 | 2011-10-30 16:31:41 |\n| 2011-01-30 14:03:25 | 2011-01-31 00:03:25 |\n| 2004-10-07 11:19:34 | 2004-10-07 21:19:34 |\n+---------------------+------------------------------+
[ADDDATE2]
name=ADDDATE
declaration=expr,days
category=Date and Time Functions
description=When invoked with the INTERVAL form of the second argument,\nADDDATE()\nis a synonym for DATE_ADD(). The related function\nSUBDATE() is a synonym for DATE_SUB(). For\ninformation on the INTERVAL unit argument, see the\ndiscussion for\nDATE_ADD().\n \nWhen invoked with the days form of the second argument,\nMariaDB treats it as an\ninteger number of days to be added to expr.\n \n\nSELECT DATE_ADD(''2008-01-02'', INTERVAL 31 DAY);\n+-----------------------------------------+\n| DATE_ADD(''2008-01-02'', INTERVAL 31 DAY) |\n+-----------------------------------------+\n| 2008-02-02 |\n+-----------------------------------------+\n \nSELECT ADDDATE(''2008-01-02'', INTERVAL 31 DAY);\n+----------------------------------------+\n| ADDDATE(''2008-01-02'', INTERVAL 31 DAY) |\n+----------------------------------------+\n| 2008-02-02 |\n+----------------------------------------+\n \nSELECT ADDDATE(''2008-01-02'', 31);\n+---------------------------+\n| ADDDATE(''2008-01-02'', 31) |\n+---------------------------+\n| 2008-02-02 |\n+---------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d, ADDDATE(d, 10) from t1;\n \n+---------------------+---------------------+\n| d | ADDDATE(d, 10) |\n+---------------------+---------------------+\n| 2007-01-30 21:31:07 | 2007-02-09 21:31:07 |\n| 1983-10-15 06:42:51 | 1983-10-25 06:42:51 |\n| 2011-04-21 12:34:56 | 2011-05-01 12:34:56 |\n| 2011-10-30 06:31:41 | 2011-11-09 06:31:41 |\n| 2011-01-30 14:03:25 | 2011-02-09 14:03:25 |\n| 2004-10-07 11:19:34 | 2004-10-17 11:19:34 |\n+---------------------+---------------------+\n \nSELECT d, ADDDATE(d, INTERVAL 10 HOUR) from t1;\n \n+---------------------+------------------------------+\n| d | ADDDATE(d, INTERVAL 10 HOUR) |\n+---------------------+------------------------------+\n| 2007-01-30 21:31:07 | 2007-01-31 07:31:07 |\n| 1983-10-15 06:42:51 | 1983-10-15 16:42:51 |\n| 2011-04-21 12:34:56 | 2011-04-21 22:34:56 |\n| 2011-10-30 06:31:41 | 2011-10-30 16:31:41 |\n| 2011-01-30 14:03:25 | 2011-01-31 00:03:25 |\n| 2004-10-07 11:19:34 | 2004-10-07 21:19:34 |\n+---------------------+------------------------------+
[ADDTIME]
declaration=expr1,expr2
category=Date and Time Functions
description=ADDTIME() adds expr2 to expr1 and returns the result. expr1\nis a time\nor datetime expression, and expr2 is a time expression.\n \n\nSELECT ADDTIME(''2007-12-31 23:59:59.999999'', ''1\n1:1:1.000002'');\n+---------------------------------------------------------+\n| ADDTIME(''2007-12-31 23:59:59.999999'', ''1\n1:1:1.000002'') |\n+---------------------------------------------------------+\n| 2008-01-02 01:01:01.000001 |\n+---------------------------------------------------------+\n \nSELECT ADDTIME(''01:00:00.999999'', ''02:00:00.999998'');\n+-----------------------------------------------+\n| ADDTIME(''01:00:00.999999'', ''02:00:00.999998'') |\n+-----------------------------------------------+\n| 03:00:01.999997 |\n+-----------------------------------------------+
[AES_DECRYPT]
declaration=crypt_str,key_str
category=Encryption Functions
description=This function allows decryption of data using the official\nAES\n(Advanced Encryption Standard) algorithm. For more\ninformation, see\nthe description of AES_ENCRYPT().
[AES_ENCRYPT]
declaration=str,key_str
category=Encryption Functions
description=AES_ENCRYPT() and AES_DECRYPT() allow encryption and\ndecryption of\ndata using the official AES (Advanced Encryption Standard)\nalgorithm,\npreviously known as "Rijndael." Encoding with a 128-bit\nkey length is\nused, but you can extend it up to 256 bits by modifying the\nsource. We\nchose 128 bits because it is much faster and it is secure\nenough for\nmost purposes.\n \nAES_ENCRYPT() encrypts a string str using the key key_str,\nand returns a binary string.\n \nAES_DECRYPT() decrypts the encrypted string and returns the\noriginal\nstring.\n \nThe input arguments may be any length. If either argument is\nNULL, the result of this function is also NULL.\n \nBecause AES is a block-level algorithm, padding is used to\nencode\nuneven length strings and so the result string length may be\ncalculated using this formula:\n \n16 x (trunc(string_length / 16) + 1)\n \nIf AES_DECRYPT() detects invalid data or incorrect padding,\nit returns\nNULL. However, it is possible for AES_DECRYPT() to return a\nnon-NULL\nvalue (possibly garbage) if the input data or the key is\ninvalid.\n \n\nINSERT INTO t VALUES\n(AES_ENCRYPT(''text'',SHA2(''password'',512)));
[ASCII]
declaration=str
category=String Functions
description=Returns the numeric ASCII value of the leftmost character of\nthe string argument. Returns 0 if the given string is empty\nand NULL if it is NULL.\n \nASCII() works for 8-bit characters.\n \n\nSELECT ASCII(9);\n+----------+\n| ASCII(9) |\n+----------+\n| 57 |\n+----------+\n \nSELECT ASCII(''9'');\n+------------+\n| ASCII(''9'') |\n+------------+\n| 57 |\n+------------+\n \nSELECT ASCII(''abc'');\n+--------------+\n| ASCII(''abc'') |\n+--------------+\n| 97 |\n+--------------+
[ASIN]
declaration=X
category=Numeric Functions
description=Returns the arc sine of X, that is, the value whose sine is\nX. Returns\nNULL if X is not in the range -1 to 1.\n \n\nSELECT ASIN(0.2);\n+--------------------+\n| ASIN(0.2) |\n+--------------------+\n| 0.2013579207903308 |\n+--------------------+\n \nSELECT ASIN(''foo'');\n+-------------+\n| ASIN(''foo'') |\n+-------------+\n| 0 |\n+-------------+\n \nSHOW WARNINGS;\n \n+---------+------+-----------------------------------------+\n| Level | Code | Message |\n+---------+------+-----------------------------------------+\n| Warning | 1292 | Truncated incorrect DOUBLE value: ''foo''\n|\n+---------+------+-----------------------------------------+
[ATAN]
declaration=X
category=Numeric Functions
description=Returns the arc tangent of X, that is, the value whose\ntangent is X.\n \n\nSELECT ATAN(2);\n+--------------------+\n| ATAN(2) |\n+--------------------+\n| 1.1071487177940904 |\n+--------------------+\n \nSELECT ATAN(-2);\n+---------------------+\n| ATAN(-2) |\n+---------------------+\n| -1.1071487177940904 |\n+---------------------+
[AVG]
declaration=[DISTINCT] expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the average value of expr. The DISTINCT option can\nbe used to return the average of the distinct values of\nexpr. NULL values are ignored. It is an aggregate function,\nand so can be used with the GROUP BY clause.\n \nAVG() returns NULL if there were no matching rows.\n \nFrom MariaDB 10.2.0, AVG() can be used as a window function.\n \n\nCREATE TABLE sales (sales_value INT);\n \nINSERT INTO sales VALUES(10),(20),(20),(40);\n \nSELECT AVG(sales_value) FROM sales;\n \n+------------------+\n| AVG(sales_value) |\n+------------------+\n| 22.5000 |\n+------------------+\n \nSELECT AVG(DISTINCT(sales_value)) FROM sales;\n \n+----------------------------+\n| AVG(DISTINCT(sales_value)) |\n+----------------------------+\n| 23.3333 |\n+----------------------------+\n \nCommonly, AVG() is used with a GROUP BY clause:\n \nCREATE TABLE student (name CHAR(10), test CHAR(10), score\nTINYINT); \n \nINSERT INTO student VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87), (''Tatiana'', ''Tuning'', 83);\n \nSELECT name, AVG(score) FROM student GROUP BY name;\n \n+---------+------------+\n| name | AVG(score) |\n+---------+------------+\n| Chun | 74.0000 |\n| Esben | 37.0000 |\n| Kaolin | 72.0000 |\n| Tatiana | 85.0000 |\n+---------+------------+\n \nBe careful to avoid this common mistake, not grouping\ncorrectly and returning mismatched data: \n \nSELECT name,test,AVG(score) FROM student;\n \n+------+------+------------+\n| name | test | MIN(score) |\n+------+------+------------+\n| Chun | SQL | 31 |\n+------+------+------------+\n \nAs a window function:\n \nCREATE TABLE student_test (name CHAR(10), test CHAR(10),\nscore TINYINT); \n \nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87), (''Tatiana'', ''Tuning'', 83);\n \nSELECT name, test, score, AVG(score) OVER (PARTITION BY\ntest) \n AS average_by_test FROM student_test;\n \n+---------+--------+-------+-----------------+\n| name | test | score | average_by_test |\n+---------+--------+-------+-----------------+\n| Chun | SQL | 75 | 65.2500 |\n| Chun | Tuning | 73 | 68.7500 |\n| Esben | SQL | 43 | 65.2500 |\n| Esben | Tuning | 31 | 68.7500 |\n| Kaolin | SQL | 56 | 65.2500 |\n| Kaolin | Tuning | 88 | 68.7500 |\n| Tatiana | SQL | 87 | 65.2500 |\n| Tatiana | Tuning | 83 | 68.7500 |\n+---------+--------+-------+-----------------+
[BENCHMARK]
declaration=count,expr
category=Information Functions
description=The BENCHMARK() function executes the expression expr\nrepeatedly count\ntimes. It may be used to time how quickly MariaDB processes\nthe\nexpression. The result value is always 0. The intended use\nis from\nwithin the mysql client, which reports query execution\ntimes.\n \n\nSELECT BENCHMARK(1000000,ENCODE(''hello'',''goodbye''));\n+----------------------------------------------+\n| BENCHMARK(1000000,ENCODE(''hello'',''goodbye'')) |\n+----------------------------------------------+\n| 0 |\n+----------------------------------------------+\n1 row in set (0.21 sec)
[BINARY]
declaration=M
category=Data Types
description=The BINARY type is similar to the CHAR type, but stores\nbinary\nbyte strings rather than non-binary character strings. M\nrepresents the\ncolumn length in bytes.\n \nIt contains no character set, and comparison and sorting are\nbased on the numeric value of the bytes.\n \nIf the maximum length is exceeded, and SQL strict mode is\nnot enabled , the extra characters will be dropped with a\nwarning. If strict mode is enabled, an error will occur.\n \nBINARY values are right-padded with 0x00 (the zero byte) to\nthe specified length when inserted. The padding is not\nremoved on select, so this needs to be taken into account\nwhen sorting and comparing, where all bytes are significant.\nThe zero byte, 0x00 is less than a space for comparison\npurposes.\n \n\nInserting too many characters, first with strict mode off,\nthen with it on:\n \nCREATE TABLE bins (a BINARY(10));\n \nINSERT INTO bins VALUES(''12345678901'');\nQuery OK, 1 row affected, 1 warning (0.04 sec)\n \nSELECT * FROM bins;\n \n+------------+\n| a |\n+------------+\n| 1234567890 |\n+------------+\n \nSET sql_mode=''STRICT_ALL_TABLES'';\n \nINSERT INTO bins VALUES(''12345678901'');\nERROR 1406 (22001): Data too long for column ''a'' at row 1\n \nSorting is performed with the byte value:\n \nTRUNCATE bins;\n \nINSERT INTO bins VALUES(''A''),(''B''),(''a''),(''b'');\n \nSELECT * FROM bins ORDER BY a;\n \n+------+\n| a |\n+------+\n| A |\n| B |\n| a |\n| b |\n+------+\n \nUsing CAST to sort as a CHAR instead:\n \nSELECT * FROM bins ORDER BY CAST(a AS CHAR);\n+------+\n| a |\n+------+\n| a |\n| A |\n| b |\n| B |\n+------+\n \nThe field is a BINARY(10), so padding of two ''\0''s are\ninserted, causing comparisons that don''t take this into\naccount to fail:\n \nTRUNCATE bins;\n \nINSERT INTO bins VALUES(''12345678'');\n \nSELECT a = ''12345678'', a = ''12345678\0\0'' from bins;\n \n+----------------+--------------------+\n| a = ''12345678'' | a = ''12345678\0\0'' |\n+----------------+--------------------+\n| 0 | 1 |\n+----------------+--------------------+
[BINLOG_GTID_POS]
declaration=binlog_filename,binlog_offset
category=Information Functions
description=The BINLOG_GTID_POS() function takes as input an old-style\nbinary log position in the form of a file name and a file\noffset. It looks up the position in the current binlog, and\nreturns a string representation of the corresponding GTID\nposition. If the position is not found in the current\nbinlog, NULL is returned.\n \n\nSELECT BINLOG_GTID_POS("master-bin.000001", 600);
[BIN]
declaration=N
category=String Functions
description=Returns a string representation of the binary value of the\ngiven longlong (that is, BIGINT) number. This is equivalent\nto CONV(N,10,2). The argument should be positive. If it is a\nFLOAT, it will be truncated. Returns NULL if the argument is\nNULL.\n \n\nSELECT BIN(12);\n+---------+\n| BIN(12) |\n+---------+\n| 1100 |\n+---------+
[BIT_AND]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the bitwise AND of all bits in expr. The calculation\nis performed with 64-bit (BIGINT) precision. It is an\naggregate function, and so can be used with the GROUP BY\nclause.\n \nFrom MariaDB 10.2.0, BIT_AND() can be used as a window\nfunction.\n \n\nCREATE TABLE vals (x INT);\n \nINSERT INTO vals VALUES(111),(110),(100);\n \nSELECT BIT_AND(x), BIT_OR(x), BIT_XOR(x) FROM vals;\n \n+------------+-----------+------------+\n| BIT_AND(x) | BIT_OR(x) | BIT_XOR(x) |\n+------------+-----------+------------+\n| 100 | 111 | 101 |\n+------------+-----------+------------+\n \nAs an aggregate function:\n \nCREATE TABLE vals2 (category VARCHAR(1), x INT);\n \nINSERT INTO vals2 VALUES\n (''a'',111),(''a'',110),(''a'',100),\n (''b'',''000''),(''b'',001),(''b'',011);\n \nSELECT category, BIT_AND(x), BIT_OR(x), BIT_XOR(x) \n FROM vals GROUP BY category;\n \n+----------+------------+-----------+------------+\n| category | BIT_AND(x) | BIT_OR(x) | BIT_XOR(x) |\n+----------+------------+-----------+------------+\n| a | 100 | 111 | 101 |\n| b | 0 | 11 | 10 |\n+----------+------------+-----------+------------+
[BIT_COUNT]
declaration=N
category=Bit Functions
description=Returns the number of bits that are set in the argument N.\n \n\nSELECT BIT_COUNT(29), BIT_COUNT(b''101010'');\n+---------------+----------------------+\n| BIT_COUNT(29) | BIT_COUNT(b''101010'') |\n+---------------+----------------------+\n| 4 | 3 |\n+---------------+----------------------+
[BIT_LENGTH]
declaration=str
category=String Functions
description=Returns the length of the given string argument in bits. If\nthe argument is not a string, it will be converted to\nstring. If the argument is NULL, it returns NULL.\n \n\nSELECT BIT_LENGTH(''text'');\n+--------------------+\n| BIT_LENGTH(''text'') |\n+--------------------+\n| 32 |\n+--------------------+\n \nSELECT BIT_LENGTH('''');\n+----------------+\n| BIT_LENGTH('''') |\n+----------------+\n| 0 |\n+----------------+\n \nCompatibility\n \nPostgreSQL and Sybase support BIT_LENGTH().
[BIT_OR]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the bitwise OR of all bits in expr. The calculation\nis performed with 64-bit (BIGINT) precision. It is an\naggregate function, and so can be used with the GROUP BY\nclause.\n \nFrom MariaDB 10.2.0, BIT_OR can be used as a window\nfunction.\n \n\nCREATE TABLE vals (x INT);\n \nINSERT INTO vals VALUES(111),(110),(100);\n \nSELECT BIT_AND(x), BIT_OR(x), BIT_XOR(x) FROM vals;\n \n+------------+-----------+------------+\n| BIT_AND(x) | BIT_OR(x) | BIT_XOR(x) |\n+------------+-----------+------------+\n| 100 | 111 | 101 |\n+------------+-----------+------------+\n \nAs an aggregate function:\n \nCREATE TABLE vals2 (category VARCHAR(1), x INT);\n \nINSERT INTO vals2 VALUES\n (''a'',111),(''a'',110),(''a'',100),\n (''b'',''000''),(''b'',001),(''b'',011);\n \nSELECT category, BIT_AND(x), BIT_OR(x), BIT_XOR(x) \n FROM vals GROUP BY category;\n \n+----------+------------+-----------+------------+\n| category | BIT_AND(x) | BIT_OR(x) | BIT_XOR(x) |\n+----------+------------+-----------+------------+\n| a | 100 | 111 | 101 |\n| b | 0 | 11 | 10 |\n+----------+------------+-----------+------------+
[BIT_XOR]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the bitwise XOR of all bits in expr. The calculation\nis performed with 64-bit (BIGINT) precision. It is an\naggregate function, and so can be used with the GROUP BY\nclause.\n \nFrom MariaDB 10.2.0, BIT_XOR() can be used as a window\nfunction.\n \n\nCREATE TABLE vals (x INT);\n \nINSERT INTO vals VALUES(111),(110),(100);\n \nSELECT BIT_AND(x), BIT_OR(x), BIT_XOR(x) FROM vals;\n \n+------------+-----------+------------+\n| BIT_AND(x) | BIT_OR(x) | BIT_XOR(x) |\n+------------+-----------+------------+\n| 100 | 111 | 101 |\n+------------+-----------+------------+\n \nAs an aggregate function:\n \nCREATE TABLE vals2 (category VARCHAR(1), x INT);\n \nINSERT INTO vals2 VALUES\n (''a'',111),(''a'',110),(''a'',100),\n (''b'',''000''),(''b'',001),(''b'',011);\n \nSELECT category, BIT_AND(x), BIT_OR(x), BIT_XOR(x) \n FROM vals GROUP BY category;\n \n+----------+------------+-----------+------------+\n| category | BIT_AND(x) | BIT_OR(x) | BIT_XOR(x) |\n+----------+------------+-----------+------------+\n| a | 100 | 111 | 101 |\n| b | 0 | 11 | 10 |\n+----------+------------+-----------+------------+
[CAST]
declaration=expr AS type
category=String Functions
description=The CAST() function takes a value of one type and produces a\nvalue of another type, similar to the CONVERT() function.\nFor more information, see the description of CONVERT(). \n \nThe main difference between the CAST() and CONVERT() is that\nCONVERT(expr,type) is ODBC syntax while CAST(expr as type)\nand CONVERT(... USING ...) are SQL92 syntax.\n \nIn MariaDB 10.4 and later, you can use the CAST() function\nwith the INTERVAL keyword.\n \nUntil MariaDB 5.5.31, X''HHHH'', the standard SQL syntax for\nbinary string literals, erroneously worked in the same way\nas 0xHHHH. In 5.5.31 it was intentionally changed to behave\nas a string in all contexts (and never as a number).\n \nThis introduces an incompatibility with previous versions of\nMariaDB, and all versions of MySQL (see the example below). \n \n\nSimple casts:\n \nSELECT CAST("abc" AS BINARY);\nSELECT CAST("1" AS UNSIGNED INTEGER);\nSELECT CAST(123 AS CHAR CHARACTER SET utf8)\n \nNote that when one casts to CHAR without specifying the\ncharacter set, the collation_connection character set\ncollation will be used. When used with CHAR CHARACTER SET,\nthe default collation for that character set will be used.\n \nSELECT COLLATION(CAST(123 AS CHAR));\n+------------------------------+\n| COLLATION(CAST(123 AS CHAR)) |\n+------------------------------+\n| latin1_swedish_ci |\n+------------------------------+\n \nSELECT COLLATION(CAST(123 AS CHAR CHARACTER SET utf8));\n+-------------------------------------------------+\n| COLLATION(CAST(123 AS CHAR CHARACTER SET utf8)) |\n+-------------------------------------------------+\n| utf8_general_ci |\n+-------------------------------------------------+\n \nIf you also want to change the collation, you have to use\nthe COLLATE operator:\n \nSELECT COLLATION(CAST(123 AS CHAR CHARACTER SET utf8) \n COLLATE utf8_unicode_ci);\n+-------------------------------------------------------------------------+\n| COLLATION(CAST(123 AS CHAR CHARACTER SET utf8) COLLATE\nutf8_unicode_ci) |\n+-------------------------------------------------------------------------+\n| utf8_unicode_ci |\n+-------------------------------------------------------------------------+\n \nUsing CAST() to order an ENUM field as a CHAR rather than\nthe internal numerical value:\n \nCREATE TABLE enum_list (enum_field enum(''c'',''a'',''b''));\n \nINSERT INTO enum_list (enum_field) \nVALUES(''c''),(''a''),(''c''),(''b'');\n \nSELECT * FROM enum_list \nORDER BY enum_field;\n \n+------------+\n| enum_field |\n+------------+\n| c |\n| c |\n| a |\n| b |\n+------------+\n \nSELECT * FROM enum_list \nORDER BY CAST(enum_field AS CHAR);\n+------------+\n| enum_field |\n+------------+\n| a |\n| b |\n| c |\n| c |\n+------------+\n \nFrom MariaDB 5.5.31, the following will trigger warnings,\nsince x''aa'' and ''X''aa'' no longer behave as a number.\nPreviously, and in all versions of MySQL, no warnings are\ntriggered since they did erroneously behave as a number:\n \nSELECT CAST(0xAA AS UNSIGNED), CAST(x''aa'' AS UNSIGNED),\nCAST(X''aa'' AS UNSIGNED);\n+------------------------+-------------------------+-------------------------+\n| CAST(0xAA AS UNSIGNED) | CAST(x''aa'' AS UNSIGNED) |\nCAST(X''aa'' AS UNSIGNED) |\n+------------------------+-------------------------+-------------------------+\n| 170 | 0 | 0 |\n+------------------------+-------------------------+-------------------------+\n1 row in set, 2 warnings (0.00 sec)\n \nWarning (Code 1292): Truncated incorrect INTEGER value:\n''\xAA''\nWarning (Code 1292): Truncated incorrect INTEGER value:\n''\xAA''\n \nCasting to intervals:\n \nSELECT CAST(2019-01-04 INTERVAL AS DAY_SECOND(2)) AS\n"Cast";\n \n+-------------+\n| Cast |\n+-------------+\n| 00:20:17.00 |\n+-------------+
[CEILING]
declaration=X
category=Numeric Functions
description=Returns the smallest integer value not less than X.\n \n\nSELECT CEILING(1.23);\n+---------------+\n| CEILING(1.23) |\n+---------------+\n| 2 |\n+---------------+\n \nSELECT CEILING(-1.23);\n+----------------+\n| CEILING(-1.23) |\n+----------------+\n| -1 |\n+----------------+
[CEIL]
declaration=X
category=Numeric Functions
description=CEIL() is a synonym for CEILING().
[CHARACTER_LENGTH]
declaration=str
category=String Functions
description=CHARACTER_LENGTH() is a synonym for CHAR_LENGTH().
[CHARSET]
declaration=str
category=Information Functions
description=Returns the character set of the string argument. If str is\nnot a string, it is considered as a binary string (so the\nfunction returns ''binary''). This applies to NULL, too. The\nreturn value is a string in the utf8 character set.\n \n\nSELECT CHARSET(''abc'');\n+----------------+\n| CHARSET(''abc'') |\n+----------------+\n| latin1 |\n+----------------+\n \nSELECT CHARSET(CONVERT(''abc'' USING utf8));\n+------------------------------------+\n| CHARSET(CONVERT(''abc'' USING utf8)) |\n+------------------------------------+\n| utf8 |\n+------------------------------------+\n \nSELECT CHARSET(USER());\n+-----------------+\n| CHARSET(USER()) |\n+-----------------+\n| utf8 |\n+-----------------+
[CHAR_LENGTH]
declaration=str
category=String Functions
description=Returns the length of the given string argument, measured in\ncharacters. A multi-byte character counts as a single\ncharacter. This means that for a string containing five\ntwo-byte characters, LENGTH() (or OCTET_LENGTH() in Oracle\nmode) returns 10, whereas CHAR_LENGTH() returns 5. If the\nargument is NULL, it returns NULL. \n \nIf the argument is not a string value, it is converted into\na string.\n \nIt is synonymous with the CHARACTER_LENGTH() function.\n \nUntil MariaDB 10.3.1, returns MYSQL_TYPE_LONGLONG, or\nbigint(10), in all cases. From MariaDB 10.3.1, returns\nMYSQL_TYPE_LONG, or int(10), when the result would fit\nwithin 32-bits.\n \n\nSELECT CHAR_LENGTH(''MariaDB'');\n+------------------------+\n| CHAR_LENGTH(''MariaDB'') |\n+------------------------+\n| 7 |\n+------------------------+\n \nSELECT CHAR_LENGTH(''?'');\n+-------------------+\n| CHAR_LENGTH(''?'') |\n+-------------------+\n| 1 |\n+-------------------+
[CHR]
declaration=N
category=String Functions
description=CHR() interprets each argument N as an integer and returns a\nVARCHAR(1) string consisting of the character given by the\ncode values of the integer. The character set and collation\nof the string are set according to the values of the\ncharacter_set_database and collation_database system\nvariables.\n \nCHR() is similar to the CHAR() function, but only accepts a\nsingle argument.\n \nCHR() is available in all sql_modes.\n \n\nSELECT CHR(67);\n+---------+\n| CHR(67) |\n+---------+\n| C |\n+---------+\n \nSELECT CHR(''67'');\n+-----------+\n| CHR(''67'') |\n+-----------+\n| C |\n+-----------+\n \nSELECT CHR(''C'');\n+----------+\n| CHR(''C'') |\n+----------+\n| |\n+----------+\n1 row in set, 1 warning (0.000 sec)\n \nSHOW WARNINGS;\n \n+---------+------+----------------------------------------+\n| Level | Code | Message |\n+---------+------+----------------------------------------+\n| Warning | 1292 | Truncated incorrect INTEGER value: ''C''\n|\n+---------+------+----------------------------------------+
[COALESCE]
declaration=value,...
category=Comparison Operators
description=Returns the first non-NULL value in the list, or NULL if\nthere are no\nnon-NULL values. At least one parameter must be passed.\n \nSee also NULL Values in MariaDB.\n \n\nSELECT COALESCE(NULL,1);\n+------------------+\n| COALESCE(NULL,1) |\n+------------------+\n| 1 |\n+------------------+\n \nSELECT COALESCE(NULL,NULL,NULL);\n+--------------------------+\n| COALESCE(NULL,NULL,NULL) |\n+--------------------------+\n| NULL |\n+--------------------------+\n \nWhen two arguments are given, COALESCE() is the same as\nIFNULL():\n \nSET @a=NULL, @b=1;\n \nSELECT COALESCE(@a, @b), IFNULL(@a, @b);\n+------------------+----------------+\n| COALESCE(@a, @b) | IFNULL(@a, @b) |\n+------------------+----------------+\n| 1 | 1 |\n+------------------+----------------+\n \nHex type confusion:\n \nCREATE TABLE t1 (a INT, b VARCHAR(10));\nINSERT INTO t1 VALUES (0x31, 0x61),(COALESCE(0x31),\nCOALESCE(0x61));\n \nSELECT * FROM t1;\n \n+------+------+\n| a | b |\n+------+------+\n| 49 | a |\n| 1 | a |\n+------+------+\n \nThe reason for the differing results above is that when 0x31\nis inserted directly to the column, it''s treated as a\nnumber (see Hexadecimal Literals), while when 0x31 is passed\nto COALESCE(), it''s treated as a string, because:\nHEX values have a string data type by default.\nCOALESCE() has the same data type as the argument.
[COERCIBILITY]
declaration=str
category=Information Functions
description=Returns the collation coercibility value of the string\nargument. Coercibility defines what will be converted to\nwhat in case of collation conflict, with an expression with\nhigher coercibility being converted to the collation of an\nexpression with lower coercibility.\n \nCoercibility | Description | Example | \n \n0 | Explicit | Value using a COLLATE clause | \n \n1 | No collation | Concatenated strings using different\ncollations | \n \n2 | Implicit | Column value | \n \n3 | Constant | USER() return value | \n \n4 | Coercible | Literal string | \n \n5 | Ignorable | NULL or derived from NULL | \n \n\nSELECT COERCIBILITY(''abc'' COLLATE latin1_swedish_ci);\n+-----------------------------------------------+\n| COERCIBILITY(''abc'' COLLATE latin1_swedish_ci) |\n+-----------------------------------------------+\n| 0 |\n+-----------------------------------------------+\n \nSELECT COERCIBILITY(USER());\n+----------------------+\n| COERCIBILITY(USER()) |\n+----------------------+\n| 3 |\n+----------------------+\n \nSELECT COERCIBILITY(''abc'');\n+---------------------+\n| COERCIBILITY(''abc'') |\n+---------------------+\n| 4 |\n+---------------------+
[COLLATION]
declaration=str
category=Information Functions
description=Returns the collation of the string argument. If str is not\na string, it is considered as a binary string (so the\nfunction returns ''binary''). This applies to NULL, too. The\nreturn value is a string in the utf8 character set.\n \nSee Character Sets and Collations.\n \n\nSELECT COLLATION(''abc'');\n+-------------------+\n| COLLATION(''abc'') |\n+-------------------+\n| latin1_swedish_ci |\n+-------------------+\n \nSELECT COLLATION(_utf8''abc'');\n+-----------------------+\n| COLLATION(_utf8''abc'') |\n+-----------------------+\n| utf8_general_ci |\n+-----------------------+
[COLUMN_ADD1]
name=COLUMN_ADD
declaration=dyncol_blob, column_nr, value [as type], [column_nr, value [as type]]...
category=Dynamic Column Functions
description=Adds or updates dynamic columns.\ndyncol_blob must be either a valid dynamic columns blob (for\nexample, COLUMN_CREATE returns such blob), or an empty\nstring.\ncolumn_name specifies the name of the column to be added. If\ndyncol_blob already has a column with this name, it will be\noverwritten.\nvalue specifies the new value for the column. Passing a NULL\nvalue will cause the column to be deleted.\nas type is optional. See #datatypes section for a discussion\nabout types.\n \nThe return value is a dynamic column blob after the\nmodifications.\n \n\n-- MariaDB 5.3+:\nUPDATE tbl SET dyncol_blob=COLUMN_ADD(dyncol_blob, 1\n/*column id*/, "value") WHERE id=1;\n \n-- MariaDB 10.0.1+:\nUPDATE t1 SET dyncol_blob=COLUMN_ADD(dyncol_blob,\n"column_name", "value") WHERE id=1;\n \nNote: COLUMN_ADD() is a regular function (just like\nCONCAT()), hence, in order to update the value in the table\nyou have to use the UPDATE ... SET\ndynamic_col=COLUMN_ADD(dynamic_col,\n....)  pattern.
[COLUMN_ADD2]
name=COLUMN_ADD
declaration=dyncol_blob, column_name, value [as type], [column_name, value [as type]]...
category=Dynamic Column Functions
description=Adds or updates dynamic columns.\ndyncol_blob must be either a valid dynamic columns blob (for\nexample, COLUMN_CREATE returns such blob), or an empty\nstring.\ncolumn_name specifies the name of the column to be added. If\ndyncol_blob already has a column with this name, it will be\noverwritten.\nvalue specifies the new value for the column. Passing a NULL\nvalue will cause the column to be deleted.\nas type is optional. See #datatypes section for a discussion\nabout types.\n \nThe return value is a dynamic column blob after the\nmodifications.\n \n\n-- MariaDB 5.3+:\nUPDATE tbl SET dyncol_blob=COLUMN_ADD(dyncol_blob, 1\n/*column id*/, "value") WHERE id=1;\n \n-- MariaDB 10.0.1+:\nUPDATE t1 SET dyncol_blob=COLUMN_ADD(dyncol_blob,\n"column_name", "value") WHERE id=1;\n \nNote: COLUMN_ADD() is a regular function (just like\nCONCAT()), hence, in order to update the value in the table\nyou have to use the UPDATE ... SET\ndynamic_col=COLUMN_ADD(dynamic_col,\n....)  pattern.
[COLUMN_CHECK]
declaration=dyncol_blob
category=Dynamic Column Functions
description=Check if dyncol_blob is a valid packed dynamic columns blob.\nReturn value of 1 means the blob is valid, return value of 0\nmeans it is not.\n \nRationale:\nNormally, one works with valid dynamic column blobs.\nFunctions like COLUMN_CREATE, COLUMN_ADD, COLUMN_DELETE\nalways return valid dynamic column blobs. However, if a\ndynamic column blob is accidentally truncated, or transcoded\nfrom one character set to another, it will be corrupted.\nThis function can be used to check if a value in a blob\nfield is a valid dynamic column blob.
[COLUMN_CREATE1]
name=COLUMN_CREATE
declaration=column_nr, value [as type], [column_nr, value [as type]]...
category=Dynamic Column Functions
description=Returns a dynamic columns blob that stores the specified\ncolumns with values.\n \nThe return value is suitable for \nstoring in a table\nfurther modification with other dynamic columns functions\n \nThe as type part allows one to specify the value type. In\nmost cases,\nthis is redundant because MariaDB will be able to deduce the\ntype of the\nvalue. Explicit type specification may be needed when the\ntype of the value is\nnot apparent. For example, a literal ''2012-12-01'' has a\nCHAR type by\ndefault, one will need to specify ''2012-12-01'' AS DATE to\nhave it stored as\na date. See Dynamic Columns:Datatypes for further details.\n \n\n-- MariaDB 5.3+:\nINSERT INTO tbl SET dyncol_blob=COLUMN_CREATE(1 /*column\nid*/, "value");\n-- MariaDB 10.0.1+:\nINSERT INTO tbl SET\ndyncol_blob=COLUMN_CREATE("column_name", "value");
[COLUMN_CREATE2]
name=COLUMN_CREATE
declaration=column_name, value [as type], [column_name, value [as type]]...
category=Dynamic Column Functions
description=Returns a dynamic columns blob that stores the specified\ncolumns with values.\n \nThe return value is suitable for \nstoring in a table\nfurther modification with other dynamic columns functions\n \nThe as type part allows one to specify the value type. In\nmost cases,\nthis is redundant because MariaDB will be able to deduce the\ntype of the\nvalue. Explicit type specification may be needed when the\ntype of the value is\nnot apparent. For example, a literal ''2012-12-01'' has a\nCHAR type by\ndefault, one will need to specify ''2012-12-01'' AS DATE to\nhave it stored as\na date. See Dynamic Columns:Datatypes for further details.\n \n\n-- MariaDB 5.3+:\nINSERT INTO tbl SET dyncol_blob=COLUMN_CREATE(1 /*column\nid*/, "value");\n-- MariaDB 10.0.1+:\nINSERT INTO tbl SET\ndyncol_blob=COLUMN_CREATE("column_name", "value");
[COLUMN_DELETE1]
name=COLUMN_DELETE
declaration=dyncol_blob, column_nr, column_nr...
category=Dynamic Column Functions
description=Deletes a dynamic column with the specified name. Multiple\nnames can be given. The return value is a dynamic column\nblob after the modification.
[COLUMN_DELETE2]
name=COLUMN_DELETE
declaration=dyncol_blob, column_name, column_name...
category=Dynamic Column Functions
description=Deletes a dynamic column with the specified name. Multiple\nnames can be given. The return value is a dynamic column\nblob after the modification.
[COLUMN_EXISTS1]
name=COLUMN_EXISTS
declaration=dyncol_blob, column_nr
category=Dynamic Column Functions
description=Checks if a column with name column_name exists in\ndyncol_blob. If yes, return 1, otherwise return 0. See\ndynamic columns for more information.
[COLUMN_EXISTS2]
name=COLUMN_EXISTS
declaration=dyncol_blob, column_name
category=Dynamic Column Functions
description=Checks if a column with name column_name exists in\ndyncol_blob. If yes, return 1, otherwise return 0. See\ndynamic columns for more information.
[COLUMN_GET1]
name=COLUMN_GET
declaration=dyncol_blob, column_nr as type
category=Dynamic Column Functions
description=Gets the value of a dynamic column by its name. If no column\nwith the given name exists, NULL will be returned.\n \ncolumn_name as type requires that one specify the datatype\nof the dynamic column they are reading. \n \nThis may seem counter-intuitive: why would one need to\nspecify which datatype they''re retrieving? Can''t the\ndynamic columns system figure the datatype from the data\nbeing stored?\n \nThe answer is: SQL is a statically-typed language. The SQL\ninterpreter needs to know the datatypes of all expressions\nbefore the query is run (for example, when one is using\nprepared statements and runs "select COLUMN_GET(...)", the\nprepared statement API requires the server to inform the\nclient about the datatype of the column being read before\nthe query is executed and the server can see what datatype\nthe column actually has).\n \nA note about lengths\n \nIf you''re running queries like:\n \nSELECT COLUMN_GET(blob, ''colname'' as CHAR) ...\n \nwithout specifying a maximum length (i.e. using #as CHAR#,\nnot as CHAR(n)), MariaDB will report the maximum length of\nthe resultset column to be 53,6870,911 for MariaDB\n5.3-10.0.0 and 16,777,216 for MariaDB 10.0.1+. This may\ncause excessive memory usage in some client libraries,\nbecause they try to pre-allocate a buffer of maximum\nresultset width. To avoid this problem, use CHAR(n) whenever\nyou''re using COLUMN_GET in the select list.\n \nSee Dynamic Columns:Datatypes for more information about\ndatatypes.
[COLUMN_GET2]
name=COLUMN_GET
declaration=dyncol_blob, column_name as type
category=Dynamic Column Functions
description=Gets the value of a dynamic column by its name. If no column\nwith the given name exists, NULL will be returned.\n \ncolumn_name as type requires that one specify the datatype\nof the dynamic column they are reading. \n \nThis may seem counter-intuitive: why would one need to\nspecify which datatype they''re retrieving? Can''t the\ndynamic columns system figure the datatype from the data\nbeing stored?\n \nThe answer is: SQL is a statically-typed language. The SQL\ninterpreter needs to know the datatypes of all expressions\nbefore the query is run (for example, when one is using\nprepared statements and runs "select COLUMN_GET(...)", the\nprepared statement API requires the server to inform the\nclient about the datatype of the column being read before\nthe query is executed and the server can see what datatype\nthe column actually has).\n \nA note about lengths\n \nIf you''re running queries like:\n \nSELECT COLUMN_GET(blob, ''colname'' as CHAR) ...\n \nwithout specifying a maximum length (i.e. using #as CHAR#,\nnot as CHAR(n)), MariaDB will report the maximum length of\nthe resultset column to be 53,6870,911 for MariaDB\n5.3-10.0.0 and 16,777,216 for MariaDB 10.0.1+. This may\ncause excessive memory usage in some client libraries,\nbecause they try to pre-allocate a buffer of maximum\nresultset width. To avoid this problem, use CHAR(n) whenever\nyou''re using COLUMN_GET in the select list.\n \nSee Dynamic Columns:Datatypes for more information about\ndatatypes.
[COLUMN_JSON]
declaration=dyncol_blob
category=Dynamic Column Functions
description=Returns a JSON representation of data in dyncol_blob. Can\nalso be used to display nested columns. See dynamic columns\nfor more information.\n \nExample\n \nselect item_name, COLUMN_JSON(dynamic_cols) from assets;\n+-----------------+----------------------------------------+\n| item_name | COLUMN_JSON(dynamic_cols) |\n+-----------------+----------------------------------------+\n| MariaDB T-shirt | {"size":"XL","color":"blue"} |\n| Thinkpad Laptop | {"color":"black","warranty":"3\nyears"} |\n+-----------------+----------------------------------------+\n \nLimitation: COLUMN_JSON will decode nested dynamic columns\nat a nesting level of not more than 10 levels deep. Dynamic\ncolumns that are nested deeper than 10 levels will be shown\nas BINARY string, without encoding.
[COLUMN_LIST]
declaration=dyncol_blob
category=Dynamic Column Functions
description=Since MariaDB 10.0.1, this function returns a\ncomma-separated list of column names. The names are quoted\nwith backticks.\n \nBefore MariaDB 10.0.1, it returned a comma-separated list of\ncolumn numbers, not names.\n \nSee dynamic columns for more information.
[COMPRESS]
declaration=string_to_compress
category=Encryption Functions
description=Compresses a string and returns the result as a binary\nstring. This\nfunction requires MariaDB to have been compiled with a\ncompression\nlibrary such as zlib. Otherwise, the return value is always\nNULL. The\ncompressed string can be uncompressed with UNCOMPRESS().\n \nThe have_compress server system variable indicates whether a\ncompression library is present. \n \n\nSELECT LENGTH(COMPRESS(REPEAT(''a'',1000)));\n+------------------------------------+\n| LENGTH(COMPRESS(REPEAT(''a'',1000))) |\n+------------------------------------+\n| 21 |\n+------------------------------------+\n \nSELECT LENGTH(COMPRESS(''''));\n+----------------------+\n| LENGTH(COMPRESS('''')) |\n+----------------------+\n| 0 |\n+----------------------+\n \nSELECT LENGTH(COMPRESS(''a''));\n+-----------------------+\n| LENGTH(COMPRESS(''a'')) |\n+-----------------------+\n| 13 |\n+-----------------------+\n \nSELECT LENGTH(COMPRESS(REPEAT(''a'',16)));\n+----------------------------------+\n| LENGTH(COMPRESS(REPEAT(''a'',16))) |\n+----------------------------------+\n| 15 |\n+----------------------------------+
[CONCAT]
declaration=str1,str2,...
category=String Functions
description=Returns the string that results from concatenating the\narguments. May have one or more arguments. If all arguments\nare non-binary strings, the result is a non-binary string.\nIf the arguments include any binary strings, the result is a\nbinary string. A numeric argument is converted to its\nequivalent binary string form; if you want to avoid that,\nyou can use an explicit type cast, as in this example:\n \nSELECT CONCAT(CAST(int_col AS CHAR), char_col);\n \nCONCAT() returns NULL if any argument is NULL.\n \nA NULL parameter hides all information contained in other\nparameters from the result. Sometimes this is not desirable;\nto avoid this, you can:\nUse the CONCAT_WS() function with an empty separator,\nbecause that function is NULL-safe.\nUse IFNULL() to turn NULLs into empty strings.\n \nOracle Mode\n \nIn Oracle mode from MariaDB 10.3, CONCAT ignores NULL.\n \n\nSELECT CONCAT(''Ma'', ''ria'', ''DB'');\n+---------------------------+\n| CONCAT(''Ma'', ''ria'', ''DB'') |\n+---------------------------+\n| MariaDB |\n+---------------------------+\n \nSELECT CONCAT(''Ma'', ''ria'', NULL, ''DB'');\n+---------------------------------+\n| CONCAT(''Ma'', ''ria'', NULL, ''DB'') |\n+---------------------------------+\n| NULL |\n+---------------------------------+\n \nSELECT CONCAT(42.0);\n+--------------+\n| CONCAT(42.0) |\n+--------------+\n| 42.0 |\n+--------------+\n \nUsing IFNULL() to handle NULLs:\n \nSELECT CONCAT(''The value of @v is: '', IFNULL(@v, ''''));\n+------------------------------------------------+\n| CONCAT(''The value of @v is: '', IFNULL(@v, '''')) |\n+------------------------------------------------+\n| The value of @v is: |\n+------------------------------------------------+\n \nIn Oracle mode, from MariaDB 10.3:\n \nSELECT CONCAT(''Ma'', ''ria'', NULL, ''DB'');\n+---------------------------------+\n| CONCAT(''Ma'', ''ria'', NULL, ''DB'') |\n+---------------------------------+\n| MariaDB |\n+---------------------------------+
[CONCAT_WS]
declaration=separator,str1,str2,...
category=String Functions
description=CONCAT_WS() stands for Concatenate With Separator and is a\nspecial form of CONCAT(). The first argument is the\nseparator for the rest of the arguments. The separator is\nadded between the strings to be concatenated. The separator\ncan be a string, as can the rest of the arguments.\n \nIf the separator is NULL, the result is NULL; all other NULL\nvalues are skipped. This makes CONCAT_WS() suitable when you\nwant to concatenate some values and avoid losing all\ninformation if one of them is NULL.\n \n\nSELECT CONCAT_WS('','',''First name'',''Second name'',''Last\nName'');\n+-------------------------------------------------------+\n| CONCAT_WS('','',''First name'',''Second name'',''Last\nName'') |\n+-------------------------------------------------------+\n| First name,Second name,Last Name |\n+-------------------------------------------------------+\n \nSELECT CONCAT_WS(''-'',''Floor'',NULL,''Room'');\n+------------------------------------+\n| CONCAT_WS(''-'',''Floor'',NULL,''Room'') |\n+------------------------------------+\n| Floor-Room |\n+------------------------------------+\n \nIn some cases, remember to include a space in the separator\nstring:\n \nSET @a = ''gnu'', @b = ''penguin'', @c = ''sea lion'';\n \nQuery OK, 0 rows affected (0.00 sec)\n \nSELECT CONCAT_WS('', '', @a, @b, @c);\n+-----------------------------+\n| CONCAT_WS('', '', @a, @b, @c) |\n+-----------------------------+\n| gnu, penguin, sea lion |\n+-----------------------------+\n \nUsing CONCAT_WS() to handle NULLs:\n \nSET @a = ''a'', @b = NULL, @c = ''c'';\n \nSELECT CONCAT_WS('''', @a, @b, @c);\n+---------------------------+\n| CONCAT_WS('''', @a, @b, @c) |\n+---------------------------+\n| ac |\n+---------------------------+
[CONNECTION_ID]
declaration=
category=Information Functions
description=Returns the connection ID (thread ID) for the connection.\nEvery\nthread (including events) has an ID that is unique among the\nset of currently\nconnected clients.\n \nUntil MariaDB 10.3.1, returns MYSQL_TYPE_LONGLONG, or\nbigint(10), in all cases. From MariaDB 10.3.1, returns\nMYSQL_TYPE_LONG, or int(10), when the result would fit\nwithin 32-bits.\n \n\nSELECT CONNECTION_ID();\n+-----------------+\n| CONNECTION_ID() |\n+-----------------+\n| 3 |\n+-----------------+
[CONTAINS]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether a geometry g1 completely\ncontains geometry g2. CONTAINS() is based on the original\nMySQL implementation and uses object bounding rectangles,\nwhile ST_CONTAINS() uses object shapes. \n \nThis tests the opposite relationship to Within().
[CONVERT1]
name=CONVERT
declaration=expr,type
category=String Functions
description=The CONVERT() and CAST() functions take a value of one type\nand produce a value of another type.\n \nThe type can be one of the following values:\nBINARY\nCHAR\nDATE\nDATETIME \nDECIMAL[(M[,D])]\nDOUBLE \nFLOAT — From MariaDB 10.4.5\nINTEGER \nShort for SIGNED INTEGER\n \nSIGNED [INTEGER]\nTIME \nUNSIGNED [INTEGER]\n \nNote that in MariaDB, INT and INTEGER are the same thing.\n \nBINARY produces a string with the BINARY data type. If the\noptional length is given, BINARY(N) causes the cast to use\nno more than N bytes of the argument. Values shorter than\nthe given number in bytes are padded with 0x00 bytes to make\nthem equal the length value.\n \nCHAR(N) causes the cast to use no more than the number of\ncharacters given in the argument.\n \nThe main difference between the CAST() and CONVERT() is that\nCONVERT(expr,type) is ODBC syntax while CAST(expr as type)\nand CONVERT(... USING ...) are SQL92 syntax.\n \nCONVERT() with USING is used to convert data between\ndifferent character sets. In MariaDB, transcoding names are\nthe same as the\ncorresponding character set names. For example, this\nstatement\nconverts the string ''abc'' in the default character set to\nthe\ncorresponding string in the utf8 character set:\n \nSELECT CONVERT(''abc'' USING utf8);\n \n\nSELECT enum_col FROM tbl_name \nORDER BY CAST(enum_col AS CHAR);\n \nConverting a BINARY to string to permit the LOWER function\nto work:\n \nSET @x = ''AardVark'';\n \nSET @x = BINARY ''AardVark'';\n \nSELECT LOWER(@x), LOWER(CONVERT (@x USING latin1));\n+-----------+----------------------------------+\n| LOWER(@x) | LOWER(CONVERT (@x USING latin1)) |\n+-----------+----------------------------------+\n| AardVark | aardvark |\n+-----------+----------------------------------+
[CONVERT2]
name=CONVERT
declaration=expr USING transcoding_name
category=String Functions
description=The CONVERT() and CAST() functions take a value of one type\nand produce a value of another type.\n \nThe type can be one of the following values:\nBINARY\nCHAR\nDATE\nDATETIME \nDECIMAL[(M[,D])]\nDOUBLE \nFLOAT — From MariaDB 10.4.5\nINTEGER \nShort for SIGNED INTEGER\n \nSIGNED [INTEGER]\nTIME \nUNSIGNED [INTEGER]\n \nNote that in MariaDB, INT and INTEGER are the same thing.\n \nBINARY produces a string with the BINARY data type. If the\noptional length is given, BINARY(N) causes the cast to use\nno more than N bytes of the argument. Values shorter than\nthe given number in bytes are padded with 0x00 bytes to make\nthem equal the length value.\n \nCHAR(N) causes the cast to use no more than the number of\ncharacters given in the argument.\n \nThe main difference between the CAST() and CONVERT() is that\nCONVERT(expr,type) is ODBC syntax while CAST(expr as type)\nand CONVERT(... USING ...) are SQL92 syntax.\n \nCONVERT() with USING is used to convert data between\ndifferent character sets. In MariaDB, transcoding names are\nthe same as the\ncorresponding character set names. For example, this\nstatement\nconverts the string ''abc'' in the default character set to\nthe\ncorresponding string in the utf8 character set:\n \nSELECT CONVERT(''abc'' USING utf8);\n \n\nSELECT enum_col FROM tbl_name \nORDER BY CAST(enum_col AS CHAR);\n \nConverting a BINARY to string to permit the LOWER function\nto work:\n \nSET @x = ''AardVark'';\n \nSET @x = BINARY ''AardVark'';\n \nSELECT LOWER(@x), LOWER(CONVERT (@x USING latin1));\n+-----------+----------------------------------+\n| LOWER(@x) | LOWER(CONVERT (@x USING latin1)) |\n+-----------+----------------------------------+\n| AardVark | aardvark |\n+-----------+----------------------------------+
[CONVERT_TZ]
declaration=dt,from_tz,to_tz
category=Date and Time Functions
description=CONVERT_TZ() converts a datetime value dt from the time zone\ngiven by from_tz to the time zone given by to_tz and returns\nthe resulting value.\n \nIn order to use named time zones, such as GMT, MET or\nAfrica/Johannesburg, the time_zone tables must be loaded\n(see mysql_tzinfo_to_sql).\n \nNo conversion will take place if the value falls outside of\nthe supported TIMESTAMP range (''1970-01-01 00:00:01'' to\n''2038-01-19 05:14:07'' UTC) when converted from from_tz to\nUTC.\n \nThis function returns NULL if the arguments are invalid (or\nnamed time zones have not been loaded).\n \nSee time zones for more information.\n \n\nSELECT CONVERT_TZ(''2016-01-01\n12:00:00'',''+00:00'',''+10:00'');\n+-----------------------------------------------------+\n| CONVERT_TZ(''2016-01-01 12:00:00'',''+00:00'',''+10:00'')\n|\n+-----------------------------------------------------+\n| 2016-01-01 22:00:00 |\n+-----------------------------------------------------+\n \nUsing named time zones (with the time zone tables loaded):\n \nSELECT CONVERT_TZ(''2016-01-01\n12:00:00'',''GMT'',''Africa/Johannesburg'');\n+---------------------------------------------------------------+\n| CONVERT_TZ(''2016-01-01\n12:00:00'',''GMT'',''Africa/Johannesburg'') |\n+---------------------------------------------------------------+\n| 2016-01-01 14:00:00 |\n+---------------------------------------------------------------+\n \nThe value is out of the TIMESTAMP range, so no conversion\ntakes place:\n \nSELECT CONVERT_TZ(''1969-12-31\n22:00:00'',''+00:00'',''+10:00'');\n+-----------------------------------------------------+\n| CONVERT_TZ(''1969-12-31 22:00:00'',''+00:00'',''+10:00'')\n|\n+-----------------------------------------------------+\n| 1969-12-31 22:00:00 |\n+-----------------------------------------------------+
[CONV]
declaration=N,from_base,to_base
category=Numeric Functions
description=Converts numbers between different number bases. Returns a\nstring\nrepresentation of the number N, converted from base\nfrom_base\nto base to_base.\n \nReturns NULL if any argument is NULL, or if the second or\nthird argument are not in the allowed range.\n \nThe argument N is interpreted as an integer, but may be\nspecified as an\ninteger or a string. The minimum base is 2 and the maximum\nbase is 36. If\nto_base is a negative number, N is regarded as a signed\nnumber.\nOtherwise, N is treated as unsigned. CONV() works with\n64-bit\nprecision.\n \nSome shortcuts for this function are also available: BIN(),\nOCT(), HEX(), UNHEX(). Also, MariaDB allows binary literal\nvalues and hexadecimal literal values.\n \n\nSELECT CONV(''a'',16,2);\n+----------------+\n| CONV(''a'',16,2) |\n+----------------+\n| 1010 |\n+----------------+\n \nSELECT CONV(''6E'',18,8);\n+-----------------+\n| CONV(''6E'',18,8) |\n+-----------------+\n| 172 |\n+-----------------+\n \nSELECT CONV(-17,10,-18);\n+------------------+\n| CONV(-17,10,-18) |\n+------------------+\n| -H |\n+------------------+\n \nSELECT CONV(12+''10''+''10''+0xa,10,10);\n+------------------------------+\n| CONV(12+''10''+''10''+0xa,10,10) |\n+------------------------------+\n| 42 |\n+------------------------------+
[COS]
declaration=X
category=Numeric Functions
description=Returns the cosine of X, where X is given in radians.\n \n\nSELECT COS(PI());\n+-----------+\n| COS(PI()) |\n+-----------+\n| -1 |\n+-----------
[COT]
declaration=X
category=Numeric Functions
description=Returns the cotangent of X.\n \n\nSELECT COT(42);\n+--------------------+\n| COT(42) |\n+--------------------+\n| 0.4364167060752729 |\n+--------------------+\n \nSELECT COT(12);\n+---------------------+\n| COT(12) |\n+---------------------+\n| -1.5726734063976893 |\n+---------------------+\n \nSELECT COT(0);\nERROR 1690 (22003): DOUBLE value is out of range in\n''cot(0)''
[COUNT]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns a count of the number of non-NULL values of expr in\nthe rows retrieved by a SELECT statement. The result is a\nBIGINT value. It is an aggregate function, and so can be\nused with the GROUP BY clause.\n \nCOUNT(*) counts the total number of rows in a table.\n \nCOUNT() returns 0 if there were no matching rows.\n \nFrom MariaDB 10.2.0, COUNT() can be used as a window\nfunction.\n \n\nCREATE TABLE student (name CHAR(10), test CHAR(10), score\nTINYINT); \n \nINSERT INTO student VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87), (''Tatiana'', ''Tuning'', 83);\n \nSELECT COUNT(*) FROM student;\n \n+----------+\n| COUNT(*) |\n+----------+\n| 8 |\n+----------+\n \nCOUNT(DISTINCT) example:\n \nSELECT COUNT(DISTINCT (name)) FROM student;\n \n+------------------------+\n| COUNT(DISTINCT (name)) |\n+------------------------+\n| 4 |\n+------------------------+\n \nAs a window function\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\n \nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, COUNT(score) OVER (PARTITION BY\nname) \n AS tests_written FROM student_test;\n \n+---------+--------+-------+---------------+\n| name | test | score | tests_written |\n+---------+--------+-------+---------------+\n| Chun | SQL | 75 | 2 |\n| Chun | Tuning | 73 | 2 |\n| Esben | SQL | 43 | 2 |\n| Esben | Tuning | 31 | 2 |\n| Kaolin | SQL | 56 | 2 |\n| Kaolin | Tuning | 88 | 2 |\n| Tatiana | SQL | 87 | 1 |\n+---------+--------+-------+---------------+
[CRC32]
declaration=expr
category=Numeric Functions
description=Computes a cyclic redundancy check value and returns a\n32-bit unsigned\nvalue. The result is NULL if the argument is NULL. The\nargument is\nexpected to be a string and (if possible) is treated as one\nif it is\nnot.\n \n\nSELECT CRC32(''MariaDB'');\n+------------------+\n| CRC32(''MariaDB'') |\n+------------------+\n| 4227209140 |\n+------------------+\n \nSELECT CRC32(''mariadb'');\n+------------------+\n| CRC32(''mariadb'') |\n+------------------+\n| 2594253378 |\n+------------------+
[CROSSES]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 if g1 spatially crosses g2. Returns NULL if g1 is\na Polygon or a MultiPolygon, or if g2 is a\nPoint or a MultiPoint. Otherwise, returns 0.\n \nThe term spatially crosses denotes a spatial relation\nbetween two\ngiven geometries that has the following properties:\nThe two geometries intersect\nTheir intersection results in a geometry that has a\ndimension that is one\n less than the maximum dimension of the two given geometries\nTheir intersection is not equal to either of the two given\ngeometries\n \nCROSSES() is based on the original MySQL implementation, and\nuses object bounding rectangles, while ST_CROSSES() uses\nobject shapes.
[CUME_DIST1]
name=CUME_DIST
declaration=
category=Window Functions
description=CUME_DIST() is a window function that returns the cumulative\ndistribution of a given row. The following formula is used\nto calculate the value:\n \n(number of rows
[CUME_DIST2]
name=CUME_DIST
declaration=[ PARTITION BY partition_expression ]   [ ORDER BY order_list ]
category=Window Functions
description=CUME_DIST() is a window function that returns the cumulative\ndistribution of a given row. The following formula is used\nto calculate the value:\n \n(number of rows
[CURRENT_TIMESTAMP]
name=CURRENT_TIMESTAMP
declaration=
category=Date and Time Functions
description=CURRENT_TIMESTAMP and CURRENT_TIMESTAMP() are synonyms for NOW().
[CURDATE]
declaration=
category=Date and Time Functions
description=Returns the current date as a value in ''YYYY-MM-DD'' or\nYYYYMMDD\nformat, depending on whether the function is used in a\nstring or\nnumeric context.\n \n\nSELECT CURDATE();\n+------------+\n| CURDATE() |\n+------------+\n| 2019-03-05 |\n+------------+\n \nIn a numeric context (note this is not performing date\ncalculations):\n \nSELECT CURDATE() +0;\n \n+--------------+\n| CURDATE() +0 |\n+--------------+\n| 20190305 |\n+--------------+\n \nData calculation:\n \nSELECT CURDATE() - INTERVAL 5 DAY;\n \n+----------------------------+\n| CURDATE() - INTERVAL 5 DAY |\n+----------------------------+\n| 2019-02-28 |\n+----------------------------+
[CURTIME]
declaration=[precision]
category=Date and Time Functions
description=Returns the current time as a value in ''HH:MM:SS'' or\nHHMMSS.uuuuuu format, depending on whether the function is\nused in a string or numeric context. The value is expressed\nin the current time zone.\n \nThe optional precision determines the microsecond precision.\nSee Microseconds in MariaDB.\n \n\nSELECT CURTIME();\n+-----------+\n| CURTIME() |\n+-----------+\n| 12:45:39 |\n+-----------+\n \nSELECT CURTIME() + 0;\n \n+---------------+\n| CURTIME() + 0 |\n+---------------+\n| 124545.000000 |\n+---------------+\n \nWith precision:\n \nSELECT CURTIME(2);\n+-------------+\n| CURTIME(2) |\n+-------------+\n| 09:49:08.09 |\n+-------------+
[DATABASE]
declaration=
category=Information Functions
description=Returns the default (current) database name as a string in\nthe utf8 character set. If there is no default database,\nDATABASE() returns NULL. Within a stored routine, the\ndefault database is the database that the routine is\nassociated with, which is not necessarily the same as the\ndatabase that is the default in the calling context.\n \nSCHEMA() is a synonym for DATABASE().\n \nTo select a default database, the USE statement can be run.\nAnother way to set the default database is specifying its\nname at mysql command line client startup.\n \n\nSELECT DATABASE();\n+------------+\n| DATABASE() |\n+------------+\n| NULL |\n+------------+\n \nUSE test;\n \nDatabase changed\n \nSELECT DATABASE();\n+------------+\n| DATABASE() |\n+------------+\n| test |\n+------------+
[DATEDIFF]
declaration=expr1,expr2
category=Date and Time Functions
description=DATEDIFF() returns (expr1 – expr2) expressed\nas a value in days from one date to the other. expr1 and\nexpr2 are date\nor date-and-time expressions. Only the date parts of the\nvalues are used in the\ncalculation.\n \n\nSELECT DATEDIFF(''2007-12-31 23:59:59'',''2007-12-30'');\n+----------------------------------------------+\n| DATEDIFF(''2007-12-31 23:59:59'',''2007-12-30'') |\n+----------------------------------------------+\n| 1 |\n+----------------------------------------------+\n \nSELECT DATEDIFF(''2010-11-30 23:59:59'',''2010-12-31'');\n+----------------------------------------------+\n| DATEDIFF(''2010-11-30 23:59:59'',''2010-12-31'') |\n+----------------------------------------------+\n| -31 |\n+----------------------------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT NOW();\n+---------------------+\n| NOW() |\n+---------------------+\n| 2011-05-23 10:56:05 |\n+---------------------+\n \nSELECT d, DATEDIFF(NOW(),d) FROM t1;\n \n+---------------------+-------------------+\n| d | DATEDIFF(NOW(),d) |\n+---------------------+-------------------+\n| 2007-01-30 21:31:07 | 1574 |\n| 1983-10-15 06:42:51 | 10082 |\n| 2011-04-21 12:34:56 | 32 |\n| 2011-10-30 06:31:41 | -160 |\n| 2011-01-30 14:03:25 | 113 |\n| 2004-10-07 11:19:34 | 2419 |\n+---------------------+-------------------+
[DATE_ADD]
declaration=date,INTERVAL expr unit
category=Date and Time Functions
description=Performs date arithmetic. The date argument specifies the\nstarting date or datetime value. expr is an expression\nspecifying the\ninterval value to be added or subtracted from the starting\ndate. expr is a\nstring; it may start with a "-" for negative intervals.\nunit is a\nkeyword indicating the units in which the expression should\nbe interpreted. See Date and Time Units for a complete list\nof permitted units. \n \nSee also DATE_SUB().\n \n\nSELECT ''2008-12-31 23:59:59'' + INTERVAL 1 SECOND;\n \n+-------------------------------------------+\n| ''2008-12-31 23:59:59'' + INTERVAL 1 SECOND |\n+-------------------------------------------+\n| 2009-01-01 00:00:00 |\n+-------------------------------------------+\n \nSELECT INTERVAL 1 DAY + ''2008-12-31'';\n \n+-------------------------------+\n| INTERVAL 1 DAY + ''2008-12-31'' |\n+-------------------------------+\n| 2009-01-01 |\n+-------------------------------+\n \nSELECT ''2005-01-01'' - INTERVAL 1 SECOND;\n \n+----------------------------------+\n| ''2005-01-01'' - INTERVAL 1 SECOND |\n+----------------------------------+\n| 2004-12-31 23:59:59 |\n+----------------------------------+\n \nSELECT DATE_ADD(''2000-12-31 23:59:59'', INTERVAL 1 SECOND);\n+----------------------------------------------------+\n| DATE_ADD(''2000-12-31 23:59:59'', INTERVAL 1 SECOND) |\n+----------------------------------------------------+\n| 2001-01-01 00:00:00 |\n+----------------------------------------------------+\n \nSELECT DATE_ADD(''2010-12-31 23:59:59'', INTERVAL 1 DAY);\n+-------------------------------------------------+\n| DATE_ADD(''2010-12-31 23:59:59'', INTERVAL 1 DAY) |\n+-------------------------------------------------+\n| 2011-01-01 23:59:59 |\n+-------------------------------------------------+\n \nSELECT DATE_ADD(''2100-12-31 23:59:59'', INTERVAL ''1:1''\nMINUTE_SECOND);\n+---------------------------------------------------------------+\n| DATE_ADD(''2100-12-31 23:59:59'', INTERVAL ''1:1''\nMINUTE_SECOND) |\n+---------------------------------------------------------------+\n| 2101-01-01 00:01:00 |\n+---------------------------------------------------------------+\n \nSELECT DATE_ADD(''1900-01-01 00:00:00'', INTERVAL ''-1 10''\nDAY_HOUR);\n+------------------------------------------------------------+\n| DATE_ADD(''1900-01-01 00:00:00'', INTERVAL ''-1 10''\nDAY_HOUR) |\n+------------------------------------------------------------+\n| 1899-12-30 14:00:00 |\n+------------------------------------------------------------+\n \nSELECT DATE_ADD(''1992-12-31 23:59:59.000002'', INTERVAL\n''1.999999'' SECOND_MICROSECOND);\n+--------------------------------------------------------------------------------+\n| DATE_ADD(''1992-12-31 23:59:59.000002'', INTERVAL\n''1.999999'' SECOND_MICROSECOND) |\n+--------------------------------------------------------------------------------+\n| 1993-01-01 00:00:01.000001 |\n+--------------------------------------------------------------------------------+
[DATE_FORMAT]
declaration=date, format[, locale]
category=Date and Time Functions
description=Formats the date value according to the format string. \n \nThe language used for the names is controlled by the value\nof the lc_time_names system variable. See server locale for\nmore on the supported locales.\n \nThe options that can be used by DATE_FORMAT(), as well as\nits inverse STR_TO_DATE() and the FROM_UNIXTIME() function,\nare:\n \nOption | Description | \n \n%a | Short weekday name in current locale (Variable\nlc_time_names). | \n \n%b | Short form month name in current locale. For locale\nen_US this is one of:\nJan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov or Dec. | \n \n%c | Month with 1 or 2 digits. | \n \n%D | Day with English suffix ''th'', ''nd'', ''st'' or\n''rd''''. (1st, 2nd, 3rd...). | \n \n%d | Day with 2 digits. | \n \n%e | Day with 1 or 2 digits. | \n \n%f | Sub seconds 6 digits. | \n \n%H | Hour with 2 digits between 00-23. | \n \n%h | Hour with 2 digits between 01-12. | \n \n%I | Hour with 2 digits between 01-12. | \n \n%i | Minute with 2 digits. | \n \n%j | Day of the year (001-366) | \n \n%k | Hour with 1 digits between 0-23. | \n \n%l | Hour with 1 digits between 1-12. | \n \n%M | Full month name in current locale (Variable\nlc_time_names). | \n \n%m | Month with 2 digits. | \n \n%p | AM/PM according to current locale (Variable\nlc_time_names). | \n \n%r | Time in 12 hour format, followed by AM/PM. Short for\n''%I:%i:%S %p''. | \n \n%S | Seconds with 2 digits. | \n \n%s | Seconds with 2 digits. | \n \n%T | Time in 24 hour format. Short for ''%H:%i:%S''. | \n \n%U | Week number (00-53), when first day of the week is\nSunday. | \n \n%u | Week number (00-53), when first day of the week is\nMonday. | \n \n%V | Week number (01-53), when first day of the week is\nSunday. Used with %X. | \n \n%v | Week number (01-53), when first day of the week is\nMonday. Used with %x. | \n \n%W | Full weekday name in current locale (Variable\nlc_time_names). | \n \n%w | Day of the week. 0 = Sunday, 6 = Saturday. | \n \n%X | Year with 4 digits when first day of the week is\nSunday. Used with %V. | \n \n%x | Year with 4 digits when first day of the week is\nMonday. Used with %v. | \n \n%Y | Year with 4 digits. | \n \n%y | Year with 2 digits. | \n \n%# | For str_to_date(), skip all numbers. | \n \n%. | For str_to_date(), skip all punctation characters. | \n \n%@ | For str_to_date(), skip all alpha characters. | \n \n%% | A literal % character. | \n \nTo get a date in one of the standard formats, GET_FORMAT()\ncan be used.\n \n\nSELECT DATE_FORMAT(''2009-10-04 22:23:00'', ''%W %M %Y'');\n+------------------------------------------------+\n| DATE_FORMAT(''2009-10-04 22:23:00'', ''%W %M %Y'') |\n+------------------------------------------------+\n| Sunday October 2009 |\n+------------------------------------------------+\n \nSELECT DATE_FORMAT(''2007-10-04 22:23:00'', ''%H:%i:%s'');\n+------------------------------------------------+\n| DATE_FORMAT(''2007-10-04 22:23:00'', ''%H:%i:%s'') |\n+------------------------------------------------+\n| 22:23:00 |\n+------------------------------------------------+\n \nSELECT DATE_FORMAT(''1900-10-04 22:23:00'', ''%D %y %a %d %m\n%b %j'');\n+------------------------------------------------------------+\n| DATE_FORMAT(''1900-10-04 22:23:00'', ''%D %y %a %d %m %b\n%j'') |\n+------------------------------------------------------------+\n| 4th 00 Thu 04 10 Oct 277 |\n+------------------------------------------------------------+\n \nSELECT DATE_FORMAT(''1997-10-04 22:23:00'', ''%H %k %I %r %T\n%S %w'');\n+------------------------------------------------------------+\n| DATE_FORMAT(''1997-10-04 22:23:00'', ''%H %k %I %r %T %S\n%w'') |\n+------------------------------------------------------------+\n| 22 22 10 10:23:00 PM 22:23:00 00 6 |\n+------------------------------------------------------------+\n \nSELECT DATE_FORMAT(''1999-01-01'', ''%X %V'');\n+------------------------------------+\n| DATE_FORMAT(''1999-01-01'', ''%X %V'') |\n+------------------------------------+\n| 1998 52 |\n+------------------------------------+\n \nSELECT DATE_FORMAT(''2006-06-00'', ''%d'');\n+---------------------------------+\n| DATE_FORMAT(''2006-06-00'', ''%d'') |\n+---------------------------------+\n| 00 |\n+---------------------------------+\n \nOptionally, the locale can be explicitly specified as the\nthird DATE_FORMAT() argument. Doing so makes the function\nindependent from the session settings, and the three\nargument version of DATE_FORMAT() can be used in virtual\nindexed and persistent generated-columns:\n \nSELECT DATE_FORMAT(''2006-01-01'', ''%W'', ''el_GR'');\n+------------------------------------------+\n| DATE_FORMAT(''2006-01-01'', ''%W'', ''el_GR'') |\n+------------------------------------------+\n| ??????? |\n+------------------------------------------+
[DATE_SUB]
declaration=date,INTERVAL expr unit
category=Date and Time Functions
description=Performs date arithmetic. The date argument specifies the\nstarting date or datetime value. expr is an expression\nspecifying the\ninterval value to be added or subtracted from the starting\ndate. expr is a\nstring; it may start with a "-" for negative intervals.\nunit is a\nkeyword indicating the units in which the expression should\nbe interpreted. See Date and Time Units for a complete list\nof permitted units. \n \nSee also DATE_ADD().\n \n\nSELECT DATE_SUB(''1998-01-02'', INTERVAL 31 DAY);\n+-----------------------------------------+\n| DATE_SUB(''1998-01-02'', INTERVAL 31 DAY) |\n+-----------------------------------------+\n| 1997-12-02 |\n+-----------------------------------------+\n \nSELECT DATE_SUB(''2005-01-01 00:00:00'', INTERVAL ''1\n1:1:1'' DAY_SECOND);\n+----------------------------------------------------------------+\n| DATE_SUB(''2005-01-01 00:00:00'', INTERVAL ''1 1:1:1''\nDAY_SECOND) |\n+----------------------------------------------------------------+\n| 2004-12-30 22:58:59 |\n+----------------------------------------------------------------+
[DAYNAME]
declaration=date
category=Date and Time Functions
description=Returns the name of the weekday for date. The language used\nfor the name is controlled by the value\nof the lc_time_names system variable. See server locale for\nmore on the supported locales.\n \n\nSELECT DAYNAME(''2007-02-03'');\n+-----------------------+\n| DAYNAME(''2007-02-03'') |\n+-----------------------+\n| Saturday |\n+-----------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d, DAYNAME(d) FROM t1;\n \n+---------------------+------------+\n| d | DAYNAME(d) |\n+---------------------+------------+\n| 2007-01-30 21:31:07 | Tuesday |\n| 1983-10-15 06:42:51 | Saturday |\n| 2011-04-21 12:34:56 | Thursday |\n| 2011-10-30 06:31:41 | Sunday |\n| 2011-01-30 14:03:25 | Sunday |\n| 2004-10-07 11:19:34 | Thursday |\n+---------------------+------------+\n \nChanging the locale:\n \nSET lc_time_names = ''fr_CA'';\n \nSELECT DAYNAME(''2013-04-01'');\n+-----------------------+\n| DAYNAME(''2013-04-01'') |\n+-----------------------+\n| lundi |\n+-----------------------+
[DAYOFMONTH]
declaration=date
category=Date and Time Functions
description=Returns the day of the month for date, in the range 1 to 31,\nor 0\nfor dates such as ''0000-00-00'' or ''2008-00-00'' which\nhave a zero day\npart.\n \nDAY() is a synonym.\n \n\nSELECT DAYOFMONTH(''2007-02-03'');\n+--------------------------+\n| DAYOFMONTH(''2007-02-03'') |\n+--------------------------+\n| 3 |\n+--------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d FROM t1 where DAYOFMONTH(d) = 30;\n \n+---------------------+\n| d |\n+---------------------+\n| 2007-01-30 21:31:07 |\n| 2011-10-30 06:31:41 |\n| 2011-01-30 14:03:25 |\n+---------------------+
[DAYOFWEEK]
declaration=date
category=Date and Time Functions
description=Returns the day of the week index for the date (1 = Sunday,\n2 = Monday, ..., 7 =\nSaturday). These index values correspond to the ODBC\nstandard.\n \nThis contrasts with WEEKDAY() which follows a different\nindex numbering\n(0 = Monday, 1 = Tuesday, ... 6 = Sunday).\n \n\nSELECT DAYOFWEEK(''2007-02-03'');\n+-------------------------+\n| DAYOFWEEK(''2007-02-03'') |\n+-------------------------+\n| 7 |\n+-------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d, DAYNAME(d), DAYOFWEEK(d), WEEKDAY(d) from t1;\n \n+---------------------+------------+--------------+------------+\n| d | DAYNAME(d) | DAYOFWEEK(d) | WEEKDAY(d) |\n+---------------------+------------+--------------+------------+\n| 2007-01-30 21:31:07 | Tuesday | 3 | 1 |\n| 1983-10-15 06:42:51 | Saturday | 7 | 5 |\n| 2011-04-21 12:34:56 | Thursday | 5 | 3 |\n| 2011-10-30 06:31:41 | Sunday | 1 | 6 |\n| 2011-01-30 14:03:25 | Sunday | 1 | 6 |\n| 2004-10-07 11:19:34 | Thursday | 5 | 3 |\n+---------------------+------------+--------------+------------+
[DAYOFYEAR]
declaration=date
category=Date and Time Functions
description=Returns the day of the year for date, in the range 1 to 366.\n \n\nSELECT DAYOFYEAR(''2018-02-16'');\n+-------------------------+\n| DAYOFYEAR(''2018-02-16'') |\n+-------------------------+\n| 47 |\n+-------------------------+
[DAY]
declaration=date
category=Date and Time Functions
description=DAY() is a synonym for DAYOFMONTH().
[DECODE]
declaration=crypt_str,pass_str
category=Encryption Functions
description=Decrypts the encrypted string crypt_str using pass_str as\nthe\npassword. crypt_str should be a string returned from\nENCODE(). The resulting string will be the original string\nonly if pass_str is the same.
[DECODE_HISTOGRAM]
declaration=hist_type,histogram
category=Information Functions
description=Returns a string of comma separated numeric values\ncorresponding to a probability distribution represented by\nthe histogram of type hist_type (SINGLE_PREC_HB or\nDOUBLE_PREC_HB). The hist_type and histogram would be\ncommonly used from the mysql.column_stats table.\n \nSee Histogram Based Statistics for details.\n \n\nCREATE TABLE origin (\n i INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,\n v INT UNSIGNED NOT NULL\n);\n \nINSERT INTO origin(v) VALUES \n (1),(2),(3),(4),(5),(10),(20),\n (30),(40),(50),(60),(70),(80),\n (90),(100),(200),(400),(800);\n \nSET histogram_size=10,histogram_type=SINGLE_PREC_HB;\n \nANALYZE TABLE origin PERSISTENT FOR ALL;\n \n+-------------+---------+----------+-----------------------------------------+\n| Table | Op | Msg_type | Msg_text |\n+-------------+---------+----------+-----------------------------------------+\n| test.origin | analyze | status | Engine-independent\nstatistics collected |\n| test.origin | analyze | status | OK |\n+-------------+---------+----------+-----------------------------------------+\n \nSELECT db_name,table_name,column_name,hist_type,\n hex(histogram),decode_histogram(hist_type,histogram) \n FROM mysql.column_stats WHERE db_name=''test'' and\ntable_name=''origin'';\n \n+---------+------------+-------------+----------------+----------------------+-------------------------------------------------------------------+\n| db_name | table_name | column_name | hist_type |\nhex(histogram) | decode_histogram(hist_type,histogram) |\n+---------+------------+-------------+----------------+----------------------+-------------------------------------------------------------------+\n| test | origin | i | SINGLE_PREC_HB | 0F2D3C5A7887A5C3D2F0\n|\n0.059,0.118,0.059,0.118,0.118,0.059,0.118,0.118,0.059,0.118,0.059\n|\n| test | origin | v | SINGLE_PREC_HB | 000001060C0F161C1F7F\n|\n0.000,0.000,0.004,0.020,0.024,0.012,0.027,0.024,0.012,0.376,0.502\n|\n+---------+------------+-------------+----------------+----------------------+-------------------------------------------------------------------+\n \nSET histogram_size=20,histogram_type=DOUBLE_PREC_HB;\n \nANALYZE TABLE origin PERSISTENT FOR ALL;\n \n+-------------+---------+----------+-----------------------------------------+\n| Table | Op | Msg_type | Msg_text |\n+-------------+---------+----------+-----------------------------------------+\n| test.origin | analyze | status | Engine-independent\nstatistics collected |\n| test.origin | analyze | status | OK |\n+-------------+---------+----------+-----------------------------------------+\n \nSELECT db_name,table_name,column_name,\n hist_type,hex(histogram),decode_histogram(hist_type,histogram)\n\n FROM mysql.column_stats WHERE db_name=''test'' and\ntable_name=''origin'';\n \n+---------+------------+-------------+----------------+------------------------------------------+-----------------------------------------------------------------------------------------+\n| db_name | table_name | column_name | hist_type |\nhex(histogram) | decode_histogram(hist_type,histogram) |\n+---------+------------+-------------+----------------+------------------------------------------+-----------------------------------------------------------------------------------------+\n| test | origin | i | DOUBLE_PREC_HB |\n0F0F2D2D3C3C5A5A78788787A5A5C3C3D2D2F0F0 |\n0.05882,0.11765,0.05882,0.11765,0.11765,0.05882,0.11765,0.11765,0.05882,0.11765,0.05882\n|\n| test | origin | v | DOUBLE_PREC_HB |\n5200F600480116067E0CB30F1B16831CB81FD67F |\n0.00125,0.00250,0.00125,0.01877,0.02502,0.01253,0.02502,0.02502,0.01253,0.37546,0.50063\n|
[DEFAULT]
declaration=col_name
category=Information Functions
description=Returns the default value for a table column. If the column\nhas no default value, NULL is returned.\nFor integer columns using AUTO_INCREMENT, 0 is returned.\n \nWhen using DEFAULT as a value to set in an INSERT or UPDATE\nstatement, you can use the bare keyword DEFAULT without the\nparentheses and argument to\nrefer to the column in context. You can only use DEFAULT as\na bare keyword if you are using it\nalone without a surrounding expression or function.\n \n\nSelect only non-default values for a column:\n \nSELECT i FROM t WHERE i != DEFAULT(i);\n \nUpdate values to be one greater than the default value:\n \nUPDATE t SET i = DEFAULT(i)+1 WHERE i
[DEGREES]
declaration=X
category=Numeric Functions
description=Returns the argument X, converted from radians to degrees.\n \nThis is the converse of the RADIANS() function.\n \n\nSELECT DEGREES(PI());\n+---------------+\n| DEGREES(PI()) |\n+---------------+\n| 180 |\n+---------------+\n \nSELECT DEGREES(PI() / 2);\n+-------------------+\n| DEGREES(PI() / 2) |\n+-------------------+\n| 90 |\n+-------------------+\n \nSELECT DEGREES(45);\n+-----------------+\n| DEGREES(45) |\n+-----------------+\n| 2578.3100780887 |\n+-----------------+
[DENSE_RANK1]
name=DENSE_RANK
declaration=
category=Window Functions
description=DENSE_RANK() is a window function that displays the number\nof a given row, starting at one and following the ORDER BY\nsequence of the window function, with identical values\nreceiving the same result. Unlike the RANK() function, there\nare no skipped values if the preceding results are\nidentical. It is also similar to the ROW_NUMBER() function\nexcept that in that function, identical values will receive\na different row number for each result.\n \n\nThe distinction between DENSE_RANK(), RANK() and\nROW_NUMBER():\n \nCREATE TABLE student(course VARCHAR(10), mark int, name\nvarchar(10));\n \nINSERT INTO student VALUES \n (''Maths'', 60, ''Thulile''),\n (''Maths'', 60, ''Pritha''),\n (''Maths'', 70, ''Voitto''),\n (''Maths'', 55, ''Chun''),\n (''Biology'', 60, ''Bilal''),\n (''Biology'', 70, ''Roger'');\n \nSELECT \n RANK() OVER (PARTITION BY course ORDER BY mark DESC) AS\nrank, \n DENSE_RANK() OVER (PARTITION BY course ORDER BY mark DESC)\nAS dense_rank, \n ROW_NUMBER() OVER (PARTITION BY course ORDER BY mark DESC)\nAS row_num, \n course, mark, name \nFROM student ORDER BY course, mark DESC;\n \n+------+------------+---------+---------+------+---------+\n| rank | dense_rank | row_num | course | mark | name |\n+------+------------+---------+---------+------+---------+\n| 1 | 1 | 1 | Biology | 70 | Roger |\n| 2 | 2 | 2 | Biology | 60 | Bilal |\n| 1 | 1 | 1 | Maths | 70 | Voitto |\n| 2 | 2 | 2 | Maths | 60 | Thulile |\n| 2 | 2 | 3 | Maths | 60 | Pritha |\n| 4 | 3 | 4 | Maths | 55 | Chun |\n+------+------------+---------+---------+------+---------+
[DENSE_RANK2]
name=DENSE_RANK
declaration=[ PARTITION BY partition_expression ]  [ ORDER BY order_list ]
category=Window Functions
description=DENSE_RANK() is a window function that displays the number\nof a given row, starting at one and following the ORDER BY\nsequence of the window function, with identical values\nreceiving the same result. Unlike the RANK() function, there\nare no skipped values if the preceding results are\nidentical. It is also similar to the ROW_NUMBER() function\nexcept that in that function, identical values will receive\na different row number for each result.\n \n\nThe distinction between DENSE_RANK(), RANK() and\nROW_NUMBER():\n \nCREATE TABLE student(course VARCHAR(10), mark int, name\nvarchar(10));\n \nINSERT INTO student VALUES \n (''Maths'', 60, ''Thulile''),\n (''Maths'', 60, ''Pritha''),\n (''Maths'', 70, ''Voitto''),\n (''Maths'', 55, ''Chun''),\n (''Biology'', 60, ''Bilal''),\n (''Biology'', 70, ''Roger'');\n \nSELECT \n RANK() OVER (PARTITION BY course ORDER BY mark DESC) AS\nrank, \n DENSE_RANK() OVER (PARTITION BY course ORDER BY mark DESC)\nAS dense_rank, \n ROW_NUMBER() OVER (PARTITION BY course ORDER BY mark DESC)\nAS row_num, \n course, mark, name \nFROM student ORDER BY course, mark DESC;\n \n+------+------------+---------+---------+------+---------+\n| rank | dense_rank | row_num | course | mark | name |\n+------+------------+---------+---------+------+---------+\n| 1 | 1 | 1 | Biology | 70 | Roger |\n| 2 | 2 | 2 | Biology | 60 | Bilal |\n| 1 | 1 | 1 | Maths | 70 | Voitto |\n| 2 | 2 | 2 | Maths | 60 | Thulile |\n| 2 | 2 | 3 | Maths | 60 | Pritha |\n| 4 | 3 | 4 | Maths | 55 | Chun |\n+------+------------+---------+---------+------+---------+
[DES_DECRYPT]
declaration=crypt_str[,key_str]
category=Encryption Functions
description=Decrypts a string encrypted with DES_ENCRYPT(). If an error\noccurs,\nthis function returns NULL.\n \nThis function works only if MariaDB has been configured with\nTLS\nsupport.\n \nIf no key_str argument is given, DES_DECRYPT() examines the\nfirst byte\nof the encrypted string to determine the DES key number that\nwas used\nto encrypt the original string, and then reads the key from\nthe DES\nkey file to decrypt the message. For this to work, the user\nmust have\nthe SUPER privilege. The key file can be specified with the\n--des-key-file server option.\n \nIf you pass this function a key_str argument, that string is\nused as\nthe key for decrypting the message.\n \nIf the crypt_str argument does not appear to be an encrypted\nstring,\nMariaDB returns the given crypt_str.
[DES_ENCRYPT]
declaration=str[,{key_num|key_str}]
category=Encryption Functions
description=Encrypts the string with the given key using the Triple-DES\nalgorithm.\n \nThis function works only if MariaDB has been configured with\nTLS support.\n \nThe encryption key to use is chosen based on the second\nargument to\nDES_ENCRYPT(), if one was given. With no argument, the first\nkey from\nthe DES key file is used. With a key_num argument, the given\nkey \nnumber (0-9) from the DES key file is used. With a key_str\nargument,\nthe given key string is used to encrypt str. \n \nThe key file can be specified with the --des-key-file server\noption.\n \nThe return string is a binary string where the first\ncharacter is \nCHAR(128 | key_num). If an error occurs, DES_ENCRYPT()\nreturns NULL.\n \nThe 128 is added to make it easier to recognize an encrypted\nkey. If\nyou use a string key, key_num is 127.\n \nThe string length for the result is given by this formula:\n \nnew_len = orig_len + (8 - (orig_len % 8)) + 1\n \nEach line in the DES key file has the following format:\n \nkey_num des_key_str\n \nEach key_num value must be a number in the range from 0 to\n9. Lines in\nthe file may be in any order. des_key_str is the string that\nis used\nto encrypt the message. There should be at least one space\nbetween the\nnumber and the key. The first key is the default key that is\nused if\nyou do not specify any key argument to DES_ENCRYPT().\n \nYou can tell MariaDB to read new key values from the key\nfile with the\nFLUSH DES_KEY_FILE statement. This requires the RELOAD\nprivilege.\n \nOne benefit of having a set of default keys is that it gives\napplications a way to check for the existence of encrypted\ncolumn\nvalues, without giving the end user the right to decrypt\nthose values.\n \n\nSELECT customer_address FROM customer_table \n WHERE crypted_credit_card =\nDES_ENCRYPT(''credit_card_number'');
[DISJOINT]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether g1 is spatially disjoint\nfrom\n(does not intersect) g2.\n \nDISJOINT() tests the opposite relationship to INTERSECTS().\n \nDISJOINT() is based on the original MySQL implementation and\nuses object bounding rectangles, while ST_DISJOINT() uses\nobject shapes.
[ELT]
declaration=N, str1[, str2, str3,...]
category=String Functions
description=Takes a numeric argument and a series of string arguments.\nReturns the string that corresponds to the given numeric\nposition. For instance, it returns str1 if N is 1, str2 if N\nis 2, and so on. If the numeric argument is a FLOAT, MariaDB\nrounds it to the nearest INTEGER. If the numeric argument is\nless than 1, greater than the total number of arguments, or\nnot a number, ELT() returns NULL. It must have at least two\narguments.\n \nIt is complementary to the FIELD() function.\n \n\nSELECT ELT(1, ''ej'', ''Heja'', ''hej'', ''foo'');\n+------------------------------------+\n| ELT(1, ''ej'', ''Heja'', ''hej'', ''foo'') |\n+------------------------------------+\n| ej |\n+------------------------------------+\n \nSELECT ELT(4, ''ej'', ''Heja'', ''hej'', ''foo'');\n+------------------------------------+\n| ELT(4, ''ej'', ''Heja'', ''hej'', ''foo'') |\n+------------------------------------+\n| foo |\n+------------------------------------+
[ENCODE]
declaration=str,pass_str
category=Encryption Functions
description=ENCODE is not considered cryptographically secure, and\nshould not be used for password encryption.\n \nEncrypt str using pass_str as the password. To decrypt the\nresult, use\nDECODE().\n \nThe result is a binary string of the same length as str.\n \nThe strength of the encryption is based on how good the\nrandom generator is. \n \nIt is not recommended to rely on the encryption performed by\nthe ENCODE function. Using a salt value (changed when a\npassword is updated) will improve matters somewhat, but for\nstoring passwords, consider a more cryptographically secure\nfunction, such as SHA2().\n \n\nENCODE(''not so secret text'',\nCONCAT(''random_salt'',''password''))
[ENCRYPT]
declaration=str[,salt]
category=Encryption Functions
description=Encrypts a string using the Unix crypt() system call,\nreturning an encrypted binary string. The salt argument\nshould be a string with at least two characters or the\nreturned result will be NULL. If no salt argument is given,\na random value of sufficient length is used.\n \nIt is not recommended to use ENCRYPT() with utf16, utf32 or\nucs2 multi-byte character sets because the crypt() system\ncall expects a string terminated with a zero byte.\n \nNote that the underlying crypt() system call may have some\nlimitations, such as ignoring all but the first eight\ncharacters.\n \nIf the have_crypt system variable is set to NO (because the\ncrypt() system call is not available), the ENCRYPT function\nwill always return NULL.\n \n\nSELECT ENCRYPT(''encrypt me'');\n+-----------------------+\n| ENCRYPT(''encrypt me'') |\n+-----------------------+\n| 4I5BsEx0lqTDk |\n+-----------------------+
[ENUM]
declaration=''value1'',''value2'',...
category=Data Types
description=An enumeration. A string object that can have only one\nvalue, chosen\nfrom the list of values ''value1'', ''value2'', ..., NULL or\nthe special \n'''' error value. In theory, an ENUM column can have a\nmaximum of 65,535 distinct\nvalues; in practice, the real maximum depends on many\nfactors. ENUM values are represented internally as integers.\n \nTrailing spaces are automatically stripped from ENUM values\non table creation.\n \nENUMs require relatively little storage space compared to\nstrings, either one or two bytes depending on the number of\nenumeration values.\n \nNULL and empty values\n \nAn ENUM can also contain NULL and empty values. If the ENUM\ncolumn is declared to permit NULL values, NULL becomes a\nvalid value, as well as the default value (see below). If\nstrict SQL Mode is not enabled, and an invalid value is\ninserted into an ENUM, a special empty string, with an index\nvalue of zero (see Numeric index, below), is inserted, with\na warning. This may be confusing, because the empty string\nis also a possible value, and the only difference if that in\nthis case its index is not 0. Inserting will fail with an\nerror if strict mode is active.\n \nIf a DEFAULT clause is missing, the default value will be:\nNULL is the column is nullable;\notherwise, the first value in the enumaration.\n \nNumeric index\n \nENUM values are indexed numerically in the order they are\ndefined, and sorting will be performed in this numeric\norder. We suggest not using ENUM to store numerals, as there\nis little to no storage space benefit, and it is easy to\nconfuse the enum integer with the enum numeral value by\nleaving out the quotes.\n \nAn ENUM defined as ENUM(''apple'',''orange'',''pear'') would\nhave the following index values:\n \nIndex | Value | \n \nNULL | NULL | \n \n0 | '''' | \n \n1 | ''apple'' | \n \n2 | ''orange'' | \n \n3 | ''pear'' | \n \n\nCREATE TABLE fruits (\n id INT NOT NULL auto_increment PRIMARY KEY,\n fruit ENUM(''apple'',''orange'',''pear''),\n bushels INT);\n \nDESCRIBE fruits;\n \n+---------+-------------------------------+------+-----+---------+----------------+\n| Field | Type | Null | Key | Default | Extra |\n+---------+-------------------------------+------+-----+---------+----------------+\n| id | int(11) | NO | PRI | NULL | auto_increment |\n| fruit | enum(''apple'',''orange'',''pear'') | YES | | NULL\n| |\n| bushels | int(11) | YES | | NULL | |\n+---------+-------------------------------+------+-----+---------+----------------+\n \nINSERT INTO fruits\n (fruit,bushels) VALUES\n (''pear'',20),\n (''apple'',100),\n (''orange'',25);\n \nINSERT INTO fruits\n (fruit,bushels) VALUES\n (''avocado'',10);\nERROR 1265 (01000): Data truncated for column ''fruit'' at\nrow 1\n \nSELECT * FROM fruits;\n \n+----+--------+---------+\n| id | fruit | bushels |\n+----+--------+---------+\n| 1 | pear | 20 |\n| 2 | apple | 100 |\n| 3 | orange | 25 |\n+----+--------+---------+\n \nSelecting by numeric index:\n \nSELECT * FROM fruits WHERE fruit=2;\n \n+----+--------+---------+\n| id | fruit | bushels |\n+----+--------+---------+\n| 3 | orange | 25 |\n+----+--------+---------+\n \nSorting is according to the index value:\n \nCREATE TABLE enums (a ENUM(''2'',''1''));\n \nINSERT INTO enums VALUES (''1''),(''2'');\n \nSELECT * FROM enums ORDER BY a ASC;\n \n+------+\n| a |\n+------+\n| 2 |\n| 1 |\n+------+\n \nIt''s easy to get confused between returning the enum\ninteger with the stored value, so we don''t suggest using\nENUM to store numerals. The first example returns the 1st\nindexed field (''2'' has an index value of 1, as it''s\ndefined first), while the second example returns the string\nvalue ''1''.\n \nSELECT * FROM enums WHERE a=1;\n \n+------+\n| a |\n+------+\n| 2 |\n+------+\n \nSELECT * FROM enums WHERE a=''1'';\n \n+------+\n| a |\n+------+\n| 1 |\n+------+
[EQUALS]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether g1 is spatially equal to\ng2.\n \nEQUALS() is based on the original MySQL implementation and\nuses object bounding rectangles, while ST_EQUALS() uses\nobject shapes.\n \nFrom MariaDB 10.2.3, MBREQUALS is a synonym for Equals.
[EXPORT_SET]
declaration=bits, on, off[, separator[, number_of_bits]]
category=String Functions
description=Takes a minimum of three arguments. Returns a string where\neach bit in the given bits argument is returned, with the\nstring values given for on and off. \n \nBits are examined from right to left, (from low-order to\nhigh-order bits). Strings are added to the result from left\nto right, separated by a separator string (defaults as\n'',''). You can optionally limit the number of bits the\nEXPORT_SET() function examines using the number_of_bits\noption. \n \nIf any of the arguments are set as NULL, the function\nreturns NULL.\n \n\nSELECT EXPORT_SET(5,''Y'',''N'','','',4);\n+-----------------------------+\n| EXPORT_SET(5,''Y'',''N'','','',4) |\n+-----------------------------+\n| Y,N,Y,N |\n+-----------------------------+\n \nSELECT EXPORT_SET(6,''1'',''0'','','',10);\n+------------------------------+\n| EXPORT_SET(6,''1'',''0'','','',10) |\n+------------------------------+\n| 0,1,1,0,0,0,0,0,0,0 |\n+------------------------------+
[EXP]
declaration=X
category=Numeric Functions
description=Returns the value of e (the base of natural logarithms)\nraised to the\npower of X. The inverse of this function is LOG() (using a\nsingle\nargument only) or LN().\n \nIf X is NULL, this function returns NULL.\n \n\nSELECT EXP(2);\n+------------------+\n| EXP(2) |\n+------------------+\n| 7.38905609893065 |\n+------------------+\n \nSELECT EXP(-2);\n+--------------------+\n| EXP(-2) |\n+--------------------+\n| 0.1353352832366127 |\n+--------------------+\n \nSELECT EXP(0);\n+--------+\n| EXP(0) |\n+--------+\n| 1 |\n+--------+\n \nSELECT EXP(NULL);\n+-----------+\n| EXP(NULL) |\n+-----------+\n| NULL |\n+-----------+
[EXTRACTVALUE]
declaration=xml_frag, xpath_expr
category=String Functions
description=The EXTRACTVALUE() function takes two string arguments: a\nfragment of XML markup and an XPath expression, (also known\nas a locator). It returns the text (That is, CDDATA), of the\nfirst text node which is a child of the element or elements\nmatching the XPath expression. \n \nIn cases where a valid XPath expression does not match any\ntext nodes in a valid XML fragment, (including the implicit\n/text() expression), the EXTRACTVALUE() function returns an\nempty string.\n \nInvalid Arguments\n \nWhen either the XML fragment or the XPath expression is\nNULL, the EXTRACTVALUE() function returns NULL. When the XML\nfragment is invalid, it raises a warning Code 1525:\n \nWarning (Code 1525): Incorrect XML value: ''parse error at\nline 1 pos 11: unexpected END-OF-INPUT''\n \nWhen the XPath value is invalid, it generates an Error 1105:\n \nERROR 1105 (HY000): XPATH syntax error: '')''\n \nExplicit text() Expressions\n \nThis function is the equivalent of performing a match using\nthe XPath expression after appending /text(). In other\nwords:\n \nSELECT\n EXTRACTVALUE(''example'', ''/cases/case'') AS ''Base\nExample'',\n EXTRACTVALUE(''example'', ''/cases/case/text()'') AS\n''text() Example'';\n \n+--------------+----------------+\n| Base Example | text() Example |\n+--------------+----------------+\n| example | example |\n+--------------+----------------+\n \nCount Matches\n \nWhen EXTRACTVALUE() returns multiple matches, it returns the\ncontent of the first child text node of each matching\nelement, in the matched order, as a single, space-delimited\nstring.\n \nBy design, the EXTRACTVALUE() function makes no distinction\nbetween a match on an empty element and no match at all. If\nyou need to determine whether no matching element was found\nin the XML fragment or if an element was found that\ncontained no child text nodes, use the XPath count()\nfunction. \n \nFor instance, when looking for a value that exists, but\ncontains no child text nodes, you would get a count of the\nnumber of matching instances:\n \nSELECT\n EXTRACTVALUE('''', ''/cases/case'') AS ''Empty Example'',\n EXTRACTVALUE('''', ''/cases/case/count()'') AS ''count()\nExample'';\n \n+---------------+-----------------+\n| Empty Example | count() Example |\n+---------------+-----------------+\n| | 1 |\n+---------------+-----------------+\n \nAlternatively, when looking for a value that doesn''t exist,\ncount() returns 0.\n \nSELECT\n EXTRACTVALUE('''', ''/cases/person'') AS ''No Match\nExample'',\n EXTRACTVALUE('''', ''/cases/person/count()'') AS ''count()\nExample'';\n \n+------------------+-----------------+\n| No Match Example | count() Example |\n+------------------+-----------------+\n| | 0|\n+------------------+-----------------+\n \nMatches\n \nImportant: The EXTRACTVALUE() function only returns CDDATA.\nIt does not return tags that the element might contain or\nthe text that these child elements contain.\n \nSELECT EXTRACTVALUE(''Personx@example.com'', ''/cases'') AS\nCase;\n \n+--------+\n| Case |\n+--------+\n| Person |\n+--------+\n \nNote, in the above example, while the XPath expression\nmatches to the parent  instance, it does not return the\ncontained  tag or its content.\n \n\nSELECT\n ExtractValue(''cccddd'', ''/a'') AS val1,\n ExtractValue(''cccddd'', ''/a/b'') AS val2,\n ExtractValue(''cccddd'', ''//b'') AS val3,\n ExtractValue(''cccddd'', ''/b'') AS val4,\n ExtractValue(''cccdddeee'', ''//b'') AS val5;\n \n+------+------+------+------+---------+\n| val1 | val2 | val3 | val4 | val5 |\n+------+------+------+------+---------+\n| ccc | ddd | ddd | | ddd eee |\n+------+------+------+------+---------+
[EXTRACT]
declaration=unit FROM date
category=Date and Time Functions
description=The EXTRACT() function extracts the required unit from the\ndate. See Date and Time Units for a complete list of\npermitted units.\n \nIn MariaDB 10.0.7 and MariaDB 5.5.35, EXTRACT (HOUR FROM\n...) was changed to return a value from 0 to 23, adhering to\nthe SQL standard. Until MariaDB 10.0.6 and MariaDB 5.5.34,\nand in all versions of MySQL at least as of MySQL 5.7, it\ncould return a value > 23. HOUR() is not a standard\nfunction, so continues to adhere to the old behaviour\ninherited from MySQL.\n \n\nSELECT EXTRACT(YEAR FROM ''2009-07-02'');\n+---------------------------------+\n| EXTRACT(YEAR FROM ''2009-07-02'') |\n+---------------------------------+\n| 2009 |\n+---------------------------------+\n \nSELECT EXTRACT(YEAR_MONTH FROM ''2009-07-02 01:02:03'');\n+------------------------------------------------+\n| EXTRACT(YEAR_MONTH FROM ''2009-07-02 01:02:03'') |\n+------------------------------------------------+\n| 200907 |\n+------------------------------------------------+\n \nSELECT EXTRACT(DAY_MINUTE FROM ''2009-07-02 01:02:03'');\n+------------------------------------------------+\n| EXTRACT(DAY_MINUTE FROM ''2009-07-02 01:02:03'') |\n+------------------------------------------------+\n| 20102 |\n+------------------------------------------------+\n \nSELECT EXTRACT(MICROSECOND FROM ''2003-01-02\n10:30:00.000123'');\n+--------------------------------------------------------+\n| EXTRACT(MICROSECOND FROM ''2003-01-02 10:30:00.000123'') |\n+--------------------------------------------------------+\n| 123 |\n+--------------------------------------------------------+\n \nFrom MariaDB 10.0.7 and MariaDB 5.5.35, EXTRACT (HOUR\nFROM...) returns a value from 0 to 23, as per the SQL\nstandard. HOUR is not a standard function, so continues to\nadhere to the old behaviour inherited from MySQL.\n \nSELECT EXTRACT(HOUR FROM ''26:30:00''), HOUR(''26:30:00'');\n+-------------------------------+------------------+\n| EXTRACT(HOUR FROM ''26:30:00'') | HOUR(''26:30:00'') |\n+-------------------------------+------------------+\n| 2 | 26 |\n+-------------------------------+------------------+
[FIELD]
declaration=pattern, str1[,str2,...]
category=String Functions
description=Returns the index position of the string or number matching\nthe given pattern. Returns 0 in the event that none of the\narguments match the pattern. Raises an Error 1582 if not\ngiven at least two arguments.\n \nWhen all arguments given to the FIELD() function are\nstrings, they are treated as case-insensitive. When all the\narguments are numbers, they are treated as numbers.\nOtherwise, they are treated as doubles. \n \nIf the given pattern occurs more than once, the FIELD()\nfunction only returns the index of the first instance. If\nthe given pattern is NULL, the function returns 0, as a NULL\npattern always fails to match.\n \nThis function is complementary to the ELT() function.\n \n\nSELECT FIELD(''ej'', ''Hej'', ''ej'', ''Heja'', ''hej'',\n''foo'') \n AS ''Field Results'';\n \n+---------------+\n| Field Results | \n+---------------+\n| 2 |\n+---------------+\n \nSELECT FIELD(''fo'', ''Hej'', ''ej'', ''Heja'', ''hej'',\n''foo'')\n AS ''Field Results'';\n \n+---------------+\n| Field Results | \n+---------------+\n| 0 |\n+---------------+\n \nSELECT FIELD(1, 2, 3, 4, 5, 1) AS ''Field Results'';\n \n+---------------+\n| Field Results |\n+---------------+\n| 5 |\n+---------------+\n \nSELECT FIELD(NULL, 2, 3) AS ''Field Results'';\n \n+---------------+\n| Field Results |\n+---------------+\n| 0 |\n+---------------+\n \nSELECT FIELD(''fail'') AS ''Field Results'';\n \nError 1582 (42000): Incorrect parameter count in call\nto native function ''field''
[FIND_IN_SET]
declaration=pattern, strlist
category=String Functions
description=Returns the index position where the given pattern occurs in\na string list. The first argument is the pattern you want to\nsearch for. The second argument is a string containing\ncomma-separated variables. If the second argument is of the\nSET data-type, the function is optimized to use bit\narithmetic.\n \nIf the pattern does not occur in the string list or if the\nstring list is an empty string, the function returns 0. If\neither argument is NULL, the function returns NULL. The\nfunction does not return the correct result if the pattern\ncontains a comma (",") character.\n \n\nSELECT FIND_IN_SET(''b'',''a,b,c,d'') AS "Found Results";\n \n+---------------+\n| Found Results |\n+---------------+\n| 2 |\n+---------------+
[FIRST_VALUE1]
name=FIRST_VALUE
declaration=expr
category=Window Functions
description=FIRST_VALUE returns the first result from an ordered set, or\nNULL if no such result exists.\n \n\nCREATE TABLE t1 (\n pk int primary key,\n a int,\n b int,\n c char(10),\n d decimal(10, 3),\n e real\n);\n \nINSERT INTO t1 VALUES\n( 1, 0, 1, ''one'', 0.1, 0.001),\n( 2, 0, 2, ''two'', 0.2, 0.002),\n( 3, 0, 3, ''three'', 0.3, 0.003),\n( 4, 1, 2, ''three'', 0.4, 0.004),\n( 5, 1, 1, ''two'', 0.5, 0.005),\n( 6, 1, 1, ''one'', 0.6, 0.006),\n( 7, 2, NULL, ''n_one'', 0.5, 0.007),\n( 8, 2, 1, ''n_two'', NULL, 0.008),\n( 9, 2, 2, NULL, 0.7, 0.009),\n(10, 2, 0, ''n_four'', 0.8, 0.010),\n(11, 2, 10, NULL, 0.9, NULL);\n \nSELECT pk, FIRST_VALUE(pk) OVER (ORDER BY pk) AS first_asc,\n LAST_VALUE(pk) OVER (ORDER BY pk) AS last_asc,\n FIRST_VALUE(pk) OVER (ORDER BY pk DESC) AS first_desc,\n LAST_VALUE(pk) OVER (ORDER BY pk DESC) AS last_desc\nFROM t1\nORDER BY pk DESC;\n \n+----+-----------+----------+------------+-----------+\n| pk | first_asc | last_asc | first_desc | last_desc |\n+----+-----------+----------+------------+-----------+\n| 11 | 1 | 11 | 11 | 11 |\n| 10 | 1 | 10 | 11 | 10 |\n| 9 | 1 | 9 | 11 | 9 |\n| 8 | 1 | 8 | 11 | 8 |\n| 7 | 1 | 7 | 11 | 7 |\n| 6 | 1 | 6 | 11 | 6 |\n| 5 | 1 | 5 | 11 | 5 |\n| 4 | 1 | 4 | 11 | 4 |\n| 3 | 1 | 3 | 11 | 3 |\n| 2 | 1 | 2 | 11 | 2 |\n| 1 | 1 | 1 | 11 | 1 |\n+----+-----------+----------+------------+-----------+\n \nCREATE OR REPLACE TABLE t1 (i int);\nINSERT INTO t1 VALUES\n(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);\n \nSELECT i,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW\nand 1 FOLLOWING) AS f_1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW and\n1 FOLLOWING) AS l_1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING\nAND 1 FOLLOWING) AS f_1p1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND\n1 FOLLOWING) AS f_1p1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING\nAND 1 PRECEDING) AS f_2p1p,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING AND\n1 PRECEDING) AS f_2p1p,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING\nAND 2 FOLLOWING) AS f_1f2f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING AND\n2 FOLLOWING) AS f_1f2f\nFROM t1;\n \n+------+------+------+--------+--------+--------+--------+--------+--------+\n| i | f_1f | l_1f | f_1p1f | f_1p1f | f_2p1p | f_2p1p |\nf_1f2f | f_1f2f |\n+------+------+------+--------+--------+--------+--------+--------+--------+\n| 1 | 1 | 2 | 1 | 2 | NULL | NULL | 2 | 3 |\n| 2 | 2 | 3 | 1 | 3 | 1 | 1 | 3 | 4 |\n| 3 | 3 | 4 | 2 | 4 | 1 | 2 | 4 | 5 |\n| 4 | 4 | 5 | 3 | 5 | 2 | 3 | 5 | 6 |\n| 5 | 5 | 6 | 4 | 6 | 3 | 4 | 6 | 7 |\n| 6 | 6 | 7 | 5 | 7 | 4 | 5 | 7 | 8 |\n| 7 | 7 | 8 | 6 | 8 | 5 | 6 | 8 | 9 |\n| 8 | 8 | 9 | 7 | 9 | 6 | 7 | 9 | 10 |\n| 9 | 9 | 10 | 8 | 10 | 7 | 8 | 10 | 10 |\n| 10 | 10 | 10 | 9 | 10 | 8 | 9 | NULL | NULL |\n+------+------+------+--------+--------+--------+--------+--------+--------+
[FIRST_VALUE2]
name=FIRST_VALUE
declaration=[ PARTITION BY partition_expression ]  [ ORDER BY order_list ]
category=Window Functions
description=FIRST_VALUE returns the first result from an ordered set, or\nNULL if no such result exists.\n \n\nCREATE TABLE t1 (\n pk int primary key,\n a int,\n b int,\n c char(10),\n d decimal(10, 3),\n e real\n);\n \nINSERT INTO t1 VALUES\n( 1, 0, 1, ''one'', 0.1, 0.001),\n( 2, 0, 2, ''two'', 0.2, 0.002),\n( 3, 0, 3, ''three'', 0.3, 0.003),\n( 4, 1, 2, ''three'', 0.4, 0.004),\n( 5, 1, 1, ''two'', 0.5, 0.005),\n( 6, 1, 1, ''one'', 0.6, 0.006),\n( 7, 2, NULL, ''n_one'', 0.5, 0.007),\n( 8, 2, 1, ''n_two'', NULL, 0.008),\n( 9, 2, 2, NULL, 0.7, 0.009),\n(10, 2, 0, ''n_four'', 0.8, 0.010),\n(11, 2, 10, NULL, 0.9, NULL);\n \nSELECT pk, FIRST_VALUE(pk) OVER (ORDER BY pk) AS first_asc,\n LAST_VALUE(pk) OVER (ORDER BY pk) AS last_asc,\n FIRST_VALUE(pk) OVER (ORDER BY pk DESC) AS first_desc,\n LAST_VALUE(pk) OVER (ORDER BY pk DESC) AS last_desc\nFROM t1\nORDER BY pk DESC;\n \n+----+-----------+----------+------------+-----------+\n| pk | first_asc | last_asc | first_desc | last_desc |\n+----+-----------+----------+------------+-----------+\n| 11 | 1 | 11 | 11 | 11 |\n| 10 | 1 | 10 | 11 | 10 |\n| 9 | 1 | 9 | 11 | 9 |\n| 8 | 1 | 8 | 11 | 8 |\n| 7 | 1 | 7 | 11 | 7 |\n| 6 | 1 | 6 | 11 | 6 |\n| 5 | 1 | 5 | 11 | 5 |\n| 4 | 1 | 4 | 11 | 4 |\n| 3 | 1 | 3 | 11 | 3 |\n| 2 | 1 | 2 | 11 | 2 |\n| 1 | 1 | 1 | 11 | 1 |\n+----+-----------+----------+------------+-----------+\n \nCREATE OR REPLACE TABLE t1 (i int);\nINSERT INTO t1 VALUES\n(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);\n \nSELECT i,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW\nand 1 FOLLOWING) AS f_1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW and\n1 FOLLOWING) AS l_1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING\nAND 1 FOLLOWING) AS f_1p1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND\n1 FOLLOWING) AS f_1p1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING\nAND 1 PRECEDING) AS f_2p1p,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING AND\n1 PRECEDING) AS f_2p1p,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING\nAND 2 FOLLOWING) AS f_1f2f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING AND\n2 FOLLOWING) AS f_1f2f\nFROM t1;\n \n+------+------+------+--------+--------+--------+--------+--------+--------+\n| i | f_1f | l_1f | f_1p1f | f_1p1f | f_2p1p | f_2p1p |\nf_1f2f | f_1f2f |\n+------+------+------+--------+--------+--------+--------+--------+--------+\n| 1 | 1 | 2 | 1 | 2 | NULL | NULL | 2 | 3 |\n| 2 | 2 | 3 | 1 | 3 | 1 | 1 | 3 | 4 |\n| 3 | 3 | 4 | 2 | 4 | 1 | 2 | 4 | 5 |\n| 4 | 4 | 5 | 3 | 5 | 2 | 3 | 5 | 6 |\n| 5 | 5 | 6 | 4 | 6 | 3 | 4 | 6 | 7 |\n| 6 | 6 | 7 | 5 | 7 | 4 | 5 | 7 | 8 |\n| 7 | 7 | 8 | 6 | 8 | 5 | 6 | 8 | 9 |\n| 8 | 8 | 9 | 7 | 9 | 6 | 7 | 9 | 10 |\n| 9 | 9 | 10 | 8 | 10 | 7 | 8 | 10 | 10 |\n| 10 | 10 | 10 | 9 | 10 | 8 | 9 | NULL | NULL |\n+------+------+------+--------+--------+--------+--------+--------+--------+
[FLOOR]
declaration=X
category=Numeric Functions
description=Returns the largest integer value not greater than X.\n \n\nSELECT FLOOR(1.23);\n+-------------+\n| FLOOR(1.23) |\n+-------------+\n| 1 |\n+-------------+\n \nSELECT FLOOR(-1.23);\n+--------------+\n| FLOOR(-1.23) |\n+--------------+\n| -2 |\n+--------------+
[FORMAT]
declaration=num, decimal_position[, locale]
category=String Functions
description=Formats the given number for display as a string, adding\nseparators to appropriate position and rounding the results\nto the given decimal position. For instance, it would format\n15233.345 to 15,233.35.\n \nIf the given decimal position is 0, it rounds to return no\ndecimal point or fractional part. You can optionally specify\na locale value to format numbers to the pattern appropriate\nfor the given region.\n \n\nSELECT FORMAT(1234567890.09876543210, 4) AS ''Format'';\n \n+--------------------+\n| Format |\n+--------------------+\n| 1,234,567,890.0988 |\n+--------------------+\n \nSELECT FORMAT(1234567.89, 4) AS ''Format'';\n \n+----------------+\n| Format |\n+----------------+\n| 1,234,567.8900 |\n+----------------+\n \nSELECT FORMAT(1234567.89, 0) AS ''Format'';\n \n+-----------+\n| Format |\n+-----------+\n| 1,234,568 |\n+-----------+\n \nSELECT FORMAT(123456789,2,''rm_CH'') AS ''Format'';\n \n+----------------+\n| Format |\n+----------------+\n| 123''456''789,00 |\n+----------------+
[FOUND_ROWS]
declaration=
category=Information Functions
description=A SELECT statement may include a LIMIT clause to restrict\nthe number\nof rows the server returns to the client. In some cases, it\nis\ndesirable to know how many rows the statement would have\nreturned\nwithout the LIMIT, but without running the statement again.\nTo obtain\nthis row count, include a SQL_CALC_FOUND_ROWS option in the\nSELECT\nstatement, and then invoke FOUND_ROWS() afterwards.\n \nYou can also use FOUND_ROWS() to obtain the number of rows\nreturned by a SELECT which does not contain a LIMIT clause.\nIn this case you don''t need to use the SQL_CALC_FOUND_ROWS\noption. This can be useful for example in a stored\nprocedure.\n \nAlso, this function works with some other statements which\nreturn a resultset, including SHOW, DESC and HELP. For\nDELETE ... RETURNING you should use ROW_COUNT(). It also\nworks as a prepared statement, or after executing a prepared\nstatement.\n \nStatements which don''t return any results don''t affect\nFOUND_ROWS() - the previous value will still be returned.\n \nWarning: When used after a CALL statement, this function\nreturns the number of rows selected by the last query in the\nprocedure, not by the whole procedure.\n \nStatements using the FOUND_ROWS() function are not safe for\nreplication.\n \n\nSHOW ENGINES;\n \n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n| Engine | Support | Comment | Transactions | XA |\nSavepoints |\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n| InnoDB | DEFAULT | Supports transactions, row-level\nlocking, and foreign keys | YES | YES | YES |\n...\n| SPHINX | YES | Sphinx storage engine | NO | NO | NO |\n+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+\n11 rows in set (0.01 sec)\n \nSELECT FOUND_ROWS();\n+--------------+\n| FOUND_ROWS() |\n+--------------+\n| 11 |\n+--------------+\n \nSELECT SQL_CALC_FOUND_ROWS * FROM tbl_name WHERE id > 100\nLIMIT 10;\n \nSELECT FOUND_ROWS();\n+--------------+\n| FOUND_ROWS() |\n+--------------+\n| 23 |\n+--------------+
[FROM_BASE64]
declaration=str
category=String Functions
description=Decodes the given base-64 encode string, returning the\nresult as a binary string. Returns NULL if the given string\nis NULL or if it''s invalid.\n \nIt is the reverse of the TO_BASE64 function.\n \nThere are numerous methods to base-64 encode a string.\nMariaDB uses the following:\nIt encodes alphabet value 64 as ''+''.\nIt encodes alphabet value 63 as ''/''.\nIt codes output in groups of four printable characters. Each\nthree byte of data encoded uses four characters. If the\nfinal group is incomplete, it pads the difference with the\n''='' character.\nIt divides long output, adding a new line very 76\ncharacters.\nIn decoding, it recognizes and ignores newlines, carriage\nreturns, tabs and space whitespace characters.\n \nSELECT TO_BASE64(''Maria'') AS ''Input'';\n \n+-----------+\n| Input |\n+-----------+\n| TWFyaWE= |\n+-----------+\n \nSELECT FROM_BASE64(''TWFyaWE='') AS ''Output'';\n \n+--------+\n| Output |\n+--------+\n| Maria |\n+--------+
[FROM_DAYS]
declaration=N
category=Date and Time Functions
description=Given a day number N, returns a DATE value. The day count is\nbased on the number of days from the start of the standard\ncalendar (0000-00-00). \n \nThe function is not designed for use with dates before the\nadvent of the Gregorian calendar in October 1582. Results\nwill not be reliable since it doesn''t account for the lost\ndays when the calendar changed from the Julian calendar.\n \nThis is the converse of the TO_DAYS() function.\n \n\nSELECT FROM_DAYS(730669);\n+-------------------+\n| FROM_DAYS(730669) |\n+-------------------+\n| 2000-07-03 |\n+-------------------+
[FROM_UNIXTIME1]
name=FROM_UNIXTIME
declaration=unix_timestamp
category=Date and Time Functions
description=Returns a representation of the unix_timestamp argument as a\nvalue in\n''YYYY-MM-DD HH:MM:SS'' or YYYYMMDDHHMMSS.uuuuuu format,\ndepending on\nwhether the function is used in a string or numeric context.\nThe value\nis expressed in the current time zone. unix_timestamp is an\ninternal\ntimestamp value such as is produced by the UNIX_TIMESTAMP()\nfunction.\n \nIf format is given, the result is formatted according to the\nformat\nstring, which is used the same way as listed in the entry\nfor the\nDATE_FORMAT() function.\n \nTimestamps in MariaDB have a maximum value of 2147483647,\nequivalent to 2038-01-19 05:14:07. This is due to the\nunderlying 32-bit limitation. Using the function on a\ntimestamp beyond this will result in NULL being returned.\nUse DATETIME as a storage type if you require dates beyond\nthis.\n \nThe options that can be used by FROM_UNIXTIME(), as well as\nDATE_FORMAT() and STR_TO_DATE(), are:\n \nOption | Description | \n \n%a | Short weekday name in current locale (Variable\nlc_time_names). | \n \n%b | Short form month name in current locale. For locale\nen_US this is one of:\nJan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov or Dec. | \n \n%c | Month with 1 or 2 digits. | \n \n%D | Day with English suffix ''th'', ''nd'', ''st'' or\n''rd''''. (1st, 2nd, 3rd...). | \n \n%d | Day with 2 digits. | \n \n%e | Day with 1 or 2 digits. | \n \n%f | Sub seconds 6 digits. | \n \n%H | Hour with 2 digits between 00-23. | \n \n%h | Hour with 2 digits between 01-12. | \n \n%I | Hour with 2 digits between 01-12. | \n \n%i | Minute with 2 digits. | \n \n%j | Day of the year (001-366) | \n \n%k | Hour with 1 digits between 0-23. | \n \n%l | Hour with 1 digits between 1-12. | \n \n%M | Full month name in current locale (Variable\nlc_time_names). | \n \n%m | Month with 2 digits. | \n \n%p | AM/PM according to current locale (Variable\nlc_time_names). | \n \n%r | Time in 12 hour format, followed by AM/PM. Short for\n''%I:%i:%S %p''. | \n \n%S | Seconds with 2 digits. | \n \n%s | Seconds with 2 digits. | \n \n%T | Time in 24 hour format. Short for ''%H:%i:%S''. | \n \n%U | Week number (00-53), when first day of the week is\nSunday. | \n \n%u | Week number (00-53), when first day of the week is\nMonday. | \n \n%V | Week number (01-53), when first day of the week is\nSunday. Used with %X. | \n \n%v | Week number (01-53), when first day of the week is\nMonday. Used with %x. | \n \n%W | Full weekday name in current locale (Variable\nlc_time_names). | \n \n%w | Day of the week. 0 = Sunday, 1 = Saturday. | \n \n%X | Year with 4 digits when first day of the week is\nSunday. Used with %V. | \n \n%x | Year with 4 digits when first day of the week is\nSunday. Used with %v. | \n \n%Y | Year with 4 digits. | \n \n%y | Year with 2 digits. | \n \n%# | For str_to_date(), skip all numbers. | \n \n%. | For str_to_date(), skip all punctation characters. | \n \n%@ | For str_to_date(), skip all alpha characters. | \n \n%% | A literal % character. | \n \nPerformance Considerations\n \nIf your session time zone is set to SYSTEM (the default),\nFROM_UNIXTIME() will call the OS function to convert the\ndata using the system time zone. At least on Linux, the\ncorresponding function (localtime_r) uses a global mutex\ninside glibc that can cause contention under high concurrent\nload.\n \nSet your time zone to a named time zone to avoid this issue.\nSee mysql time zone tables for details on how to do this.\n \n\nSELECT FROM_UNIXTIME(1196440219);\n+---------------------------+\n| FROM_UNIXTIME(1196440219) |\n+---------------------------+\n| 2007-11-30 11:30:19 |\n+---------------------------+\n \nSELECT FROM_UNIXTIME(1196440219) + 0;\n \n+-------------------------------+\n| FROM_UNIXTIME(1196440219) + 0 |\n+-------------------------------+\n| 20071130113019.000000 |\n+-------------------------------+\n \nSELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), ''%Y %D %M %h:%i:%s\n%x'');\n+---------------------------------------------------------+\n| FROM_UNIXTIME(UNIX_TIMESTAMP(), ''%Y %D %M %h:%i:%s %x'')\n|\n+---------------------------------------------------------+\n| 2010 27th March 01:03:47 2010 |\n+---------------------------------------------------------+
[FROM_UNIXTIME2]
name=FROM_UNIXTIME
declaration=unix_timestamp,format
category=Date and Time Functions
description=Returns a representation of the unix_timestamp argument as a\nvalue in\n''YYYY-MM-DD HH:MM:SS'' or YYYYMMDDHHMMSS.uuuuuu format,\ndepending on\nwhether the function is used in a string or numeric context.\nThe value\nis expressed in the current time zone. unix_timestamp is an\ninternal\ntimestamp value such as is produced by the UNIX_TIMESTAMP()\nfunction.\n \nIf format is given, the result is formatted according to the\nformat\nstring, which is used the same way as listed in the entry\nfor the\nDATE_FORMAT() function.\n \nTimestamps in MariaDB have a maximum value of 2147483647,\nequivalent to 2038-01-19 05:14:07. This is due to the\nunderlying 32-bit limitation. Using the function on a\ntimestamp beyond this will result in NULL being returned.\nUse DATETIME as a storage type if you require dates beyond\nthis.\n \nThe options that can be used by FROM_UNIXTIME(), as well as\nDATE_FORMAT() and STR_TO_DATE(), are:\n \nOption | Description | \n \n%a | Short weekday name in current locale (Variable\nlc_time_names). | \n \n%b | Short form month name in current locale. For locale\nen_US this is one of:\nJan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov or Dec. | \n \n%c | Month with 1 or 2 digits. | \n \n%D | Day with English suffix ''th'', ''nd'', ''st'' or\n''rd''''. (1st, 2nd, 3rd...). | \n \n%d | Day with 2 digits. | \n \n%e | Day with 1 or 2 digits. | \n \n%f | Sub seconds 6 digits. | \n \n%H | Hour with 2 digits between 00-23. | \n \n%h | Hour with 2 digits between 01-12. | \n \n%I | Hour with 2 digits between 01-12. | \n \n%i | Minute with 2 digits. | \n \n%j | Day of the year (001-366) | \n \n%k | Hour with 1 digits between 0-23. | \n \n%l | Hour with 1 digits between 1-12. | \n \n%M | Full month name in current locale (Variable\nlc_time_names). | \n \n%m | Month with 2 digits. | \n \n%p | AM/PM according to current locale (Variable\nlc_time_names). | \n \n%r | Time in 12 hour format, followed by AM/PM. Short for\n''%I:%i:%S %p''. | \n \n%S | Seconds with 2 digits. | \n \n%s | Seconds with 2 digits. | \n \n%T | Time in 24 hour format. Short for ''%H:%i:%S''. | \n \n%U | Week number (00-53), when first day of the week is\nSunday. | \n \n%u | Week number (00-53), when first day of the week is\nMonday. | \n \n%V | Week number (01-53), when first day of the week is\nSunday. Used with %X. | \n \n%v | Week number (01-53), when first day of the week is\nMonday. Used with %x. | \n \n%W | Full weekday name in current locale (Variable\nlc_time_names). | \n \n%w | Day of the week. 0 = Sunday, 1 = Saturday. | \n \n%X | Year with 4 digits when first day of the week is\nSunday. Used with %V. | \n \n%x | Year with 4 digits when first day of the week is\nSunday. Used with %v. | \n \n%Y | Year with 4 digits. | \n \n%y | Year with 2 digits. | \n \n%# | For str_to_date(), skip all numbers. | \n \n%. | For str_to_date(), skip all punctation characters. | \n \n%@ | For str_to_date(), skip all alpha characters. | \n \n%% | A literal % character. | \n \nPerformance Considerations\n \nIf your session time zone is set to SYSTEM (the default),\nFROM_UNIXTIME() will call the OS function to convert the\ndata using the system time zone. At least on Linux, the\ncorresponding function (localtime_r) uses a global mutex\ninside glibc that can cause contention under high concurrent\nload.\n \nSet your time zone to a named time zone to avoid this issue.\nSee mysql time zone tables for details on how to do this.\n \n\nSELECT FROM_UNIXTIME(1196440219);\n+---------------------------+\n| FROM_UNIXTIME(1196440219) |\n+---------------------------+\n| 2007-11-30 11:30:19 |\n+---------------------------+\n \nSELECT FROM_UNIXTIME(1196440219) + 0;\n \n+-------------------------------+\n| FROM_UNIXTIME(1196440219) + 0 |\n+-------------------------------+\n| 20071130113019.000000 |\n+-------------------------------+\n \nSELECT FROM_UNIXTIME(UNIX_TIMESTAMP(), ''%Y %D %M %h:%i:%s\n%x'');\n+---------------------------------------------------------+\n| FROM_UNIXTIME(UNIX_TIMESTAMP(), ''%Y %D %M %h:%i:%s %x'')\n|\n+---------------------------------------------------------+\n| 2010 27th March 01:03:47 2010 |\n+---------------------------------------------------------+
[GEOMETRYCOLLECTION]
declaration=g1,g2,...
category=Geometry Constructors
description=Constructs a WKB GeometryCollection. If any argument is not\na well-formed WKB representation of a geometry, the return\nvalue is NULL.\n \n\nCREATE TABLE gis_geometrycollection (g GEOMETRYCOLLECTION);\nSHOW FIELDS FROM gis_geometrycollection;\n \nINSERT INTO gis_geometrycollection VALUES\n (GeomCollFromText(''GEOMETRYCOLLECTION(POINT(0 0),\nLINESTRING(0 0,10 10))'')),\n (GeometryFromWKB(AsWKB(GeometryCollection(Point(44, 6),\nLineString(Point(3, 6), Point(7, 9)))))),\n (GeomFromText(''GeometryCollection()'')),\n (GeomFromText(''GeometryCollection EMPTY''));
[GET_FORMAT]
declaration={DATE|DATETIME|TIME}, {''EUR''|''USA''|''JIS''|''ISO''|''INTERNAL''}
category=Date and Time Functions
description=Returns a format string. This function is useful in\ncombination with\nthe DATE_FORMAT() and the STR_TO_DATE() functions.\n \nPossible result formats are:\n \nFunction Call | Result Format | \n \nGET_FORMAT(DATE,''EUR'') | ''%d.%m.%Y'' | \n \nGET_FORMAT(DATE,''USA'') | ''%m.%d.%Y'' | \n \nGET_FORMAT(DATE,''JIS'') | ''%Y-%m-%d'' | \n \nGET_FORMAT(DATE,''ISO'') | ''%Y-%m-%d'' | \n \nGET_FORMAT(DATE,''INTERNAL'') | ''%Y%m%d'' | \n \nGET_FORMAT(DATETIME,''EUR'') | ''%Y-%m-%d %H.%i.%s'' | \n \nGET_FORMAT(DATETIME,''USA'') | ''%Y-%m-%d %H.%i.%s'' | \n \nGET_FORMAT(DATETIME,''JIS'') | ''%Y-%m-%d %H:%i:%s'' | \n \nGET_FORMAT(DATETIME,''ISO'') | ''%Y-%m-%d %H:%i:%s'' | \n \nGET_FORMAT(DATETIME,''INTERNAL'') | ''%Y%m%d%H%i%s'' | \n \nGET_FORMAT(TIME,''EUR'') | ''%H.%i.%s'' | \n \nGET_FORMAT(TIME,''USA'') | ''%h:%i:%s %p'' | \n \nGET_FORMAT(TIME,''JIS'') | ''%H:%i:%s'' | \n \nGET_FORMAT(TIME,''ISO'') | ''%H:%i:%s'' | \n \nGET_FORMAT(TIME,''INTERNAL'') | ''%H%i%s'' | \n \n\nObtaining the string matching to the standard European date\nformat:\n \nSELECT GET_FORMAT(DATE, ''EUR'');\n+-------------------------+\n| GET_FORMAT(DATE, ''EUR'') |\n+-------------------------+\n| %d.%m.%Y |\n+-------------------------+\n \nUsing the same string to format a date:\n \nSELECT DATE_FORMAT(''2003-10-03'',GET_FORMAT(DATE,''EUR''));\n+--------------------------------------------------+\n| DATE_FORMAT(''2003-10-03'',GET_FORMAT(DATE,''EUR'')) |\n+--------------------------------------------------+\n| 03.10.2003 |\n+--------------------------------------------------+\n \nSELECT STR_TO_DATE(''10.31.2003'',GET_FORMAT(DATE,''USA''));\n+--------------------------------------------------+\n| STR_TO_DATE(''10.31.2003'',GET_FORMAT(DATE,''USA'')) |\n+--------------------------------------------------+\n| 2003-10-31 |\n+--------------------------------------------------+
[GET_LOCK]
declaration=str,timeout
category=Miscellaneous Functions
description=Tries to obtain a lock with a name given by the string str,\nusing a timeout of timeout seconds. Returns 1 if the lock\nwas obtained successfully, 0 if the attempt timed out (for\nexample, because another client has previously locked the\nname), or NULL if an error occurred (such as running out of\nmemory or the thread was killed with mysqladmin kill).\n \nA lock is released with RELEASE_LOCK(), when the connection\nterminates (either normally or abnormally), or before\nMariaDB 10.0.2, when the connection executes another\nGET_LOCK statement. From MariaDB 10.0.2, a connection can\nhold multiple locks at the same time, so a lock that is no\nlonger needed needs to be explicitly released.\n \nThe IS_FREE_LOCK function returns whether a specified lock a\nfree or not, and the IS_USED_LOCK whether the function is in\nuse or not.\n \nLocks obtained with GET_LOCK() do not interact with\ntransactions. That is, committing a transaction does not\nrelease any such locks obtained during the transaction.\n \nFrom MariaDB 10.0.2, it is also possible to recursively set\nthe same lock. If a lock with the same name is set n times,\nit needs to be released n times as well. \n \nstr is case insensitive for GET_LOCK() and related\nfunctions. If str is an empty string or NULL, GET_LOCK()\nreturns NULL and does nothing. From MariaDB 10.2.2, timeout\nsupports microseconds. Before then, it was rounded to the\nclosest integer.\n \nIf the metadata_lock_info plugin is installed, locks\nacquired with this function are visible in the Information\nSchema METADATA_LOCK_INFO table.\n \nThis function can be used to implement application locks or\nto simulate record locks. Names are locked on a server-wide\nbasis. If a name has been locked by one client, GET_LOCK()\nblocks any request by another client for a lock with the\nsame name. This allows clients that agree on a given lock\nname to use the name to perform cooperative advisory\nlocking. But be aware that it also allows a client that is\nnot among the set of cooperating clients to lock a name,\neither inadvertently or deliberately, and thus prevent any\nof the cooperating clients from locking that name. One way\nto reduce the likelihood of this is to use lock names that\nare database-specific or application-specific. For example,\nuse lock names of the form db_name.str or app_name.str.\n \nStatements using the GET_LOCK() function are not safe for\nreplication.\n \nThe patch to permit multiple locks was contributed by\nKonstantin "Kostja" Osipov (MDEV-3917).\n \n\nSELECT GET_LOCK(''lock1'',10);\n+----------------------+\n| GET_LOCK(''lock1'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSELECT IS_FREE_LOCK(''lock1''), IS_USED_LOCK(''lock1'');\n+-----------------------+-----------------------+\n| IS_FREE_LOCK(''lock1'') | IS_USED_LOCK(''lock1'') |\n+-----------------------+-----------------------+\n| 0 | 46 |\n+-----------------------+-----------------------+\n \nSELECT IS_FREE_LOCK(''lock2''), IS_USED_LOCK(''lock2'');\n+-----------------------+-----------------------+\n| IS_FREE_LOCK(''lock2'') | IS_USED_LOCK(''lock2'') |\n+-----------------------+-----------------------+\n| 1 | NULL |\n+-----------------------+-----------------------+\n \nFrom MariaDB 10.0.2, multiple locks can be held:\n \nSELECT GET_LOCK(''lock2'',10);\n+----------------------+\n| GET_LOCK(''lock2'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSELECT IS_FREE_LOCK(''lock1''), IS_FREE_LOCK(''lock2'');\n+-----------------------+-----------------------+\n| IS_FREE_LOCK(''lock1'') | IS_FREE_LOCK(''lock2'') |\n+-----------------------+-----------------------+\n| 0 | 0 |\n+-----------------------+-----------------------+\n \nSELECT RELEASE_LOCK(''lock1''), RELEASE_LOCK(''lock2'');\n+-----------------------+-----------------------+\n| RELEASE_LOCK(''lock1'') | RELEASE_LOCK(''lock2'') |\n+-----------------------+-----------------------+\n| 1 | 1 |\n+-----------------------+-----------------------+\n \nBefore MariaDB 10.0.2, a connection could only hold a single\nlock:\n \nSELECT GET_LOCK(''lock2'',10);\n+----------------------+\n| GET_LOCK(''lock2'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSELECT IS_FREE_LOCK(''lock1''), IS_FREE_LOCK(''lock2'');\n+-----------------------+-----------------------+\n| IS_FREE_LOCK(''lock1'') | IS_FREE_LOCK(''lock2'') |\n+-----------------------+-----------------------+\n| 1 | 0 |\n+-----------------------+-----------------------+\n \nSELECT RELEASE_LOCK(''lock1''), RELEASE_LOCK(''lock2'');\n+-----------------------+-----------------------+\n| RELEASE_LOCK(''lock1'') | RELEASE_LOCK(''lock2'') |\n+-----------------------+-----------------------+\n| NULL | 1 |\n+-----------------------+-----------------------+\n \nFrom MariaDB 10.0.2, it is possible to hold the same lock\nrecursively. This example is viewed using the\nmetadata_lock_info plugin:\n \nSELECT GET_LOCK(''lock3'',10);\n+----------------------+\n| GET_LOCK(''lock3'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSELECT GET_LOCK(''lock3'',10);\n+----------------------+\n| GET_LOCK(''lock3'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n \n+-----------+---------------------+---------------+-----------+--------------+------------+\n| THREAD_ID | LOCK_MODE | LOCK_DURATION | LOCK_TYPE |\nTABLE_SCHEMA | TABLE_NAME |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n| 46 | MDL_SHARED_NO_WRITE | NULL | User lock | lock3 | |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n \nSELECT RELEASE_LOCK(''lock3'');\n+-----------------------+\n| RELEASE_LOCK(''lock3'') |\n+-----------------------+\n| 1 |\n+-----------------------+\n \nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n \n+-----------+---------------------+---------------+-----------+--------------+------------+\n| THREAD_ID | LOCK_MODE | LOCK_DURATION | LOCK_TYPE |\nTABLE_SCHEMA | TABLE_NAME |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n| 46 | MDL_SHARED_NO_WRITE | NULL | User lock | lock3 | |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n \nSELECT RELEASE_LOCK(''lock3'');\n+-----------------------+\n| RELEASE_LOCK(''lock3'') |\n+-----------------------+\n| 1 |\n+-----------------------+\n \nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n \nEmpty set (0.000 sec)\n \nTimeout example: Connection 1:\n \nSELECT GET_LOCK(''lock4'',10);\n+----------------------+\n| GET_LOCK(''lock4'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nConnection 2:\n \nSELECT GET_LOCK(''lock4'',10);\n \nAfter 10 seconds...\n \n+----------------------+\n| GET_LOCK(''lock4'',10) |\n+----------------------+\n| 0 |\n+----------------------+\n \nDeadlocks are automatically detected and resolved.\nConnection 1:\n \nSELECT GET_LOCK(''lock5'',10); \n+----------------------+\n| GET_LOCK(''lock5'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nConnection 2:\n \nSELECT GET_LOCK(''lock6'',10);\n+----------------------+\n| GET_LOCK(''lock6'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nConnection 1:\n \nSELECT GET_LOCK(''lock6'',10); \n+----------------------+\n| GET_LOCK(''lock6'',10) |\n+----------------------+\n| 0 |\n+----------------------+\n \nConnection 2:\n \nSELECT GET_LOCK(''lock5'',10);\nERROR 1213 (40001): Deadlock found when trying to get lock;\n try restarting transaction
[GLENGTH]
declaration=ls
category=LineString Properties
description=Returns as a double-precision number the length of the\nLineString value ls in its associated spatial reference.\n \n\nSET @ls = ''LineString(1 1,2 2,3 3)'';\n \nSELECT GLength(GeomFromText(@ls));\n+----------------------------+\n| GLength(GeomFromText(@ls)) |\n+----------------------------+\n| 2.82842712474619 |\n+----------------------------+
[GREATEST]
declaration=value1,value2,...
category=Comparison Operators
description=With two or more arguments, returns the largest\n(maximum-valued)\nargument. The arguments are compared using the same rules as\nfor\nLEAST().\n \n\nSELECT GREATEST(2,0);\n+---------------+\n| GREATEST(2,0) |\n+---------------+\n| 2 |\n+---------------+\n \nSELECT GREATEST(34.0,3.0,5.0,767.0);\n+------------------------------+\n| GREATEST(34.0,3.0,5.0,767.0) |\n+------------------------------+\n| 767.0 |\n+------------------------------+\n \nSELECT GREATEST(''B'',''A'',''C'');\n+-----------------------+\n| GREATEST(''B'',''A'',''C'') |\n+-----------------------+\n| C |\n+-----------------------+
[GROUP_CONCAT]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=This function returns a string result with the concatenated\nnon-NULL\nvalues from a group. It returns NULL if there are no\nnon-NULL values.\n \nThe maximum returned length in bytes is determined by the\ngroup_concat_max_len server system variable, which defaults\nto 1M (>= MariaDB 10.2.4) or 1K (
[HEX]
declaration=N_or_S
category=String Functions
description=If N_or_S is a number, returns a string representation of\nthe hexadecimal\nvalue of N, where N is a longlong (BIGINT) number. This is\nequivalent to CONV(N,10,16).\n \nIf N_or_S is a string, returns a hexadecimal string\nrepresentation of\nN_or_S where each byte of each character in N_or_S is\nconverted to two hexadecimal\ndigits. If N_or_S is NULL, returns NULL. The inverse of this\noperation is performed by the UNHEX()\nfunction.\n \n\nSELECT HEX(255);\n+----------+\n| HEX(255) |\n+----------+\n| FF |\n+----------+\n \nSELECT 0x4D617269614442;\n \n+------------------+\n| 0x4D617269614442 |\n+------------------+\n| MariaDB |\n+------------------+\n \nSELECT HEX(''MariaDB'');\n+----------------+\n| HEX(''MariaDB'') |\n+----------------+\n| 4D617269614442 |\n+----------------+
[HOUR]
declaration=time
category=Date and Time Functions
description=Returns the hour for time. The range of the return value is\n0 to 23\nfor time-of-day values. However, the range of TIME values\nactually is\nmuch larger, so HOUR can return values greater than 23.\n \nThe return value is always positive, even if a negative TIME\nvalue is provided.\n \n\nSELECT HOUR(''10:05:03'');\n+------------------+\n| HOUR(''10:05:03'') |\n+------------------+\n| 10 |\n+------------------+\n \nSELECT HOUR(''272:59:59'');\n+-------------------+\n| HOUR(''272:59:59'') |\n+-------------------+\n| 272 |\n+-------------------+\n \nDifference between EXTRACT (HOUR FROM ...) (>= MariaDB\n10.0.7 and MariaDB 5.5.35) and HOUR:\n \nSELECT EXTRACT(HOUR FROM ''26:30:00''), HOUR(''26:30:00'');\n+-------------------------------+------------------+\n| EXTRACT(HOUR FROM ''26:30:00'') | HOUR(''26:30:00'') |\n+-------------------------------+------------------+\n| 2 | 26 |\n+-------------------------------+------------------+
[IFNULL]
declaration=expr1,expr2
category=Control Flow Functions
description=If expr1 is not NULL, IFNULL() returns expr1; otherwise it\nreturns\nexpr2. IFNULL() returns a numeric or string value, depending\non the\ncontext in which it is used.\n \n\nSELECT IFNULL(1,0); \n+-------------+\n| IFNULL(1,0) |\n+-------------+\n| 1 |\n+-------------+\n \nSELECT IFNULL(NULL,10);\n+-----------------+\n| IFNULL(NULL,10) |\n+-----------------+\n| 10 |\n+-----------------+\n \nSELECT IFNULL(1/0,10);\n+----------------+\n| IFNULL(1/0,10) |\n+----------------+\n| 10.0000 |\n+----------------+\n \nSELECT IFNULL(1/0,''yes'');\n+-------------------+\n| IFNULL(1/0,''yes'') |\n+-------------------+\n| yes |\n+-------------------+
[INET6_ATON]
declaration=expr
category=Miscellaneous Functions
description=Given an IPv6 or IPv4 network address as a string, returns a\nbinary string that represents the numeric value of the\naddress.\n \nNo trailing zone ID''s or traling network masks are\npermitted. For IPv4 addresses, or IPv6 addresses with IPv4\naddress parts, no classful addresses or trailing port\nnumbers are permitted and octal numbers are not supported.\n \nThe returned binary string will be VARBINARY(16) or\nVARBINARY(4) for IPv6 and IPv4 addresses respectively.\n \nReturns NULL if the argument is not understood.\n \n\nSELECT HEX(INET6_ATON(''10.0.1.1''));\n+-----------------------------+\n| HEX(INET6_ATON(''10.0.1.1'')) |\n+-----------------------------+\n| 0A000101 |\n+-----------------------------+\n \nSELECT HEX(INET6_ATON(''48f3::d432:1431:ba23:846f''));\n+----------------------------------------------+\n| HEX(INET6_ATON(''48f3::d432:1431:ba23:846f'')) |\n+----------------------------------------------+\n| 48F3000000000000D4321431BA23846F |\n+----------------------------------------------+
[INET6_NTOA]
declaration=expr
category=Miscellaneous Functions
description=Given an IPv6 or IPv4 network address as a numeric binary\nstring, returns the address as a nonbinary string in the\nconnection character set.\n \nThe return string is lowercase, and is platform independent,\nsince it does not use functions specific to the operating\nsystem. It has a maximum length of 39 characters.\n \nReturns NULL if the argument is not understood.\n \n\nSELECT INET6_NTOA(UNHEX(''0A000101''));\n+-------------------------------+\n| INET6_NTOA(UNHEX(''0A000101'')) |\n+-------------------------------+\n| 10.0.1.1 |\n+-------------------------------+\n \nSELECT\nINET6_NTOA(UNHEX(''48F3000000000000D4321431BA23846F''));\n+-------------------------------------------------------+\n| INET6_NTOA(UNHEX(''48F3000000000000D4321431BA23846F'')) |\n+-------------------------------------------------------+\n| 48f3::d432:1431:ba23:846f |\n+-------------------------------------------------------+
[INET_ATON]
declaration=expr
category=Miscellaneous Functions
description=Given the dotted-quad representation of an IPv4 network\naddress as a string,\nreturns an integer that represents the numeric value of the\naddress.\nAddresses may be 4- or 8-byte addresses.\n \nReturns NULL if the argument is not understood.\n \n\nSELECT INET_ATON(''192.168.1.1'');\n+--------------------------+\n| INET_ATON(''192.168.1.1'') |\n+--------------------------+\n| 3232235777 |\n+--------------------------+\n \nThis is calculated as follows: 192 x 2563 + 168 x 256 2 + 1\nx 256 + 1
[INET_NTOA]
declaration=expr
category=Miscellaneous Functions
description=Given a numeric IPv4 network address in network byte order\n(4 or 8 byte),\nreturns the dotted-quad representation of the address as a\nstring.\n \n\nSELECT INET_NTOA(3232235777);\n+-----------------------+\n| INET_NTOA(3232235777) |\n+-----------------------+\n| 192.168.1.1 |\n+-----------------------+\n \n192.168.1.1 corresponds to 3232235777 since 192 x 2563 + 168\nx 256 2 + 1 x 256 + 1 = 3232235777
[INSTR]
declaration=str,substr
category=String Functions
description=Returns the position of the first occurrence of substring\nsubstr in\nstring str. This is the same as the two-argument form of\nLOCATE(),\nexcept that the order of the arguments is reversed.\n \nINSTR() performs a case-insensitive search.\n \nIf any argument is NULL, returns NULL.\n \n\nSELECT INSTR(''foobarbar'', ''bar'');\n+---------------------------+\n| INSTR(''foobarbar'', ''bar'') |\n+---------------------------+\n| 4 |\n+---------------------------+\n \nSELECT INSTR(''My'', ''Maria'');\n+----------------------+\n| INSTR(''My'', ''Maria'') |\n+----------------------+\n| 0 |\n+----------------------+
[INTERSECTS]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether geometry g1 spatially\nintersects geometry g2.\n \nINTERSECTS() is based on the original MySQL implementation\nand uses object bounding rectangles, while ST_INTERSECTS()\nuses object shapes.\n \nINTERSECTS() tests the opposite relationship to DISJOINT().
[INTERVAL]
declaration=N,N1,N2,N3,...
category=Comparison Operators
description=Returns the index of the last argument that is less than the\nfirst argument or is NULL. \n \nReturns 0 if N < N1, 1 if N < N2, 2 if N < N3 and so on or\n-1 if N is NULL. All\narguments are treated as integers. It is required that N1 <\nN2 < N3
[ISNULL]
declaration=expr
category=Comparison Operators
description=If expr is NULL, ISNULL() returns 1, otherwise it returns 0.\n \nSee also NULL Values in MariaDB.\n \n\nSELECT ISNULL(1+1);\n+-------------+\n| ISNULL(1+1) |\n+-------------+\n| 0 |\n+-------------+\n \nSELECT ISNULL(1/0);\n+-------------+\n| ISNULL(1/0) |\n+-------------+\n| 1 |\n+-------------+
[IS_FREE_LOCK]
declaration=str
category=Miscellaneous Functions
description=Checks whether the lock named str is free to use (that is,\nnot locked).\nReturns 1 if the lock is free (no one is using the lock),\n 0 if the lock is in use, and NULL if an\nerror occurs (such as an incorrect argument, like an empty\nstring or NULL). str is case insensitive.\n \nIf the metadata_lock_info plugin is installed, the\nInformation Schema metadata_lock_info table contains\ninformation about locks of this kind (as well as metadata\nlocks).\n \nStatements using the IS_FREE_LOCK() function are not safe\nfor replication.
[IS_IPV4]
declaration=expr
category=Miscellaneous Functions
description=If the expression is a valid IPv4 address, returns 1,\notherwise returns 0.\n \nIS_IPV4() is stricter than INET_ATON(), but as strict as\nINET6_ATON(), in determining the validity of an IPv4\naddress. This implies that if IS_IPV4 returns 1, the same\nexpression will always return a non-NULL result when passed\nto INET_ATON(), but that the reverse may not apply.\n \n\nSELECT IS_IPV4(''1110.0.1.1'');\n+-----------------------+\n| IS_IPV4(''1110.0.1.1'') |\n+-----------------------+\n| 0 |\n+-----------------------+\n \nSELECT IS_IPV4(''48f3::d432:1431:ba23:846f'');\n+--------------------------------------+\n| IS_IPV4(''48f3::d432:1431:ba23:846f'') |\n+--------------------------------------+\n| 0 |\n+--------------------------------------+
[IS_IPV4_COMPAT]
declaration=expr
category=Miscellaneous Functions
description=Returns 1 if a given numeric binary string IPv6 address,\nsuch as returned by INET6_ATON(), is IPv4-compatible,\notherwise returns 0. \n \n\nSELECT IS_IPV4_COMPAT(INET6_ATON(''::10.0.1.1''));\n+------------------------------------------+\n| IS_IPV4_COMPAT(INET6_ATON(''::10.0.1.1'')) |\n+------------------------------------------+\n| 1 |\n+------------------------------------------+\n \nSELECT\nIS_IPV4_COMPAT(INET6_ATON(''::48f3::d432:1431:ba23:846f''));\n+-----------------------------------------------------------+\n|\nIS_IPV4_COMPAT(INET6_ATON(''::48f3::d432:1431:ba23:846f''))\n|\n+-----------------------------------------------------------+\n| 0 |\n+-----------------------------------------------------------+
[IS_IPV4_MAPPED]
declaration=expr
category=Miscellaneous Functions
description=Returns 1 if a given a numeric binary string IPv6 address,\nsuch as returned by INET6_ATON(), is a valid IPv4-mapped\naddress, otherwise returns 0.\n \n\nSELECT IS_IPV4_MAPPED(INET6_ATON(''::10.0.1.1''));\n+------------------------------------------+\n| IS_IPV4_MAPPED(INET6_ATON(''::10.0.1.1'')) |\n+------------------------------------------+\n| 0 |\n+------------------------------------------+\n \nSELECT IS_IPV4_MAPPED(INET6_ATON(''::ffff:10.0.1.1''));\n+-----------------------------------------------+\n| IS_IPV4_MAPPED(INET6_ATON(''::ffff:10.0.1.1'')) |\n+-----------------------------------------------+\n| 1 |\n+-----------------------------------------------+
[IS_IPV6]
declaration=expr
category=Miscellaneous Functions
description=Returns 1 if the expression is a valid IPv6 address\nspecified as a string, otherwise returns 0. Does not\nconsider IPv4 addresses to be valid IPv6 addresses.\n \n\n SELECT IS_IPV6(''48f3::d432:1431:ba23:846f'');\n+--------------------------------------+\n| IS_IPV6(''48f3::d432:1431:ba23:846f'') |\n+--------------------------------------+\n| 1 |\n+--------------------------------------+\n1 row in set (0.02 sec)\n \nSELECT IS_IPV6(''10.0.1.1'');\n+---------------------+\n| IS_IPV6(''10.0.1.1'') |\n+---------------------+\n| 0 |\n+---------------------+
[IS_USED_LOCK]
declaration=str
category=Miscellaneous Functions
description=Checks whether the lock named str is in use (that is,\nlocked). If so,\nit returns the connection identifier of the client that\nholds the\nlock. Otherwise, it returns NULL. str is case insensitive.\n \nIf the metadata_lock_info plugin is installed, the\nInformation Schema metadata_lock_info table contains\ninformation about locks of this kind (as well as metadata\nlocks).\n \nStatements using the IS_USED_LOCK() function are not safe\nfor replication.
[JSON_ARRAY]
declaration=[value[, value2] ...]
category=JSON Functions
description=Returns a JSON array containing the listed values. The list\ncan be empty.\n \nExample\n \nSELECT Json_Array(56, 3.1416, ''My name is "Foo"'', NULL);\n+--------------------------------------------------+\n| Json_Array(56, 3.1416, ''My name is "Foo"'', NULL) |\n+--------------------------------------------------+\n| [56, 3.1416, "My name is \"Foo\"", null] |\n+--------------------------------------------------+
[JSON_ARRAY_APPEND]
declaration=json_doc, path, value[, path, value] ...
category=JSON Functions
description=Appends values to the end of the specified arrays within a\nJSON document, returning the result, or NULL if any of the\narguments are NULL.\n \nEvaluation is performed from left to right, with the\nresulting document from the previous pair becoming the new\nvalue against which the next pair is evaluated.\n \nIf the json_doc is not a valid JSON document, or if any of\nthe paths are not valid, or contain a * or ** wildcard, an\nerror is returned.\n \n\nSET @json = ''[1, 2, [3, 4]]'';\n \nSELECT JSON_ARRAY_APPEND(@json, ''$[0]'', 5)\n+-------------------------------------+\n| JSON_ARRAY_APPEND(@json, ''$[0]'', 5) |\n+-------------------------------------+\n| [[1, 5], 2, [3, 4]] |\n+-------------------------------------+\n \nSELECT JSON_ARRAY_APPEND(@json, ''$[1]'', 6);\n+-------------------------------------+\n| JSON_ARRAY_APPEND(@json, ''$[1]'', 6) |\n+-------------------------------------+\n| [1, [2, 6], [3, 4]] |\n+-------------------------------------+\n \nSELECT JSON_ARRAY_APPEND(@json, ''$[1]'', 6, ''$[2]'', 7);\n+------------------------------------------------+\n| JSON_ARRAY_APPEND(@json, ''$[1]'', 6, ''$[2]'', 7) |\n+------------------------------------------------+\n| [1, [2, 6], [3, 4, 7]] |\n+------------------------------------------------+\n \nSELECT JSON_ARRAY_APPEND(@json, ''$'', 5);\n+----------------------------------+\n| JSON_ARRAY_APPEND(@json, ''$'', 5) |\n+----------------------------------+\n| [1, 2, [3, 4], 5] |\n+----------------------------------+\n \nSET @json = ''{"A": 1, "B": [2], "C": [3, 4]}'';\n \nSELECT JSON_ARRAY_APPEND(@json, ''$.B'', 5);\n+------------------------------------+\n| JSON_ARRAY_APPEND(@json, ''$.B'', 5) |\n+------------------------------------+\n| {"A": 1, "B": [2, 5], "C": [3, 4]} |\n+------------------------------------+
[JSON_ARRAY_INSERT]
declaration=json_doc, path, value[, path, value] ...
category=JSON Functions
description=Inserts a value into a JSON document, returning the modified\ndocument, or NULL if any of the arguments are NULL.\n \nEvaluation is performed from left to right, with the\nresulting document from the previous pair becoming the new\nvalue against which the next pair is evaluated.\n \nIf the json_doc is not a valid JSON document, or if any of\nthe paths are not valid, or contain a * or ** wildcard, an\nerror is returned.\n \n\nSET @json = ''[1, 2, [3, 4]]'';\n \nSELECT JSON_ARRAY_INSERT(@json, ''$[0]'', 5);\n+-------------------------------------+\n| JSON_ARRAY_INSERT(@json, ''$[0]'', 5) |\n+-------------------------------------+\n| [5, 1, 2, [3, 4]] |\n+-------------------------------------+\n \nSELECT JSON_ARRAY_INSERT(@json, ''$[1]'', 6);\n+-------------------------------------+\n| JSON_ARRAY_INSERT(@json, ''$[1]'', 6) |\n+-------------------------------------+\n| [1, 6, 2, [3, 4]] |\n+-------------------------------------+\n \nSELECT JSON_ARRAY_INSERT(@json, ''$[1]'', 6, ''$[2]'', 7);\n+------------------------------------------------+\n| JSON_ARRAY_INSERT(@json, ''$[1]'', 6, ''$[2]'', 7) |\n+------------------------------------------------+\n| [1, 6, 7, 2, [3, 4]] |\n+------------------------------------------------+
[JSON_COMPACT]
declaration=json_doc
category=JSON Functions
description=Removes all unnecessary spaces so the json document is as\nshort as possible.\n \nExample\n \nSET @j = ''{ "A": 1, "B": [2, 3]}'';\n \nSELECT JSON_COMPACT(@j), @j;\n+-------------------+------------------------+\n| JSON_COMPACT(@j) | @j |\n+-------------------+------------------------+\n| {"A":1,"B":[2,3]} | { "A": 1, "B": [2, 3]} |\n+-------------------+------------------------+
[JSON_CONTAINS]
declaration=json_doc, val[, path]
category=JSON Functions
description=Returns whether or not the specified value is found in the\ngiven JSON document or, optionally, at the specified path\nwithin the document. Returns 1 if it does, 0 if not and NULL\nif any of the arguments are null. An error occurs if the\ndocument or path is not valid, or contains the * or **\nwildcards.\n \n\nSET @json = ''{"A": 0, "B": {"C": 1}, "D": 2}'';\n \nSELECT JSON_CONTAINS(@json, ''2'', ''$.A'');\n+----------------------------------+\n| JSON_CONTAINS(@json, ''2'', ''$.A'') |\n+----------------------------------+\n| 0 |\n+----------------------------------+\n \nSELECT JSON_CONTAINS(@json, ''2'', ''$.D'');\n+----------------------------------+\n| JSON_CONTAINS(@json, ''2'', ''$.D'') |\n+----------------------------------+\n| 1 |\n+----------------------------------+\n \nSELECT JSON_CONTAINS(@json, ''{"C": 1}'', ''$.A'');\n+-----------------------------------------+\n| JSON_CONTAINS(@json, ''{"C": 1}'', ''$.A'') |\n+-----------------------------------------+\n| 0 |\n+-----------------------------------------+\n \nSELECT JSON_CONTAINS(@json, ''{"C": 1}'', ''$.B'');\n+-----------------------------------------+\n| JSON_CONTAINS(@json, ''{"C": 1}'', ''$.B'') |\n+-----------------------------------------+\n| 1 |\n+-----------------------------------------+
[JSON_CONTAINS_PATH]
declaration=json_doc, return_arg, path[, path] ...
category=JSON Functions
description=Indicates whether the given JSON document contains data at\nthe specified path or paths. Returns 1 if it does, 0 if not\nand NULL if any of the arguments are null.\n \nThe return_arg can be one or all:\none - Returns 1 if at least one path exists within the JSON\ndocument. \nall - Returns 1 only if all paths exist within the JSON\ndocument.\n \n\nSET @json = ''{"A": 1, "B": [2], "C": [3, 4]}'';\n \nSELECT JSON_CONTAINS_PATH(@json, ''one'', ''$.A'', ''$.D'');\n+------------------------------------------------+\n| JSON_CONTAINS_PATH(@json, ''one'', ''$.A'', ''$.D'') |\n+------------------------------------------------+\n| 1 |\n+------------------------------------------------+\n1 row in set (0.00 sec)\n \nSELECT JSON_CONTAINS_PATH(@json, ''all'', ''$.A'', ''$.D'');\n+------------------------------------------------+\n| JSON_CONTAINS_PATH(@json, ''all'', ''$.A'', ''$.D'') |\n+------------------------------------------------+\n| 0 |\n+------------------------------------------------+
[JSON_DEPTH]
declaration=json_doc
category=JSON Functions
description=Returns the maximum depth of the given JSON document, or\nNULL if the argument is null. An error will occur if the\nargument is an invalid JSON document.\nScalar values or empty arrays or objects have a depth of 1.\nArrays or objects that are not empty but contain only\nelements or member values of depth 1 will have a depth of 2.\nIn other cases, the depth will be greater than 2.\n \n\nSELECT JSON_DEPTH(''[]''), JSON_DEPTH(''true''),\nJSON_DEPTH(''{}'');\n+------------------+--------------------+------------------+\n| JSON_DEPTH(''[]'') | JSON_DEPTH(''true'') |\nJSON_DEPTH(''{}'') |\n+------------------+--------------------+------------------+\n| 1 | 1 | 1 |\n+------------------+--------------------+------------------+\n \nSELECT JSON_DEPTH(''[1, 2, 3]''), JSON_DEPTH(''[[], {},\n[]]'');\n+-------------------------+----------------------------+\n| JSON_DEPTH(''[1, 2, 3]'') | JSON_DEPTH(''[[], {}, []]'') |\n+-------------------------+----------------------------+\n| 2 | 2 |\n+-------------------------+----------------------------+\n \nSELECT JSON_DEPTH(''[1, 2, [3, 4, 5, 6], 7]'');\n+---------------------------------------+\n| JSON_DEPTH(''[1, 2, [3, 4, 5, 6], 7]'') |\n+---------------------------------------+\n| 3 |\n+---------------------------------------+
[JSON_DETAILED]
declaration=json_doc[, tab_size]
category=JSON Functions
description=Represents JSON in the most understandable way emphasizing\nnested structures.\n \nExample\n \nSET @j = ''{ "A":1,"B":[2,3]}'';\n \nSELECT @j;\n+--------------------+\n| @j |\n+--------------------+\n| { "A":1,"B":[2,3]} |\n+--------------------+\n \nSELECT JSON_DETAILED(@j);\n+------------------------------------------------------------+\n| JSON_DETAILED(@j) |\n+------------------------------------------------------------+\n| {\n "A": 1,\n "B": \n [\n 2,\n 3\n ]\n} |\n+------------------------------------------------------------+
[JSON_EXTRACT]
declaration=json_doc, path[, path] ...
category=JSON Functions
description=Extracts data from a JSON document. The extracted data is\nselected from the parts matching the path arguments. Returns\nall matched values; either as a single matched value, or, if\nthe arguments could return multiple values, a result\nautowrapped as an array in the matching order.\n \nReturns NULL if no paths match or if any of the arguments\nare NULL. \n \nAn error will occur if any path argument is not a valid\npath, or if the json_doc argument is not a valid JSON\ndocument.\n \n\nSET @json = ''[1, 2, [3, 4]]'';\n \nSELECT JSON_EXTRACT(@json, ''$[1]'');\n+-----------------------------+\n| JSON_EXTRACT(@json, ''$[1]'') |\n+-----------------------------+\n| 2 |\n+-----------------------------+\n \nSELECT JSON_EXTRACT(@json, ''$[2]'');\n+-----------------------------+\n| JSON_EXTRACT(@json, ''$[2]'') |\n+-----------------------------+\n| [3, 4] |\n+-----------------------------+\n \nSELECT JSON_EXTRACT(@json, ''$[2][1]'');\n+--------------------------------+\n| JSON_EXTRACT(@json, ''$[2][1]'') |\n+--------------------------------+\n| 4 |\n+--------------------------------+
[JSON_INSERT]
declaration=json_doc, path, val[, path, val] ...
category=JSON Functions
description=Inserts data into a JSON document, returning the resulting\ndocument or NULL if any argument is null. \n \nAn error will occur if the JSON document is not invalid, or\nif any of the paths are invalid or contain a * or **\nwildcard.\n \nJSON_INSERT can only insert data while JSON_REPLACE can only\nupdate. JSON_SET can update or insert data. \n \n\nSET @json = ''{ "A": 0, "B": [1, 2]}'';\n \nSELECT JSON_INSERT(@json, ''$.C'', ''[3, 4]'');\n+--------------------------------------+\n| JSON_INSERT(@json, ''$.C'', ''[3, 4]'') |\n+--------------------------------------+\n| { "A": 0, "B": [1, 2], "C":"[3, 4]"} |\n+--------------------------------------+
[JSON_KEYS]
declaration=json_doc[, path]
category=JSON Functions
description=Returns the keys as a JSON array from the top-level value of\na JSON object or, if the optional path argument is provided,\nthe top-level keys from the path. \n \nExcludes keys from nested sub-objects in the top level\nvalue. The resulting array will be empty if the selected\nobject is empty.\n \nReturns NULL if any of the arguments are null, a given path\ndoes not locate an object, or if the json_doc argument is\nnot an object.\n \nAn error will occur if JSON document is invalid, the path is\ninvalid or if the path contains a * or ** wildcard.\n \n\nSELECT JSON_KEYS(''{"A": 1, "B": {"C": 2}}'');\n+--------------------------------------+\n| JSON_KEYS(''{"A": 1, "B": {"C": 2}}'') |\n+--------------------------------------+\n| ["A", "B"] |\n+--------------------------------------+\n \nSELECT JSON_KEYS(''{"A": 1, "B": 2, "C": {"D":\n3}}'', ''$.C'');\n+-----------------------------------------------------+\n| JSON_KEYS(''{"A": 1, "B": 2, "C": {"D": 3}}'',\n''$.C'') |\n+-----------------------------------------------------+\n| ["D"] |\n+-----------------------------------------------------+
[JSON_LENGTH]
declaration=json_doc[, path]
category=JSON Functions
description=Returns the length of a JSON document, or, if the optional\npath argument is given, the length of the value within the\ndocument specified by the path. \n \nReturns NULL if any of the arguments argument are null or\nthe path argument does not identify a value in the document.\n\n \nAn error will occur if the JSON document is invalid, the\npath is invalid or if the path contains a * or ** wildcard.\n \nLength will be determined as follow:\nA scalar''s length is always 1.\nIf an array, the number of elements in the array.\nIf an object, the number of members in the object.\n \nThe length of nested arrays or objects are not counted.
[JSON_LOOSE]
declaration=json_doc
category=JSON Functions
description=Adds spaces to a JSON document to make it look more\nreadable.\n \nExample\n \nSET @j = ''{ "A":1,"B":[2,3]}'';\n \nSELECT JSON_LOOSE(@j), @j;\n+-----------------------+--------------------+\n| JSON_LOOSE(@j) | @j |\n+-----------------------+--------------------+\n| {"A": 1, "B": [2, 3]} | { "A":1,"B":[2,3]} |\n+-----------------------+--------------------+
[JSON_MERGE]
declaration=json_doc, json_doc[, json_doc] ...
category=JSON Functions
description=Merges the given JSON documents.\n \nReturns the merged result,or NULL if any argument is NULL.\n \nAn error occurs if any of the arguments are not valid JSON\ndocuments.\n \nExample\n \nSET @json1 = ''[1, 2]'';\n \nSET @json2 = ''[3, 4]'';\n \nSELECT JSON_MERGE(@json1,@json2);\n+---------------------------+\n| JSON_MERGE(@json1,@json2) |\n+---------------------------+\n| [1, 2, 3, 4] |\n+---------------------------+
[JSON_OBJECT]
declaration=[key, value[, key, value] ...]
category=JSON Functions
description=Returns a JSON object containing the given key/value pairs.\nThe key/value list can be empty.\n \nAn error will occur if there are an odd number of arguments,\nor any key name is NULL.\n \nExample\n \nSELECT JSON_OBJECT("id", 1, "name", "Monty");\n+---------------------------------------+\n| JSON_OBJECT("id", 1, "name", "Monty") |\n+---------------------------------------+\n| {"id": 1, "name": "Monty"} |\n+---------------------------------------+
[JSON_QUERY]
declaration=json_doc, path
category=JSON Functions
description=Given a JSON document, returns an object or array specified\nby the path. Returns NULL if not given a valid JSON\ndocument, or if there is no match.\n \n\nselect json_query(''{"key1":{"a":1, "b":[1,2]}}'',\n''$.key1'');\n+-----------------------------------------------------+\n| json_query(''{"key1":{"a":1, "b":[1,2]}}'',\n''$.key1'') |\n+-----------------------------------------------------+\n| {"a":1, "b":[1,2]} |\n+-----------------------------------------------------+\n \nselect json_query(''{"key1":123, "key1": [1,2,3]}'',\n''$.key1'');\n+-------------------------------------------------------+\n| json_query(''{"key1":123, "key1": [1,2,3]}'',\n''$.key1'') |\n+-------------------------------------------------------+\n| [1,2,3] |\n+-------------------------------------------------------+
[JSON_QUOTE]
declaration=json_value
category=JSON Functions
description=Quotes a string as a JSON value, usually for producing valid\nJSON string literals for inclusion in JSON documents. Wraps\nthe string with double quote characters and escapes interior\nquotes and other special characters, returning a utf8mb4\nstring. \n \nReturns NULL if the argument is NULL.\n \n\nSELECT JSON_QUOTE(''A''), JSON_QUOTE("B"),\nJSON_QUOTE(''"C"'');\n+-----------------+-----------------+-------------------+\n| JSON_QUOTE(''A'') | JSON_QUOTE("B") |\nJSON_QUOTE(''"C"'') |\n+-----------------+-----------------+-------------------+\n| "A" | "B" | "\"C\"" |\n+-----------------+-----------------+-------------------+
[JSON_REMOVE]
declaration=json_doc, path[, path] ...
category=JSON Functions
description=Removes data from a JSON document returning the result, or\nNULL if any of the arguments are null. If the element does\nnot exist in the document, no changes are made.\n \nAn error will occur if JSON document is invalid, the path is\ninvalid or if the path contains a * or ** wildcard.\n \nPath arguments are evaluated from left to right, with the\nresult from the earlier evaluation being used as the value\nfor the next.\n \n\nSELECT JSON_REMOVE(''{"A": 1, "B": 2, "C": {"D":\n3}}'', ''$.C'');\n+-------------------------------------------------------+\n| JSON_REMOVE(''{"A": 1, "B": 2, "C": {"D": 3}}'',\n''$.C'') |\n+-------------------------------------------------------+\n| {"A": 1, "B": 2} |\n+-------------------------------------------------------+\n \nSELECT JSON_REMOVE(''["A", "B", ["C", "D"],\n"E"]'', ''$[1]'');\n+----------------------------------------------------+\n| JSON_REMOVE(''["A", "B", ["C", "D"], "E"]'',\n''$[1]'') |\n+----------------------------------------------------+\n| ["A", ["C", "D"], "E"] |\n+----------------------------------------------------+
[JSON_REPLACE]
declaration=json_doc, path, val[, path, val] ...
category=JSON Functions
description=Replaces existing values in a JSON document, returning the\nresult, or NULL if any of the arguments are NULL. \n \nAn error will occur if the JSON document is invalid, the\npath is invalid or if the path contains a * or ** wildcard.\n \nPaths and values are evaluated from left to right, with the\nresult from the earlier evaluation being used as the value\nfor the next.\n \nJSON_REPLACE can only update data, while JSON_INSERT can\nonly insert. JSON_SET can update or insert data. \n \n\nSELECT JSON_REPLACE(''{ "A": 1, "B": [2, 3]}'',\n''$.B[1]'', 4);\n+-----------------------------------------------------+\n| JSON_REPLACE(''{ "A": 1, "B": [2, 3]}'', ''$.B[1]'',\n4) |\n+-----------------------------------------------------+\n| { "A": 1, "B": [2, 4]} |\n+-----------------------------------------------------+
[JSON_SEARCH]
declaration=json_doc, return_arg, search_str[, escape_char[, path] ...]
category=JSON Functions
description=Returns the path to the given string within a JSON document,\nor NULL if any of json_doc, search_str or a path argument is\nNULL; if the search string is not found, or if no path\nexists within the document. \n \nA warning will occur if the JSON document is not valid, any\nof the path arguments are not valid, if return_arg is\nneither one nor all, or if the escape character is not a\nconstant. NULL will be returned.\n \nreturn_arg can be one of two values:\n''one: Terminates after finding the first match, so will\nreturn one path string. If there is more than one match, it\nis undefined which is considered first.\nall: Returns all matching path strings, without duplicates.\nMultiple strings are autowrapped as an array. The order is\nundefined.\n \n\nSET @json = ''["A", [{"B": "1"}], {"C":"AB"},\n{"D":"BC"}]'';\n \nSELECT JSON_SEARCH(@json, ''one'', ''AB'');\n+---------------------------------+\n| JSON_SEARCH(@json, ''one'', ''AB'') |\n+---------------------------------+\n| "$[2].C" |\n+---------------------------------+
[JSON_SET]
declaration=json_doc, path, val[, path, val] ...
category=JSON Functions
description=Updates or inserts data into a JSON document, returning the\nresult, or NULL if any of the arguments are NULL or the\noptional path fails to find an object.\n \nAn error will occur if the JSON document is invalid, the\npath is invalid or if the path contains a * or  wildcard.\n \nJSON_SET can update or insert data, while JSON_REPLACE can\nonly update, and JSON_INSERT only insert.
[JSON_TYPE]
declaration=json_val
category=JSON Functions
description=Returns the type of a JSON value, or NULL if the argument is\nnull.\n \nAn error will occur if the argument is an invalid JSON\nvalue.\n \nThe following is a complete list of the possible return\ntypes:\n \nReturn type | Value | \n \nARRAY | JSON array | \n \nBIT | MariaDB BIT scalar | \n \nBLOB | MariaDB binary types (BINARY, VARBINARY or BLOB) | \n \nBOOLEAN | JSON true/false literals | \n \nDATE | MariaDB DATE scalar | \n \nDATETIME | MariaDB DATETIME or TIMESTAMP scalar | \n \nDECIMAL | MariaDB DECIMAL or NUMERIC scalar | \n \nDOUBLE | MariaDB DOUBLE FLOAT scalar | \n \nINTEGER | MariaDB integer types (TINYINT, SMALLINT,\nMEDIUMINT, INT or BIGINT) | \n \nNULL | JSON null literal or NULL argument | \n \nOBJECT | JSON object | \n \nOPAQUE | Any valid JSON value that is not one of the other\ntypes. | \n \nSTRING | MariaDB character types (CHAR, VARCHAR, TEXT, ENUM\nor SET) | \n \nTIME | MariaDB TIME scalar | \n \n\nSELECT JSON_TYPE(''{"A": 1, "B": 2, "C": 3}'');\n+---------------------------------------+\n| JSON_TYPE(''{"A": 1, "B": 2, "C": 3}'') |\n+---------------------------------------+\n| OBJECT |\n+---------------------------------------+
[JSON_UNQUOTE]
declaration=val
category=JSON Functions
description=Unquotes a JSON value, returning a string, or NULL if the\nargument is null. \n \nAn error will occur if the given value begins and ends with\ndouble quotes and is an invalid JSON string literal.\n \nCertain character sequences have special meanings within a\nstring. Usually, a backspace is ignored, but the escape\nsequences in the table below are recognised by MariaDB,\nunless the SQL Mode is set to NO_BACKSLASH_ESCAPES SQL.\n \nEscape sequence | Character | \n \n\" | Double quote (") | \n \n\b | Backspace | \n \n\f | Formfeed | \n \n\n | Newline (linefeed) | \n \n\r | Carriage return | \n \n\t | Tab | \n \n\\ | Backslash (\) | \n \n\uXXXX | UTF-8 bytes for Unicode value XXXX | \n \n\nSELECT JSON_UNQUOTE(''"Monty"'');\n+-------------------------+\n| JSON_UNQUOTE(''"Monty"'') |\n+-------------------------+\n| Monty |\n+-------------------------+\n \nWith the default SQL Mode:\n \nSELECT JSON_UNQUOTE(''Si\bng\ting'');\n+-----------------------------+\n| JSON_UNQUOTE(''Si\bng\ting'') |\n+-----------------------------+\n| Sng ing |\n+-----------------------------+\n \nSetting NO_BACKSLASH_ESCAPES:\n \nSET @@sql_mode = ''NO_BACKSLASH_ESCAPES'';\n \nSELECT JSON_UNQUOTE(''Si\bng\ting'');\n+-----------------------------+\n| JSON_UNQUOTE(''Si\bng\ting'') |\n+-----------------------------+\n| Si\bng\ting |\n+-----------------------------+
[JSON_VALID]
declaration=value
category=JSON Functions
description=Indicates whether the given value is a valid JSON document\nor not. Returns 1 if valid, 0 if not, and NULL if the\nargument is NULL.\n \nFrom MariaDB 10.4.3, the JSON_VALID function is\nautomatically used as a CHECK constraint for the JSON data\ntype alias in order to ensure that a valid json document is\ninserted. \n \n\nSELECT JSON_VALID(''{"id": 1, "name": "Monty"}'');\n+------------------------------------------+\n| JSON_VALID(''{"id": 1, "name": "Monty"}'') |\n+------------------------------------------+\n| 1 |\n+------------------------------------------+\n \nSELECT JSON_VALID(''{"id": 1, "name": "Monty",\n"oddfield"}'');\n+------------------------------------------------------+\n| JSON_VALID(''{"id": 1, "name": "Monty",\n"oddfield"}'') |\n+------------------------------------------------------+\n| 0 |\n+------------------------------------------------------+
[JSON_VALUE]
declaration=json_doc, path
category=JSON Functions
description=Given a JSON document, returns the scalar specified by the\npath. Returns NULL if not given a valid JSON document, or if\nthere is no match.\n \n\nselect json_value(''{"key1":123}'', ''$.key1'');\n+--------------------------------------+\n| json_value(''{"key1":123}'', ''$.key1'') |\n+--------------------------------------+\n| 123 |\n+--------------------------------------+\n \nselect json_value(''{"key1": [1,2,3], "key1":123}'',\n''$.key1'');\n+-------------------------------------------------------+\n| json_value(''{"key1": [1,2,3], "key1":123}'',\n''$.key1'') |\n+-------------------------------------------------------+\n| 123 |\n+-------------------------------------------------------+
[LAST_DAY]
declaration=date
category=Date and Time Functions
description=Takes a date or datetime value and returns the corresponding\nvalue for\nthe last day of the month. Returns NULL if the argument is\ninvalid.\n \n\nSELECT LAST_DAY(''2003-02-05'');\n+------------------------+\n| LAST_DAY(''2003-02-05'') |\n+------------------------+\n| 2003-02-28 |\n+------------------------+\n \nSELECT LAST_DAY(''2004-02-05'');\n+------------------------+\n| LAST_DAY(''2004-02-05'') |\n+------------------------+\n| 2004-02-29 |\n+------------------------+\n \nSELECT LAST_DAY(''2004-01-01 01:01:01'');\n+---------------------------------+\n| LAST_DAY(''2004-01-01 01:01:01'') |\n+---------------------------------+\n| 2004-01-31 |\n+---------------------------------+\n \nSELECT LAST_DAY(''2003-03-32'');\n+------------------------+\n| LAST_DAY(''2003-03-32'') |\n+------------------------+\n| NULL |\n+------------------------+\n1 row in set, 1 warning (0.00 sec)\n \nWarning (Code 1292): Incorrect datetime value:\n''2003-03-32''
[LAST_INSERT_ID1]
name=LAST_INSERT_ID
declaration=
category=Information Functions
description=LAST_INSERT_ID() (no arguments) returns\nthe first automatically generated value successfully\ninserted for an\nAUTO_INCREMENT column as a result of the most recently\nexecuted INSERT\nstatement. The value of LAST_INSERT_ID() remains unchanged\nif no rows\nare successfully inserted.\n \nIf one gives an argument to LAST_INSERT_ID(), then it will\nreturn the value of the expression and\nthe next call to LAST_INSERT_ID() will return the same\nvalue. The value will also be sent to the client\nand can be accessed by the mysql_insert_id function.\n \nFor example, after inserting a row that generates an\nAUTO_INCREMENT\nvalue, you can get the value like this:\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 9 |\n+------------------+\n \nYou can also use LAST_INSERT_ID() to delete the last\ninserted row:\n \nDELETE FROM product WHERE id = LAST_INSERT_ID();\n \nIf no rows were successfully inserted, LAST_INSERT_ID()\nreturns 0.\n \nThe value of LAST_INSERT_ID() will be consistent across all\nversions\nif all rows in the INSERT or UPDATE statement were\nsuccessful.\n \nThe currently executing statement does not affect the value\nof\nLAST_INSERT_ID(). Suppose that you generate an\nAUTO_INCREMENT value\nwith one statement, and then refer to LAST_INSERT_ID() in a\nmultiple-row INSERT statement that inserts rows into a table\nwith its\nown AUTO_INCREMENT column. The value of LAST_INSERT_ID()\nwill remain\nstable in the second statement; its value for the second and\nlater\nrows is not affected by the earlier row insertions.\n(However, if you\nmix references to LAST_INSERT_ID() and LAST_INSERT_ID(expr),\nthe\neffect is undefined.)\n \nIf the previous statement returned an error, the value of\nLAST_INSERT_ID() is undefined. For transactional tables, if\nthe\nstatement is rolled back due to an error, the value of\nLAST_INSERT_ID() is left undefined. For manual ROLLBACK, the\nvalue of\nLAST_INSERT_ID() is not restored to that before the\ntransaction; it\nremains as it was at the point of the ROLLBACK.\n \nWithin the body of a stored routine (procedure or function)\nor a\ntrigger, the value of LAST_INSERT_ID() changes the same way\nas for\nstatements executed outside the body of these kinds of\nobjects. The\neffect of a stored routine or trigger upon the value of\nLAST_INSERT_ID() that is seen by following statements\ndepends on the\nkind of routine:\nIf a stored procedure executes statements that change the\nvalue of LAST_INSERT_ID(), the new value will be seen by\nstatements that follow the procedure call.\n \nFor stored functions and triggers that change the value, the\nvalue is restored when the function or trigger ends, so\nfollowing statements will not see a changed value.\n \n\nCREATE TABLE t (\n id INTEGER UNSIGNED AUTO_INCREMENT PRIMARY KEY, \n f VARCHAR(1)) \nENGINE = InnoDB;\n \nINSERT INTO t(f) VALUES(''a'');\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 1 |\n+------------------+\n \nINSERT INTO t(f) VALUES(''b'');\n \nINSERT INTO t(f) VALUES(''c'');\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 3 |\n+------------------+\n \nINSERT INTO t(f) VALUES(''d''),(''e'');\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 4 |\n+------------------+\n \nSELECT * FROM t;\n \n+----+------+\n| id | f |\n+----+------+\n| 1 | a |\n| 2 | b |\n| 3 | c |\n| 4 | d |\n| 5 | e |\n+----+------+\n \nSELECT LAST_INSERT_ID(12);\n+--------------------+\n| LAST_INSERT_ID(12) |\n+--------------------+\n| 12 |\n+--------------------+\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 12 |\n+------------------+\n \nINSERT INTO t(f) VALUES(''f'');\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 6 |\n+------------------+\n \nSELECT * FROM t;\n \n+----+------+\n| id | f |\n+----+------+\n| 1 | a |\n| 2 | b |\n| 3 | c |\n| 4 | d |\n| 5 | e |\n| 6 | f |\n+----+------+\n \nSELECT LAST_INSERT_ID(12);\n+--------------------+\n| LAST_INSERT_ID(12) |\n+--------------------+\n| 12 |\n+--------------------+\n \nINSERT INTO t(f) VALUES(''g'');\n \nSELECT * FROM t;\n \n+----+------+\n| id | f |\n+----+------+\n| 1 | a |\n| 2 | b |\n| 3 | c |\n| 4 | d |\n| 5 | e |\n| 6 | f |\n| 7 | g |\n+----+------+
[LAST_INSERT_ID2]
name=LAST_INSERT_ID
declaration=expr
category=Information Functions
description=LAST_INSERT_ID() (no arguments) returns\nthe first automatically generated value successfully\ninserted for an\nAUTO_INCREMENT column as a result of the most recently\nexecuted INSERT\nstatement. The value of LAST_INSERT_ID() remains unchanged\nif no rows\nare successfully inserted.\n \nIf one gives an argument to LAST_INSERT_ID(), then it will\nreturn the value of the expression and\nthe next call to LAST_INSERT_ID() will return the same\nvalue. The value will also be sent to the client\nand can be accessed by the mysql_insert_id function.\n \nFor example, after inserting a row that generates an\nAUTO_INCREMENT\nvalue, you can get the value like this:\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 9 |\n+------------------+\n \nYou can also use LAST_INSERT_ID() to delete the last\ninserted row:\n \nDELETE FROM product WHERE id = LAST_INSERT_ID();\n \nIf no rows were successfully inserted, LAST_INSERT_ID()\nreturns 0.\n \nThe value of LAST_INSERT_ID() will be consistent across all\nversions\nif all rows in the INSERT or UPDATE statement were\nsuccessful.\n \nThe currently executing statement does not affect the value\nof\nLAST_INSERT_ID(). Suppose that you generate an\nAUTO_INCREMENT value\nwith one statement, and then refer to LAST_INSERT_ID() in a\nmultiple-row INSERT statement that inserts rows into a table\nwith its\nown AUTO_INCREMENT column. The value of LAST_INSERT_ID()\nwill remain\nstable in the second statement; its value for the second and\nlater\nrows is not affected by the earlier row insertions.\n(However, if you\nmix references to LAST_INSERT_ID() and LAST_INSERT_ID(expr),\nthe\neffect is undefined.)\n \nIf the previous statement returned an error, the value of\nLAST_INSERT_ID() is undefined. For transactional tables, if\nthe\nstatement is rolled back due to an error, the value of\nLAST_INSERT_ID() is left undefined. For manual ROLLBACK, the\nvalue of\nLAST_INSERT_ID() is not restored to that before the\ntransaction; it\nremains as it was at the point of the ROLLBACK.\n \nWithin the body of a stored routine (procedure or function)\nor a\ntrigger, the value of LAST_INSERT_ID() changes the same way\nas for\nstatements executed outside the body of these kinds of\nobjects. The\neffect of a stored routine or trigger upon the value of\nLAST_INSERT_ID() that is seen by following statements\ndepends on the\nkind of routine:\nIf a stored procedure executes statements that change the\nvalue of LAST_INSERT_ID(), the new value will be seen by\nstatements that follow the procedure call.\n \nFor stored functions and triggers that change the value, the\nvalue is restored when the function or trigger ends, so\nfollowing statements will not see a changed value.\n \n\nCREATE TABLE t (\n id INTEGER UNSIGNED AUTO_INCREMENT PRIMARY KEY, \n f VARCHAR(1)) \nENGINE = InnoDB;\n \nINSERT INTO t(f) VALUES(''a'');\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 1 |\n+------------------+\n \nINSERT INTO t(f) VALUES(''b'');\n \nINSERT INTO t(f) VALUES(''c'');\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 3 |\n+------------------+\n \nINSERT INTO t(f) VALUES(''d''),(''e'');\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 4 |\n+------------------+\n \nSELECT * FROM t;\n \n+----+------+\n| id | f |\n+----+------+\n| 1 | a |\n| 2 | b |\n| 3 | c |\n| 4 | d |\n| 5 | e |\n+----+------+\n \nSELECT LAST_INSERT_ID(12);\n+--------------------+\n| LAST_INSERT_ID(12) |\n+--------------------+\n| 12 |\n+--------------------+\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 12 |\n+------------------+\n \nINSERT INTO t(f) VALUES(''f'');\n \nSELECT LAST_INSERT_ID();\n+------------------+\n| LAST_INSERT_ID() |\n+------------------+\n| 6 |\n+------------------+\n \nSELECT * FROM t;\n \n+----+------+\n| id | f |\n+----+------+\n| 1 | a |\n| 2 | b |\n| 3 | c |\n| 4 | d |\n| 5 | e |\n| 6 | f |\n+----+------+\n \nSELECT LAST_INSERT_ID(12);\n+--------------------+\n| LAST_INSERT_ID(12) |\n+--------------------+\n| 12 |\n+--------------------+\n \nINSERT INTO t(f) VALUES(''g'');\n \nSELECT * FROM t;\n \n+----+------+\n| id | f |\n+----+------+\n| 1 | a |\n| 2 | b |\n| 3 | c |\n| 4 | d |\n| 5 | e |\n| 6 | f |\n| 7 | g |\n+----+------+
[LAST_VALUE1]
name=LAST_VALUE
declaration=expr,[expr,...]
category=Information Functions
description=LAST_VALUE() evaluates all expressions and returns the last.\n \nThis is useful together with setting user variables to a\nvalue with @var:=expr, for example when you want to get data\nof rows updated/deleted without having to do two queries\nagainst the table.\n \nSince MariaDB 10.2.2, LAST_VALUE can be used as a window\nfunction.\n \nReturns NULL if no last value exists.\n \n\nCREATE TABLE t1 (a int, b int);\nINSERT INTO t1 VALUES(1,10),(2,20);\nDELETE FROM t1 WHERE a=1 AND last_value(@a:=a,@b:=b,1);\nSELECT @a,@b;\n \n+------+------+\n| @a | @b |\n+------+------+\n| 1 | 10 |\n+------+------+\n \nAs a window function:\n \nCREATE TABLE t1 (\n pk int primary key,\n a int,\n b int,\n c char(10),\n d decimal(10, 3),\n e real\n);\n \nINSERT INTO t1 VALUES\n( 1, 0, 1, ''one'', 0.1, 0.001),\n( 2, 0, 2, ''two'', 0.2, 0.002),\n( 3, 0, 3, ''three'', 0.3, 0.003),\n( 4, 1, 2, ''three'', 0.4, 0.004),\n( 5, 1, 1, ''two'', 0.5, 0.005),\n( 6, 1, 1, ''one'', 0.6, 0.006),\n( 7, 2, NULL, ''n_one'', 0.5, 0.007),\n( 8, 2, 1, ''n_two'', NULL, 0.008),\n( 9, 2, 2, NULL, 0.7, 0.009),\n(10, 2, 0, ''n_four'', 0.8, 0.010),\n(11, 2, 10, NULL, 0.9, NULL);\n \nSELECT pk, FIRST_VALUE(pk) OVER (ORDER BY pk) AS first_asc,\n LAST_VALUE(pk) OVER (ORDER BY pk) AS last_asc,\n FIRST_VALUE(pk) OVER (ORDER BY pk DESC) AS first_desc,\n LAST_VALUE(pk) OVER (ORDER BY pk DESC) AS last_desc\nFROM t1\nORDER BY pk DESC;\n \n+----+-----------+----------+------------+-----------+\n| pk | first_asc | last_asc | first_desc | last_desc |\n+----+-----------+----------+------------+-----------+\n| 11 | 1 | 11 | 11 | 11 |\n| 10 | 1 | 10 | 11 | 10 |\n| 9 | 1 | 9 | 11 | 9 |\n| 8 | 1 | 8 | 11 | 8 |\n| 7 | 1 | 7 | 11 | 7 |\n| 6 | 1 | 6 | 11 | 6 |\n| 5 | 1 | 5 | 11 | 5 |\n| 4 | 1 | 4 | 11 | 4 |\n| 3 | 1 | 3 | 11 | 3 |\n| 2 | 1 | 2 | 11 | 2 |\n| 1 | 1 | 1 | 11 | 1 |\n+----+-----------+----------+------------+-----------+\n \nCREATE OR REPLACE TABLE t1 (i int);\nINSERT INTO t1 VALUES\n(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);\n \nSELECT i,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW\nand 1 FOLLOWING) AS f_1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW and\n1 FOLLOWING) AS l_1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING\nAND 1 FOLLOWING) AS f_1p1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND\n1 FOLLOWING) AS f_1p1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING\nAND 1 PRECEDING) AS f_2p1p,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING AND\n1 PRECEDING) AS f_2p1p,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING\nAND 2 FOLLOWING) AS f_1f2f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING AND\n2 FOLLOWING) AS f_1f2f\nFROM t1;\n \n+------+------+------+--------+--------+--------+--------+--------+--------+\n| i | f_1f | l_1f | f_1p1f | f_1p1f | f_2p1p | f_2p1p |\nf_1f2f | f_1f2f |\n+------+------+------+--------+--------+--------+--------+--------+--------+\n| 1 | 1 | 2 | 1 | 2 | NULL | NULL | 2 | 3 |\n| 2 | 2 | 3 | 1 | 3 | 1 | 1 | 3 | 4 |\n| 3 | 3 | 4 | 2 | 4 | 1 | 2 | 4 | 5 |\n| 4 | 4 | 5 | 3 | 5 | 2 | 3 | 5 | 6 |\n| 5 | 5 | 6 | 4 | 6 | 3 | 4 | 6 | 7 |\n| 6 | 6 | 7 | 5 | 7 | 4 | 5 | 7 | 8 |\n| 7 | 7 | 8 | 6 | 8 | 5 | 6 | 8 | 9 |\n| 8 | 8 | 9 | 7 | 9 | 6 | 7 | 9 | 10 |\n| 9 | 9 | 10 | 8 | 10 | 7 | 8 | 10 | 10 |\n| 10 | 10 | 10 | 9 | 10 | 8 | 9 | NULL | NULL |\n+------+------+------+--------+--------+--------+--------+--------+--------+
[LAST_VALUE2]
name=LAST_VALUE
declaration=expr
category=Information Functions
description=LAST_VALUE() evaluates all expressions and returns the last.\n \nThis is useful together with setting user variables to a\nvalue with @var:=expr, for example when you want to get data\nof rows updated/deleted without having to do two queries\nagainst the table.\n \nSince MariaDB 10.2.2, LAST_VALUE can be used as a window\nfunction.\n \nReturns NULL if no last value exists.\n \n\nCREATE TABLE t1 (a int, b int);\nINSERT INTO t1 VALUES(1,10),(2,20);\nDELETE FROM t1 WHERE a=1 AND last_value(@a:=a,@b:=b,1);\nSELECT @a,@b;\n \n+------+------+\n| @a | @b |\n+------+------+\n| 1 | 10 |\n+------+------+\n \nAs a window function:\n \nCREATE TABLE t1 (\n pk int primary key,\n a int,\n b int,\n c char(10),\n d decimal(10, 3),\n e real\n);\n \nINSERT INTO t1 VALUES\n( 1, 0, 1, ''one'', 0.1, 0.001),\n( 2, 0, 2, ''two'', 0.2, 0.002),\n( 3, 0, 3, ''three'', 0.3, 0.003),\n( 4, 1, 2, ''three'', 0.4, 0.004),\n( 5, 1, 1, ''two'', 0.5, 0.005),\n( 6, 1, 1, ''one'', 0.6, 0.006),\n( 7, 2, NULL, ''n_one'', 0.5, 0.007),\n( 8, 2, 1, ''n_two'', NULL, 0.008),\n( 9, 2, 2, NULL, 0.7, 0.009),\n(10, 2, 0, ''n_four'', 0.8, 0.010),\n(11, 2, 10, NULL, 0.9, NULL);\n \nSELECT pk, FIRST_VALUE(pk) OVER (ORDER BY pk) AS first_asc,\n LAST_VALUE(pk) OVER (ORDER BY pk) AS last_asc,\n FIRST_VALUE(pk) OVER (ORDER BY pk DESC) AS first_desc,\n LAST_VALUE(pk) OVER (ORDER BY pk DESC) AS last_desc\nFROM t1\nORDER BY pk DESC;\n \n+----+-----------+----------+------------+-----------+\n| pk | first_asc | last_asc | first_desc | last_desc |\n+----+-----------+----------+------------+-----------+\n| 11 | 1 | 11 | 11 | 11 |\n| 10 | 1 | 10 | 11 | 10 |\n| 9 | 1 | 9 | 11 | 9 |\n| 8 | 1 | 8 | 11 | 8 |\n| 7 | 1 | 7 | 11 | 7 |\n| 6 | 1 | 6 | 11 | 6 |\n| 5 | 1 | 5 | 11 | 5 |\n| 4 | 1 | 4 | 11 | 4 |\n| 3 | 1 | 3 | 11 | 3 |\n| 2 | 1 | 2 | 11 | 2 |\n| 1 | 1 | 1 | 11 | 1 |\n+----+-----------+----------+------------+-----------+\n \nCREATE OR REPLACE TABLE t1 (i int);\nINSERT INTO t1 VALUES\n(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);\n \nSELECT i,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW\nand 1 FOLLOWING) AS f_1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW and\n1 FOLLOWING) AS l_1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING\nAND 1 FOLLOWING) AS f_1p1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND\n1 FOLLOWING) AS f_1p1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING\nAND 1 PRECEDING) AS f_2p1p,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING AND\n1 PRECEDING) AS f_2p1p,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING\nAND 2 FOLLOWING) AS f_1f2f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING AND\n2 FOLLOWING) AS f_1f2f\nFROM t1;\n \n+------+------+------+--------+--------+--------+--------+--------+--------+\n| i | f_1f | l_1f | f_1p1f | f_1p1f | f_2p1p | f_2p1p |\nf_1f2f | f_1f2f |\n+------+------+------+--------+--------+--------+--------+--------+--------+\n| 1 | 1 | 2 | 1 | 2 | NULL | NULL | 2 | 3 |\n| 2 | 2 | 3 | 1 | 3 | 1 | 1 | 3 | 4 |\n| 3 | 3 | 4 | 2 | 4 | 1 | 2 | 4 | 5 |\n| 4 | 4 | 5 | 3 | 5 | 2 | 3 | 5 | 6 |\n| 5 | 5 | 6 | 4 | 6 | 3 | 4 | 6 | 7 |\n| 6 | 6 | 7 | 5 | 7 | 4 | 5 | 7 | 8 |\n| 7 | 7 | 8 | 6 | 8 | 5 | 6 | 8 | 9 |\n| 8 | 8 | 9 | 7 | 9 | 6 | 7 | 9 | 10 |\n| 9 | 9 | 10 | 8 | 10 | 7 | 8 | 10 | 10 |\n| 10 | 10 | 10 | 9 | 10 | 8 | 9 | NULL | NULL |\n+------+------+------+--------+--------+--------+--------+--------+--------+
[LAST_VALUE3]
name=LAST_VALUE
declaration=[ PARTITION BY partition_expression ]  [ ORDER BY order_list ]
category=Information Functions
description=LAST_VALUE() evaluates all expressions and returns the last.\n \nThis is useful together with setting user variables to a\nvalue with @var:=expr, for example when you want to get data\nof rows updated/deleted without having to do two queries\nagainst the table.\n \nSince MariaDB 10.2.2, LAST_VALUE can be used as a window\nfunction.\n \nReturns NULL if no last value exists.\n \n\nCREATE TABLE t1 (a int, b int);\nINSERT INTO t1 VALUES(1,10),(2,20);\nDELETE FROM t1 WHERE a=1 AND last_value(@a:=a,@b:=b,1);\nSELECT @a,@b;\n \n+------+------+\n| @a | @b |\n+------+------+\n| 1 | 10 |\n+------+------+\n \nAs a window function:\n \nCREATE TABLE t1 (\n pk int primary key,\n a int,\n b int,\n c char(10),\n d decimal(10, 3),\n e real\n);\n \nINSERT INTO t1 VALUES\n( 1, 0, 1, ''one'', 0.1, 0.001),\n( 2, 0, 2, ''two'', 0.2, 0.002),\n( 3, 0, 3, ''three'', 0.3, 0.003),\n( 4, 1, 2, ''three'', 0.4, 0.004),\n( 5, 1, 1, ''two'', 0.5, 0.005),\n( 6, 1, 1, ''one'', 0.6, 0.006),\n( 7, 2, NULL, ''n_one'', 0.5, 0.007),\n( 8, 2, 1, ''n_two'', NULL, 0.008),\n( 9, 2, 2, NULL, 0.7, 0.009),\n(10, 2, 0, ''n_four'', 0.8, 0.010),\n(11, 2, 10, NULL, 0.9, NULL);\n \nSELECT pk, FIRST_VALUE(pk) OVER (ORDER BY pk) AS first_asc,\n LAST_VALUE(pk) OVER (ORDER BY pk) AS last_asc,\n FIRST_VALUE(pk) OVER (ORDER BY pk DESC) AS first_desc,\n LAST_VALUE(pk) OVER (ORDER BY pk DESC) AS last_desc\nFROM t1\nORDER BY pk DESC;\n \n+----+-----------+----------+------------+-----------+\n| pk | first_asc | last_asc | first_desc | last_desc |\n+----+-----------+----------+------------+-----------+\n| 11 | 1 | 11 | 11 | 11 |\n| 10 | 1 | 10 | 11 | 10 |\n| 9 | 1 | 9 | 11 | 9 |\n| 8 | 1 | 8 | 11 | 8 |\n| 7 | 1 | 7 | 11 | 7 |\n| 6 | 1 | 6 | 11 | 6 |\n| 5 | 1 | 5 | 11 | 5 |\n| 4 | 1 | 4 | 11 | 4 |\n| 3 | 1 | 3 | 11 | 3 |\n| 2 | 1 | 2 | 11 | 2 |\n| 1 | 1 | 1 | 11 | 1 |\n+----+-----------+----------+------------+-----------+\n \nCREATE OR REPLACE TABLE t1 (i int);\nINSERT INTO t1 VALUES\n(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);\n \nSELECT i,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW\nand 1 FOLLOWING) AS f_1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW and\n1 FOLLOWING) AS l_1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING\nAND 1 FOLLOWING) AS f_1p1f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 PRECEDING AND\n1 FOLLOWING) AS f_1p1f,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING\nAND 1 PRECEDING) AS f_2p1p,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 2 PRECEDING AND\n1 PRECEDING) AS f_2p1p,\n FIRST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING\nAND 2 FOLLOWING) AS f_1f2f,\n LAST_VALUE(i) OVER (ORDER BY i ROWS BETWEEN 1 FOLLOWING AND\n2 FOLLOWING) AS f_1f2f\nFROM t1;\n \n+------+------+------+--------+--------+--------+--------+--------+--------+\n| i | f_1f | l_1f | f_1p1f | f_1p1f | f_2p1p | f_2p1p |\nf_1f2f | f_1f2f |\n+------+------+------+--------+--------+--------+--------+--------+--------+\n| 1 | 1 | 2 | 1 | 2 | NULL | NULL | 2 | 3 |\n| 2 | 2 | 3 | 1 | 3 | 1 | 1 | 3 | 4 |\n| 3 | 3 | 4 | 2 | 4 | 1 | 2 | 4 | 5 |\n| 4 | 4 | 5 | 3 | 5 | 2 | 3 | 5 | 6 |\n| 5 | 5 | 6 | 4 | 6 | 3 | 4 | 6 | 7 |\n| 6 | 6 | 7 | 5 | 7 | 4 | 5 | 7 | 8 |\n| 7 | 7 | 8 | 6 | 8 | 5 | 6 | 8 | 9 |\n| 8 | 8 | 9 | 7 | 9 | 6 | 7 | 9 | 10 |\n| 9 | 9 | 10 | 8 | 10 | 7 | 8 | 10 | 10 |\n| 10 | 10 | 10 | 9 | 10 | 8 | 9 | NULL | NULL |\n+------+------+------+--------+--------+--------+--------+--------+--------+
[LCASE]
declaration=str
category=String Functions
description=LCASE() is a synonym for LOWER().
[LEAST]
declaration=value1,value2,...
category=Comparison Operators
description=With two or more arguments, returns the smallest\n(minimum-valued)\nargument. The arguments are compared using the following\nrules:\nIf the return value is used in an INTEGER context or all\narguments are integer-valued, they are compared as integers.\nIf the return value is used in a REAL context or all\narguments are real-valued, they are compared as reals.\nIf any argument is a case-sensitive string, the arguments\nare compared as case-sensitive strings.\nIn all other cases, the arguments are compared as\ncase-insensitive strings.\n \nLEAST() returns NULL if any argument is NULL.\n \n\nSELECT LEAST(2,0);\n+------------+\n| LEAST(2,0) |\n+------------+\n| 0 |\n+------------+\n \nSELECT LEAST(34.0,3.0,5.0,767.0);\n+---------------------------+\n| LEAST(34.0,3.0,5.0,767.0) |\n+---------------------------+\n| 3.0 |\n+---------------------------+\n \nSELECT LEAST(''B'',''A'',''C'');\n+--------------------+\n| LEAST(''B'',''A'',''C'') |\n+--------------------+\n| A |\n+--------------------+
[LEFT]
declaration=str,len
category=String Functions
description=Returns the leftmost len characters from the string str, or\nNULL if\nany argument is NULL.\n \n\nSELECT LEFT(''MariaDB'', 5);\n+--------------------+\n| LEFT(''MariaDB'', 5) |\n+--------------------+\n| Maria |\n+--------------------+
[LENGTHB]
declaration=str
category=String Functions
description=LENGTHB() is a synonym for LENGTH().
[LENGTH]
declaration=str
category=String Functions
description=Returns the length of the string str, measured in bytes. A\nmulti-byte\ncharacter counts as multiple bytes. This means that for a\nstring\ncontaining five two-byte characters, LENGTH() returns 10,\nwhereas\nCHAR_LENGTH() returns 5. \n \nIf str is not a string value, it is converted into a string.\nIf str is NULL, the function returns NULL.\n \nUntil MariaDB 10.3.1, returns MYSQL_TYPE_LONGLONG, or\nbigint(10), in all cases. From MariaDB 10.3.1, returns\nMYSQL_TYPE_LONG, or int(10), when the result would fit\nwithin 32-bits.\n \nOracle Mode\n \nWhen running Oracle mode from MariaDB 10.3, LENGTH() is a\nsynonym for CHAR_LENGTH().\n \n\nSELECT LENGTH(''MariaDB'');\n+-------------------+\n| LENGTH(''MariaDB'') |\n+-------------------+\n| 7 |\n+-------------------+\n \nSELECT LENGTH(''?'');\n+--------------+\n| LENGTH(''?'') |\n+--------------+\n| 2 |\n+--------------+\n \nIn Oracle mode from MariaDB 10.3:\n \nSELECT LENGTH(''?'');\n+--------------+\n| LENGTH(''?'') |\n+--------------+\n| 1 |\n+--------------+
[LINESTRING]
declaration=pt1,pt2,...
category=Geometry Constructors
description=Constructs a WKB LineString value from a number of WKB Point\narguments. If any argument is not a WKB Point, the return\nvalue is\nNULL. If the number of Point arguments is less than two, the\nreturn value is NULL.\n \n\nSET @ls = ''LineString(1 1,2 2,3 3)'';\n \nSELECT AsText(EndPoint(GeomFromText(@ls)));\n+-------------------------------------+\n| AsText(EndPoint(GeomFromText(@ls))) |\n+-------------------------------------+\n| POINT(3 3) |\n+-------------------------------------+\n \nCREATE TABLE gis_line (g LINESTRING);\nINSERT INTO gis_line VALUES\n (LineFromText(''LINESTRING(0 0,0 10,10 0)'')),\n (LineStringFromText(''LINESTRING(10 10,20 10,20 20,10 20,10\n10)'')),\n (LineStringFromWKB(AsWKB(LineString(Point(10, 10),\nPoint(40, 10)))));
[LN]
declaration=X
category=Numeric Functions
description=Returns the natural logarithm of X; that is, the base-e\nlogarithm of X.\nIf X is less than or equal to 0, or NULL, then NULL is\nreturned.\n \nThe inverse of this function is EXP().\n \n\nSELECT LN(2);\n+-------------------+\n| LN(2) |\n+-------------------+\n| 0.693147180559945 |\n+-------------------+\n \nSELECT LN(-2);\n+--------+\n| LN(-2) |\n+--------+\n| NULL |\n+--------+
[LOAD_FILE]
declaration=file_name
category=String Functions
description=Reads the file and returns the file contents as a string. To\nuse this function, the file must be located on the server\nhost, you must specify the full path name to the file, and\nyou must have the FILE privilege. The file must be readable\nby all and it must be less than the size, in bytes, of the\nmax_allowed_packet system variable. If the secure_file_priv\nsystem variable is set to a non-empty directory name, the\nfile to be loaded must be located in that directory.\n \nIf the file does not exist or cannot be read because one of\nthe preceding conditions is not satisfied, the function\nreturns NULL.\n \nSince MariaDB 5.1, the character_set_filesystem system\nvariable has controlled interpretation of file names that\nare given as literal strings.\n \nStatements using the LOAD_FILE() function are not safe for\nstatement based replication. This is because the slave will\nexecute the LOAD_FILE() command itself. If the file doesn''t\nexist on the slave, the function will return NULL.\n \n\nUPDATE t SET blob_col=LOAD_FILE(''/tmp/picture'') WHERE\nid=1;
[LOCATE1]
name=LOCATE
declaration=substr,str
category=String Functions
description=The first syntax returns the position of the first\noccurrence of\nsubstring substr in string str. The second syntax returns\nthe position\nof the first occurrence of substring substr in string str,\nstarting at\nposition pos. Returns 0 if substr is not in str.\n \nLOCATE() performs a case-insensitive search.\n \nIf any argument is NULL, returns NULL.\n \nINSTR() is a synonym of LOCATE() without the third argument.\n \n\nSELECT LOCATE(''bar'', ''foobarbar'');\n+----------------------------+\n| LOCATE(''bar'', ''foobarbar'') |\n+----------------------------+\n| 4 |\n+----------------------------+\n \nSELECT LOCATE(''My'', ''Maria'');\n+-----------------------+\n| LOCATE(''My'', ''Maria'') |\n+-----------------------+\n| 0 |\n+-----------------------+\n \nSELECT LOCATE(''bar'', ''foobarbar'', 5);\n+-------------------------------+\n| LOCATE(''bar'', ''foobarbar'', 5) |\n+-------------------------------+\n| 7 |\n+-------------------------------+
[LOCATE2]
name=LOCATE
declaration=substr,str,pos
category=String Functions
description=The first syntax returns the position of the first\noccurrence of\nsubstring substr in string str. The second syntax returns\nthe position\nof the first occurrence of substring substr in string str,\nstarting at\nposition pos. Returns 0 if substr is not in str.\n \nLOCATE() performs a case-insensitive search.\n \nIf any argument is NULL, returns NULL.\n \nINSTR() is a synonym of LOCATE() without the third argument.\n \n\nSELECT LOCATE(''bar'', ''foobarbar'');\n+----------------------------+\n| LOCATE(''bar'', ''foobarbar'') |\n+----------------------------+\n| 4 |\n+----------------------------+\n \nSELECT LOCATE(''My'', ''Maria'');\n+-----------------------+\n| LOCATE(''My'', ''Maria'') |\n+-----------------------+\n| 0 |\n+-----------------------+\n \nSELECT LOCATE(''bar'', ''foobarbar'', 5);\n+-------------------------------+\n| LOCATE(''bar'', ''foobarbar'', 5) |\n+-------------------------------+\n| 7 |\n+-------------------------------+
[LOG10]
declaration=X
category=Numeric Functions
description=Returns the base-10 logarithm of X.\n \n\nSELECT LOG10(2);\n+-------------------+\n| LOG10(2) |\n+-------------------+\n| 0.301029995663981 |\n+-------------------+\n \nSELECT LOG10(100);\n+------------+\n| LOG10(100) |\n+------------+\n| 2 |\n+------------+\n \nSELECT LOG10(-100);\n+-------------+\n| LOG10(-100) |\n+-------------+\n| NULL |\n+-------------+
[LOG1]
name=LOG
declaration=X
category=Numeric Functions
description=If called with one parameter, this function returns the\nnatural\nlogarithm of X. If X is less than or equal to 0, then NULL\nis\nreturned.\n \nIf called with two parameters, it returns the logarithm of X\nto the base B. If B is
[LOG2]
declaration=X
category=Numeric Functions
description=Returns the base-2 logarithm of X.\n \n\nSELECT LOG2(4398046511104);\n+---------------------+\n| LOG2(4398046511104) |\n+---------------------+\n| 42 |\n+---------------------+\n \nSELECT LOG2(65536);\n+-------------+\n| LOG2(65536) |\n+-------------+\n| 16 |\n+-------------+\n \nSELECT LOG2(-100);\n+------------+\n| LOG2(-100) |\n+------------+\n| NULL |\n+------------+
[LOG2]
name=LOG
declaration=B,X
category=Numeric Functions
description=If called with one parameter, this function returns the\nnatural\nlogarithm of X. If X is less than or equal to 0, then NULL\nis\nreturned.\n \nIf called with two parameters, it returns the logarithm of X\nto the base B. If B is
[LOWER]
declaration=str
category=String Functions
description=Returns the string str with all characters changed to\nlowercase\naccording to the current character set mapping. The default\nis latin1\n(cp1252 West European).\n \n\n SELECT LOWER(''QUADRATICALLY'');\n+------------------------+\n| LOWER(''QUADRATICALLY'') |\n+------------------------+\n| quadratically |\n+------------------------+\n \nLOWER() (and UPPER()) are ineffective when applied to binary\nstrings (BINARY, VARBINARY, BLOB). \nTo perform lettercase conversion, CONVERT the string to a\nnon-binary string:\n \nSET @str = BINARY ''North Carolina'';\n \nSELECT LOWER(@str), LOWER(CONVERT(@str USING latin1));\n+----------------+-----------------------------------+\n| LOWER(@str) | LOWER(CONVERT(@str USING latin1)) |\n+----------------+-----------------------------------+\n| North Carolina | north carolina |\n+----------------+-----------------------------------+
[LPAD]
declaration=str, len [,padstr]
category=String Functions
description=Returns the string str, left-padded with the string padstr\nto a length\nof len characters. If str is longer than len, the return\nvalue is\nshortened to len characters. If padstr is omitted, the LPAD\nfunction pads spaces.\n \nPrior to MariaDB 10.3.1, the padstr parameter was mandatory.\n \nReturns NULL if given a NULL argument. If the result is\nempty (zero length), returns either an empty string or, from\nMariaDB 10.3.6 with SQL_MODE=Oracle, NULL.\n \nThe Oracle mode version of the function can be accessed\noutside of Oracle mode by using LPAD_ORACLE as the function\nname.\n \n\nSELECT LPAD(''hello'',10,''.'');\n+----------------------+\n| LPAD(''hello'',10,''.'') |\n+----------------------+\n| .....hello |\n+----------------------+\n \nSELECT LPAD(''hello'',2,''.'');\n+---------------------+\n| LPAD(''hello'',2,''.'') |\n+---------------------+\n| he |\n+---------------------+\n \nFrom MariaDB 10.3.1, with the pad string defaulting to\nspace.\n \nSELECT LPAD(''hello'',10);\n+------------------+\n| LPAD(''hello'',10) |\n+------------------+\n| hello |\n+------------------+\n \nOracle mode version from MariaDB 10.3.6:\n \nSELECT LPAD('''',0),LPAD_ORACLE('''',0);\n+------------+-------------------+\n| LPAD('''',0) | LPAD_ORACLE('''',0) |\n+------------+-------------------+\n| | NULL |\n+------------+-------------------+
[LTRIM]
declaration=str
category=String Functions
description=Returns the string str with leading space characters\nremoved.\n \nReturns NULL if given a NULL argument. If the result is\nempty, returns either an empty string, or, from MariaDB\n10.3.6 with SQL_MODE=Oracle, NULL.\n \nThe Oracle mode version of the function can be accessed\noutside of Oracle mode by using LTRIM_ORACLE as the function\nname.\n \n\nSELECT QUOTE(LTRIM('' MariaDB ''));\n+-------------------------------+\n| QUOTE(LTRIM('' MariaDB '')) |\n+-------------------------------+\n| ''MariaDB '' |\n+-------------------------------+\n \nOracle mode version from MariaDB 10.3.6:\n \nSELECT LTRIM(''''),LTRIM_ORACLE('''');\n+-----------+------------------+\n| LTRIM('''') | LTRIM_ORACLE('''') |\n+-----------+------------------+\n| | NULL |\n+-----------+------------------+
[MAKEDATE]
declaration=year,dayofyear
category=Date and Time Functions
description=Returns a date, given year and day-of-year values. dayofyear\nmust be\ngreater than 0 or the result is NULL.\n \n\nSELECT MAKEDATE(2011,31), MAKEDATE(2011,32);\n+-------------------+-------------------+\n| MAKEDATE(2011,31) | MAKEDATE(2011,32) |\n+-------------------+-------------------+\n| 2011-01-31 | 2011-02-01 |\n+-------------------+-------------------+\n \nSELECT MAKEDATE(2011,365), MAKEDATE(2014,365);\n+--------------------+--------------------+\n| MAKEDATE(2011,365) | MAKEDATE(2014,365) |\n+--------------------+--------------------+\n| 2011-12-31 | 2014-12-31 |\n+--------------------+--------------------+\n \nSELECT MAKEDATE(2011,0);\n+------------------+\n| MAKEDATE(2011,0) |\n+------------------+\n| NULL |\n+------------------+
[MAKETIME]
declaration=hour,minute,second
category=Date and Time Functions
description=Returns a time value calculated from the hour, minute, and\nsecond arguments.\n \nIf minute or second are out of the range 0 to 60, NULL is\nreturned. The hour can be in the range -838 to 838, outside\nof which the value is truncated with a warning.\n \n\nSELECT MAKETIME(13,57,33);\n+--------------------+\n| MAKETIME(13,57,33) |\n+--------------------+\n| 13:57:33 |\n+--------------------+\n \nSELECT MAKETIME(-13,57,33);\n+---------------------+\n| MAKETIME(-13,57,33) |\n+---------------------+\n| -13:57:33 |\n+---------------------+\n \nSELECT MAKETIME(13,67,33);\n+--------------------+\n| MAKETIME(13,67,33) |\n+--------------------+\n| NULL |\n+--------------------+\n \nSELECT MAKETIME(-1000,57,33);\n+-----------------------+\n| MAKETIME(-1000,57,33) |\n+-----------------------+\n| -838:59:59 |\n+-----------------------+\n1 row in set, 1 warning (0.00 sec)\n \nSHOW WARNINGS;\n \n+---------+------+-----------------------------------------------+\n| Level | Code | Message |\n+---------+------+-----------------------------------------------+\n| Warning | 1292 | Truncated incorrect time value:\n''-1000:57:33'' |\n+---------+------+-----------------------------------------------+
[MAKE_SET]
declaration=bits,str1,str2,...
category=String Functions
description=Returns a set value (a string containing substrings\nseparated by ","\ncharacters) consisting of the strings that have the\ncorresponding bit\nin bits set. str1 corresponds to bit 0, str2 to bit 1, and\nso on. NULL\nvalues in str1, str2, ... are not appended to the result.\n \n\nSELECT MAKE_SET(1,''a'',''b'',''c'');\n+-------------------------+\n| MAKE_SET(1,''a'',''b'',''c'') |\n+-------------------------+\n| a |\n+-------------------------+\n \nSELECT MAKE_SET(1 | 4,''hello'',''nice'',''world'');\n+----------------------------------------+\n| MAKE_SET(1 | 4,''hello'',''nice'',''world'') |\n+----------------------------------------+\n| hello,world |\n+----------------------------------------+\n \nSELECT MAKE_SET(1 | 4,''hello'',''nice'',NULL,''world'');\n+---------------------------------------------+\n| MAKE_SET(1 | 4,''hello'',''nice'',NULL,''world'') |\n+---------------------------------------------+\n| hello |\n+---------------------------------------------+\n \nSELECT QUOTE(MAKE_SET(0,''a'',''b'',''c''));\n+--------------------------------+\n| QUOTE(MAKE_SET(0,''a'',''b'',''c'')) |\n+--------------------------------+\n| '''' |\n+--------------------------------+
[MASTER_GTID_WAIT]
declaration=gtid-list[, timeout
category=Miscellaneous Functions
description=This function takes a string containing a comma-separated\nlist of global transaction id''s\n(similar to the value of, for example, gtid_binlog_pos). It\nwaits until the value of gtid_slave_pos has the same or\nhigher seq_no within all replication domains specified in\nthe gtid-list; in other words, it waits until the slave has\nreached the specified GTID position.\n \nAn optional second argument gives a timeout in seconds. If\nthe timeout\nexpires before the specified GTID position is reached, then\nthe function\nreturns -1. Passing NULL or a negative number for the\ntimeout means no timeout, and the function will wait\nindefinitely.\n \n If the wait completes without a timeout, 0 is returned.\nPassing NULL for the\n gtid-list makes the function return NULL immediately,\nwithout waiting.\n \nThe gtid-list may be the empty string, in which case\nMASTER_GTID_WAIT()\nreturns immediately. If the gtid-list contains fewer domains\nthan\ngtid_slave_pos, then only those domains are waited upon. If\ngtid-list\ncontains a domain that is not present in @@gtid_slave_pos,\nthen\nMASTER_GTID_WAIT() will wait until an event containing such\ndomain_id arrives\non the slave (or until timed out or killed).\n \nMASTER_GTID_WAIT() can be useful to ensure that a slave has\ncaught up to\na master. Simply take the value of gtid_binlog_pos on the\nmaster, and use it in a MASTER_GTID_WAIT() call on the\nslave; when the call completes, the slave\nwill have caught up with that master position.\n \nMASTER_GTID_WAIT() can also be used in client applications\ntogether with the\nlast_gtid session variable. This is useful in a\nread-scaleout replication setup, where the application\nwrites to a single master but divides the\nreads out to a number of slaves to distribute the load. In\nsuch a setup, there\nis a risk that an application could first do an update on\nthe master, and then\na bit later do a read on a slave, and if the slave is not\nfast enough, the\ndata read from the slave might not include the update just\nmade, possibly\nconfusing the application and/or the end-user. One way to\navoid this is to\nrequest the value of last_gtid on the master just after the\nupdate. Then\nbefore doing the read on the slave, do a MASTER_GTID_WAIT()\non the value\nobtained from the master; this will ensure that the read is\nnot performed\nuntil the slave has replicated sufficiently far for the\nupdate to have become\nvisible.\n \nNote that MASTER_GTID_WAIT() can be used even if the slave\nis configured not\nto use GTID for connections (CHANGE MASTER TO\nmaster_use_gtid=no). This is\nbecause from MariaDB 10, GTIDs are always logged on the\nmaster server, and\nalways recorded on the slave servers.\n \nDifferences to MASTER_POS_WAIT()\n \nMASTER_GTID_WAIT() is global; it waits for any master\nconnection to reach\n the specified GTID position. MASTER_POS_WAIT() works only\nagainst a\n specific connection. This also means that while\nMASTER_POS_WAIT() aborts if\n its master connection is terminated with STOP SLAVE or due\nto an error,\n MASTER_GTID_WAIT() continues to wait while slaves are\nstopped.\n \nMASTER_GTID_WAIT() can take its timeout as a floating-point\nvalue, so a\n timeout in fractional seconds is supported, eg.\nMASTER_GTID_WAIT("0-1-100",\n 0.5). (The minimum wait is one microsecond, 0.000001\nseconds).\n \nMASTER_GTID_WAIT() allows one to specify a timeout of zero\nin order to do a\n non-blocking check to see if the slaves have progressed to\na specific GTID position\n (MASTER_POS_WAIT() takes a zero timeout as meaning an\ninfinite wait). To do\n an infinite MASTER_GTID_WAIT(), specify a negative timeout,\nor omit the\n timeout argument.\n \nMASTER_GTID_WAIT() does not return the number of events\nexecuted since the\n wait started, nor does it return NULL if a slave thread is\nstopped. It\n always returns either 0 for successful wait completed, or\n-1 for timeout\n reached (or NULL if the specified gtid-pos is NULL).\n \nSince MASTER_GTID_WAIT() looks only at the seq_no part of\nthe GTIDs, not the\nserver_id, care is needed if a slave becomes diverged from\nanother server so\nthat two different GTIDs with the same seq_no (in the same\ndomain) arrive at\nthe same server. This situation is in any case best avoided;\nsetting\ngtid_strict_mode is recommended, as this will prevent any\nsuch out-of-order sequence numbers from ever being\nreplicated on a slave.
[MASTER_POS_WAIT]
declaration=log_name,log_pos[,timeout,["connection_name"]]
category=Miscellaneous Functions
description=This function is useful in replication for controlling\nmaster/slave synchronization. It blocks until the slave has\nread and applied all updates up to the specified position\n(log_name,log_pos) in the master log. The return value is\nthe number of log events the slave had to wait for to\nadvance to the specified position. The function returns NULL\nif\nthe slave SQL thread is not started, the slave''s master\ninformation is not\ninitialized, the arguments are incorrect, or an error\noccurs. It returns -1 if\nthe timeout has been exceeded. If the slave SQL thread stops\nwhile\n MASTER_POS_WAIT() is waiting, the function returns NULL. If\nthe slave is past the specified position, the function\nreturns immediately.\n \nIf a timeout value is specified, MASTER_POS_WAIT() stops\nwaiting when timeout seconds have elapsed. timeout must be\ngreater than 0; a\nzero or negative timeout means no timeout.\n \nThe connection_name is used when you are using\nmulti-source-replication. If you don''t specify it, it''s\nset to the value of the default_master_connection system\nvariable.\n \nStatements using the MASTER_POS_WAIT() function are not safe\nfor replication.
[MAX]
declaration=[DISTINCT] expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the largest, or maximum, value of expr. MAX() can\nalso take a string\nargument in which case it returns the maximum string value.\nThe DISTINCT\nkeyword can be used to find the maximum of the distinct\nvalues of expr,\nhowever, this produces the same result as omitting DISTINCT.\n \nNote that SET and ENUM fields are currently compared by\ntheir string value rather than their relative position in\nthe set, so MAX() may produce a different highest result\nthan ORDER BY DESC.\n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, MAX() can be used as a window function.\n \nMAX() returns NULL if there were no matching rows.\n \n\nCREATE TABLE student (name CHAR(10), test CHAR(10), score\nTINYINT); \n \nINSERT INTO student VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87), (''Tatiana'', ''Tuning'', 83);\n \nSELECT name, MAX(score) FROM student GROUP BY name;\n \n+---------+------------+\n| name | MAX(score) |\n+---------+------------+\n| Chun | 75 |\n| Esben | 43 |\n| Kaolin | 88 |\n| Tatiana | 87 |\n+---------+------------+\n \nMAX string:\n \nSELECT MAX(name) FROM student;\n \n+-----------+\n| MAX(name) |\n+-----------+\n| Tatiana |\n+-----------+\n \nBe careful to avoid this common mistake, not grouping\ncorrectly and returning mismatched data: \n \nSELECT name,test,MAX(SCORE) FROM student;\n \n+------+------+------------+\n| name | test | MAX(SCORE) |\n+------+------+------------+\n| Chun | SQL | 88 |\n+------+------+------------+\n \nDifference between ORDER BY DESC and MAX():\n \nCREATE TABLE student2(name CHAR(10),grade\nENUM(''b'',''c'',''a''));\n \nINSERT INTO student2\nVALUES(''Chun'',''b''),(''Esben'',''c''),(''Kaolin'',''a'');\n \nSELECT MAX(grade) FROM student2;\n \n+------------+\n| MAX(grade) |\n+------------+\n| c |\n+------------+\n \nSELECT grade FROM student2 ORDER BY grade DESC LIMIT 1;\n \n+-------+\n| grade |\n+-------+\n| a |\n+-------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, MAX(score) \n OVER (PARTITION BY name) AS highest_score FROM\nstudent_test;\n \n+---------+--------+-------+---------------+\n| name | test | score | highest_score |\n+---------+--------+-------+---------------+\n| Chun | SQL | 75 | 75 |\n| Chun | Tuning | 73 | 75 |\n| Esben | SQL | 43 | 43 |\n| Esben | Tuning | 31 | 43 |\n| Kaolin | SQL | 56 | 88 |\n| Kaolin | Tuning | 88 | 88 |\n| Tatiana | SQL | 87 | 87 |\n+---------+--------+-------+---------------+
[MBRCONTAINS]
declaration=g1,g2
category=MBR
description=Returns 1 or 0 to indicate whether the Minimum Bounding\nRectangle of\ng1 contains the Minimum Bounding Rectangle of g2. This tests\nthe\nopposite relationship as MBRWithin().\n \n\nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\n \nSET @g2 = GeomFromText(''Point(1 1)'');\n \nSELECT MBRContains(@g1,@g2), MBRContains(@g2,@g1);\n+----------------------+----------------------+\n| MBRContains(@g1,@g2) | MBRContains(@g2,@g1) |\n+----------------------+----------------------+\n| 1 | 0 |\n+----------------------+----------------------+
[MBRDISJOINT]
declaration=g1,g2
category=MBR
description=Returns 1 or 0 to indicate whether the Minimum Bounding\nRectangles of the two geometries g1 and g2 are disjoint. Two\ngeometries are disjoint if they do not intersect, that is\ntouch or overlap.\n \n\nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((4 4,4 7,7 7,7 4,4 4))'');\nSELECTmbrdisjoint(@g1,@g2);\n+----------------------+\n| mbrdisjoint(@g1,@g2) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((3 3,3 6,6 6,6 3,3 3))'');\nSELECT mbrdisjoint(@g1,@g2);\n+----------------------+\n| mbrdisjoint(@g1,@g2) |\n+----------------------+\n| 0 |\n+----------------------+
[MBREQUAL]
declaration=g1,g2
category=MBR
description=Returns 1 or 0 to indicate whether the Minimum Bounding\nRectangles of\nthe two geometries g1 and g2 are the same.\n \n\nSET @g1=GEOMFROMTEXT(''LINESTRING(0 0, 1 2)'');\nSET @g2=GEOMFROMTEXT(''POLYGON((0 0, 0 2, 1 2, 1 0, 0\n0))'');\nSELECT MbrEqual(@g1,@g2);\n+-------------------+\n| MbrEqual(@g1,@g2) |\n+-------------------+\n| 1 |\n+-------------------+\n \nSET @g1=GEOMFROMTEXT(''LINESTRING(0 0, 1 3)'');\nSET @g2=GEOMFROMTEXT(''POLYGON((0 0, 0 2, 1 4, 1 0, 0\n0))'');\nSELECT MbrEqual(@g1,@g2);\n+-------------------+\n| MbrEqual(@g1,@g2) |\n+-------------------+\n| 0 |\n+-------------------+
[MBRINTERSECTS]
declaration=g1,g2
category=MBR
description=Returns 1 or 0 to indicate whether the Minimum Bounding\nRectangles of the two geometries g1 and g2 intersect.\n \n\nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((3 3,3 6,6 6,6 3,3 3))'');\nSELECT mbrintersects(@g1,@g2);\n+------------------------+\n| mbrintersects(@g1,@g2) |\n+------------------------+\n| 1 |\n+------------------------+\n \nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((4 4,4 7,7 7,7 4,4 4))'');\nSELECT mbrintersects(@g1,@g2);\n+------------------------+\n| mbrintersects(@g1,@g2) |\n+------------------------+\n| 0 |\n+------------------------+
[MBROVERLAPS]
declaration=g1,g2
category=MBR
description=Returns 1 or 0 to indicate whether the Minimum Bounding\nRectangles of\nthe two geometries g1 and g2 overlap. The term spatially\noverlaps is\nused if two geometries intersect and their intersection\nresults in a\ngeometry of the same dimension but not equal to either of\nthe given\ngeometries.\n \n\nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((4 4,4 7,7 7,7 4,4 4))'');\nSELECT mbroverlaps(@g1,@g2);\n+----------------------+\n| mbroverlaps(@g1,@g2) |\n+----------------------+\n| 0 |\n+----------------------+\n \nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((3 3,3 6,6 6,6 3,3 3))'');\nSELECT mbroverlaps(@g1,@g2);\n+----------------------+\n| mbroverlaps(@g1,@g2) |\n+----------------------+\n| 0 |\n+----------------------+\n \nSET @g1 = GeomFromText(''Polygon((0 0,0 4,4 4,4 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((3 3,3 6,6 6,6 3,3 3))'');\nSELECT mbroverlaps(@g1,@g2);\n+----------------------+\n| mbroverlaps(@g1,@g2) |\n+----------------------+\n| 1 |\n+----------------------+
[MBRTOUCHES]
declaration=g1,g2
category=MBR
description=Returns 1 or 0 to indicate whether the Minimum Bounding\nRectangles of\nthe two geometries g1 and g2 touch. Two geometries spatially\ntouch if\nthe interiors of the geometries do not intersect, but the\nboundary of\none of the geometries intersects either the boundary or the\ninterior\nof the other.\n \n\nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((4 4,4 7,7 7,7 4,4 4))'');\nSELECT mbrtouches(@g1,@g2);\n+---------------------+\n| mbrtouches(@g1,@g2) |\n+---------------------+\n| 0 |\n+---------------------+\n \nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((3 3,3 6,6 6,6 3,3 3))'');\nSELECT mbrtouches(@g1,@g2);\n+---------------------+\n| mbrtouches(@g1,@g2) |\n+---------------------+\n| 1 |\n+---------------------+\n \nSET @g1 = GeomFromText(''Polygon((0 0,0 4,4 4,4 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((3 3,3 6,6 6,6 3,3 3))'');\nSELECT mbrtouches(@g1,@g2);\n+---------------------+\n| mbrtouches(@g1,@g2) |\n+---------------------+\n| 0 |\n+---------------------+
[MBRWITHIN]
declaration=g1,g2
category=MBR
description=Returns 1 or 0 to indicate whether the Minimum Bounding\nRectangle of\ng1 is within the Minimum Bounding Rectangle of g2. This\ntests the\nopposite relationship as MBRContains().\n \n\nSET @g1 = GeomFromText(''Polygon((0 0,0 3,3 3,3 0,0 0))'');\nSET @g2 = GeomFromText(''Polygon((0 0,0 5,5 5,5 0,0 0))'');\nSELECT MBRWithin(@g1,@g2), MBRWithin(@g2,@g1);\n+--------------------+--------------------+\n| MBRWithin(@g1,@g2) | MBRWithin(@g2,@g1) |\n+--------------------+--------------------+\n| 1 | 0 |\n+--------------------+--------------------+
[MD5]
declaration=str
category=Encryption Functions
description=Calculates an MD5 128-bit checksum for the string. \n \nThe return value is a 32-hex digit string, and as of MariaDB\n5.5, is a nonbinary string in the connection character set\nand collation, determined by the values of the\ncharacter_set_connection and collation_connection system\nvariables. Before 5.5, the return value was a binary string.\n \nNULL is returned if the argument was NULL. \n \n\nSELECT MD5(''testing'');\n+----------------------------------+\n| MD5(''testing'') |\n+----------------------------------+\n| ae2b1fca515949e5d54fb22b8ed95575 |\n+----------------------------------+
[MEDIAN1]
name=MEDIAN
declaration=median expression
category=Window Functions
description=MEDIAN() is a window function that returns the median value\nof a range of values.\n \nIt is a specific case of PERCENTILE_CONT, with an argument\nof 0.5 and the ORDER BY column the one in MEDIAN''s\nargument. \n \nMEDIAN() OVER ( [ PARTITION BY partition_expression] )\n \nIs equivalent to:\n \nPERCENTILE_CONT(0.5) WITHIN \n GROUP (ORDER BY ) OVER ( [ PARTITION BY\npartition_expression ])\n \n\nCREATE TABLE book_rating (name CHAR(30), star_rating\nTINYINT);\n \nINSERT INTO book_rating VALUES (''Lord of the Ladybirds'',\n5);\nINSERT INTO book_rating VALUES (''Lord of the Ladybirds'',\n3);\nINSERT INTO book_rating VALUES (''Lady of the Flies'', 1);\nINSERT INTO book_rating VALUES (''Lady of the Flies'', 2);\nINSERT INTO book_rating VALUES (''Lady of the Flies'', 5);\n \nSELECT name, median(star_rating) OVER (PARTITION BY name)\nFROM book_rating;\n \n+-----------------------+----------------------------------------------+\n| name | median(star_rating) OVER (PARTITION BY name) |\n+-----------------------+----------------------------------------------+\n| Lord of the Ladybirds | 4.0000000000 |\n| Lord of the Ladybirds | 4.0000000000 |\n| Lady of the Flies | 2.0000000000 |\n| Lady of the Flies | 2.0000000000 |\n| Lady of the Flies | 2.0000000000 |\n+-----------------------+----------------------------------------------+
[MEDIAN2]
name=MEDIAN
declaration=[ PARTITION BY partition_expression ]
category=Window Functions
description=MEDIAN() is a window function that returns the median value\nof a range of values.\n \nIt is a specific case of PERCENTILE_CONT, with an argument\nof 0.5 and the ORDER BY column the one in MEDIAN''s\nargument. \n \nMEDIAN() OVER ( [ PARTITION BY partition_expression] )\n \nIs equivalent to:\n \nPERCENTILE_CONT(0.5) WITHIN \n GROUP (ORDER BY ) OVER ( [ PARTITION BY\npartition_expression ])\n \n\nCREATE TABLE book_rating (name CHAR(30), star_rating\nTINYINT);\n \nINSERT INTO book_rating VALUES (''Lord of the Ladybirds'',\n5);\nINSERT INTO book_rating VALUES (''Lord of the Ladybirds'',\n3);\nINSERT INTO book_rating VALUES (''Lady of the Flies'', 1);\nINSERT INTO book_rating VALUES (''Lady of the Flies'', 2);\nINSERT INTO book_rating VALUES (''Lady of the Flies'', 5);\n \nSELECT name, median(star_rating) OVER (PARTITION BY name)\nFROM book_rating;\n \n+-----------------------+----------------------------------------------+\n| name | median(star_rating) OVER (PARTITION BY name) |\n+-----------------------+----------------------------------------------+\n| Lord of the Ladybirds | 4.0000000000 |\n| Lord of the Ladybirds | 4.0000000000 |\n| Lady of the Flies | 2.0000000000 |\n| Lady of the Flies | 2.0000000000 |\n| Lady of the Flies | 2.0000000000 |\n+-----------------------+----------------------------------------------+
[MICROSECOND]
declaration=expr
category=Date and Time Functions
description=Returns the microseconds from the time or datetime\nexpression expr as a number in the range from 0 to 999999.\n \nIf expr is a time with no microseconds, zero is returned,\nwhile if expr is a date with no time, zero with a warning is\nreturned.\n \n\nSELECT MICROSECOND(''12:00:00.123456'');\n+--------------------------------+\n| MICROSECOND(''12:00:00.123456'') |\n+--------------------------------+\n| 123456 |\n+--------------------------------+\n \nSELECT MICROSECOND(''2009-12-31 23:59:59.000010'');\n+-------------------------------------------+\n| MICROSECOND(''2009-12-31 23:59:59.000010'') |\n+-------------------------------------------+\n| 10 |\n+-------------------------------------------+\n \nSELECT MICROSECOND(''2013-08-07 12:13:14'');\n+------------------------------------+\n| MICROSECOND(''2013-08-07 12:13:14'') |\n+------------------------------------+\n| 0 |\n+------------------------------------+\n \nSELECT MICROSECOND(''2013-08-07'');\n+---------------------------+\n| MICROSECOND(''2013-08-07'') |\n+---------------------------+\n| 0 |\n+---------------------------+\n1 row in set, 1 warning (0.00 sec)\n \nSHOW WARNINGS;\n \n+---------+------+----------------------------------------------+\n| Level | Code | Message |\n+---------+------+----------------------------------------------+\n| Warning | 1292 | Truncated incorrect time value:\n''2013-08-07'' |\n+---------+------+----------------------------------------------+
[MID]
declaration=str,pos,len
category=String Functions
description=MID(str,pos,len) is a synonym for SUBSTRING(str,pos,len).\n \n\nSELECT MID(''abcd'',4,1);\n+-----------------+\n| MID(''abcd'',4,1) |\n+-----------------+\n| d |\n+-----------------+\n \nSELECT MID(''abcd'',2,2);\n+-----------------+\n| MID(''abcd'',2,2) |\n+-----------------+\n| bc |\n+-----------------+\n \nA negative starting position:\n \nSELECT MID(''abcd'',-2,4);\n+------------------+\n| MID(''abcd'',-2,4) |\n+------------------+\n| cd |\n+------------------+
[MINUTE]
declaration=time
category=Date and Time Functions
description=Returns the minute for time, in the range 0 to 59. \n \n\nSELECT MINUTE(''2013-08-03 11:04:03'');\n+-------------------------------+\n| MINUTE(''2013-08-03 11:04:03'') |\n+-------------------------------+\n| 4 |\n+-------------------------------+\n \n SELECT MINUTE (''23:12:50'');\n+---------------------+\n| MINUTE (''23:12:50'') |\n+---------------------+\n| 12 |\n+---------------------+
[MIN]
declaration=[DISTINCT] expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the minimum value of expr. MIN() may take a string\nargument, in which case it returns the minimum string value.\nThe DISTINCT\nkeyword can be used to find the minimum of the distinct\nvalues of expr,\nhowever, this produces the same result as omitting DISTINCT.\n \nNote that SET and ENUM fields are currently compared by\ntheir string value rather than their relative position in\nthe set, so MIN() may produce a different lowest result than\nORDER BY ASC.\n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, MIN() can be used as a window function.\n \nMIN() returns NULL if there were no matching rows.\n \n\nCREATE TABLE student (name CHAR(10), test CHAR(10), score\nTINYINT); \n \nINSERT INTO student VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87), (''Tatiana'', ''Tuning'', 83);\n \nSELECT name, MIN(score) FROM student GROUP BY name;\n \n+---------+------------+\n| name | MIN(score) |\n+---------+------------+\n| Chun | 73 |\n| Esben | 31 |\n| Kaolin | 56 |\n| Tatiana | 83 |\n+---------+------------+\n \nMIN() with a string:\n \nSELECT MIN(name) FROM student;\n \n+-----------+\n| MIN(name) |\n+-----------+\n| Chun |\n+-----------+\n \nBe careful to avoid this common mistake, not grouping\ncorrectly and returning mismatched data: \n \nSELECT name,test,MIN(score) FROM student;\n \n+------+------+------------+\n| name | test | MIN(score) |\n+------+------+------------+\n| Chun | SQL | 31 |\n+------+------+------------+\n \nDifference between ORDER BY ASC and MIN():\n \nCREATE TABLE student2(name CHAR(10),grade\nENUM(''b'',''c'',''a''));\n \nINSERT INTO student2\nVALUES(''Chun'',''b''),(''Esben'',''c''),(''Kaolin'',''a'');\n \nSELECT MIN(grade) FROM student2;\n \n+------------+\n| MIN(grade) |\n+------------+\n| a |\n+------------+\n \nSELECT grade FROM student2 ORDER BY grade ASC LIMIT 1;\n \n+-------+\n| grade |\n+-------+\n| b |\n+-------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, MIN(score) \n OVER (PARTITION BY name) AS lowest_score FROM student_test;\n \n+---------+--------+-------+--------------+\n| name | test | score | lowest_score |\n+---------+--------+-------+--------------+\n| Chun | SQL | 75 | 73 |\n| Chun | Tuning | 73 | 73 |\n| Esben | SQL | 43 | 31 |\n| Esben | Tuning | 31 | 31 |\n| Kaolin | SQL | 56 | 56 |\n| Kaolin | Tuning | 88 | 56 |\n| Tatiana | SQL | 87 | 87 |\n+---------+--------+-------+--------------+
[MLINEFROMTEXT]
declaration=wkt[,srid]
category=WKT
description=Constructs a MULTILINESTRING value using its WKT\nrepresentation and SRID.\n \nMLineFromText() and MultiLineStringFromText() are synonyms.\n \n\nCREATE TABLE gis_multi_line (g MULTILINESTRING);\nSHOW FIELDS FROM gis_multi_line;\n \nINSERT INTO gis_multi_line VALUES\n (MultiLineStringFromText(''MULTILINESTRING((10 48,10 21,10\n0),(16 0,16 23,16 48))'')),\n (MLineFromText(''MULTILINESTRING((10 48,10 21,10 0))'')),\n (MLineFromWKB(AsWKB(MultiLineString(LineString(Point(1, 2),\nPoint(3, 5)), LineString(Point(2, 5), Point(5, 8), Point(21,\n7))))));
[MLINEFROMWKB]
declaration=wkb[,srid]
category=WKB
description=Constructs a MULTILINESTRING value using its WKB\nrepresentation and SRID.\n \nMLineFromWKB() and MultiLineStringFromWKB() are synonyms.\n \n\nSET @g = ST_AsBinary(MLineFromText(''MULTILINESTRING((10\n48,10 21,10 0),(16 0,16 23,16 48))''));\n \nSELECT ST_AsText(MLineFromWKB(@g));\n+--------------------------------------------------------+\n| ST_AsText(MLineFromWKB(@g)) |\n+--------------------------------------------------------+\n| MULTILINESTRING((10 48,10 21,10 0),(16 0,16 23,16 48)) |\n+--------------------------------------------------------+
[MOD]
declaration=N,M
category=Numeric Functions
description=Modulo operation. Returns the remainder of N divided by M.\nSee also Modulo Operator.\n \nIf the ERROR_ON_DIVISION_BY_ZERO SQL_MODE is used, any\nnumber modulus zero produces an error. Otherwise, it returns\nNULL.\n \nThe integer part of a division can be obtained using DIV.\n \n\nSELECT 1042 % 50;\n \n+-----------+\n| 1042 % 50 |\n+-----------+\n| 42 |\n+-----------+\n \nSELECT MOD(234, 10);\n+--------------+\n| MOD(234, 10) |\n+--------------+\n| 4 |\n+--------------+\n \nSELECT 253 % 7;\n \n+---------+\n| 253 % 7 |\n+---------+\n| 1 |\n+---------+\n \nSELECT MOD(29,9);\n+-----------+\n| MOD(29,9) |\n+-----------+\n| 2 |\n+-----------+\n \nSELECT 29 MOD 9;\n \n+----------+\n| 29 MOD 9 |\n+----------+\n| 2 |\n+----------+
[MONTHNAME]
declaration=date
category=Date and Time Functions
description=Returns the full name of the month for date. The language\nused for the name is controlled by the value of the\nlc_time_names system variable. See server locale for more on\nthe supported locales.\n \n\nSELECT MONTHNAME(''2019-02-03'');\n+-------------------------+\n| MONTHNAME(''2019-02-03'') |\n+-------------------------+\n| February |\n+-------------------------+\n \nChanging the locale:\n \nSET lc_time_names = ''fr_CA'';\n \nSELECT MONTHNAME(''2019-05-21'');\n+-------------------------+\n| MONTHNAME(''2019-05-21'') |\n+-------------------------+\n| mai |\n+-------------------------+
[MONTH]
declaration=date
category=Date and Time Functions
description=Returns the month for date in the range 1 to 12 for January\nto\nDecember, or 0 for dates such as ''0000-00-00'' or\n''2008-00-00'' that\nhave a zero month part.\n \n\nSELECT MONTH(''2019-01-03'');\n+---------------------+\n| MONTH(''2019-01-03'') |\n+---------------------+\n| 1 |\n+---------------------+\n \nSELECT MONTH(''2019-00-03'');\n+---------------------+\n| MONTH(''2019-00-03'') |\n+---------------------+\n| 0 |\n+---------------------+
[MPOINTFROMTEXT]
declaration=wkt[,srid]
category=WKT
description=Constructs a MULTIPOINT value using its WKT representation\nand SRID.\n \nMPointFromText() and MultiPointFromText() are synonyms.\n \n\nCREATE TABLE gis_multi_point (g MULTIPOINT);\nSHOW FIELDS FROM gis_multi_point;\n \nINSERT INTO gis_multi_point VALUES\n (MultiPointFromText(''MULTIPOINT(0 0,10 10,10 20,20\n20)'')),\n (MPointFromText(''MULTIPOINT(1 1,11 11,11 21,21 21)'')),\n (MPointFromWKB(AsWKB(MultiPoint(Point(3, 6), Point(4,\n10)))));
[MPOINTFROMWKB]
declaration=wkb[,srid]
category=WKB
description=Constructs a MULTIPOINT value using its WKB representation\nand SRID.\n \nMPointFromWKB() and MultiPointFromWKB() are synonyms.\n \n\nSET @g = ST_AsBinary(MPointFromText(''MultiPoint( 1 1, 2 2,\n5 3, 7 2, 9 3, 8 4, 6 6, 6 9, 4 9, 1 5 )''));\n \nSELECT ST_AsText(MPointFromWKB(@g));\n+-----------------------------------------------------+\n| ST_AsText(MPointFromWKB(@g)) |\n+-----------------------------------------------------+\n| MULTIPOINT(1 1,2 2,5 3,7 2,9 3,8 4,6 6,6 9,4 9,1 5) |\n+-----------------------------------------------------+
[MPOLYFROMTEXT]
declaration=wkt[,srid]
category=WKT
description=Constructs a MULTIPOLYGON value using its WKT representation\nand SRID.\n \nMPolyFromText() and MultiPolygonFromText() are synonyms.\n \n\nCREATE TABLE gis_multi_polygon (g MULTIPOLYGON);\nSHOW FIELDS FROM gis_multi_polygon;\n \nINSERT INTO gis_multi_polygon VALUES\n (MultiPolygonFromText(''MULTIPOLYGON(((28 26,28 0,84 0,84\n42,28 26),(52 18,66 23,73 9,48 6,52 18)),((59 18,67 18,67\n13,59 13,59 18)))'')),\n (MPolyFromText(''MULTIPOLYGON(((28 26,28 0,84 0,84 42,28\n26),(52 18,66 23,73 9,48 6,52 18)),((59 18,67 18,67 13,59\n13,59 18)))'')),\n (MPolyFromWKB(AsWKB(MultiPolygon(Polygon(LineString(Point(0,\n3), Point(3, 3), Point(3, 0), Point(0, 3)))))));
[MPOLYFROMWKB]
declaration=wkb[,srid]
category=WKB
description=Constructs a MULTIPOLYGON value using its WKB representation\nand SRID.\n \nMPolyFromWKB() and MultiPolygonFromWKB() are synonyms.\n \n\nSET @g = ST_AsBinary(MPointFromText(''MULTIPOLYGON(((28\n26,28 0,84 0,84 42,28 26),(52 18,66 23,73 9,48 6,52\n18)),((59 18,67 18,67 13,59 13,59 18)))''));\n \nSELECT ST_AsText(MPolyFromWKB(@g));\n+---------------------------------------------------------------------------------------------------------------+\n| ST_AsText(MPolyFromWKB(@g)) |\n+---------------------------------------------------------------------------------------------------------------+\n| MULTIPOLYGON(((28 26,28 0,84 0,84 42,28 26),(52 18,66\n23,73 9,48 6,52 18)),((59 18,67 18,67 13,59 13,59 18))) |\n+---------------------------------------------------------------------------------------------------------------+
[MULTILINESTRING]
declaration=ls1,ls2,...
category=Geometry Constructors
description=Constructs a WKB MultiLineString value using WKB LineString\narguments. If any argument is not a WKB LineString, the\nreturn value is\nNULL.\n \nExample\n \nCREATE TABLE gis_multi_line (g MULTILINESTRING);\nINSERT INTO gis_multi_line VALUES\n (MultiLineStringFromText(''MULTILINESTRING((10 48,10 21,10\n0),(16 0,16 23,16 48))'')),\n (MLineFromText(''MULTILINESTRING((10 48,10 21,10 0))'')),\n (MLineFromWKB(AsWKB(MultiLineString(LineString(Point(1, 2),\nPoint(3, 5)), LineString(Point(2, 5),Point(5, 8),Point(21,\n7))))));
[MULTIPOINT]
declaration=pt1,pt2,...
category=Geometry Constructors
description=Constructs a WKB MultiPoint value using WKB Point arguments.\nIf any argument is not a WKB Point, the return value is\nNULL.\n \n\nSET @g = ST_GEOMFROMTEXT(''MultiPoint( 1 1, 2 2, 5 3, 7 2, 9\n3, 8 4, 6 6, 6 9, 4 9, 1 5 )'');\n \nCREATE TABLE gis_multi_point (g MULTIPOINT);\nINSERT INTO gis_multi_point VALUES\n (MultiPointFromText(''MULTIPOINT(0 0,10 10,10 20,20\n20)'')),\n (MPointFromText(''MULTIPOINT(1 1,11 11,11 21,21 21)'')),\n (MPointFromWKB(AsWKB(MultiPoint(Point(3, 6), Point(4,\n10)))));
[MULTIPOLYGON]
declaration=poly1,poly2,...
category=Geometry Constructors
description=Constructs a WKB MultiPolygon value from a set of WKB\nPolygon arguments. If any argument is not a WKB Polygon, the\nreturn value is NULL.\n \nExample\n \nCREATE TABLE gis_multi_polygon (g MULTIPOLYGON);\nINSERT INTO gis_multi_polygon VALUES\n (MultiPolygonFromText(''MULTIPOLYGON(((28 26,28 0,84 0,84\n42,28 26),(52 18,66 23,73 9,48 6,52 18)),((59 18,67 18,67\n13,59 13,59 18)))'')),\n (MPolyFromText(''MULTIPOLYGON(((28 26,28 0,84 0,84 42,28\n26),(52 18,66 23,73 9,48 6,52 18)),((59 18,67 18,67 13,59\n13,59 18)))'')),\n (MPolyFromWKB(AsWKB(MultiPolygon(Polygon(LineString(Point(0,\n3), Point(3, 3), Point(3, 0), Point(0, 3)))))));
[NAME_CONST]
declaration=name,value
category=Miscellaneous Functions
description=Returns the given value. When used to produce a result set\ncolumn,\n NAME_CONST() causes the column to have the given name. The\narguments should be constants.\n \nThis function is used internally when replicating stored\nprocedures. It makes little sense to use it explicitly in\nSQL statements, and it was not supposed to be used like\nthat.\n \nSELECT NAME_CONST(''myname'', 14);\n+--------+\n| myname |\n+--------+\n| 14 |\n+--------+
[NOW]
declaration=[precision]
category=Date and Time Functions
description=Returns the current date and time as a value in ''YYYY-MM-DD\nHH:MM:SS''\nor YYYYMMDDHHMMSS.uuuuuu format, depending on whether the\nfunction is\nused in a string or numeric context. The value is expressed\nin the\ncurrent time zone.\n \nThe optional precision determines the microsecond precision.\nSee Microseconds in MariaDB.\n \nNOW() (or its synonyms) can be used as the default value for\nTIMESTAMP columns as well as, since MariaDB 10.0.1, DATETIME\ncolumns. Before MariaDB 10.0.1, it was only possible for a\nsingle TIMESTAMP column per table to contain the\nCURRENT_TIMESTAMP as its default.\n \nWhen displayed in the INFORMATION_SCHEMA.COLUMNS table, a\ndefault CURRENT TIMESTAMP is displayed as CURRENT_TIMESTAMP\nup until MariaDB 10.2.2, and as current_timestamp() from\nMariaDB 10.2.3, due to to MariaDB 10.2 accepting expressions\nin the DEFAULT clause.\n \n\nSELECT NOW();\n+---------------------+\n| NOW() |\n+---------------------+\n| 2010-03-27 13:13:25 |\n+---------------------+\n \nSELECT NOW() + 0;\n \n+-----------------------+\n| NOW() + 0 |\n+-----------------------+\n| 20100327131329.000000 |\n+-----------------------+\n \nWith precision:\n \nSELECT CURRENT_TIMESTAMP(2);\n+------------------------+\n| CURRENT_TIMESTAMP(2) |\n+------------------------+\n| 2018-07-10 09:47:26.24 |\n+------------------------+\n \nUsed as a default TIMESTAMP:\n \nCREATE TABLE t (createdTS TIMESTAMP NOT NULL DEFAULT\nCURRENT_TIMESTAMP);\n \nFrom MariaDB 10.2.2:\n \nSELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE\nTABLE_SCHEMA=''test''\n AND COLUMN_NAME LIKE ''%ts%''\G\n*************************** 1. row\n***************************\n TABLE_CATALOG: def\n TABLE_SCHEMA: test\n TABLE_NAME: t\n COLUMN_NAME: ts\n ORDINAL_POSITION: 1\n COLUMN_DEFAULT: current_timestamp()\n...
[NULLIF]
declaration=expr1,expr2
category=Control Flow Functions
description=Returns NULL if expr1 = expr2 is true, otherwise returns\nexpr1. This is\nthe same as CASE WHEN expr1 = expr2 THEN NULL ELSE expr1\nEND.\n \n\nSELECT NULLIF(1,1);\n+-------------+\n| NULLIF(1,1) |\n+-------------+\n| NULL |\n+-------------+\n \nSELECT NULLIF(1,2);\n+-------------+\n| NULLIF(1,2) |\n+-------------+\n| 1 |\n+-------------+
[OCTET_LENGTH]
declaration=str
category=String Functions
description=OCTET_LENGTH() is normally a synonym for LENGTH(). When\nrunning Oracle mode from MariaDB 10.3, they are not\nsynonyms, but OCTET_LENGTH() behaves as LENGTH() would when\nnot in Oracle mode.
[OCT]
declaration=N
category=Numeric Functions
description=Returns a string representation of the octal value of N,\nwhere N is a longlong (BIGINT) number. This is equivalent to\nCONV(N,10,8). Returns NULL if N is NULL.\n \n\nSELECT OCT(34);\n+---------+\n| OCT(34) |\n+---------+\n| 42 |\n+---------+\n \nSELECT OCT(12);\n+---------+\n| OCT(12) |\n+---------+\n| 14 |\n+---------+
[OLD_PASSWORD]
declaration=str
category=Encryption Functions
description=OLD_PASSWORD() was added to MySQL when the implementation of\n\nPASSWORD() was changed to improve security. OLD_PASSWORD()\nreturns the\nvalue of the old (pre-MySQL 4.1) implementation of\nPASSWORD() as a\nstring, and is intended to permit you to reset passwords for\nany\npre-4.1 clients that need to connect to a more recent MySQL\nserver version, or any version of MariaDB,\nwithout locking them out.\n \nAs of MariaDB 5.5, the return value is a nonbinary string in\nthe connection character set and collation, determined by\nthe values of the character_set_connection and\ncollation_connection system variables. Before 5.5, the\nreturn value was a binary string.\n \nThe return value is 16 bytes in length, or NULL if the\nargument was NULL.
[ORD]
declaration=str
category=String Functions
description=If the leftmost character of the string str is a multi-byte\ncharacter,\nreturns the code for that character, calculated from the\nnumeric\nvalues of its constituent bytes using this formula:\n \n (1st byte code)\n+ (2nd byte code x 256)\n+ (3rd byte code x 256 x 256) ...\n \nIf the leftmost character is not a multi-byte character,\nORD() returns\nthe same value as the ASCII() function.\n \n\nSELECT ORD(''2'');\n+----------+\n| ORD(''2'') |\n+----------+\n| 50 |\n+----------+
[OVERLAPS]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether g1 spatially overlaps g2.\nThe term spatially overlaps is used if two geometries\nintersect and their\nintersection results in a geometry of the same dimension but\nnot equal to\neither of the given geometries.\n \nOVERLAPS() is based on the original MySQL implementation and\nuses object bounding rectangles, while ST_OVERLAPS() uses\nobject shapes.
[PASSWORD]
declaration=str
category=Encryption Functions
description=The PASSWORD() function is used for hashing passwords for\nuse in authentication by the MariaDB server. It is not\nintended for use in other applications.\n \nCalculates and returns a hashed password string from the\nplaintext password str. Returns an empty string (>= MariaDB\n10.0.4) or NULL (
[PERCENT_RANK1]
name=PERCENT_RANK
declaration=
category=Window Functions
description=PERCENT_RANK() is a window function that returns the\nrelative percent rank of a given row. The following formula\nis used to calculate the percent rank:\n \n(rank - 1) / (number of rows in the window or partition - 1)\n \n\ncreate table t1 (\n pk int primary key,\n a int,\n b int\n);\n \ninsert into t1 values\n( 1 , 0, 10),\n( 2 , 0, 10),\n( 3 , 1, 10),\n( 4 , 1, 10),\n( 8 , 2, 10),\n( 5 , 2, 20),\n( 6 , 2, 20),\n( 7 , 2, 20),\n( 9 , 4, 20),\n(10 , 4, 20);\n \nselect pk, a, b,\n rank() over (order by a) as rank,\n percent_rank() over (order by a) as pct_rank,\n cume_dist() over (order by a) as cume_dist\nfrom t1;\n \n+----+------+------+------+--------------+--------------+\n| pk | a | b | rank | pct_rank | cume_dist |\n+----+------+------+------+--------------+--------------+\n| 1 | 0 | 10 | 1 | 0.0000000000 | 0.2000000000 |\n| 2 | 0 | 10 | 1 | 0.0000000000 | 0.2000000000 |\n| 3 | 1 | 10 | 3 | 0.2222222222 | 0.4000000000 |\n| 4 | 1 | 10 | 3 | 0.2222222222 | 0.4000000000 |\n| 5 | 2 | 20 | 5 | 0.4444444444 | 0.8000000000 |\n| 6 | 2 | 20 | 5 | 0.4444444444 | 0.8000000000 |\n| 7 | 2 | 20 | 5 | 0.4444444444 | 0.8000000000 |\n| 8 | 2 | 10 | 5 | 0.4444444444 | 0.8000000000 |\n| 9 | 4 | 20 | 9 | 0.8888888889 | 1.0000000000 |\n| 10 | 4 | 20 | 9 | 0.8888888889 | 1.0000000000 |\n+----+------+------+------+--------------+--------------+\n \nselect pk, a, b,\n percent_rank() over (order by pk) as pct_rank,\n cume_dist() over (order by pk) as cume_dist\nfrom t1 order by pk;\n \n+----+------+------+--------------+--------------+\n| pk | a | b | pct_rank | cume_dist |\n+----+------+------+--------------+--------------+\n| 1 | 0 | 10 | 0.0000000000 | 0.1000000000 |\n| 2 | 0 | 10 | 0.1111111111 | 0.2000000000 |\n| 3 | 1 | 10 | 0.2222222222 | 0.3000000000 |\n| 4 | 1 | 10 | 0.3333333333 | 0.4000000000 |\n| 5 | 2 | 20 | 0.4444444444 | 0.5000000000 |\n| 6 | 2 | 20 | 0.5555555556 | 0.6000000000 |\n| 7 | 2 | 20 | 0.6666666667 | 0.7000000000 |\n| 8 | 2 | 10 | 0.7777777778 | 0.8000000000 |\n| 9 | 4 | 20 | 0.8888888889 | 0.9000000000 |\n| 10 | 4 | 20 | 1.0000000000 | 1.0000000000 |\n+----+------+------+--------------+--------------+\n \nselect pk, a, b,\n percent_rank() over (partition by a order by a) as\npct_rank,\n cume_dist() over (partition by a order by a) as cume_dist\nfrom t1;\n \n+----+------+------+--------------+--------------+\n| pk | a | b | pct_rank | cume_dist |\n+----+------+------+--------------+--------------+\n| 1 | 0 | 10 | 0.0000000000 | 1.0000000000 |\n| 2 | 0 | 10 | 0.0000000000 | 1.0000000000 |\n| 3 | 1 | 10 | 0.0000000000 | 1.0000000000 |\n| 4 | 1 | 10 | 0.0000000000 | 1.0000000000 |\n| 5 | 2 | 20 | 0.0000000000 | 1.0000000000 |\n| 6 | 2 | 20 | 0.0000000000 | 1.0000000000 |\n| 7 | 2 | 20 | 0.0000000000 | 1.0000000000 |\n| 8 | 2 | 10 | 0.0000000000 | 1.0000000000 |\n| 9 | 4 | 20 | 0.0000000000 | 1.0000000000 |\n| 10 | 4 | 20 | 0.0000000000 | 1.0000000000 |\n+----+------+------+--------------+--------------+
[PERCENT_RANK2]
name=PERCENT_RANK
declaration=[ PARTITION BY partition_expression ]   [ ORDER BY order_list ]
category=Window Functions
description=PERCENT_RANK() is a window function that returns the\nrelative percent rank of a given row. The following formula\nis used to calculate the percent rank:\n \n(rank - 1) / (number of rows in the window or partition - 1)\n \n\ncreate table t1 (\n pk int primary key,\n a int,\n b int\n);\n \ninsert into t1 values\n( 1 , 0, 10),\n( 2 , 0, 10),\n( 3 , 1, 10),\n( 4 , 1, 10),\n( 8 , 2, 10),\n( 5 , 2, 20),\n( 6 , 2, 20),\n( 7 , 2, 20),\n( 9 , 4, 20),\n(10 , 4, 20);\n \nselect pk, a, b,\n rank() over (order by a) as rank,\n percent_rank() over (order by a) as pct_rank,\n cume_dist() over (order by a) as cume_dist\nfrom t1;\n \n+----+------+------+------+--------------+--------------+\n| pk | a | b | rank | pct_rank | cume_dist |\n+----+------+------+------+--------------+--------------+\n| 1 | 0 | 10 | 1 | 0.0000000000 | 0.2000000000 |\n| 2 | 0 | 10 | 1 | 0.0000000000 | 0.2000000000 |\n| 3 | 1 | 10 | 3 | 0.2222222222 | 0.4000000000 |\n| 4 | 1 | 10 | 3 | 0.2222222222 | 0.4000000000 |\n| 5 | 2 | 20 | 5 | 0.4444444444 | 0.8000000000 |\n| 6 | 2 | 20 | 5 | 0.4444444444 | 0.8000000000 |\n| 7 | 2 | 20 | 5 | 0.4444444444 | 0.8000000000 |\n| 8 | 2 | 10 | 5 | 0.4444444444 | 0.8000000000 |\n| 9 | 4 | 20 | 9 | 0.8888888889 | 1.0000000000 |\n| 10 | 4 | 20 | 9 | 0.8888888889 | 1.0000000000 |\n+----+------+------+------+--------------+--------------+\n \nselect pk, a, b,\n percent_rank() over (order by pk) as pct_rank,\n cume_dist() over (order by pk) as cume_dist\nfrom t1 order by pk;\n \n+----+------+------+--------------+--------------+\n| pk | a | b | pct_rank | cume_dist |\n+----+------+------+--------------+--------------+\n| 1 | 0 | 10 | 0.0000000000 | 0.1000000000 |\n| 2 | 0 | 10 | 0.1111111111 | 0.2000000000 |\n| 3 | 1 | 10 | 0.2222222222 | 0.3000000000 |\n| 4 | 1 | 10 | 0.3333333333 | 0.4000000000 |\n| 5 | 2 | 20 | 0.4444444444 | 0.5000000000 |\n| 6 | 2 | 20 | 0.5555555556 | 0.6000000000 |\n| 7 | 2 | 20 | 0.6666666667 | 0.7000000000 |\n| 8 | 2 | 10 | 0.7777777778 | 0.8000000000 |\n| 9 | 4 | 20 | 0.8888888889 | 0.9000000000 |\n| 10 | 4 | 20 | 1.0000000000 | 1.0000000000 |\n+----+------+------+--------------+--------------+\n \nselect pk, a, b,\n percent_rank() over (partition by a order by a) as\npct_rank,\n cume_dist() over (partition by a order by a) as cume_dist\nfrom t1;\n \n+----+------+------+--------------+--------------+\n| pk | a | b | pct_rank | cume_dist |\n+----+------+------+--------------+--------------+\n| 1 | 0 | 10 | 0.0000000000 | 1.0000000000 |\n| 2 | 0 | 10 | 0.0000000000 | 1.0000000000 |\n| 3 | 1 | 10 | 0.0000000000 | 1.0000000000 |\n| 4 | 1 | 10 | 0.0000000000 | 1.0000000000 |\n| 5 | 2 | 20 | 0.0000000000 | 1.0000000000 |\n| 6 | 2 | 20 | 0.0000000000 | 1.0000000000 |\n| 7 | 2 | 20 | 0.0000000000 | 1.0000000000 |\n| 8 | 2 | 10 | 0.0000000000 | 1.0000000000 |\n| 9 | 4 | 20 | 0.0000000000 | 1.0000000000 |\n| 10 | 4 | 20 | 0.0000000000 | 1.0000000000 |\n+----+------+------+--------------+--------------+
[PERIOD_ADD]
declaration=P,N
category=Date and Time Functions
description=Adds N months to period P. P is in the format YYMM or\nYYYYMM, and is not a date value. If P contains a two-digit\nyear, values from 00 to 69 are converted to from 2000 to\n2069, while values from 70 are converted to 1970 upwards.\n \nReturns a value in the format YYYYMM.\n \n\nSELECT PERIOD_ADD(200801,2);\n+----------------------+\n| PERIOD_ADD(200801,2) |\n+----------------------+\n| 200803 |\n+----------------------+\n \nSELECT PERIOD_ADD(6910,2);\n+--------------------+\n| PERIOD_ADD(6910,2) |\n+--------------------+\n| 206912 |\n+--------------------+\n \nSELECT PERIOD_ADD(7010,2);\n+--------------------+\n| PERIOD_ADD(7010,2) |\n+--------------------+\n| 197012 |\n+--------------------+
[PERIOD_DIFF]
declaration=P1,P2
category=Date and Time Functions
description=Returns the number of months between periods P1 and P2. P1\nand P2 \ncan be in the format YYMM or YYYYMM, and are not date\nvalues.\n \nIf P1 or P2 contains a two-digit year, values from 00 to 69\nare converted to from 2000 to 2069, while values from 70 are\nconverted to 1970 upwards.\n \n\nSELECT PERIOD_DIFF(200802,200703);\n+----------------------------+\n| PERIOD_DIFF(200802,200703) |\n+----------------------------+\n| 11 |\n+----------------------------+\n \nSELECT PERIOD_DIFF(6902,6803);\n+------------------------+\n| PERIOD_DIFF(6902,6803) |\n+------------------------+\n| 11 |\n+------------------------+\n \nSELECT PERIOD_DIFF(7002,6803);\n+------------------------+\n| PERIOD_DIFF(7002,6803) |\n+------------------------+\n| -1177 |\n+------------------------+
[PI]
declaration=
category=Numeric Functions
description=Returns the value of ? (pi). The default number of decimal\nplaces\ndisplayed is six, but MariaDB uses the full double-precision\nvalue\ninternally.\n \n\nSELECT PI();\n+----------+\n| PI() |\n+----------+\n| 3.141593 |\n+----------+\n \nSELECT PI()+0.0000000000000000000000;\n \n+-------------------------------+\n| PI()+0.0000000000000000000000 |\n+-------------------------------+\n| 3.1415926535897931159980 |\n+-------------------------------+
[POINT]
declaration=x,y
category=Geometry Constructors
description=Constructs a WKB Point using the given coordinates.\n \n\nSET @g = ST_GEOMFROMTEXT(''Point(1 1)'');\n \nCREATE TABLE gis_point (g POINT);\nINSERT INTO gis_point VALUES\n (PointFromText(''POINT(10 10)'')),\n (PointFromText(''POINT(20 10)'')),\n (PointFromText(''POINT(20 20)'')),\n (PointFromWKB(AsWKB(PointFromText(''POINT(10 20)''))));
[POLYGON]
declaration=ls1,ls2,...
category=Geometry Constructors
description=Constructs a WKB Polygon value from a number of WKB\nLineString\narguments. If any argument does not represent the WKB of a\nLinearRing (that is,\nnot a closed and simple LineString) the return value is\nNULL.\n \nNote that according to the OpenGIS standard, a POLYGON\nshould have exactly one ExteriorRing and all other rings\nshould lie within that ExteriorRing and thus be the\nInteriorRings. Practically, however, some systems, including\nMariaDB''s, permit polygons to have several\n''ExteriorRings''. In the case of there being multiple,\nnon-overlapping exterior rings ST_NUMINTERIORRINGS() will\nreturn 1.\n \n\nSET @g = ST_GEOMFROMTEXT(''POLYGON((1 1,1 5,4 9,6 9,9 3,7\n2,1 1))'');\n \nCREATE TABLE gis_polygon (g POLYGON);\nINSERT INTO gis_polygon VALUES\n (PolygonFromText(''POLYGON((10 10,20 10,20 20,10 20,10\n10))'')),\n (PolyFromText(''POLYGON((0 0,50 0,50 50,0 50,0 0), (10\n10,20 10,20 20,10 20,10 10))'')),\n (PolyFromWKB(AsWKB(Polygon(LineString(Point(0, 0),\nPoint(30, 0), Point(30, 30), Point(0, 0))))));\n \nNon-overlapping ''polygon'':\n \nSELECT ST_NumInteriorRings(ST_PolyFromText(''POLYGON((0 0,10\n0,10 10,0 10,0 0),\n (-1 -1,-5 -1,-5 -5,-1 -5,-1 -1))'')) AS NumInteriorRings;\n \n+------------------+\n| NumInteriorRings |\n+------------------+\n| 1 |\n+------------------+
[POSITION]
declaration=substr IN str
category=String Functions
description=POSITION(substr IN str) is a synonym for LOCATE(substr,str).\n \nIt''s part of ODBC 3.0.
[POWER]
declaration=X,Y
category=Numeric Functions
description=This is a synonym for POW(), which returns the value of X\nraised to the power of Y.
[POW]
declaration=X,Y
category=Numeric Functions
description=Returns the value of X raised to the power of Y.\n \nPOWER() is a synonym.\n \n\nSELECT POW(2,3);\n+----------+\n| POW(2,3) |\n+----------+\n| 8 |\n+----------+\n \nSELECT POW(2,-2);\n+-----------+\n| POW(2,-2) |\n+-----------+\n| 0.25 |\n+-----------+
[QUARTER]
declaration=date
category=Date and Time Functions
description=Returns the quarter of the year for date, in the range 1 to\n4. Returns 0 if month contains a zero value, or NULL if the\ngiven value is not otherwise a valid date (zero values are\naccepted).\n \n\nSELECT QUARTER(''2008-04-01'');\n+-----------------------+\n| QUARTER(''2008-04-01'') |\n+-----------------------+\n| 2 |\n+-----------------------+\n \nSELECT QUARTER(''2019-00-01'');\n+-----------------------+\n| QUARTER(''2019-00-01'') |\n+-----------------------+\n| 0 |\n+-----------------------+
[QUOTE]
declaration=str
category=String Functions
description=Quotes a string to produce a result that can be used as a\nproperly escaped data\nvalue in an SQL statement. The string is returned enclosed\nby single quotes and\nwith each instance of single quote ("''"), backslash\n("\"),\nASCII NUL, and Control-Z preceded by a backslash. If the\nargument\nis NULL, the return value is the word "NULL" without\nenclosing single\nquotes.\n \n\nSELECT QUOTE("Don''t!");\n+-----------------+\n| QUOTE("Don''t!") |\n+-----------------+\n| ''Don\''t!'' |\n+-----------------+\n \nSELECT QUOTE(NULL); \n+-------------+\n| QUOTE(NULL) |\n+-------------+\n| NULL |\n+-------------+
[RADIANS]
declaration=X
category=Numeric Functions
description=Returns the argument X, converted from degrees to radians.\nNote that\n? radians equals 180 degrees. \n \nThis is the converse of the DEGREES() function.\n \n\nSELECT RADIANS(45);\n+-------------------+\n| RADIANS(45) |\n+-------------------+\n| 0.785398163397448 |\n+-------------------+\n \nSELECT RADIANS(90);\n+-----------------+\n| RADIANS(90) |\n+-----------------+\n| 1.5707963267949 |\n+-----------------+\n \nSELECT RADIANS(PI());\n+--------------------+\n| RADIANS(PI()) |\n+--------------------+\n| 0.0548311355616075 |\n+--------------------+\n \nSELECT RADIANS(180);\n+------------------+\n| RADIANS(180) |\n+------------------+\n| 3.14159265358979 |\n+------------------+
[RAND1]
name=RAND
declaration=
category=Numeric Functions
description=Returns a random DOUBLE precision floating point value v in\nthe range 0
[RAND2]
name=RAND
declaration=N
category=Numeric Functions
description=Returns a random DOUBLE precision floating point value v in\nthe range 0
[RANK1]
name=RANK
declaration=
category=Window Functions
description=RANK() is a window function that displays the number of a\ngiven row, starting at one and following the ORDER BY\nsequence of the window function, with identical values\nreceiving the same result. It is similar to the ROW_NUMBER()\nfunction except that in that function, identical values will\nreceive a different row number for each result.\n \n\nThe distinction between DENSE_RANK(), RANK() and\nROW_NUMBER():\n \nCREATE TABLE student(course VARCHAR(10), mark int, name\nvarchar(10));\n \nINSERT INTO student VALUES \n (''Maths'', 60, ''Thulile''),\n (''Maths'', 60, ''Pritha''),\n (''Maths'', 70, ''Voitto''),\n (''Maths'', 55, ''Chun''),\n (''Biology'', 60, ''Bilal''),\n (''Biology'', 70, ''Roger'');\n \nSELECT \n RANK() OVER (PARTITION BY course ORDER BY mark DESC) AS\nrank, \n DENSE_RANK() OVER (PARTITION BY course ORDER BY mark DESC)\nAS dense_rank, \n ROW_NUMBER() OVER (PARTITION BY course ORDER BY mark DESC)\nAS row_num, \n course, mark, name \nFROM student ORDER BY course, mark DESC;\n \n+------+------------+---------+---------+------+---------+\n| rank | dense_rank | row_num | course | mark | name |\n+------+------------+---------+---------+------+---------+\n| 1 | 1 | 1 | Biology | 70 | Roger |\n| 2 | 2 | 2 | Biology | 60 | Bilal |\n| 1 | 1 | 1 | Maths | 70 | Voitto |\n| 2 | 2 | 2 | Maths | 60 | Thulile |\n| 2 | 2 | 3 | Maths | 60 | Pritha |\n| 4 | 3 | 4 | Maths | 55 | Chun |\n+------+------------+---------+---------+------+---------+
[RANK2]
name=RANK
declaration=[ PARTITION BY partition_expression ]  [ ORDER BY order_list ]
category=Window Functions
description=RANK() is a window function that displays the number of a\ngiven row, starting at one and following the ORDER BY\nsequence of the window function, with identical values\nreceiving the same result. It is similar to the ROW_NUMBER()\nfunction except that in that function, identical values will\nreceive a different row number for each result.\n \n\nThe distinction between DENSE_RANK(), RANK() and\nROW_NUMBER():\n \nCREATE TABLE student(course VARCHAR(10), mark int, name\nvarchar(10));\n \nINSERT INTO student VALUES \n (''Maths'', 60, ''Thulile''),\n (''Maths'', 60, ''Pritha''),\n (''Maths'', 70, ''Voitto''),\n (''Maths'', 55, ''Chun''),\n (''Biology'', 60, ''Bilal''),\n (''Biology'', 70, ''Roger'');\n \nSELECT \n RANK() OVER (PARTITION BY course ORDER BY mark DESC) AS\nrank, \n DENSE_RANK() OVER (PARTITION BY course ORDER BY mark DESC)\nAS dense_rank, \n ROW_NUMBER() OVER (PARTITION BY course ORDER BY mark DESC)\nAS row_num, \n course, mark, name \nFROM student ORDER BY course, mark DESC;\n \n+------+------------+---------+---------+------+---------+\n| rank | dense_rank | row_num | course | mark | name |\n+------+------------+---------+---------+------+---------+\n| 1 | 1 | 1 | Biology | 70 | Roger |\n| 2 | 2 | 2 | Biology | 60 | Bilal |\n| 1 | 1 | 1 | Maths | 70 | Voitto |\n| 2 | 2 | 2 | Maths | 60 | Thulile |\n| 2 | 2 | 3 | Maths | 60 | Pritha |\n| 4 | 3 | 4 | Maths | 55 | Chun |\n+------+------------+---------+---------+------+---------+
[REGEXP_INSTR10]
name=REGEXP_INSTR
declaration=''ABC'' COLLATE utf8_bin,''b''
category=String Functions
description=
[REGEXP_INSTR11]
name=REGEXP_INSTR
declaration=BINARY''ABC'',''b''
category=String Functions
description=
[REGEXP_INSTR12]
name=REGEXP_INSTR
declaration=''ABC'',''(?-i)b''
category=String Functions
description=
[REGEXP_INSTR13]
name=REGEXP_INSTR
declaration=''ABC'' COLLATE utf8_bin,''(?i)b''
category=String Functions
description=
[REGEXP_INSTR1]
name=REGEXP_INSTR
declaration=subject, pattern
category=String Functions
description=
[REGEXP_INSTR2]
name=REGEXP_INSTR
declaration=i.e. not in bytes
category=String Functions
description=
[REGEXP_INSTR3]
name=REGEXP_INSTR
declaration=?i
category=String Functions
description=
[REGEXP_INSTR4]
name=REGEXP_INSTR
declaration=?-i
category=String Functions
description=
[REGEXP_INSTR5]
name=REGEXP_INSTR
declaration=''abc'',''b''
category=String Functions
description=
[REGEXP_INSTR6]
name=REGEXP_INSTR
declaration=''abc'',''x''
category=String Functions
description=
[REGEXP_INSTR7]
name=REGEXP_INSTR
declaration=''BJÖRN'',''N''
category=String Functions
description=
[REGEXP_INSTR8]
name=REGEXP_INSTR
declaration=BINARY ''BJÖRN'',''N''
category=String Functions
description=
[REGEXP_INSTR9]
name=REGEXP_INSTR
declaration=''ABC'',''b''
category=String Functions
description=
[REGEXP_REPLACE]
declaration=subject, pattern, replace
category=String Functions
description=REGEXP_REPLACE returns the string subject with all\noccurrences of the regular expression pattern replaced by\nthe string replace. If no occurrences are found, then\nsubject is returned as is.\n \nThe replace string can have backreferences to the\nsubexpressions in the form \N, where N is a number from 1\nto 9.\n \nThe function follows the case sensitivity rules of the\neffective collation. Matching is performed case\ninsensitively for case insensitive collations, and case\nsensitively for case sensitive collations and for binary\ndata.\n \nThe collation case sensitivity can be overwritten using the\n(?i) and (?-i) PCRE flags.\n \nMariaDB 10.0.5 switched to the PCRE regular expression\nlibrary for enhanced regular expression performance, and\nREGEXP_REPLACE was introduced as part of this enhancement.\n \nMariaDB 10.0.11 introduced the default_regex_flags variable\nto address the remaining compatibilities between PCRE and\nthe old regex library. \n \n\nSELECT REGEXP_REPLACE(''ab12cd'',''[0-9]'','''') AS\nremove_digits;\n-> abcd\n \nSELECT REGEXP_REPLACE(''titlebody'', '''','' '')\nAS strip_html;\n-> title body\n \nBackreferences to the subexpressions in the form \N, where\nN is a number from 1 to 9:\n \nSELECT REGEXP_REPLACE(''James Bond'',''^(.*)\n(.*)$'',''\\2, \\1'') AS reorder_name;\n-> Bond, James\n \nCase insensitive and case sensitive matches:\n \nSELECT REGEXP_REPLACE(''ABC'',''b'',''-'') AS\ncase_insensitive;\n-> A-C\n \nSELECT REGEXP_REPLACE(''ABC'' COLLATE utf8_bin,''b'',''-'')\nAS case_sensitive;\n-> ABC\n \nSELECT REGEXP_REPLACE(BINARY ''ABC'',''b'',''-'') AS\nbinary_data;\n-> ABC\n \nOverwriting the collation case sensitivity using the (?i)\nand (?-i) PCRE flags.\n \nSELECT REGEXP_REPLACE(''ABC'',''(?-i)b'',''-'') AS\nforce_case_sensitive;\n-> ABC\n \nSELECT REGEXP_REPLACE(BINARY ''ABC'',''(?i)b'',''-'') AS\nforce_case_insensitive;\n-> A-C
[REGEXP_SUBSTR]
declaration=subject,pattern
category=String Functions
description=Returns the part of the string subject that matches the\nregular expression pattern, or an empty string if pattern\nwas not found.\n \nThe function follows the case sensitivity rules of the\neffective collation. Matching is performed case\ninsensitively for case insensitive collations, and case\nsensitively for case sensitive collations and for binary\ndata.\n \nThe collation case sensitivity can be overwritten using the\n(?i) and (?-i) PCRE flags.\n \nMariaDB 10.0.5 switched to the PCRE regular expression\nlibrary for enhanced regular expression performance, and\nREGEXP_SUBSTR was introduced as part of this enhancement.\n \nMariaDB 10.0.11 introduced the default_regex_flags variable\nto address the remaining compatibilities between PCRE and\nthe old regex library. \n \n\nSELECT REGEXP_SUBSTR(''ab12cd'',''[0-9]+'');\n-> 12\n \nSELECT REGEXP_SUBSTR(\n ''See https://mariadb.org/en/foundation/ for details'',\n ''https?://[^/]*'');\n-> https://mariadb.org\n \nSELECT REGEXP_SUBSTR(''ABC'',''b'');\n-> B\n \nSELECT REGEXP_SUBSTR(''ABC'' COLLATE utf8_bin,''b'');\n->\n \nSELECT REGEXP_SUBSTR(BINARY''ABC'',''b'');\n->\n \nSELECT REGEXP_SUBSTR(''ABC'',''(?i)b'');\n-> B\n \nSELECT REGEXP_SUBSTR(''ABC'' COLLATE utf8_bin,''(?+i)b'');\n-> B
[RELEASE_LOCK]
declaration=str
category=Miscellaneous Functions
description=Releases the lock named by the string str that was obtained\nwith GET_LOCK(). Returns 1 if the lock was released, 0 if\nthe lock was not established by this thread (in which case\nthe lock is not\nreleased), and NULL if the named lock did not exist. The\nlock does not exist if it was never obtained by a call to\nGET_LOCK() or if it has previously been released.\n \nMariaDB until 10.0.1\n \nBefore 10.0.2, GET_LOCK() released the existing lock, if\nany. Since 10.0.2 this does not happen, because multiple\nlocks are allowed.\n \nstr is case insensitive. If str is an empty string or NULL,\nRELEASE_LOCK() returns NULL and does nothing.\n \nStatements using the RELEASE_LOCK() function are not safe\nfor replication.\n \nThe DO statement is convenient to use with RELEASE_LOCK().\n \n\nConnection1:\n \nSELECT GET_LOCK(''lock1'',10);\n+----------------------+\n| GET_LOCK(''lock1'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nConnection 2:\n \nSELECT GET_LOCK(''lock2'',10);\n+----------------------+\n| GET_LOCK(''lock2'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nConnection 1:\n \nSELECT RELEASE_LOCK(''lock1''), RELEASE_LOCK(''lock2''),\nRELEASE_LOCK(''lock3'');\n+-----------------------+-----------------------+-----------------------+\n| RELEASE_LOCK(''lock1'') | RELEASE_LOCK(''lock2'') |\nRELEASE_LOCK(''lock3'') |\n+-----------------------+-----------------------+-----------------------+\n| 1 | 0 | NULL |\n+-----------------------+-----------------------+-----------------------+\n \nFrom MariaDB 10.0.2, it is possible to hold the same lock\nrecursively. This example is viewed using the\nmetadata_lock_info plugin:\n \nSELECT GET_LOCK(''lock3'',10);\n+----------------------+\n| GET_LOCK(''lock3'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSELECT GET_LOCK(''lock3'',10);\n+----------------------+\n| GET_LOCK(''lock3'',10) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n \n+-----------+---------------------+---------------+-----------+--------------+------------+\n| THREAD_ID | LOCK_MODE | LOCK_DURATION | LOCK_TYPE |\nTABLE_SCHEMA | TABLE_NAME |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n| 46 | MDL_SHARED_NO_WRITE | NULL | User lock | lock3 | |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n \nSELECT RELEASE_LOCK(''lock3'');\n+-----------------------+\n| RELEASE_LOCK(''lock3'') |\n+-----------------------+\n| 1 |\n+-----------------------+\n \nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n \n+-----------+---------------------+---------------+-----------+--------------+------------+\n| THREAD_ID | LOCK_MODE | LOCK_DURATION | LOCK_TYPE |\nTABLE_SCHEMA | TABLE_NAME |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n| 46 | MDL_SHARED_NO_WRITE | NULL | User lock | lock3 | |\n+-----------+---------------------+---------------+-----------+--------------+------------+\n \nSELECT RELEASE_LOCK(''lock3'');\n+-----------------------+\n| RELEASE_LOCK(''lock3'') |\n+-----------------------+\n| 1 |\n+-----------------------+\n \nSELECT * FROM INFORMATION_SCHEMA.METADATA_LOCK_INFO;\n \nEmpty set (0.000 sec)
[REVERSE]
declaration=str
category=String Functions
description=Returns the string str with the order of the characters\nreversed.\n \n\nSELECT REVERSE(''desserts'');\n+---------------------+\n| REVERSE(''desserts'') |\n+---------------------+\n| stressed |\n+---------------------+
[RIGHT]
declaration=str,len
category=String Functions
description=Returns the rightmost len characters from the string str, or\nNULL if\nany argument is NULL.\n \n\nSELECT RIGHT(''MariaDB'', 2);\n+---------------------+\n| RIGHT(''MariaDB'', 2) |\n+---------------------+\n| DB |\n+---------------------+
[ROUND1]
name=ROUND
declaration=X
category=Numeric Functions
description=Rounds the argument X to D decimal places. The rounding\nalgorithm\ndepends on the data type of X. D defaults to 0 if not\nspecified.\nD can be negative to cause D digits left of the decimal\npoint of the\nvalue X to become zero.\n \n\nSELECT ROUND(-1.23);\n+--------------+\n| ROUND(-1.23) |\n+--------------+\n| -1 |\n+--------------+\n \nSELECT ROUND(-1.58);\n+--------------+\n| ROUND(-1.58) |\n+--------------+\n| -2 |\n+--------------+\n \nSELECT ROUND(1.58); \n+-------------+\n| ROUND(1.58) |\n+-------------+\n| 2 |\n+-------------+\n \nSELECT ROUND(1.298, 1);\n+-----------------+\n| ROUND(1.298, 1) |\n+-----------------+\n| 1.3 |\n+-----------------+\n \nSELECT ROUND(1.298, 0);\n+-----------------+\n| ROUND(1.298, 0) |\n+-----------------+\n| 1 |\n+-----------------+\n \nSELECT ROUND(23.298, -1);\n+-------------------+\n| ROUND(23.298, -1) |\n+-------------------+\n| 20 |\n+-------------------+
[ROUND2]
name=ROUND
declaration=X,D
category=Numeric Functions
description=Rounds the argument X to D decimal places. The rounding\nalgorithm\ndepends on the data type of X. D defaults to 0 if not\nspecified.\nD can be negative to cause D digits left of the decimal\npoint of the\nvalue X to become zero.\n \n\nSELECT ROUND(-1.23);\n+--------------+\n| ROUND(-1.23) |\n+--------------+\n| -1 |\n+--------------+\n \nSELECT ROUND(-1.58);\n+--------------+\n| ROUND(-1.58) |\n+--------------+\n| -2 |\n+--------------+\n \nSELECT ROUND(1.58); \n+-------------+\n| ROUND(1.58) |\n+-------------+\n| 2 |\n+-------------+\n \nSELECT ROUND(1.298, 1);\n+-----------------+\n| ROUND(1.298, 1) |\n+-----------------+\n| 1.3 |\n+-----------------+\n \nSELECT ROUND(1.298, 0);\n+-----------------+\n| ROUND(1.298, 0) |\n+-----------------+\n| 1 |\n+-----------------+\n \nSELECT ROUND(23.298, -1);\n+-------------------+\n| ROUND(23.298, -1) |\n+-------------------+\n| 20 |\n+-------------------+
[ROW_COUNT]
declaration=
category=Information Functions
description=ROW_COUNT() returns the number of rows updated, inserted or\ndeleted\nby the preceding statement. This is the same as the row\ncount that the\nmysql client displays and the value from the\nmysql_affected_rows() C\nAPI function.\n \nGenerally:\nFor statements which return a result set (such as SELECT,\nSHOW, DESC or HELP), returns -1, even when the result set is\nempty. This is also true for administrative statements, such\nas OPTIMIZE.\nFor DML statements other than SELECT and for ALTER TABLE,\nreturns the number of affected rows.\nFor DDL statements (including TRUNCATE) and for other\nstatements which don''t return any result set (such as USE,\nDO, SIGNAL or DEALLOCATE PREPARE), returns 0.\n \nFor UPDATE, affected rows is by default the number of rows\nthat were actually changed. If the CLIENT_FOUND_ROWS flag to\nmysql_real_connect() is specified when connecting to mysqld,\naffected rows is instead the number of rows matched by the\nWHERE clause. \n \nFor REPLACE, deleted rows are also counted. So, if REPLACE\ndeletes a row and adds a new row, ROW_COUNT() returns 2.\n \nFor INSERT ... ON DUPLICATE KEY, updated rows are counted\ntwice. So, if INSERT adds a new rows and modifies another\nrow, ROW_COUNT() returns 3.\n \nROW_COUNT() does not take into account rows that are not\ndirectly deleted/updated by the last statement. This means\nthat rows deleted by foreign keys or triggers are not\ncounted.\n \nWarning: You can use ROW_COUNT() with prepared statements,\nbut you need to call it after EXECUTE, not after DEALLOCATE\nPREPARE, because the row count for allocate prepare is\nalways 0.\n \nWarning: When used after a CALL statement, this function\nreturns the number of rows affected by the last statement in\nthe procedure, not by the whole procedure.\n \nWarning: After INSERT DELAYED, ROW_COUNT() returns the\nnumber of the rows you tried to insert, not the number of\nthe successful writes.\n \nThis information can also be found in the diagnostics area.\n \nStatements using the ROW_COUNT() function are not safe for\nreplication.\n \n\nCREATE TABLE t (A INT);\n \nINSERT INTO t VALUES(1),(2),(3);\n \nSELECT ROW_COUNT();\n+-------------+\n| ROW_COUNT() |\n+-------------+\n| 3 |\n+-------------+\n \nDELETE FROM t WHERE A IN(1,2);\n \nSELECT ROW_COUNT(); \n+-------------+\n| ROW_COUNT() |\n+-------------+\n| 2 |\n+-------------+\n \nExample with prepared statements:\n \nSET @q = ''INSERT INTO t VALUES(1),(2),(3);'';\n \nPREPARE stmt FROM @q;\n \nEXECUTE stmt;\n \nQuery OK, 3 rows affected (0.39 sec)\nRecords: 3 Duplicates: 0 Warnings: 0\n \nSELECT ROW_COUNT();\n+-------------+\n| ROW_COUNT() |\n+-------------+\n| 3 |\n+-------------+
[ROW_NUMBER1]
name=ROW_NUMBER
declaration=
category=Window Functions
description=ROW_NUMBER() is a window function that displays the number\nof a given row, starting at one and following the ORDER BY\nsequence of the window function, with identical values\nreceiving different row numbers. It is similar to the RANK()\nand DENSE_RANK() functions except that in that function,\nidentical values will receive the same rank for each result.\n \n\nThe distinction between DENSE_RANK(), RANK() and\nROW_NUMBER():\n \nCREATE TABLE student(course VARCHAR(10), mark int, name\nvarchar(10));\n \nINSERT INTO student VALUES \n (''Maths'', 60, ''Thulile''),\n (''Maths'', 60, ''Pritha''),\n (''Maths'', 70, ''Voitto''),\n (''Maths'', 55, ''Chun''),\n (''Biology'', 60, ''Bilal''),\n (''Biology'', 70, ''Roger'');\n \nSELECT \n RANK() OVER (PARTITION BY course ORDER BY mark DESC) AS\nrank, \n DENSE_RANK() OVER (PARTITION BY course ORDER BY mark DESC)\nAS dense_rank, \n ROW_NUMBER() OVER (PARTITION BY course ORDER BY mark DESC)\nAS row_num, \n course, mark, name \nFROM student ORDER BY course, mark DESC;\n \n+------+------------+---------+---------+------+---------+\n| rank | dense_rank | row_num | course | mark | name |\n+------+------------+---------+---------+------+---------+\n| 1 | 1 | 1 | Biology | 70 | Roger |\n| 2 | 2 | 2 | Biology | 60 | Bilal |\n| 1 | 1 | 1 | Maths | 70 | Voitto |\n| 2 | 2 | 2 | Maths | 60 | Thulile |\n| 2 | 2 | 3 | Maths | 60 | Pritha |\n| 4 | 3 | 4 | Maths | 55 | Chun |\n+------+------------+---------+---------+------+---------+
[ROW_NUMBER2]
name=ROW_NUMBER
declaration=[ PARTITION BY partition_expression ]  [ ORDER BY order_list ]
category=Window Functions
description=ROW_NUMBER() is a window function that displays the number\nof a given row, starting at one and following the ORDER BY\nsequence of the window function, with identical values\nreceiving different row numbers. It is similar to the RANK()\nand DENSE_RANK() functions except that in that function,\nidentical values will receive the same rank for each result.\n \n\nThe distinction between DENSE_RANK(), RANK() and\nROW_NUMBER():\n \nCREATE TABLE student(course VARCHAR(10), mark int, name\nvarchar(10));\n \nINSERT INTO student VALUES \n (''Maths'', 60, ''Thulile''),\n (''Maths'', 60, ''Pritha''),\n (''Maths'', 70, ''Voitto''),\n (''Maths'', 55, ''Chun''),\n (''Biology'', 60, ''Bilal''),\n (''Biology'', 70, ''Roger'');\n \nSELECT \n RANK() OVER (PARTITION BY course ORDER BY mark DESC) AS\nrank, \n DENSE_RANK() OVER (PARTITION BY course ORDER BY mark DESC)\nAS dense_rank, \n ROW_NUMBER() OVER (PARTITION BY course ORDER BY mark DESC)\nAS row_num, \n course, mark, name \nFROM student ORDER BY course, mark DESC;\n \n+------+------------+---------+---------+------+---------+\n| rank | dense_rank | row_num | course | mark | name |\n+------+------------+---------+---------+------+---------+\n| 1 | 1 | 1 | Biology | 70 | Roger |\n| 2 | 2 | 2 | Biology | 60 | Bilal |\n| 1 | 1 | 1 | Maths | 70 | Voitto |\n| 2 | 2 | 2 | Maths | 60 | Thulile |\n| 2 | 2 | 3 | Maths | 60 | Pritha |\n| 4 | 3 | 4 | Maths | 55 | Chun |\n+------+------------+---------+---------+------+---------+
[RPAD]
declaration=str, len [, padstr]
category=String Functions
description=Returns the string str, right-padded with the string padstr\nto a\nlength of len characters. If str is longer than len, the\nreturn value\nis shortened to len characters. If padstr is omitted, the\nRPAD function pads spaces.\n \nPrior to MariaDB 10.3.1, the padstr parameter was mandatory.\n \nReturns NULL if given a NULL argument. If the result is\nempty (a length of zero), returns either an empty string,\nor, from MariaDB 10.3.6 with SQL_MODE=Oracle, NULL.\n \nThe Oracle mode version of the function can be accessed\noutside of Oracle mode by using RPAD_ORACLE as the function\nname.\n \n\nSELECT RPAD(''hello'',10,''.'');\n+----------------------+\n| RPAD(''hello'',10,''.'') |\n+----------------------+\n| hello..... |\n+----------------------+\n \nSELECT RPAD(''hello'',2,''.'');\n+---------------------+\n| RPAD(''hello'',2,''.'') |\n+---------------------+\n| he |\n+---------------------+\n \nFrom MariaDB 10.3.1, with the pad string defaulting to\nspace.\n \nSELECT RPAD(''hello'',30);\n+--------------------------------+\n| RPAD(''hello'',30) |\n+--------------------------------+\n| hello |\n+--------------------------------+\n \nOracle mode version from MariaDB 10.3.6:\n \nSELECT RPAD('''',0),RPAD_ORACLE('''',0);\n+------------+-------------------+\n| RPAD('''',0) | RPAD_ORACLE('''',0) |\n+------------+-------------------+\n| | NULL |\n+------------+-------------------+
[RTRIM]
declaration=str
category=String Functions
description=Returns the string str with trailing space characters\nremoved.\n \nReturns NULL if given a NULL argument. If the result is\nempty, returns either an empty string, or, from MariaDB\n10.3.6 with SQL_MODE=Oracle, NULL.\n \nThe Oracle mode version of the function can be accessed\noutside of Oracle mode by using RTRIM_ORACLE as the function\nname.\n \n\nSELECT QUOTE(RTRIM(''MariaDB ''));\n+-----------------------------+\n| QUOTE(RTRIM(''MariaDB '')) |\n+-----------------------------+\n| ''MariaDB'' |\n+-----------------------------+\n \nOracle mode version from MariaDB 10.3.6:\n \nSELECT RTRIM(''''),RTRIM_ORACLE('''');\n+-----------+------------------+\n| RTRIM('''') | RTRIM_ORACLE('''') |\n+-----------+------------------+\n| | NULL |\n+-----------+------------------+
[SCHEMA]
declaration=
category=Information Functions
description=This function is a synonym for DATABASE().
[SECOND]
declaration=time
category=Date and Time Functions
description=Returns the second for a given time (which can include\nmicroseconds), in the range 0 to 59, or NULL if not given a\nvalid time value.\n \n\nSELECT SECOND(''10:05:03'');\n+--------------------+\n| SECOND(''10:05:03'') |\n+--------------------+\n| 3 |\n+--------------------+\n \nSELECT SECOND(''10:05:01.999999'');\n+---------------------------+\n| SECOND(''10:05:01.999999'') |\n+---------------------------+\n| 1 |\n+---------------------------+
[SEC_TO_TIME]
declaration=seconds
category=Date and Time Functions
description=Returns the seconds argument, converted to hours, minutes,\nand\nseconds, as a TIME value. The range of the result is\nconstrained to\nthat of the TIME data type. A warning occurs if the argument\ncorresponds to a value outside that range.\n \nThe time will be returned in the format hh:mm:ss, or hhmmss\nif used in a numeric calculation.\n \n\nSELECT SEC_TO_TIME(12414);\n+--------------------+\n| SEC_TO_TIME(12414) |\n+--------------------+\n| 03:26:54 |\n+--------------------+\n \nSELECT SEC_TO_TIME(12414)+0;\n \n+----------------------+\n| SEC_TO_TIME(12414)+0 |\n+----------------------+\n| 32654 |\n+----------------------+\n \nSELECT SEC_TO_TIME(9999999);\n+----------------------+\n| SEC_TO_TIME(9999999) |\n+----------------------+\n| 838:59:59 |\n+----------------------+\n1 row in set, 1 warning (0.00 sec)\n \nSHOW WARNINGS;\n \n+---------+------+-------------------------------------------+\n| Level | Code | Message |\n+---------+------+-------------------------------------------+\n| Warning | 1292 | Truncated incorrect time value:\n''9999999'' |\n+---------+------+-------------------------------------------+
[SESSION_USER]
declaration=
category=Information Functions
description=SESSION_USER() is a synonym for USER().
[SHA1]
declaration=str
category=Encryption Functions
description=Calculates an SHA-1 160-bit checksum for the string str, as\ndescribed in\nRFC 3174 (Secure Hash Algorithm).\n \nThe value is returned as a string of 40 hex digits, or NULL\nif the argument was NULL. As of MariaDB 5.5, the return\nvalue is a nonbinary string in the connection character set\nand collation, determined by the values of the\ncharacter_set_connection and collation_connection system\nvariables. Before 5.5, the return value was a binary string.\n \n\nSELECT SHA1(''some boring text'');\n+------------------------------------------+\n| SHA1(''some boring text'') |\n+------------------------------------------+\n| af969fc2085b1bb6d31e517d5c456def5cdd7093 |\n+------------------------------------------+
[SHA2]
declaration=str,hash_len
category=Encryption Functions
description=Given a string str, calculates an SHA-2 checksum, which is\nconsidered more cryptographically secure than its SHA-1\nequivalent. The SHA-2 family includes SHA-224, SHA-256,\nSHA-384, and SHA-512, and the hash_len must correspond to\none of these, i.e. 224, 256, 384 or 512. 0 is equivalent to\n256.\n \nThe return value is a nonbinary string in the connection\ncharacter set and collation, determined by the values of the\ncharacter_set_connection and collation_connection system\nvariables. \n \nNULL is returned if the hash length is not valid, or the\nstring str is NULL.\n \nSHA2 will only work if MariaDB was has been configured with\nTLS support. \n \n\nSELECT SHA2(''Maria'',224);\n+----------------------------------------------------------+\n| SHA2(''Maria'',224) |\n+----------------------------------------------------------+\n| 6cc67add32286412efcab9d0e1675a43a5c2ef3cec8879f81516ff83 |\n+----------------------------------------------------------+\n \nSELECT SHA2(''Maria'',256);\n+------------------------------------------------------------------+\n| SHA2(''Maria'',256) |\n+------------------------------------------------------------------+\n|\n9ff18ebe7449349f358e3af0b57cf7a032c1c6b2272cb2656ff85eb112232f16\n|\n+------------------------------------------------------------------+\n \nSELECT SHA2(''Maria'',0);\n+------------------------------------------------------------------+\n| SHA2(''Maria'',0) |\n+------------------------------------------------------------------+\n|\n9ff18ebe7449349f358e3af0b57cf7a032c1c6b2272cb2656ff85eb112232f16\n|\n+------------------------------------------------------------------+
[SIGN]
declaration=X
category=Numeric Functions
description=Returns the sign of the argument as -1, 0, or 1, depending\non whether\nX is negative, zero, or positive.\n \n\nSELECT SIGN(-32);\n+-----------+\n| SIGN(-32) |\n+-----------+\n| -1 |\n+-----------+\n \nSELECT SIGN(0);\n+---------+\n| SIGN(0) |\n+---------+\n| 0 |\n+---------+\n \nSELECT SIGN(234);\n+-----------+\n| SIGN(234) |\n+-----------+\n| 1 |\n+-----------+
[SIN]
declaration=X
category=Numeric Functions
description=Returns the sine of X, where X is given in radians.\n \n\nSELECT SIN(1.5707963267948966);\n+-------------------------+\n| SIN(1.5707963267948966) |\n+-------------------------+\n| 1 |\n+-------------------------+\n \nSELECT SIN(PI());\n+----------------------+\n| SIN(PI()) |\n+----------------------+\n| 1.22460635382238e-16 |\n+----------------------+\n \nSELECT ROUND(SIN(PI()));\n+------------------+\n| ROUND(SIN(PI())) |\n+------------------+\n| 0 |\n+------------------+
[SLEEP]
declaration=duration
category=Miscellaneous Functions
description=Sleeps (pauses) for the number of seconds given by the\nduration argument, then\nreturns 0. If SLEEP() is interrupted, it\nreturns 1. The duration may have a fractional part given in\nmicroseconds.\n \nStatements using the SLEEP() function are not safe for\nreplication.\n \nExample\n \nSELECT SLEEP(5.5);\n+------------+\n| SLEEP(5.5) |\n+------------+\n| 0 |\n+------------+\n1 row in set (5.50 sec)
[SOUNDEX]
declaration=str
category=String Functions
description=Returns a soundex string from str. Two strings that sound\nalmost the\nsame should have identical soundex strings. A standard\nsoundex string is four\ncharacters long, but the SOUNDEX() function returns an\narbitrarily long\nstring. You can use SUBSTRING() on the result to get a\nstandard soundex\nstring. All non-alphabetic characters in str are ignored.\nAll\ninternational alphabetic characters outside the A-Z range\nare treated as\nvowels.\n \nImportant: When using SOUNDEX(), you should be aware of the\nfollowing limitations:\nThis function, as currently implemented, is intended to work\nwell with\n strings that are in the English language only. Strings in\nother languages may\n not produce reliable results.\n \n\nSOUNDEX(''Hello'');\n+------------------+\n| SOUNDEX(''Hello'') |\n+------------------+\n| H400 |\n+------------------+\n \nSELECT SOUNDEX(''MariaDB'');\n+--------------------+\n| SOUNDEX(''MariaDB'') |\n+--------------------+\n| M631 |\n+--------------------+\n \nSELECT SOUNDEX(''Knowledgebase'');\n+--------------------------+\n| SOUNDEX(''Knowledgebase'') |\n+--------------------------+\n| K543212 |\n+--------------------------+\n \nSELECT givenname, surname FROM users WHERE\nSOUNDEX(givenname) = SOUNDEX("robert");\n+-----------+---------+\n| givenname | surname |\n+-----------+---------+\n| Roberto | Castro |\n+-----------+---------+
[SPACE]
declaration=N
category=String Functions
description=Returns a string consisting of N space characters. If N is\nNULL, returns NULL.\n \n\nSELECT QUOTE(SPACE(6));\n+-----------------+\n| QUOTE(SPACE(6)) |\n+-----------------+\n| '' '' |\n+-----------------+
[SPIDER_BG_DIRECT_SQL]
declaration=''sql'', ''tmp_table_list'', ''parameters''
category=Spider Functions
description=Executes the given SQL statement in the background on the\nremote server, as defined in the parameters listing. If the\nquery returns a result-set, it sttores the results in the\ngiven temporary table. When the given SQL statement executes\nsuccessfully, this function returns the number of called\nUDF''s. It returns 0 when the given SQL statement fails.\n \nThis function is a UDF installed with the Spider storage\nengine.\n \n\nSELECT SPIDER_BG_DIRECT_SQL(''SELECT * FROM example_table'',\n'''', \n ''srv "node1", port "8607"'') AS "Direct Query";\n+--------------+\n| Direct Query | \n+--------------+\n| 1 |\n+--------------+\n \nParameters\n \nerror_rw_mode\n \nDescription: Returns empty results on network error.\n0 : Return error on getting network error.\n1: Return 0 records on getting network error.\n \nDefault Table Value: 0\nDSN Parameter Name: erwm
[SPIDER_COPY_TABLES]
declaration=spider_table_name,   source_link_id, destination_link_id_list [,parameters]
category=Spider Functions
description=A UDF installed with the Spider Storage Engine, this\nfunction copies table data from source_link_id to\ndestination_link_id_list. The service does not need to be\nstopped in order to copy.\n \nIf the Spider table is partitioned, the name must be of the\nformat table_name#P#partition_name. The partition name can\nbe viewed in the mysql.spider_tables table, for example:\n \nSELECT table_name FROM mysql.spider_tables;\n+-------------+\n| table_name |\n+-------------+\n| spt_a#P#pt1 |\n| spt_a#P#pt2 |\n| spt_a#P#pt3 |\n+-------------+\n \nReturns 1 if the data was copied successfully, or 0 if\ncopying the data failed.
[SPIDER_DIRECT_SQL]
declaration=''sql'', ''tmp_table_list'', ''parameters''
category=Spider Functions
description=A UDF installed with the Spider Storage Engine, this\nfunction is used to execute the SQL string sql on the remote\nserver, as defined in parameters. If any resultsets are\nreturned, they are stored in the tmp_table_list.\n \nThe function returns 1 if the SQL executes successfully, or\n0 if it fails.\n \n\nSELECT SPIDER_DIRECT_SQL(''SELECT * FROM s'', '''', ''srv\n"node1", port "8607"'');\n+----------------------------------------------------------------------+\n| SPIDER_DIRECT_SQL(''SELECT * FROM s'', '''', ''srv\n"node1", port "8607"'') |\n+----------------------------------------------------------------------+\n| 1 |\n+----------------------------------------------------------------------+
[SPIDER_FLUSH_TABLE_MON_CACHE]
declaration=
category=Spider Functions
description=A UDF installed with the Spider Storage Engine, this\nfunction is used for refreshing monitoring server\ninformation. It returns a value of 1.\n \n\nSELECT SPIDER_FLUSH_TABLE_MON_CACHE();\n+--------------------------------+\n| SPIDER_FLUSH_TABLE_MON_CACHE() |\n+--------------------------------+\n| 1 |\n+--------------------------------+
[SQRT]
declaration=X
category=Numeric Functions
description=Returns the square root of X. If X is negative, NULL is\nreturned.\n \n\nSELECT SQRT(4);\n+---------+\n| SQRT(4) |\n+---------+\n| 2 |\n+---------+\n \nSELECT SQRT(20);\n+------------------+\n| SQRT(20) |\n+------------------+\n| 4.47213595499958 |\n+------------------+\n \nSELECT SQRT(-16);\n+-----------+\n| SQRT(-16) |\n+-----------+\n| NULL |\n+-----------+\n \nSELECT SQRT(1764);\n+------------+\n| SQRT(1764) |\n+------------+\n| 42 |\n+------------+
[STDDEV]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the population standard deviation of expr. This\nfunction is\nprovided for compatibility with Oracle. The standard SQL\nfunction\nSTDDEV_POP() can be used instead.\n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, STDDEV() can be used as a window\nfunction.\n \nThis function returns NULL if there were no matching rows.\n \n\nAs an aggregate function:\n \nCREATE OR REPLACE TABLE stats (category VARCHAR(2), x INT);\n \nINSERT INTO stats VALUES \n (''a'',1),(''a'',2),(''a'',3),\n (''b'',11),(''b'',12),(''b'',20),(''b'',30),(''b'',60);\n \nSELECT category, STDDEV_POP(x), STDDEV_SAMP(x), VAR_POP(x) \n FROM stats GROUP BY category;\n \n+----------+---------------+----------------+------------+\n| category | STDDEV_POP(x) | STDDEV_SAMP(x) | VAR_POP(x) |\n+----------+---------------+----------------+------------+\n| a | 0.8165 | 1.0000 | 0.6667 |\n| b | 18.0400 | 20.1693 | 325.4400 |\n+----------+---------------+----------------+------------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\n \nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, STDDEV_POP(score) \n OVER (PARTITION BY test) AS stddev_results FROM\nstudent_test;\n \n+---------+--------+-------+----------------+\n| name | test | score | stddev_results |\n+---------+--------+-------+----------------+\n| Chun | SQL | 75 | 16.9466 |\n| Chun | Tuning | 73 | 24.1247 |\n| Esben | SQL | 43 | 16.9466 |\n| Esben | Tuning | 31 | 24.1247 |\n| Kaolin | SQL | 56 | 16.9466 |\n| Kaolin | Tuning | 88 | 24.1247 |\n| Tatiana | SQL | 87 | 16.9466 |\n+---------+--------+-------+----------------+
[STDDEV_POP]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the population standard deviation of expr (the\nsquare root of\nVAR_POP()). You can also use STD() or\nSTDDEV(), which are equivalent but not standard SQL.\n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, STDDEV_POP() can be used as a window\nfunction.\n \nSTDDEV_POP() returns NULL if there were no matching rows.\n \n\nAs an aggregate function:\n \nCREATE OR REPLACE TABLE stats (category VARCHAR(2), x INT);\n \nINSERT INTO stats VALUES \n (''a'',1),(''a'',2),(''a'',3),\n (''b'',11),(''b'',12),(''b'',20),(''b'',30),(''b'',60);\n \nSELECT category, STDDEV_POP(x), STDDEV_SAMP(x), VAR_POP(x) \n FROM stats GROUP BY category;\n \n+----------+---------------+----------------+------------+\n| category | STDDEV_POP(x) | STDDEV_SAMP(x) | VAR_POP(x) |\n+----------+---------------+----------------+------------+\n| a | 0.8165 | 1.0000 | 0.6667 |\n| b | 18.0400 | 20.1693 | 325.4400 |\n+----------+---------------+----------------+------------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\n \nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, STDDEV_POP(score) \n OVER (PARTITION BY test) AS stddev_results FROM\nstudent_test;\n \n+---------+--------+-------+----------------+\n| name | test | score | stddev_results |\n+---------+--------+-------+----------------+\n| Chun | SQL | 75 | 16.9466 |\n| Chun | Tuning | 73 | 24.1247 |\n| Esben | SQL | 43 | 16.9466 |\n| Esben | Tuning | 31 | 24.1247 |\n| Kaolin | SQL | 56 | 16.9466 |\n| Kaolin | Tuning | 88 | 24.1247 |\n| Tatiana | SQL | 87 | 16.9466 |\n+---------+--------+-------+----------------+
[STDDEV_SAMP]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the sample standard deviation of expr (the square\nroot of VAR_SAMP()).\n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, STDDEV_SAMP() can be used as a window\nfunction.\n \nSTDDEV_SAMP() returns NULL if there were no matching rows.
[STD]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the population standard deviation of expr. This is\nan extension\nto standard SQL. The standard SQL function STDDEV_POP() can\nbe used instead. \n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, STD() can be used as a window function.\n \nThis function returns NULL if there were no matching rows.\n \n\nAs an aggregate function:\n \nCREATE OR REPLACE TABLE stats (category VARCHAR(2), x INT);\n \nINSERT INTO stats VALUES \n (''a'',1),(''a'',2),(''a'',3),\n (''b'',11),(''b'',12),(''b'',20),(''b'',30),(''b'',60);\n \nSELECT category, STDDEV_POP(x), STDDEV_SAMP(x), VAR_POP(x) \n FROM stats GROUP BY category;\n \n+----------+---------------+----------------+------------+\n| category | STDDEV_POP(x) | STDDEV_SAMP(x) | VAR_POP(x) |\n+----------+---------------+----------------+------------+\n| a | 0.8165 | 1.0000 | 0.6667 |\n| b | 18.0400 | 20.1693 | 325.4400 |\n+----------+---------------+----------------+------------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\n \nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, STDDEV_POP(score) \n OVER (PARTITION BY test) AS stddev_results FROM\nstudent_test;\n \n+---------+--------+-------+----------------+\n| name | test | score | stddev_results |\n+---------+--------+-------+----------------+\n| Chun | SQL | 75 | 16.9466 |\n| Chun | Tuning | 73 | 24.1247 |\n| Esben | SQL | 43 | 16.9466 |\n| Esben | Tuning | 31 | 24.1247 |\n| Kaolin | SQL | 56 | 16.9466 |\n| Kaolin | Tuning | 88 | 24.1247 |\n| Tatiana | SQL | 87 | 16.9466 |\n+---------+--------+-------+----------------+
[STRCMP]
declaration=expr1,expr2
category=String Functions
description=STRCMP() returns 0 if the strings are the same, -1 if the\nfirst\nargument is smaller than the second according to the current\nsort order,\nand 1 otherwise.\n \n\nSELECT STRCMP(''text'', ''text2'');\n+-------------------------+\n| STRCMP(''text'', ''text2'') |\n+-------------------------+\n| -1 |\n+-------------------------+\n \nSELECT STRCMP(''text2'', ''text'');\n+-------------------------+\n| STRCMP(''text2'', ''text'') |\n+-------------------------+\n| 1 |\n+-------------------------+\n \nSELECT STRCMP(''text'', ''text'');\n+------------------------+\n| STRCMP(''text'', ''text'') |\n+------------------------+\n| 0 |\n+------------------------+
[STR_TO_DATE]
declaration=str,format
category=Date and Time Functions
description=This is the inverse of the DATE_FORMAT() function. It takes\na string str and a format string format. STR_TO_DATE()\nreturns a\nDATETIME value if the format string contains both date and\ntime parts, or a\nDATE or TIME value if the string contains only date or time\nparts.\n \nThe date, time, or datetime values contained in str should\nbe given in the format indicated by format. If str contains\nan illegal date, time, or datetime value, STR_TO_DATE()\nreturns NULL. An illegal value also produces a warning.\n \nThe options that can be used by STR_TO_DATE(), as well as\nits inverse DATE_FORMAT() and the FROM_UNIXTIME() function,\nare:\n \nOption | Description | \n \n%a | Short weekday name in current locale (Variable\nlc_time_names). | \n \n%b | Short form month name in current locale. For locale\nen_US this is one of:\nJan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov or Dec. | \n \n%c | Month with 1 or 2 digits. | \n \n%D | Day with English suffix ''th'', ''nd'', ''st'' or\n''rd''''. (1st, 2nd, 3rd...). | \n \n%d | Day with 2 digits. | \n \n%e | Day with 1 or 2 digits. | \n \n%f | Sub seconds 6 digits. | \n \n%H | Hour with 2 digits between 00-23. | \n \n%h | Hour with 2 digits between 01-12. | \n \n%I | Hour with 2 digits between 01-12. | \n \n%i | Minute with 2 digits. | \n \n%j | Day of the year (001-366) | \n \n%k | Hour with 1 digits between 0-23. | \n \n%l | Hour with 1 digits between 1-12. | \n \n%M | Full month name in current locale (Variable\nlc_time_names). | \n \n%m | Month with 2 digits. | \n \n%p | AM/PM according to current locale (Variable\nlc_time_names). | \n \n%r | Time in 12 hour format, followed by AM/PM. Short for\n''%I:%i:%S %p''. | \n \n%S | Seconds with 2 digits. | \n \n%s | Seconds with 2 digits. | \n \n%T | Time in 24 hour format. Short for ''%H:%i:%S''. | \n \n%U | Week number (00-53), when first day of the week is\nSunday. | \n \n%u | Week number (00-53), when first day of the week is\nMonday. | \n \n%V | Week number (01-53), when first day of the week is\nSunday. Used with %X. | \n \n%v | Week number (01-53), when first day of the week is\nMonday. Used with %x. | \n \n%W | Full weekday name in current locale (Variable\nlc_time_names). | \n \n%w | Day of the week. 0 = Sunday, 6 = Saturday. | \n \n%X | Year with 4 digits when first day of the week is\nSunday. Used with %V. | \n \n%x | Year with 4 digits when first day of the week is\nMonday. Used with %v. | \n \n%Y | Year with 4 digits. | \n \n%y | Year with 2 digits. | \n \n%# | For str_to_date(), skip all numbers. | \n \n%. | For str_to_date(), skip all punctation characters. | \n \n%@ | For str_to_date(), skip all alpha characters. | \n \n%% | A literal % character. | \n \n\nSELECT STR_TO_DATE(''Wednesday, June 2, 2014'', ''%W, %M %e,\n%Y'');\n+---------------------------------------------------------+\n| STR_TO_DATE(''Wednesday, June 2, 2014'', ''%W, %M %e,\n%Y'') |\n+---------------------------------------------------------+\n| 2014-06-02 |\n+---------------------------------------------------------+\n \nSELECT STR_TO_DATE(''Wednesday23423, June 2, 2014'', ''%W,\n%M %e, %Y'');\n+--------------------------------------------------------------+\n| STR_TO_DATE(''Wednesday23423, June 2, 2014'', ''%W, %M %e,\n%Y'') |\n+--------------------------------------------------------------+\n| NULL |\n+--------------------------------------------------------------+\n1 row in set, 1 warning (0.00 sec)\n \nSHOW WARNINGS;\n \n+---------+------+-----------------------------------------------------------------------------------+\n| Level | Code | Message |\n+---------+------+-----------------------------------------------------------------------------------+\n| Warning | 1411 | Incorrect datetime value:\n''Wednesday23423, June 2, 2014'' for function str_to_date |\n+---------+------+-----------------------------------------------------------------------------------+\n \nSELECT STR_TO_DATE(''Wednesday23423, June 2, 2014'', ''%W%#,\n%M %e, %Y'');\n+----------------------------------------------------------------+\n| STR_TO_DATE(''Wednesday23423, June 2, 2014'', ''%W%#, %M\n%e, %Y'') |\n+----------------------------------------------------------------+\n| 2014-06-02 |\n+----------------------------------------------------------------+
[ST_AREA]
declaration=poly
category=Polygon Properties
description=Returns as a double-precision number the area of the Polygon\nvalue poly, as measured in its spatial reference system.\n \nST_Area() and Area() are synonyms.\n \n\nSET @poly = ''Polygon((0 0,0 3,3 0,0 0),(1 1,1 2,2 1,1\n1))'';\n \nSELECT Area(GeomFromText(@poly));\n+---------------------------+\n| Area(GeomFromText(@poly)) |\n+---------------------------+\n| 4 |\n+---------------------------+
[ST_ASBINARY]
declaration=g
category=WKB
description=Converts a value in internal geometry format to its WKB\nrepresentation and returns the binary result.\n \nST_AsBinary(), AsBinary(), ST_AsWKB() and AsWKB() are\nsynonyms,\n \n\nSET @poly = ST_GeomFromText(''POLYGON((0 0,0 1,1 1,1 0,0\n0))'');\nSELECT ST_AsBinary(@poly);\n \nSELECT ST_AsText(ST_GeomFromWKB(ST_AsWKB(@poly)));\n+--------------------------------------------+\n| ST_AsText(ST_GeomFromWKB(ST_AsWKB(@poly))) |\n+--------------------------------------------+\n| POLYGON((0 0,0 1,1 1,1 0,0 0)) |\n+--------------------------------------------+
[ST_ASTEXT]
declaration=g
category=WKT
description=Converts a value in internal geometry format to its WKT\nrepresentation and returns the string result.\n \nST_AsText(), AsText(), ST_AsWKT() and AsWKT() are all\nsynonyms.\n \n\nSET @g = ''LineString(1 1,4 4,6 6)'';\n \nSELECT ST_AsText(ST_GeomFromText(@g));\n+--------------------------------+\n| ST_AsText(ST_GeomFromText(@g)) |\n+--------------------------------+\n| LINESTRING(1 1,4 4,6 6) |\n+--------------------------------+
[ST_BOUNDARY]
declaration=g
category=Geometry Properties
description=Returns a geometry that is the closure of the combinatorial\nboundary of the geometry value g.\n \nBOUNDARY() is a synonym.\n \n\nSELECT ST_AsText(ST_Boundary(ST_GeomFromText(''LINESTRING(3\n3,0 0, -3 3)'')));\n+----------------------------------------------------------------------+\n| ST_AsText(ST_Boundary(ST_GeomFromText(''LINESTRING(3 3,0\n0, -3 3)''))) |\n+----------------------------------------------------------------------+\n| MULTIPOINT(3 3,-3 3) |\n+----------------------------------------------------------------------+\n \nSELECT ST_AsText(ST_Boundary(ST_GeomFromText(''POLYGON((3\n3,0 0, -3 3, 3 3))'')));\n+--------------------------------------------------------------------------+\n| ST_AsText(ST_Boundary(ST_GeomFromText(''POLYGON((3 3,0 0,\n-3 3, 3 3))''))) |\n+--------------------------------------------------------------------------+\n| LINESTRING(3 3,0 0,-3 3,3 3) |\n+--------------------------------------------------------------------------+
[ST_BUFFER]
declaration=g1,r
category=Geometry Constructors
description=Returns a geometry that represents all points whose distance\nfrom geometry g1 is less than or equal to distance, or\nradius, r.\n \nUses for this function could include creating for example a\nnew geometry representing a buffer zone around an island.\n \nBUFFER() is a synonym.\n \n\nDetermining whether a point is within a buffer zone:\n \nSET @g1 = ST_GEOMFROMTEXT(''POLYGON((10 10, 10 20, 20 20, 20\n10, 10 10))'');\n \nSET @g2 = ST_GEOMFROMTEXT(''POINT(8 8)'');\n \nSELECT ST_WITHIN(@g2,ST_BUFFER(@g1,5));\n+---------------------------------+\n| ST_WITHIN(@g2,ST_BUFFER(@g1,5)) |\n+---------------------------------+\n| 1 |\n+---------------------------------+\n \nSELECT ST_WITHIN(@g2,ST_BUFFER(@g1,1));\n+---------------------------------+\n| ST_WITHIN(@g2,ST_BUFFER(@g1,1)) |\n+---------------------------------+\n| 0 |\n+---------------------------------+
[ST_CENTROID]
declaration=mpoly
category=Polygon Properties
description=Returns a point reflecting the mathematical centroid\n(geometric center) for the MultiPolygon mpoly. The resulting\npoint will not necessarily be on the MultiPolygon. \n \nST_Centroid() and Centroid() are synonyms.\n \n\nSET @poly = ST_GeomFromText(''POLYGON((0 0,20 0,20 20,0 20,0\n0))'');\nSELECT ST_AsText(ST_Centroid(@poly)) AS center;\n \n+--------------+\n| center |\n+--------------+\n| POINT(10 10) |\n+--------------+
[ST_CONTAINS]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether a geometry g1 completely\ncontains geometry g2.\n \nST_CONTAINS() uses object shapes, while CONTAINS(), based on\nthe original MySQL implementation, uses object bounding\nrectangles.\n \nST_CONTAINS tests the opposite relationship to ST_WITHIN().\n \n\nSET @g1 = ST_GEOMFROMTEXT(''POLYGON((175 150, 20 40, 50 60,\n125 100, 175 150))'');\n \nSET @g2 = ST_GEOMFROMTEXT(''POINT(174 149)'');\n \nSELECT ST_CONTAINS(@g1,@g2);\n+----------------------+\n| ST_CONTAINS(@g1,@g2) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSET @g2 = ST_GEOMFROMTEXT(''POINT(175 151)'');\n \nSELECT ST_CONTAINS(@g1,@g2);\n+----------------------+\n| ST_CONTAINS(@g1,@g2) |\n+----------------------+\n| 0 |\n+----------------------+
[ST_CONVEXHULL]
declaration=g
category=Geometry Constructors
description=Given a geometry, returns a geometry that is the minimum\nconvex geometry enclosing all geometries within the set.\nReturns NULL if the geometry value is NULL or an empty\nvalue.\n \nST_ConvexHull() and ConvexHull() are synonyms.\n \n\nThe ConvexHull of a single point is simply the single point:\n \nSET @g = ST_GEOMFROMTEXT(''Point(0 0)'');\n \nSELECT ST_ASTEXT(ST_CONVEXHULL(@g));\n+------------------------------+\n| ST_ASTEXT(ST_CONVEXHULL(@g)) |\n+------------------------------+\n| POINT(0 0) |\n+------------------------------+\n \nSET @g = ST_GEOMFROMTEXT(''MultiPoint(0 0, 1 2, 2 3)'');\n \nSELECT ST_ASTEXT(ST_CONVEXHULL(@g));\n+------------------------------+\n| ST_ASTEXT(ST_CONVEXHULL(@g)) |\n+------------------------------+\n| POLYGON((0 0,1 2,2 3,0 0)) |\n+------------------------------+\n \nSET @g = ST_GEOMFROMTEXT(''MultiPoint( 1 1, 2 2, 5 3, 7 2, 9\n3, 8 4, 6 6, 6 9, 4 9, 1 5 )'');\n \nSELECT ST_ASTEXT(ST_CONVEXHULL(@g));\n+----------------------------------------+\n| ST_ASTEXT(ST_CONVEXHULL(@g)) |\n+----------------------------------------+\n| POLYGON((1 1,1 5,4 9,6 9,9 3,7 2,1 1)) |\n+----------------------------------------+
[ST_CROSSES]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 if geometry g1 spatially crosses geometry g2.\nReturns NULL if g1 is a Polygon or a MultiPolygon, or if g2\nis a\nPoint or a MultiPoint. Otherwise, returns 0.\n \nThe term spatially crosses denotes a spatial relation\nbetween two\ngiven geometries that has the following properties:\nThe two geometries intersect\nTheir intersection results in a geometry that has a\ndimension that is one\n less than the maximum dimension of the two given geometries\nTheir intersection is not equal to either of the two given\ngeometries\n \nST_CROSSES() uses object shapes, while CROSSES(), based on\nthe original MySQL implementation, uses object bounding\nrectangles.\n \n\nSET @g1 = ST_GEOMFROMTEXT(''LINESTRING(174 149, 176 151)'');\n \nSET @g2 = ST_GEOMFROMTEXT(''POLYGON((175 150, 20 40, 50 60,\n125 100, 175 150))'');\n \nSELECT ST_CROSSES(@g1,@g2);\n+---------------------+\n| ST_CROSSES(@g1,@g2) |\n+---------------------+\n| 1 |\n+---------------------+\n \nSET @g1 = ST_GEOMFROMTEXT(''LINESTRING(176 149, 176 151)'');\n \nSELECT ST_CROSSES(@g1,@g2);\n+---------------------+\n| ST_CROSSES(@g1,@g2) |\n+---------------------+\n| 0 |\n+---------------------+
[ST_DIFFERENCE]
declaration=g1,g2
category=Geometry Relations
description=Returns a geometry representing the point set difference of\nthe given geometry values.\n \nExample\n \nSET @g1 = POINT(10,10), @g2 = POINT(20,20);\n \nSELECT ST_AsText(ST_Difference(@g1, @g2));\n+------------------------------------+\n| ST_AsText(ST_Difference(@g1, @g2)) |\n+------------------------------------+\n| POINT(10 10) |\n+------------------------------------+
[ST_DIMENSION]
declaration=g
category=Geometry Properties
description=Returns the inherent dimension of the geometry value g. The\nresult can\nbe\n \nDimension | Definition | \n \n -1 | empty geometry | \n \n 0 | geometry with no length or area | \n \n 1 | geometry with no area but nonzero length | \n \n 2 | geometry with nonzero area | \n \nST_Dimension() and Dimension() are synonyms.\n \n\nSELECT Dimension(GeomFromText(''LineString(1 1,2 2)''));\n+------------------------------------------------+\n| Dimension(GeomFromText(''LineString(1 1,2 2)'')) |\n+------------------------------------------------+\n| 1 |\n+------------------------------------------------+
[ST_DISJOINT]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether geometry g1 is spatially\ndisjoint from\n(does not intersect with) geometry g2.\n \nST_DISJOINT() uses object shapes, while DISJOINT(), based on\nthe original MySQL implementation, uses object bounding\nrectangles.\n \nST_DISJOINT() tests the opposite relationship to\nST_INTERSECTS().\n \n\nSET @g1 = ST_GEOMFROMTEXT(''POINT(0 0)'');\n \nSET @g2 = ST_GEOMFROMTEXT(''LINESTRING(2 0, 0 2)'');\n \nSELECT ST_DISJOINT(@g1,@g2);\n+----------------------+\n| ST_DISJOINT(@g1,@g2) |\n+----------------------+\n| 1 |\n+----------------------+\n \nSET @g2 = ST_GEOMFROMTEXT(''LINESTRING(0 0, 0 2)'');\n \nSELECT ST_DISJOINT(@g1,@g2);\n+----------------------+\n| ST_DISJOINT(@g1,@g2) |\n+----------------------+\n| 0 |\n+----------------------+
[ST_DISTANCE]
declaration=g1,g2
category=Geometry Relations
description=Returns the distance between two geometries, or null if not\ngiven valid inputs.\n \nExample\n \nSELECT ST_Distance(POINT(1,2),POINT(2,2));\n+------------------------------------+\n| ST_Distance(POINT(1,2),POINT(2,2)) |\n+------------------------------------+\n| 1 |\n+------------------------------------+
[ST_ENDPOINT]
declaration=ls
category=LineString Properties
description=Returns the Point that is the endpoint of the\nLineString value ls.\n \nST_EndPoint() and EndPoint() are synonyms.\n \n\nSET @ls = ''LineString(1 1,2 2,3 3)'';\n \nSELECT AsText(EndPoint(GeomFromText(@ls)));\n+-------------------------------------+\n| AsText(EndPoint(GeomFromText(@ls))) |\n+-------------------------------------+\n| POINT(3 3) |\n+-------------------------------------+
[ST_ENVELOPE]
declaration=g
category=Geometry Properties
description=Returns the Minimum Bounding Rectangle (MBR) for the\ngeometry value g. The result is returned as a Polygon value.\n \nThe polygon is defined by the corner points of the bounding\nbox:\n \nPOLYGON((MINX MINY, MAXX MINY, MAXX MAXY, MINX MAXY, MINX\nMINY))\n \nST_ENVELOPE() and ENVELOPE() are synonyms.\n \n\nSELECT AsText(ST_ENVELOPE(GeomFromText(''LineString(1 1,4\n4)'')));\n+----------------------------------------------------------+\n| AsText(ST_ENVELOPE(GeomFromText(''LineString(1 1,4 4)'')))\n|\n+----------------------------------------------------------+\n| POLYGON((1 1,4 1,4 4,1 4,1 1)) |\n+----------------------------------------------------------+
[ST_EQUALS]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether geometry g1 is spatially\nequal to geometry g2.\n \nST_EQUALS() uses object shapes, while EQUALS(), based on the\noriginal MySQL implementation, uses object bounding\nrectangles.\n \n\nSET @g1 = ST_GEOMFROMTEXT(''LINESTRING(174 149, 176 151)'');\n \nSET @g2 = ST_GEOMFROMTEXT(''LINESTRING(176 151, 174 149)'');\n \nSELECT ST_EQUALS(@g1,@g2);\n+--------------------+\n| ST_EQUALS(@g1,@g2) |\n+--------------------+\n| 1 |\n+--------------------+\n \nSET @g1 = ST_GEOMFROMTEXT(''POINT(0 2)'');\n \nSET @g1 = ST_GEOMFROMTEXT(''POINT(2 0)'');\n \nSELECT ST_EQUALS(@g1,@g2);\n+--------------------+\n| ST_EQUALS(@g1,@g2) |\n+--------------------+\n| 0 |\n+--------------------+
[ST_EXTERIORRING]
declaration=poly
category=Polygon Properties
description=Returns the exterior ring of the Polygon value poly as a\nLineString.\n \nST_ExteriorRing() and ExteriorRing() are synonyms.\n \n\nSET @poly = ''Polygon((0 0,0 3,3 3,3 0,0 0),(1 1,1 2,2 2,2\n1,1 1))'';\n \nSELECT AsText(ExteriorRing(GeomFromText(@poly)));\n+-------------------------------------------+\n| AsText(ExteriorRing(GeomFromText(@poly))) |\n+-------------------------------------------+\n| LINESTRING(0 0,0 3,3 3,3 0,0 0) |\n+-------------------------------------------+
[ST_GEOMCOLLFROMTEXT]
declaration=wkt[,srid]
category=WKT
description=Constructs a GEOMETRYCOLLECTION value using its WKT \nrepresentation and SRID.\n \nST_GeomCollFromText(), ST_GeometryCollectionFromText(),\nGeomCollFromText() and GeometryCollectionFromText() are all\nsynonyms.\n \nExample\n \nCREATE TABLE gis_geometrycollection (g GEOMETRYCOLLECTION);\nSHOW FIELDS FROM gis_geometrycollection;\n \nINSERT INTO gis_geometrycollection VALUES\n (GeomCollFromText(''GEOMETRYCOLLECTION(POINT(0 0),\nLINESTRING(0 0,10 10))'')),\n (GeometryFromWKB(AsWKB(GeometryCollection(Point(44, 6),\nLineString(Point(3, 6), Point(7, 9)))))),\n (GeomFromText(''GeometryCollection()'')),\n (GeomFromText(''GeometryCollection EMPTY''));
[ST_GEOMCOLLFROMWKB]
declaration=wkb[,srid]
category=WKB
description=Constructs a GEOMETRYCOLLECTION value using its WKB\nrepresentation and SRID.\n \nST_GeomCollFromWKB(), ST_GeometryCollectionFromWKB(),\nGeomCollFromWKB() and GeometryCollectionFromWKB() are\nsynonyms.\n \n\nSET @g =\nST_AsBinary(ST_GeomFromText(''GEOMETRYCOLLECTION(POLYGON((5\n5,10 5,10 10,5 5)),POINT(10 10))''));\n \nSELECT ST_AsText(ST_GeomCollFromWKB(@g));\n+----------------------------------------------------------------+\n| ST_AsText(ST_GeomCollFromWKB(@g)) |\n+----------------------------------------------------------------+\n| GEOMETRYCOLLECTION(POLYGON((5 5,10 5,10 10,5 5)),POINT(10\n10)) |\n+----------------------------------------------------------------+
[ST_GEOMETRYN]
declaration=gc,N
category=Geometry Properties
description=Returns the N-th geometry in the GeometryCollection gc.\nGeometries are numbered beginning with 1.\n \nST_GeometryN() and GeometryN() are synonyms.\n \nExample\n \nSET @gc = ''GeometryCollection(Point(1 1),LineString(12 14,\n9 11))'';\n \nSELECT AsText(GeometryN(GeomFromText(@gc),1));\n+----------------------------------------+\n| AsText(GeometryN(GeomFromText(@gc),1)) |\n+----------------------------------------+\n| POINT(1 1) |\n+----------------------------------------+
[ST_GEOMETRYTYPE]
declaration=g
category=Geometry Properties
description=Returns as a string the name of the geometry type of which\nthe\ngeometry instance g is a member. The name corresponds to one\nof the\ninstantiable Geometry subclasses.\n \nST_GeometryType() and GeometryType() are synonyms.\n \n\nSELECT GeometryType(GeomFromText(''POINT(1 1)''));\n+------------------------------------------+\n| GeometryType(GeomFromText(''POINT(1 1)'')) |\n+------------------------------------------+\n| POINT |\n+------------------------------------------+
[ST_GEOMFROMTEXT]
declaration=wkt[,srid]
category=WKT
description=Constructs a geometry value of any type using its WKT\nrepresentation and SRID.\n \nGeomFromText(), GeometryFromText(), ST_GeomFromText() and\nST_GeometryFromText() are all synonyms.\n \nExample\n \nSET @g = ST_GEOMFROMTEXT(''POLYGON((1 1,1 5,4 9,6 9,9 3,7\n2,1 1))'');
[ST_GEOMFROMWKB]
declaration=wkb[,srid]
category=WKB
description=Constructs a geometry value of any type using its WKB\nrepresentation and SRID.\n \nST_GeomFromWKB(), ST_GeometryFromWKB(), GeomFromWKB() and\nGeometryFromWKB() are synonyms.\n \n\nSET @g = ST_AsBinary(ST_LineFromText(''LINESTRING(0 4, 4\n6)''));\n \nSELECT ST_AsText(ST_GeomFromWKB(@g));\n+-------------------------------+\n| ST_AsText(ST_GeomFromWKB(@g)) |\n+-------------------------------+\n| LINESTRING(0 4,4 6) |\n+-------------------------------+
[ST_INTERIORRINGN]
declaration=poly,N
category=Polygon Properties
description=Returns the N-th interior ring for the Polygon value poly as\na LineString. Rings are numbered beginning with 1.\n \nST_InteriorRingN() and InteriorRingN() are synonyms.\n \n\nSET @poly = ''Polygon((0 0,0 3,3 3,3 0,0 0),(1 1,1 2,2 2,2\n1,1 1))'';\n \nSELECT AsText(InteriorRingN(GeomFromText(@poly),1));\n+----------------------------------------------+\n| AsText(InteriorRingN(GeomFromText(@poly),1)) |\n+----------------------------------------------+\n| LINESTRING(1 1,1 2,2 2,2 1,1 1) |\n+----------------------------------------------+
[ST_INTERSECTION]
declaration=g1,g2
category=Geometry Constructors
description=Returns a geometry that is the intersection, or shared\nportion, of geometry g1 and geometry g2.\n \n\nSET @g1 = ST_GEOMFROMTEXT(''POINT(2 1)'');\n \nSET @g2 = ST_GEOMFROMTEXT(''LINESTRING(2 1, 0 2)'');\n \nSELECT ASTEXT(ST_INTERSECTION(@g1,@g2));\n+----------------------------------+\n| ASTEXT(ST_INTERSECTION(@g1,@g2)) |\n+----------------------------------+\n| POINT(2 1) |\n+----------------------------------+
[ST_INTERSECTS]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether geometry g1 spatially\nintersects geometry g2.\n \nST_INTERSECTS() uses object shapes, while INTERSECTS(),\nbased on the original MySQL implementation, uses object\nbounding rectangles.\n \nST_INTERSECTS() tests the opposite relationship to\nST_DISJOINT().\n \n\nSET @g1 = ST_GEOMFROMTEXT(''POINT(0 0)'');\n \nSET @g2 = ST_GEOMFROMTEXT(''LINESTRING(0 0, 0 2)'');\n \nSELECT ST_INTERSECTS(@g1,@g2);\n+------------------------+\n| ST_INTERSECTS(@g1,@g2) |\n+------------------------+\n| 1 |\n+------------------------+\n \nSET @g2 = ST_GEOMFROMTEXT(''LINESTRING(2 0, 0 2)'');\n \nSELECT ST_INTERSECTS(@g1,@g2);\n+------------------------+\n| ST_INTERSECTS(@g1,@g2) |\n+------------------------+\n| 0 |\n+------------------------+
[ST_ISCLOSED]
declaration=g
category=Geometry Properties
description=Returns 1 if a given LINESTRING''s start and end points are\nthe same, or 0 if they are not the same. Before MariaDB\n10.1.5, returns NULL if not given a LINESTRING. After\nMariaDB 10.1.5, returns -1.\n \nST_IsClosed() and IsClosed() are synonyms.\n \n\nSET @ls = ''LineString(0 0, 0 4, 4 4, 0 0)'';\n \nSELECT ST_ISCLOSED(GEOMFROMTEXT(@ls));\n+--------------------------------+\n| ST_ISCLOSED(GEOMFROMTEXT(@ls)) |\n+--------------------------------+\n| 1 |\n+--------------------------------+\n \nSET @ls = ''LineString(0 0, 0 4, 4 4, 0 1)'';\n \nSELECT ST_ISCLOSED(GEOMFROMTEXT(@ls));\n+--------------------------------+\n| ST_ISCLOSED(GEOMFROMTEXT(@ls)) |\n+--------------------------------+\n| 0 |\n+--------------------------------+
[ST_ISEMPTY]
declaration=g
category=Geometry Properties
description=IsEmpty is a function defined by the OpenGIS specification,\nbut is not fully implemented by MariaDB or MySQL. \n \nSince MariaDB and MySQL do not support GIS EMPTY values such\nas POINT EMPTY, as implemented it simply returns 1 if the\ngeometry value g is invalid, 0 if it is valid, and NULL if\nthe argument is NULL.\n \nST_IsEmpty() and IsEmpty() are synonyms.
[ST_ISRING]
declaration=g
category=Geometry Properties
description=Returns true if a given LINESTRING is a ring, that is, both\nST_IsClosed and ST_IsSimple. A simple curve does not pass\nthrough the same point more than once. However, see\nMDEV-7510.\n \nSt_IsRing() and IsRing() are synonyms.
[ST_ISSIMPLE]
declaration=g
category=Geometry Properties
description=Returns true if the given Geometry has no anomalous\ngeometric points, false if it does, or NULL if given a NULL\nvalue.\n \nST_IsSimple() and IsSimple() are synonyms.\n \n\nA POINT is always simple.\n \nSET @g = ''Point(1 2)'';\n \nSELECT ST_ISSIMPLE(GEOMFROMTEXT(@g));\n+-------------------------------+\n| ST_ISSIMPLE(GEOMFROMTEXT(@g)) |\n+-------------------------------+\n| 1 |\n+-------------------------------+
[ST_LENGTH]
declaration=ls
category=Geometry Relations
description=Returns as a double-precision number the length of the\nLineString value ls in its associated spatial reference.\n \n\nSET @ls = ''LineString(1 1,2 2,3 3)'';\n \nSELECT ST_LENGTH(ST_GeomFromText(@ls));\n+---------------------------------+\n| ST_LENGTH(ST_GeomFromText(@ls)) |\n+---------------------------------+\n| 2.82842712474619 |\n+---------------------------------+
[ST_LINEFROMTEXT]
declaration=wkt[,srid]
category=WKT
description=Constructs a LINESTRING value using its WKT representation\nand SRID.\n \nST_LineFromText(), ST_LineStringFromText(),\nST_LineFromText() and ST_LineStringFromText() are all\nsynonyms.\n \n\nCREATE TABLE gis_line (g LINESTRING);\nSHOW FIELDS FROM gis_line;\n \nINSERT INTO gis_line VALUES\n (LineFromText(''LINESTRING(0 0,0 10,10 0)'')),\n (LineStringFromText(''LINESTRING(10 10,20 10,20 20,10 20,10\n10)'')),\n (LineStringFromWKB(AsWKB(LineString(Point(10, 10),\nPoint(40, 10)))));
[ST_LINEFROMWKB]
declaration=wkb[,srid]
category=WKB
description=Constructs a LINESTRING value using its WKB representation\nand SRID.\n \nST_LineFromWKB(), LineFromWKB(), ST_LineStringFromWKB(), and\nLineStringFromWKB() are synonyms.\n \n\nSET @g = ST_AsBinary(ST_LineFromText(''LineString(0 4,4\n6)''));\n \nSELECT ST_AsText(ST_LineFromWKB(@g)) AS l;\n \n+---------------------+\n| l |\n+---------------------+\n| LINESTRING(0 4,4 6) |\n+---------------------+
[ST_NUMGEOMETRIES]
declaration=gc
category=Geometry Properties
description=Returns the number of geometries in the GeometryCollection\ngc.\n \nST_NumGeometries() and NumGeometries() are synonyms.\n \nExample\n \nSET @gc = ''GeometryCollection(Point(1 1),LineString(2 2, 3\n3))'';\n \nSELECT NUMGEOMETRIES(GeomFromText(@gc));\n+----------------------------------+\n| NUMGEOMETRIES(GeomFromText(@gc)) |\n+----------------------------------+\n| 2 |\n+----------------------------------+
[ST_NUMINTERIORRINGS]
declaration=poly
category=Polygon Properties
description=Returns an integer containing the number of interior rings\nin the Polygon value poly.\n \nNote that according the the OpenGIS standard, a POLYGON\nshould have exactly one ExteriorRing and all other rings\nshould lie within that ExteriorRing and thus be the\nInteriorRings. Practically, however, some systems, including\nMariaDB''s, permit polygons to have several\n''ExteriorRings''. In the case of there being multiple,\nnon-overlapping exterior rings ST_NumInteriorRings() will\nreturn 1.\n \nST_NumInteriorRings() and NumInteriorRings() are synonyms.\n \n\nSET @poly = ''Polygon((0 0,0 3,3 3,3 0,0 0),(1 1,1 2,2 2,2\n1,1 1))'';\n \nSELECT NumInteriorRings(GeomFromText(@poly));\n+---------------------------------------+\n| NumInteriorRings(GeomFromText(@poly)) |\n+---------------------------------------+\n| 1 |\n+---------------------------------------+\n \nNon-overlapping ''polygon'':\n \nSELECT ST_NumInteriorRings(ST_PolyFromText(''POLYGON((0 0,10\n0,10 10,0 10,0 0),\n (-1 -1,-5 -1,-5 -5,-1 -5,-1 -1))'')) AS NumInteriorRings;\n \n+------------------+\n| NumInteriorRings |\n+------------------+\n| 1 |\n+------------------+
[ST_NUMPOINTS]
declaration=ls
category=LineString Properties
description=Returns the number of Point objects in the LineString\nvalue ls.\n \nST_NumPoints() and NumPoints() are synonyms.\n \n\nSET @ls = ''LineString(1 1,2 2,3 3)'';\n \nSELECT NumPoints(GeomFromText(@ls));\n+------------------------------+\n| NumPoints(GeomFromText(@ls)) |\n+------------------------------+\n| 3 |\n+------------------------------+
[ST_OVERLAPS]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether geometry g1 spatially\noverlaps geometry g2.\n \nThe term spatially overlaps is used if two geometries\nintersect and their\nintersection results in a geometry of the same dimension but\nnot equal to\neither of the given geometries.\n \nST_OVERLAPS() uses object shapes, while OVERLAPS(), based on\nthe original MySQL implementation, uses object bounding\nrectangles.
[ST_POINTFROMTEXT]
declaration=wkt[,srid]
category=WKT
description=Constructs a POINT value using its WKT representation and\nSRID.\n \nST_PointFromText() and PointFromText() are synonyms.\n \n\nCREATE TABLE gis_point (g POINT);\nSHOW FIELDS FROM gis_point;\n \nINSERT INTO gis_point VALUES\n (PointFromText(''POINT(10 10)'')),\n (PointFromText(''POINT(20 10)'')),\n (PointFromText(''POINT(20 20)'')),\n (PointFromWKB(AsWKB(PointFromText(''POINT(10 20)''))));
[ST_POINTFROMWKB]
declaration=wkb[,srid]
category=WKB
description=Constructs a POINT value using its WKB representation and\nSRID.\n \nST_PointFromWKB() and PointFromWKB() are synonyms.\n \n\nSET @g = ST_AsBinary(ST_PointFromText(''POINT(0 4)''));\n \nSELECT ST_AsText(ST_PointFromWKB(@g)) AS p;\n \n+------------+\n| p |\n+------------+\n| POINT(0 4) |\n+------------+
[ST_POINTN]
declaration=ls,N
category=LineString Properties
description=Returns the N-th Point in the LineString value ls.\nPoints are numbered beginning with 1.\n \nST_PointN() and PointN() are synonyms.\n \n\nSET @ls = ''LineString(1 1,2 2,3 3)'';\n \nSELECT AsText(PointN(GeomFromText(@ls),2));\n+-------------------------------------+\n| AsText(PointN(GeomFromText(@ls),2)) |\n+-------------------------------------+\n| POINT(2 2) |\n+-------------------------------------+
[ST_POINTONSURFACE]
declaration=g
category=Geometry Constructors
description=Given a geometry, returns a POINT guaranteed to intersect a\nsurface. However, see MDEV-7514.\n \nST_PointOnSurface() and PointOnSurface() are synonyms.
[ST_POLYFROMTEXT]
declaration=wkt[,srid]
category=WKT
description=Constructs a POLYGON value using its WKT representation and\nSRID.\n \nST_PolyFromText(), ST_PolygonFromText(), PolyFromText() and\nST_PolygonFromText() are all synonyms.\n \n\nCREATE TABLE gis_polygon (g POLYGON);\nINSERT INTO gis_polygon VALUES\n (PolygonFromText(''POLYGON((10 10,20 10,20 20,10 20,10\n10))'')),\n (PolyFromText(''POLYGON((0 0,50 0,50 50,0 50,0 0), (10\n10,20 10,20 20,10 20,10 10))''));
[ST_POLYFROMWKB]
declaration=wkb[,srid]
category=WKB
description=Constructs a POLYGON value using its WKB representation and\nSRID.\n \nST_PolyFromWKB(), ST_PolygonFromWKB(), PolyFromWKB() and\nPolygonFromWKB() are synonyms.\n \n\nSET @g = ST_AsBinary(ST_PolyFromText(''POLYGON((1 1,1 5,4\n9,6 9,9 3,7 2,1 1))''));\n \nSELECT ST_AsText(ST_PolyFromWKB(@g)) AS p;\n \n+----------------------------------------+\n| p |\n+----------------------------------------+\n| POLYGON((1 1,1 5,4 9,6 9,9 3,7 2,1 1)) |\n+----------------------------------------+
[ST_RELATE]
declaration=g1, g2, i
category=Geometry Properties
description=Returns true if Geometry g1 is spatially related to\nGeometryg2 by testing for intersections between the\ninterior, boundary and exterior of the two geometries as\nspecified by the values in intersection matrix pattern i.
[ST_SRID]
declaration=g
category=Geometry Properties
description=Returns an integer indicating the Spatial Reference System\nID for the\ngeometry value g.\n \nIn MariaDB, the SRID value is just an integer associated\nwith the\ngeometry value. All calculations are done assuming Euclidean\n(planar)\ngeometry.\n \nST_SRID() and SRID() are synonyms.\n \n\nSELECT SRID(GeomFromText(''LineString(1 1,2 2)'',101));\n+-----------------------------------------------+\n| SRID(GeomFromText(''LineString(1 1,2 2)'',101)) |\n+-----------------------------------------------+\n| 101 |\n+-----------------------------------------------+
[ST_SYMDIFFERENCE]
declaration=g1,g2
category=Geometry Constructors
description=Returns a geometry that represents the portions of geometry\ng1 and geometry g2 that don''t intersect.\n \n\nSET @g1 = ST_GEOMFROMTEXT(''LINESTRING(10 20, 10 40)'');\n \nSET @g2 = ST_GEOMFROMTEXT(''LINESTRING(10 15, 10 25)'');\n \nSELECT ASTEXT(ST_SYMDIFFERENCE(@g1,@g2));\n+----------------------------------------------+\n| ASTEXT(ST_SYMDIFFERENCE(@g1,@g2)) |\n+----------------------------------------------+\n| MULTILINESTRING((10 15,10 20),(10 25,10 40)) |\n+----------------------------------------------+\n \nSET @g2 = ST_GeomFromText(''LINESTRING(10 20, 10 41)'');\n \nSELECT ASTEXT(ST_SYMDIFFERENCE(@g1,@g2));\n+-----------------------------------+\n| ASTEXT(ST_SYMDIFFERENCE(@g1,@g2)) |\n+-----------------------------------+\n| LINESTRING(10 40,10 41) |\n+-----------------------------------+
[ST_TOUCHES]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether geometry g1 spatially\ntouches geometry g2. Two geometries spatially touch if the\ninteriors of the geometries do not intersect,\nbut the boundary of one of the geometries intersects either\nthe boundary or the\ninterior of the other.\n \nST_TOUCHES() uses object shapes, while TOUCHES(), based on\nthe original MySQL implementation, uses object bounding\nrectangles.\n \n\nSET @g1 = ST_GEOMFROMTEXT(''POINT(2 0)'');\n \nSET @g2 = ST_GEOMFROMTEXT(''LINESTRING(2 0, 0 2)'');\n \nSELECT ST_TOUCHES(@g1,@g2);\n+---------------------+\n| ST_TOUCHES(@g1,@g2) |\n+---------------------+\n| 1 |\n+---------------------+\n \nSET @g1 = ST_GEOMFROMTEXT(''POINT(2 1)'');\n \nSELECT ST_TOUCHES(@g1,@g2);\n+---------------------+\n| ST_TOUCHES(@g1,@g2) |\n+---------------------+\n| 0 |\n+---------------------+
[ST_UNION]
declaration=g1,g2
category=Geometry Constructors
description=Returns a geometry that is the union of the geometry g1 and\ngeometry g2.\n \n\nSET @g1 = GEOMFROMTEXT(''POINT (0 2)'');\n \nSET @g2 = GEOMFROMTEXT(''POINT (2 0)'');\n \nSELECT ASTEXT(ST_UNION(@g1,@g2));\n+---------------------------+\n| ASTEXT(ST_UNION(@g1,@g2)) |\n+---------------------------+\n| MULTIPOINT(2 0,0 2) |\n+---------------------------+\n \nSET @g1 = GEOMFROMTEXT(''POLYGON((0 0,0 3,3 3,3 0,0 0))'');\n \nSET @g2 = GEOMFROMTEXT(''POLYGON((2 2,4 2,4 4,2 4,2 2))'');\n \nSELECT ASTEXT(ST_UNION(@g1,@g2));\n+------------------------------------------------+\n| ASTEXT(ST_UNION(@g1,@g2)) |\n+------------------------------------------------+\n| POLYGON((0 0,0 3,2 3,2 4,4 4,4 2,3 2,3 0,0 0)) |\n+------------------------------------------------+
[ST_WITHIN]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether geometry g1 is spatially\nwithin geometry g2.\n \nThis tests the opposite relationship as ST_CONTAINS().\n \nST_WITHIN() uses object shapes, while WITHIN(), based on the\noriginal MySQL implementation, uses object bounding\nrectangles.\n \n\nSET @g1 = ST_GEOMFROMTEXT(''POINT(174 149)'');\n \nSET @g2 = ST_GEOMFROMTEXT(''POLYGON((175 150, 20 40, 50 60,\n125 100, 175 150))'');\n \nSELECT ST_WITHIN(@g1,@g2);\n+--------------------+\n| ST_WITHIN(@g1,@g2) |\n+--------------------+\n| 1 |\n+--------------------+\n \nSET @g1 = ST_GEOMFROMTEXT(''POINT(176 151)'');\n \nSELECT ST_WITHIN(@g1,@g2);\n+--------------------+\n| ST_WITHIN(@g1,@g2) |\n+--------------------+\n| 0 |\n+--------------------+
[ST_X]
declaration=p
category=Point Properties
description=Returns the X-coordinate value for the point p as a\ndouble-precision number.\n \nST_X() and X() are synonyms.\n \n\nSET @pt = ''Point(56.7 53.34)'';\n \nSELECT X(GeomFromText(@pt));\n+----------------------+\n| X(GeomFromText(@pt)) |\n+----------------------+\n| 56.7 |\n+----------------------+
[ST_Y]
declaration=p
category=Point Properties
description=Returns the Y-coordinate value for the point p as a\ndouble-precision number.\n \nST_Y() and Y() are synonyms.\n \n\nSET @pt = ''Point(56.7 53.34)'';\n \nSELECT Y(GeomFromText(@pt));\n+----------------------+\n| Y(GeomFromText(@pt)) |\n+----------------------+\n| 53.34 |\n+----------------------+
[SUBDATE1]
name=SUBDATE
declaration=date,INTERVAL expr unit
category=Date and Time Functions
description=When invoked with the INTERVAL form of the second argument,\nSUBDATE()\nis a synonym for DATE_SUB(). See Date and Time Units for a\ncomplete list of permitted units. \n \nThe second form allows the use of an integer value for days.\nIn such\ncases, it is interpreted as the number of days to be\nsubtracted from\nthe date or datetime expression expr.\n \n\nSELECT DATE_SUB(''2008-01-02'', INTERVAL 31 DAY);\n+-----------------------------------------+\n| DATE_SUB(''2008-01-02'', INTERVAL 31 DAY) |\n+-----------------------------------------+\n| 2007-12-02 |\n+-----------------------------------------+\n \nSELECT SUBDATE(''2008-01-02'', INTERVAL 31 DAY);\n+----------------------------------------+\n| SUBDATE(''2008-01-02'', INTERVAL 31 DAY) |\n+----------------------------------------+\n| 2007-12-02 |\n+----------------------------------------+\n \nSELECT SUBDATE(''2008-01-02 12:00:00'', 31);\n+------------------------------------+\n| SUBDATE(''2008-01-02 12:00:00'', 31) |\n+------------------------------------+\n| 2007-12-02 12:00:00 |\n+------------------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d, SUBDATE(d, 10) from t1;\n \n+---------------------+---------------------+\n| d | SUBDATE(d, 10) |\n+---------------------+---------------------+\n| 2007-01-30 21:31:07 | 2007-01-20 21:31:07 |\n| 1983-10-15 06:42:51 | 1983-10-05 06:42:51 |\n| 2011-04-21 12:34:56 | 2011-04-11 12:34:56 |\n| 2011-10-30 06:31:41 | 2011-10-20 06:31:41 |\n| 2011-01-30 14:03:25 | 2011-01-20 14:03:25 |\n| 2004-10-07 11:19:34 | 2004-09-27 11:19:34 |\n+---------------------+---------------------+\n \nSELECT d, SUBDATE(d, INTERVAL 10 MINUTE) from t1;\n \n+---------------------+--------------------------------+\n| d | SUBDATE(d, INTERVAL 10 MINUTE) |\n+---------------------+--------------------------------+\n| 2007-01-30 21:31:07 | 2007-01-30 21:21:07 |\n| 1983-10-15 06:42:51 | 1983-10-15 06:32:51 |\n| 2011-04-21 12:34:56 | 2011-04-21 12:24:56 |\n| 2011-10-30 06:31:41 | 2011-10-30 06:21:41 |\n| 2011-01-30 14:03:25 | 2011-01-30 13:53:25 |\n| 2004-10-07 11:19:34 | 2004-10-07 11:09:34 |\n+---------------------+--------------------------------+
[SUBDATE2]
name=SUBDATE
declaration=expr,days
category=Date and Time Functions
description=When invoked with the INTERVAL form of the second argument,\nSUBDATE()\nis a synonym for DATE_SUB(). See Date and Time Units for a\ncomplete list of permitted units. \n \nThe second form allows the use of an integer value for days.\nIn such\ncases, it is interpreted as the number of days to be\nsubtracted from\nthe date or datetime expression expr.\n \n\nSELECT DATE_SUB(''2008-01-02'', INTERVAL 31 DAY);\n+-----------------------------------------+\n| DATE_SUB(''2008-01-02'', INTERVAL 31 DAY) |\n+-----------------------------------------+\n| 2007-12-02 |\n+-----------------------------------------+\n \nSELECT SUBDATE(''2008-01-02'', INTERVAL 31 DAY);\n+----------------------------------------+\n| SUBDATE(''2008-01-02'', INTERVAL 31 DAY) |\n+----------------------------------------+\n| 2007-12-02 |\n+----------------------------------------+\n \nSELECT SUBDATE(''2008-01-02 12:00:00'', 31);\n+------------------------------------+\n| SUBDATE(''2008-01-02 12:00:00'', 31) |\n+------------------------------------+\n| 2007-12-02 12:00:00 |\n+------------------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d, SUBDATE(d, 10) from t1;\n \n+---------------------+---------------------+\n| d | SUBDATE(d, 10) |\n+---------------------+---------------------+\n| 2007-01-30 21:31:07 | 2007-01-20 21:31:07 |\n| 1983-10-15 06:42:51 | 1983-10-05 06:42:51 |\n| 2011-04-21 12:34:56 | 2011-04-11 12:34:56 |\n| 2011-10-30 06:31:41 | 2011-10-20 06:31:41 |\n| 2011-01-30 14:03:25 | 2011-01-20 14:03:25 |\n| 2004-10-07 11:19:34 | 2004-09-27 11:19:34 |\n+---------------------+---------------------+\n \nSELECT d, SUBDATE(d, INTERVAL 10 MINUTE) from t1;\n \n+---------------------+--------------------------------+\n| d | SUBDATE(d, INTERVAL 10 MINUTE) |\n+---------------------+--------------------------------+\n| 2007-01-30 21:31:07 | 2007-01-30 21:21:07 |\n| 1983-10-15 06:42:51 | 1983-10-15 06:32:51 |\n| 2011-04-21 12:34:56 | 2011-04-21 12:24:56 |\n| 2011-10-30 06:31:41 | 2011-10-30 06:21:41 |\n| 2011-01-30 14:03:25 | 2011-01-30 13:53:25 |\n| 2004-10-07 11:19:34 | 2004-10-07 11:09:34 |\n+---------------------+--------------------------------+
[SUBSTRING1]
name=SUBSTRING
declaration=str,pos
category=String Functions
description=The forms without a len argument return a substring from\nstring str starting at position pos.\n \nThe forms with a len argument return a substring len\ncharacters long from string str, starting at position pos.\n \nThe forms that use FROM are standard SQL syntax.\n \nIt is also possible to use a negative value for pos. In this\ncase, the beginning of the substring is pos characters from\nthe end of the string, rather than the beginning. A negative\nvalue may be used for pos in any of the forms of this\nfunction.\n \nBy default, the position of the first character in the\nstring from which the substring is to be extracted is\nreckoned as 1. For Oracle-compatibility, from MariaDB\n10.3.3, when sql_mode is set to ''oracle'', position zero is\ntreated as position 1 (although the first character is still\nreckoned as 1).\n \nIf any argument is NULL, returns NULL.\n \n\nSELECT SUBSTRING(''Knowledgebase'',5);\n+------------------------------+\n| SUBSTRING(''Knowledgebase'',5) |\n+------------------------------+\n| ledgebase |\n+------------------------------+\n \nSELECT SUBSTRING(''MariaDB'' FROM 6);\n+-----------------------------+\n| SUBSTRING(''MariaDB'' FROM 6) |\n+-----------------------------+\n| DB |\n+-----------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'',3,7);\n+--------------------------------+\n| SUBSTRING(''Knowledgebase'',3,7) |\n+--------------------------------+\n| owledge |\n+--------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'', -4);\n+--------------------------------+\n| SUBSTRING(''Knowledgebase'', -4) |\n+--------------------------------+\n| base |\n+--------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'', -8, 4);\n+-----------------------------------+\n| SUBSTRING(''Knowledgebase'', -8, 4) |\n+-----------------------------------+\n| edge |\n+-----------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'' FROM -8 FOR 4);\n+------------------------------------------+\n| SUBSTRING(''Knowledgebase'' FROM -8 FOR 4) |\n+------------------------------------------+\n| edge |\n+------------------------------------------+\n \nOracle mode from MariaDB 10.3.3:\n \nSELECT SUBSTR(''abc'',0,3);\n+-------------------+\n| SUBSTR(''abc'',0,3) |\n+-------------------+\n| |\n+-------------------+\n \nSELECT SUBSTR(''abc'',1,2);\n+-------------------+\n| SUBSTR(''abc'',1,2) |\n+-------------------+\n| ab |\n+-------------------+\n \nSET sql_mode=''oracle'';\n \nSELECT SUBSTR(''abc'',0,3);\n+-------------------+\n| SUBSTR(''abc'',0,3) |\n+-------------------+\n| abc |\n+-------------------+\n \nSELECT SUBSTR(''abc'',1,2);\n+-------------------+\n| SUBSTR(''abc'',1,2) |\n+-------------------+\n| ab |\n+-------------------+
[SUBSTRING2]
name=SUBSTRING
declaration=str FROM pos
category=String Functions
description=The forms without a len argument return a substring from\nstring str starting at position pos.\n \nThe forms with a len argument return a substring len\ncharacters long from string str, starting at position pos.\n \nThe forms that use FROM are standard SQL syntax.\n \nIt is also possible to use a negative value for pos. In this\ncase, the beginning of the substring is pos characters from\nthe end of the string, rather than the beginning. A negative\nvalue may be used for pos in any of the forms of this\nfunction.\n \nBy default, the position of the first character in the\nstring from which the substring is to be extracted is\nreckoned as 1. For Oracle-compatibility, from MariaDB\n10.3.3, when sql_mode is set to ''oracle'', position zero is\ntreated as position 1 (although the first character is still\nreckoned as 1).\n \nIf any argument is NULL, returns NULL.\n \n\nSELECT SUBSTRING(''Knowledgebase'',5);\n+------------------------------+\n| SUBSTRING(''Knowledgebase'',5) |\n+------------------------------+\n| ledgebase |\n+------------------------------+\n \nSELECT SUBSTRING(''MariaDB'' FROM 6);\n+-----------------------------+\n| SUBSTRING(''MariaDB'' FROM 6) |\n+-----------------------------+\n| DB |\n+-----------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'',3,7);\n+--------------------------------+\n| SUBSTRING(''Knowledgebase'',3,7) |\n+--------------------------------+\n| owledge |\n+--------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'', -4);\n+--------------------------------+\n| SUBSTRING(''Knowledgebase'', -4) |\n+--------------------------------+\n| base |\n+--------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'', -8, 4);\n+-----------------------------------+\n| SUBSTRING(''Knowledgebase'', -8, 4) |\n+-----------------------------------+\n| edge |\n+-----------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'' FROM -8 FOR 4);\n+------------------------------------------+\n| SUBSTRING(''Knowledgebase'' FROM -8 FOR 4) |\n+------------------------------------------+\n| edge |\n+------------------------------------------+\n \nOracle mode from MariaDB 10.3.3:\n \nSELECT SUBSTR(''abc'',0,3);\n+-------------------+\n| SUBSTR(''abc'',0,3) |\n+-------------------+\n| |\n+-------------------+\n \nSELECT SUBSTR(''abc'',1,2);\n+-------------------+\n| SUBSTR(''abc'',1,2) |\n+-------------------+\n| ab |\n+-------------------+\n \nSET sql_mode=''oracle'';\n \nSELECT SUBSTR(''abc'',0,3);\n+-------------------+\n| SUBSTR(''abc'',0,3) |\n+-------------------+\n| abc |\n+-------------------+\n \nSELECT SUBSTR(''abc'',1,2);\n+-------------------+\n| SUBSTR(''abc'',1,2) |\n+-------------------+\n| ab |\n+-------------------+
[SUBSTRING3]
name=SUBSTRING
declaration=str,pos,len
category=String Functions
description=The forms without a len argument return a substring from\nstring str starting at position pos.\n \nThe forms with a len argument return a substring len\ncharacters long from string str, starting at position pos.\n \nThe forms that use FROM are standard SQL syntax.\n \nIt is also possible to use a negative value for pos. In this\ncase, the beginning of the substring is pos characters from\nthe end of the string, rather than the beginning. A negative\nvalue may be used for pos in any of the forms of this\nfunction.\n \nBy default, the position of the first character in the\nstring from which the substring is to be extracted is\nreckoned as 1. For Oracle-compatibility, from MariaDB\n10.3.3, when sql_mode is set to ''oracle'', position zero is\ntreated as position 1 (although the first character is still\nreckoned as 1).\n \nIf any argument is NULL, returns NULL.\n \n\nSELECT SUBSTRING(''Knowledgebase'',5);\n+------------------------------+\n| SUBSTRING(''Knowledgebase'',5) |\n+------------------------------+\n| ledgebase |\n+------------------------------+\n \nSELECT SUBSTRING(''MariaDB'' FROM 6);\n+-----------------------------+\n| SUBSTRING(''MariaDB'' FROM 6) |\n+-----------------------------+\n| DB |\n+-----------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'',3,7);\n+--------------------------------+\n| SUBSTRING(''Knowledgebase'',3,7) |\n+--------------------------------+\n| owledge |\n+--------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'', -4);\n+--------------------------------+\n| SUBSTRING(''Knowledgebase'', -4) |\n+--------------------------------+\n| base |\n+--------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'', -8, 4);\n+-----------------------------------+\n| SUBSTRING(''Knowledgebase'', -8, 4) |\n+-----------------------------------+\n| edge |\n+-----------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'' FROM -8 FOR 4);\n+------------------------------------------+\n| SUBSTRING(''Knowledgebase'' FROM -8 FOR 4) |\n+------------------------------------------+\n| edge |\n+------------------------------------------+\n \nOracle mode from MariaDB 10.3.3:\n \nSELECT SUBSTR(''abc'',0,3);\n+-------------------+\n| SUBSTR(''abc'',0,3) |\n+-------------------+\n| |\n+-------------------+\n \nSELECT SUBSTR(''abc'',1,2);\n+-------------------+\n| SUBSTR(''abc'',1,2) |\n+-------------------+\n| ab |\n+-------------------+\n \nSET sql_mode=''oracle'';\n \nSELECT SUBSTR(''abc'',0,3);\n+-------------------+\n| SUBSTR(''abc'',0,3) |\n+-------------------+\n| abc |\n+-------------------+\n \nSELECT SUBSTR(''abc'',1,2);\n+-------------------+\n| SUBSTR(''abc'',1,2) |\n+-------------------+\n| ab |\n+-------------------+
[SUBSTRING4]
name=SUBSTRING
declaration=str FROM pos FOR len
category=String Functions
description=The forms without a len argument return a substring from\nstring str starting at position pos.\n \nThe forms with a len argument return a substring len\ncharacters long from string str, starting at position pos.\n \nThe forms that use FROM are standard SQL syntax.\n \nIt is also possible to use a negative value for pos. In this\ncase, the beginning of the substring is pos characters from\nthe end of the string, rather than the beginning. A negative\nvalue may be used for pos in any of the forms of this\nfunction.\n \nBy default, the position of the first character in the\nstring from which the substring is to be extracted is\nreckoned as 1. For Oracle-compatibility, from MariaDB\n10.3.3, when sql_mode is set to ''oracle'', position zero is\ntreated as position 1 (although the first character is still\nreckoned as 1).\n \nIf any argument is NULL, returns NULL.\n \n\nSELECT SUBSTRING(''Knowledgebase'',5);\n+------------------------------+\n| SUBSTRING(''Knowledgebase'',5) |\n+------------------------------+\n| ledgebase |\n+------------------------------+\n \nSELECT SUBSTRING(''MariaDB'' FROM 6);\n+-----------------------------+\n| SUBSTRING(''MariaDB'' FROM 6) |\n+-----------------------------+\n| DB |\n+-----------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'',3,7);\n+--------------------------------+\n| SUBSTRING(''Knowledgebase'',3,7) |\n+--------------------------------+\n| owledge |\n+--------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'', -4);\n+--------------------------------+\n| SUBSTRING(''Knowledgebase'', -4) |\n+--------------------------------+\n| base |\n+--------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'', -8, 4);\n+-----------------------------------+\n| SUBSTRING(''Knowledgebase'', -8, 4) |\n+-----------------------------------+\n| edge |\n+-----------------------------------+\n \nSELECT SUBSTRING(''Knowledgebase'' FROM -8 FOR 4);\n+------------------------------------------+\n| SUBSTRING(''Knowledgebase'' FROM -8 FOR 4) |\n+------------------------------------------+\n| edge |\n+------------------------------------------+\n \nOracle mode from MariaDB 10.3.3:\n \nSELECT SUBSTR(''abc'',0,3);\n+-------------------+\n| SUBSTR(''abc'',0,3) |\n+-------------------+\n| |\n+-------------------+\n \nSELECT SUBSTR(''abc'',1,2);\n+-------------------+\n| SUBSTR(''abc'',1,2) |\n+-------------------+\n| ab |\n+-------------------+\n \nSET sql_mode=''oracle'';\n \nSELECT SUBSTR(''abc'',0,3);\n+-------------------+\n| SUBSTR(''abc'',0,3) |\n+-------------------+\n| abc |\n+-------------------+\n \nSELECT SUBSTR(''abc'',1,2);\n+-------------------+\n| SUBSTR(''abc'',1,2) |\n+-------------------+\n| ab |\n+-------------------+
[SUBSTRING_INDEX]
declaration=str,delim,count
category=String Functions
description=Returns the substring from string str before count\noccurrences of the\ndelimiter delim. If count is positive, everything to the\nleft\nof the final delimiter (counting from the left) is returned.\nIf count\nis negative, everything to the right of the final delimiter\n(counting from the\nright) is returned. SUBSTRING_INDEX() performs a\ncase-sensitive match when\nsearching for delim.\n \nIf any argument is NULL, returns NULL.\n \n\nSELECT SUBSTRING_INDEX(''www.mariadb.org'', ''.'', 2);\n+--------------------------------------------+\n| SUBSTRING_INDEX(''www.mariadb.org'', ''.'', 2) |\n+--------------------------------------------+\n| www.mariadb |\n+--------------------------------------------+\n \nSELECT SUBSTRING_INDEX(''www.mariadb.org'', ''.'', -2);\n+---------------------------------------------+\n| SUBSTRING_INDEX(''www.mariadb.org'', ''.'', -2) |\n+---------------------------------------------+\n| mariadb.org |\n+---------------------------------------------+
[SUBTIME]
declaration=expr1,expr2
category=Date and Time Functions
description=SUBTIME() returns expr1 - expr2 expressed as a value in the\nsame\nformat as expr1. expr1 is a time or datetime expression, and\nexpr2 is\na time expression.\n \n\nSELECT SUBTIME(''2007-12-31 23:59:59.999999'',''1\n1:1:1.000002'');\n+--------------------------------------------------------+\n| SUBTIME(''2007-12-31 23:59:59.999999'',''1 1:1:1.000002'')\n|\n+--------------------------------------------------------+\n| 2007-12-30 22:58:58.999997 |\n+--------------------------------------------------------+\n \nSELECT SUBTIME(''01:00:00.999999'', ''02:00:00.999998'');\n+-----------------------------------------------+\n| SUBTIME(''01:00:00.999999'', ''02:00:00.999998'') |\n+-----------------------------------------------+\n| -00:59:59.999999 |\n+-----------------------------------------------+
[SUM]
declaration=[DISTINCT] expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the sum of expr. If the return set has no rows,\nSUM() returns\nNULL. The DISTINCT keyword can be used to sum only the\ndistinct values\nof expr.\n \nFrom MariaDB 10.2.0, SUM() can be used as a window function,\nalthough not with the DISTINCT specifier.\n \n\nCREATE TABLE sales (sales_value INT);\nINSERT INTO sales VALUES(10),(20),(20),(40);\n \nSELECT SUM(sales_value) FROM sales;\n \n+------------------+\n| SUM(sales_value) |\n+------------------+\n| 90 |\n+------------------+\n \nSELECT SUM(DISTINCT(sales_value)) FROM sales;\n \n+----------------------------+\n| SUM(DISTINCT(sales_value)) |\n+----------------------------+\n| 70 |\n+----------------------------+\n \nCommonly, SUM is used with a GROUP BY clause:\n \nCREATE TABLE sales (name CHAR(10), month CHAR(10), units\nINT);\n \nINSERT INTO sales VALUES \n (''Chun'', ''Jan'', 75), (''Chun'', ''Feb'', 73),\n (''Esben'', ''Jan'', 43), (''Esben'', ''Feb'', 31),\n (''Kaolin'', ''Jan'', 56), (''Kaolin'', ''Feb'', 88),\n (''Tatiana'', ''Jan'', 87), (''Tatiana'', ''Feb'', 83);\n \nSELECT name, SUM(units) FROM sales GROUP BY name;\n \n+---------+------------+\n| name | SUM(units) |\n+---------+------------+\n| Chun | 148 |\n| Esben | 74 |\n| Kaolin | 144 |\n| Tatiana | 170 |\n+---------+------------+\n \nThe GROUP BY clause is required when using an aggregate\nfunction along with regular column data, otherwise the\nresult will be a mismatch, as in the following common type\nof mistake:\n \nSELECT name,SUM(units) FROM sales\n;\n+------+------------+\n| name | SUM(units) |\n+------+------------+\n| Chun | 536 |\n+------+------------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, SUM(score) OVER (PARTITION BY\nname) AS total_score FROM student_test;\n \n+---------+--------+-------+-------------+\n| name | test | score | total_score |\n+---------+--------+-------+-------------+\n| Chun | SQL | 75 | 148 |\n| Chun | Tuning | 73 | 148 |\n| Esben | SQL | 43 | 74 |\n| Esben | Tuning | 31 | 74 |\n| Kaolin | SQL | 56 | 144 |\n| Kaolin | Tuning | 88 | 144 |\n| Tatiana | SQL | 87 | 87 |\n+---------+--------+-------+-------------+
[SYSDATE]
declaration=[precision]
category=Date and Time Functions
description=Returns the current date and time as a value in ''YYYY-MM-DD\nHH:MM:SS''\nor YYYYMMDDHHMMSS.uuuuuu format, depending on whether the\nfunction is\nused in a string or numeric context.\n \nThe optional precision determines the microsecond precision.\nSee Microseconds in MariaDB.\n \nSYSDATE() returns the time at which it executes. This\ndiffers from the\nbehavior for NOW(), which returns a constant time that\nindicates the\ntime at which the statement began to execute. (Within a\nstored routine\nor trigger, NOW() returns the time at which the routine or\ntriggering\nstatement began to execute.)\n \nIn addition, changing the timestamp system variable with a\nSET timestamp statement affects the value returned by\nNOW() but not by SYSDATE(). This means that timestamp\nsettings in the\nbinary log have no effect on invocations of SYSDATE().\n \nBecause SYSDATE() can return different values even within\nthe same\nstatement, and is not affected by SET TIMESTAMP, it is\nnon-deterministic and therefore unsafe for replication if\nstatement-based binary logging is used. If that is a\nproblem, you can\nuse row-based logging, or start the server with the mysqld\noption --sysdate-is-now to cause SYSDATE() to be an alias\nfor NOW(). The non-deterministic nature of SYSDATE() also\nmeans that indexes cannot be used for evaluating expressions\nthat refer to it, and that statements using the SYSDATE()\nfunction are unsafe for statement-based replication.\n \n\nDifference between NOW() and SYSDATE():\n \nSELECT NOW(), SLEEP(2), NOW();\n+---------------------+----------+---------------------+\n| NOW() | SLEEP(2) | NOW() |\n+---------------------+----------+---------------------+\n| 2010-03-27 13:23:40 | 0 | 2010-03-27 13:23:40 |\n+---------------------+----------+---------------------+\n \nSELECT SYSDATE(), SLEEP(2), SYSDATE();\n+---------------------+----------+---------------------+\n| SYSDATE() | SLEEP(2) | SYSDATE() |\n+---------------------+----------+---------------------+\n| 2010-03-27 13:23:52 | 0 | 2010-03-27 13:23:54 |\n+---------------------+----------+---------------------+\n \nWith precision:\n \nSELECT SYSDATE(4);\n+--------------------------+\n| SYSDATE(4) |\n+--------------------------+\n| 2018-07-10 10:17:13.1689 |\n+--------------------------+
[SYSTEM_USER]
declaration=
category=Information Functions
description=SYSTEM_USER() is a synonym for USER().
[TAN]
declaration=X
category=Numeric Functions
description=Returns the tangent of X, where X is given in radians.\n \n\nSELECT TAN(0.7853981633974483);\n+-------------------------+\n| TAN(0.7853981633974483) |\n+-------------------------+\n| 0.9999999999999999 |\n+-------------------------+\n \nSELECT TAN(PI());\n+-----------------------+\n| TAN(PI()) |\n+-----------------------+\n| -1.22460635382238e-16 |\n+-----------------------+\n \nSELECT TAN(PI()+1);\n+-----------------+\n| TAN(PI()+1) |\n+-----------------+\n| 1.5574077246549 |\n+-----------------+\n \nSELECT TAN(RADIANS(PI()));\n+--------------------+\n| TAN(RADIANS(PI())) |\n+--------------------+\n| 0.0548861508080033 |\n+--------------------+
[TIMEDIFF]
declaration=expr1,expr2
category=Date and Time Functions
description=TIMEDIFF() returns expr1 - expr2 expressed as a time value.\nexpr1 and\nexpr2 are time or date-and-time expressions, but both must\nbe of the\nsame type.\n \n\nSELECT TIMEDIFF(''2000:01:01 00:00:00'', ''2000:01:01\n00:00:00.000001'');\n+---------------------------------------------------------------+\n| TIMEDIFF(''2000:01:01 00:00:00'', ''2000:01:01\n00:00:00.000001'') |\n+---------------------------------------------------------------+\n| -00:00:00.000001 |\n+---------------------------------------------------------------+\n \nSELECT TIMEDIFF(''2008-12-31 23:59:59.000001'', ''2008-12-30\n01:01:01.000002'');\n+----------------------------------------------------------------------+\n| TIMEDIFF(''2008-12-31 23:59:59.000001'', ''2008-12-30\n01:01:01.000002'') |\n+----------------------------------------------------------------------+\n| 46:58:57.999999 |\n+----------------------------------------------------------------------+
[TIMESTAMPADD]
declaration=unit,interval,datetime_expr
category=Date and Time Functions
description=Adds the integer expression interval to the date or datetime\nexpression datetime_expr. The unit for interval is given by\nthe unit\nargument, which should be one of the following values:\nMICROSECOND, SECOND, MINUTE, HOUR, DAY, WEEK, MONTH,\nQUARTER, or YEAR.\n \nThe unit value may be specified using one of keywords as\nshown, or\nwith a prefix of SQL_TSI_. For example, DAY and SQL_TSI_DAY\nboth are\nlegal.\n \nBefore MariaDB 5.5, FRAC_SECOND was permitted as a synonym\nfor MICROSECOND.\n \n\nSELECT TIMESTAMPADD(MINUTE,1,''2003-01-02'');\n+-------------------------------------+\n| TIMESTAMPADD(MINUTE,1,''2003-01-02'') |\n+-------------------------------------+\n| 2003-01-02 00:01:00 |\n+-------------------------------------+\n \nSELECT TIMESTAMPADD(WEEK,1,''2003-01-02'');\n+-----------------------------------+\n| TIMESTAMPADD(WEEK,1,''2003-01-02'') |\n+-----------------------------------+\n| 2003-01-09 |\n+-----------------------------------+
[TIMESTAMPDIFF]
declaration=unit,datetime_expr1,datetime_expr2
category=Date and Time Functions
description=Returns datetime_expr2 - datetime_expr1, where\ndatetime_expr1 and\ndatetime_expr2 are date or datetime expressions. One\nexpression may be\na date and the other a datetime; a date value is treated as\na datetime\nhaving the time part ''00:00:00'' where necessary. The unit\nfor the\nresult (an integer) is given by the unit argument. The legal\nvalues\nfor unit are the same as those listed in the description of\nthe\nTIMESTAMPADD() function, i.e MICROSECOND, SECOND, MINUTE,\nHOUR, DAY, WEEK, MONTH, QUARTER, or YEAR.\n \nTIMESTAMPDIFF can also be used to calculate age.\n \n\nSELECT TIMESTAMPDIFF(MONTH,''2003-02-01'',''2003-05-01'');\n+------------------------------------------------+\n| TIMESTAMPDIFF(MONTH,''2003-02-01'',''2003-05-01'') |\n+------------------------------------------------+\n| 3 |\n+------------------------------------------------+\n \nSELECT TIMESTAMPDIFF(YEAR,''2002-05-01'',''2001-01-01'');\n+-----------------------------------------------+\n| TIMESTAMPDIFF(YEAR,''2002-05-01'',''2001-01-01'') |\n+-----------------------------------------------+\n| -1 |\n+-----------------------------------------------+\n \nSELECT TIMESTAMPDIFF(MINUTE,''2003-02-01'',''2003-05-01\n12:05:55'');\n+----------------------------------------------------------+\n| TIMESTAMPDIFF(MINUTE,''2003-02-01'',''2003-05-01\n12:05:55'') |\n+----------------------------------------------------------+\n| 128885 |\n+----------------------------------------------------------+\n \nCalculating age:\n \nSELECT CURDATE();\n+------------+\n| CURDATE() |\n+------------+\n| 2019-05-27 |\n+------------+\n \nSELECT TIMESTAMPDIFF(YEAR, ''1971-06-06'', CURDATE()) AS\nage;\n \n+------+\n| age |\n+------+\n| 47 |\n+------+\n \nSELECT TIMESTAMPDIFF(YEAR, ''1971-05-06'', CURDATE()) AS\nage;\n \n+------+\n| age |\n+------+\n| 48 |\n+------+\n \nAge as of 2014-08-02:\n \nSELECT name, date_of_birth,\nTIMESTAMPDIFF(YEAR,date_of_birth,''2014-08-02'') AS age \n FROM student_details;\n \n+---------+---------------+------+\n| name | date_of_birth | age |\n+---------+---------------+------+\n| Chun | 1993-12-31 | 20 |\n| Esben | 1946-01-01 | 68 |\n| Kaolin | 1996-07-16 | 18 |\n| Tatiana | 1988-04-13 | 26 |\n+---------+---------------+------+
[TIME_FORMAT]
declaration=time,format
category=Date and Time Functions
description=This is used like the DATE_FORMAT() function, but the format\nstring\nmay contain format specifiers only for hours, minutes, and\nseconds.\nOther specifiers produce a NULL value or 0.\n \n\nSELECT TIME_FORMAT(''100:00:00'', ''%H %k %h %I %l'');\n+--------------------------------------------+\n| TIME_FORMAT(''100:00:00'', ''%H %k %h %I %l'') |\n+--------------------------------------------+\n| 100 100 04 04 4 |\n+--------------------------------------------+
[TIME_TO_SEC]
declaration=time
category=Date and Time Functions
description=Returns the time argument, converted to seconds.\n \nThe value returned by TIME_TO_SEC is of type DOUBLE. Before\nMariaDB 5.3 (and MySQL 5.6), the type was INT. See\nMicroseconds in MariaDB.\n \n\nSELECT TIME_TO_SEC(''22:23:00'');\n+-------------------------+\n| TIME_TO_SEC(''22:23:00'') |\n+-------------------------+\n| 80580 |\n+-------------------------+\n \nSELECT TIME_TO_SEC(''00:39:38'');\n+-------------------------+\n| TIME_TO_SEC(''00:39:38'') |\n+-------------------------+\n| 2378 |\n+-------------------------+
[TOUCHES]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether g1 spatially touches g2.\nTwo\ngeometries spatially touch if the interiors of the\ngeometries do not intersect,\nbut the boundary of one of the geometries intersects either\nthe boundary or the\ninterior of the other.\n \nTOUCHES() is based on the original MySQL implementation and\nuses object bounding rectangles, while ST_TOUCHES() uses\nobject shapes.
[TO_BASE64]
declaration=str
category=String Functions
description=Converts the string argument str to its base-64 encoded\nform, returning the result as a character string in the\nconnection character set and collation.\n \nThe argument str will be converted to string first if it is\nnot a string. A NULL argument will return a NULL result.\n \nThe reverse function, FROM_BASE64(), decodes an encoded\nbase-64 string.\n \nThere are a numerous different methods to base-64 encode a\nstring. The following are used by MariaDB and MySQL:\nAlphabet value 64 is encoded as ''+''.\nAlphabet value 63 is encoded as ''/''.\nEncoding output is made up of groups of four printable\ncharacters, with each three bytes of data encoded using four\ncharacters. If the final group is not complete, it is padded\nwith ''='' characters to make up a length of four.\nTo divide long output, a newline is added after every 76\ncharacters.\nDecoding will recognize and ignore newlines, carriage\nreturns, tabs, and spaces. \n \n\nSELECT TO_BASE64(''Maria'');\n+--------------------+\n| TO_BASE64(''Maria'') |\n+--------------------+\n| TWFyaWE= |\n+--------------------+
[TO_DAYS]
declaration=date
category=Date and Time Functions
description=Given a date date, returns the number of days since the\nstart of the current calendar (0000-00-00).\n \nThe function is not designed for use with dates before the\nadvent of the Gregorian calendar in October 1582. Results\nwill not be reliable since it doesn''t account for the lost\ndays when the calendar changed from the Julian calendar.\n \nThis is the converse of the FROM_DAYS() function.\n \n\nSELECT TO_DAYS(''2007-10-07'');\n+-----------------------+\n| TO_DAYS(''2007-10-07'') |\n+-----------------------+\n| 733321 |\n+-----------------------+\n \nSELECT TO_DAYS(''0000-01-01'');\n+-----------------------+\n| TO_DAYS(''0000-01-01'') |\n+-----------------------+\n| 1 |\n+-----------------------+\n \nSELECT TO_DAYS(950501);\n+-----------------+\n| TO_DAYS(950501) |\n+-----------------+\n| 728779 |\n+-----------------+
[TO_SECONDS]
declaration=expr
category=Date and Time Functions
description=Returns the number of seconds from year 0 till expr, or NULL\nif expr is not a valid date or datetime.\n \n\nSELECT TO_SECONDS(''2013-06-13'');\n+--------------------------+\n| TO_SECONDS(''2013-06-13'') |\n+--------------------------+\n| 63538300800 |\n+--------------------------+\n \nSELECT TO_SECONDS(''2013-06-13 21:45:13'');\n+-----------------------------------+\n| TO_SECONDS(''2013-06-13 21:45:13'') |\n+-----------------------------------+\n| 63538379113 |\n+-----------------------------------+\n \nSELECT TO_SECONDS(NOW());\n+-------------------+\n| TO_SECONDS(NOW()) |\n+-------------------+\n| 63543530875 |\n+-------------------+\n \nSELECT TO_SECONDS(20130513);\n+----------------------+\n| TO_SECONDS(20130513) |\n+----------------------+\n| 63535622400 |\n+----------------------+\n1 row in set (0.00 sec)\n \nSELECT TO_SECONDS(130513);\n+--------------------+\n| TO_SECONDS(130513) |\n+--------------------+\n| 63535622400 |\n+--------------------+
[TRIM1]
name=TRIM
declaration=[{BOTH | LEADING | TRAILING} [remstr] FROM] str
category=String Functions
description=Returns the string str with all remstr prefixes or suffixes\nremoved. If none of the specifiers BOTH, LEADING, or\nTRAILING is given, BOTH is assumed. remstr is optional and,\nif not specified, spaces are removed.\n \nReturns NULL if given a NULL argument. If the result is\nempty, returns either an empty string, or, from MariaDB\n10.3.6 with SQL_MODE=Oracle, NULL.\n \nThe Oracle mode version of the function can be accessed\noutside of Oracle mode by using TRIM_ORACLE as the function\nname.\n \n\nSELECT TRIM('' bar '')\G\n*************************** 1. row\n***************************\nTRIM('' bar ''): bar\n \nSELECT TRIM(LEADING ''x'' FROM ''xxxbarxxx'')\G\n*************************** 1. row\n***************************\nTRIM(LEADING ''x'' FROM ''xxxbarxxx''): barxxx\n \nSELECT TRIM(BOTH ''x'' FROM ''xxxbarxxx'')\G\n*************************** 1. row\n***************************\nTRIM(BOTH ''x'' FROM ''xxxbarxxx''): bar\n \nSELECT TRIM(TRAILING ''xyz'' FROM ''barxxyz'')\G\n*************************** 1. row\n***************************\nTRIM(TRAILING ''xyz'' FROM ''barxxyz''): barx\n \nOracle mode version from MariaDB 10.3.6:\n \nSELECT TRIM(''''),TRIM_ORACLE('''');\n+----------+-----------------+\n| TRIM('''') | TRIM_ORACLE('''') |\n+----------+-----------------+\n| | NULL |\n+----------+-----------------+
[TRIM2]
name=TRIM
declaration=[remstr FROM] str
category=String Functions
description=Returns the string str with all remstr prefixes or suffixes\nremoved. If none of the specifiers BOTH, LEADING, or\nTRAILING is given, BOTH is assumed. remstr is optional and,\nif not specified, spaces are removed.\n \nReturns NULL if given a NULL argument. If the result is\nempty, returns either an empty string, or, from MariaDB\n10.3.6 with SQL_MODE=Oracle, NULL.\n \nThe Oracle mode version of the function can be accessed\noutside of Oracle mode by using TRIM_ORACLE as the function\nname.\n \n\nSELECT TRIM('' bar '')\G\n*************************** 1. row\n***************************\nTRIM('' bar ''): bar\n \nSELECT TRIM(LEADING ''x'' FROM ''xxxbarxxx'')\G\n*************************** 1. row\n***************************\nTRIM(LEADING ''x'' FROM ''xxxbarxxx''): barxxx\n \nSELECT TRIM(BOTH ''x'' FROM ''xxxbarxxx'')\G\n*************************** 1. row\n***************************\nTRIM(BOTH ''x'' FROM ''xxxbarxxx''): bar\n \nSELECT TRIM(TRAILING ''xyz'' FROM ''barxxyz'')\G\n*************************** 1. row\n***************************\nTRIM(TRAILING ''xyz'' FROM ''barxxyz''): barx\n \nOracle mode version from MariaDB 10.3.6:\n \nSELECT TRIM(''''),TRIM_ORACLE('''');\n+----------+-----------------+\n| TRIM('''') | TRIM_ORACLE('''') |\n+----------+-----------------+\n| | NULL |\n+----------+-----------------+
[TRUNCATE]
declaration=X,D
category=Numeric Functions
description=Returns the number X, truncated to D decimal places. If D is\n0, the\nresult has no decimal point or fractional part. D can be\nnegative to\ncause D digits left of the decimal point of the value X to\nbecome\nzero.\n \n\nSELECT TRUNCATE(1.223,1);\n+-------------------+\n| TRUNCATE(1.223,1) |\n+-------------------+\n| 1.2 |\n+-------------------+\n \nSELECT TRUNCATE(1.999,1);\n+-------------------+\n| TRUNCATE(1.999,1) |\n+-------------------+\n| 1.9 |\n+-------------------+\n \nSELECT TRUNCATE(1.999,0); \n+-------------------+\n| TRUNCATE(1.999,0) |\n+-------------------+\n| 1 |\n+-------------------+\n \nSELECT TRUNCATE(-1.999,1);\n+--------------------+\n| TRUNCATE(-1.999,1) |\n+--------------------+\n| -1.9 |\n+--------------------+\n \nSELECT TRUNCATE(122,-2);\n+------------------+\n| TRUNCATE(122,-2) |\n+------------------+\n| 100 |\n+------------------+\n \nSELECT TRUNCATE(10.28*100,0);\n+-----------------------+\n| TRUNCATE(10.28*100,0) |\n+-----------------------+\n| 1028 |\n+-----------------------+
[UCASE]
declaration=str
category=String Functions
description=UCASE() is a synonym for UPPER().
[UNCOMPRESSED_LENGTH]
declaration=compressed_string
category=Encryption Functions
description=Returns the length that the compressed string had before\nbeing\ncompressed with COMPRESS().\n \nUNCOMPRESSED_LENGTH() returns NULL or an incorrect result if\nthe string is not compressed.\n \nUntil MariaDB 10.3.1, returns MYSQL_TYPE_LONGLONG, or\nbigint(10), in all cases. From MariaDB 10.3.1, returns\nMYSQL_TYPE_LONG, or int(10), when the result would fit\nwithin 32-bits.\n \n\nSELECT UNCOMPRESSED_LENGTH(COMPRESS(REPEAT(''a'',30)));\n+-----------------------------------------------+\n| UNCOMPRESSED_LENGTH(COMPRESS(REPEAT(''a'',30))) |\n+-----------------------------------------------+\n| 30 |\n+-----------------------------------------------+
[UNCOMPRESS]
declaration=string_to_uncompress
category=Encryption Functions
description=Uncompresses a string compressed by the COMPRESS() function.\nIf the\nargument is not a compressed value, the result is NULL. This\nfunction\nrequires MariaDB to have been compiled with a compression\nlibrary such\nas zlib. Otherwise, the return value is always NULL. The\nhave_compress server system variable indicates whether a\ncompression library is present. \n \n\nSELECT UNCOMPRESS(COMPRESS(''a string''));\n+----------------------------------+\n| UNCOMPRESS(COMPRESS(''a string'')) |\n+----------------------------------+\n| a string |\n+----------------------------------+\n \nSELECT UNCOMPRESS(''a string'');\n+------------------------+\n| UNCOMPRESS(''a string'') |\n+------------------------+\n| NULL |\n+------------------------+
[UNHEX]
declaration=str
category=String Functions
description=Performs the inverse operation of HEX(str). That is, it\ninterprets\neach pair of hexadecimal digits in the argument as a number\nand\nconverts it to the character represented by the number. The\nresulting\ncharacters are returned as a binary string.\n \nIf str is NULL, UNHEX() returns NULL.\n \n\nSELECT HEX(''MariaDB'');\n+----------------+\n| HEX(''MariaDB'') |\n+----------------+\n| 4D617269614442 |\n+----------------+\n \nSELECT UNHEX(''4D617269614442'');\n+-------------------------+\n| UNHEX(''4D617269614442'') |\n+-------------------------+\n| MariaDB |\n+-------------------------+\n \nSELECT 0x4D617269614442;\n \n+------------------+\n| 0x4D617269614442 |\n+------------------+\n| MariaDB |\n+------------------+\n \nSELECT UNHEX(HEX(''string''));\n+----------------------+\n| UNHEX(HEX(''string'')) |\n+----------------------+\n| string |\n+----------------------+\n \nSELECT HEX(UNHEX(''1267''));\n+--------------------+\n| HEX(UNHEX(''1267'')) |\n+--------------------+\n| 1267 |\n+--------------------+
[UNIX_TIMESTAMP1]
name=UNIX_TIMESTAMP
declaration=
category=Date and Time Functions
description=If called with no argument, returns a Unix timestamp\n(seconds since\n''1970-01-01 00:00:00'' UTC) as an unsigned integer. If\nUNIX_TIMESTAMP()\nis called with a date argument, it returns the value of the\nargument as seconds\nsince ''1970-01-01 00:00:00'' UTC. date may be a DATE\nstring, a\nDATETIME string, a TIMESTAMP, or a number in\nthe format YYMMDD or YYYYMMDD. The server interprets date as\na value in the\ncurrent time zone and converts it to an internal value in\nUTC. Clients can set\ntheir time zone as described in time zones.\n \nThe inverse function of UNIX_TIMESTAMP() is FROM_UNIXTIME()\n \nUNIX_TIMESTAMP() supports microseconds.\n \nTimestamps in MariaDB have a maximum value of 2147483647,\nequivalent to 2038-01-19 05:14:07. This is due to the\nunderlying 32-bit limitation. Using the function on a date\nbeyond this will result in NULL being returned. Use DATETIME\nas a storage type if you require dates beyond this.\n \nError Handling\n \nReturns NULL for wrong arguments to UNIX_TIMESTAMP(). In\nMySQL and MariaDB before 5.3 wrong arguments to\nUNIX_TIMESTAMP() returned 0. \n \nCompatibility\n \nAs you can see in the examples above,\nUNIX_TIMESTAMP(constant-date-string) returns a timestamp\nwith 6 decimals while MariaDB 5.2 and before returns it\nwithout decimals. This can cause a problem if you are using\nUNIX_TIMESTAMP() as a partitioning function. You can fix\nthis by using FLOOR(UNIX_TIMESTAMP(..)) or changing the date\nstring to a date number, like 20080101000000. \n \n\nSELECT UNIX_TIMESTAMP();\n+------------------+\n| UNIX_TIMESTAMP() |\n+------------------+\n| 1269711082 |\n+------------------+\n \nSELECT UNIX_TIMESTAMP(''2007-11-30 10:30:19'');\n+---------------------------------------+\n| UNIX_TIMESTAMP(''2007-11-30 10:30:19'') |\n+---------------------------------------+\n| 1196436619.000000 |\n+---------------------------------------+\n \nSELECT UNIX_TIMESTAMP("2007-11-30 10:30:19.123456");\n+----------------------------------------------+\n| unix_timestamp("2007-11-30 10:30:19.123456") |\n+----------------------------------------------+\n| 1196411419.123456 |\n+----------------------------------------------+\n \nSELECT FROM_UNIXTIME(UNIX_TIMESTAMP(''2007-11-30\n10:30:19''));\n+------------------------------------------------------+\n| FROM_UNIXTIME(UNIX_TIMESTAMP(''2007-11-30 10:30:19'')) |\n+------------------------------------------------------+\n| 2007-11-30 10:30:19.000000 |\n+------------------------------------------------------+\n \nSELECT FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(''2007-11-30\n10:30:19'')));\n+-------------------------------------------------------------+\n| FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(''2007-11-30\n10:30:19''))) |\n+-------------------------------------------------------------+\n| 2007-11-30 10:30:19 |\n+-------------------------------------------------------------+
[UNIX_TIMESTAMP2]
name=UNIX_TIMESTAMP
declaration=date
category=Date and Time Functions
description=If called with no argument, returns a Unix timestamp\n(seconds since\n''1970-01-01 00:00:00'' UTC) as an unsigned integer. If\nUNIX_TIMESTAMP()\nis called with a date argument, it returns the value of the\nargument as seconds\nsince ''1970-01-01 00:00:00'' UTC. date may be a DATE\nstring, a\nDATETIME string, a TIMESTAMP, or a number in\nthe format YYMMDD or YYYYMMDD. The server interprets date as\na value in the\ncurrent time zone and converts it to an internal value in\nUTC. Clients can set\ntheir time zone as described in time zones.\n \nThe inverse function of UNIX_TIMESTAMP() is FROM_UNIXTIME()\n \nUNIX_TIMESTAMP() supports microseconds.\n \nTimestamps in MariaDB have a maximum value of 2147483647,\nequivalent to 2038-01-19 05:14:07. This is due to the\nunderlying 32-bit limitation. Using the function on a date\nbeyond this will result in NULL being returned. Use DATETIME\nas a storage type if you require dates beyond this.\n \nError Handling\n \nReturns NULL for wrong arguments to UNIX_TIMESTAMP(). In\nMySQL and MariaDB before 5.3 wrong arguments to\nUNIX_TIMESTAMP() returned 0. \n \nCompatibility\n \nAs you can see in the examples above,\nUNIX_TIMESTAMP(constant-date-string) returns a timestamp\nwith 6 decimals while MariaDB 5.2 and before returns it\nwithout decimals. This can cause a problem if you are using\nUNIX_TIMESTAMP() as a partitioning function. You can fix\nthis by using FLOOR(UNIX_TIMESTAMP(..)) or changing the date\nstring to a date number, like 20080101000000. \n \n\nSELECT UNIX_TIMESTAMP();\n+------------------+\n| UNIX_TIMESTAMP() |\n+------------------+\n| 1269711082 |\n+------------------+\n \nSELECT UNIX_TIMESTAMP(''2007-11-30 10:30:19'');\n+---------------------------------------+\n| UNIX_TIMESTAMP(''2007-11-30 10:30:19'') |\n+---------------------------------------+\n| 1196436619.000000 |\n+---------------------------------------+\n \nSELECT UNIX_TIMESTAMP("2007-11-30 10:30:19.123456");\n+----------------------------------------------+\n| unix_timestamp("2007-11-30 10:30:19.123456") |\n+----------------------------------------------+\n| 1196411419.123456 |\n+----------------------------------------------+\n \nSELECT FROM_UNIXTIME(UNIX_TIMESTAMP(''2007-11-30\n10:30:19''));\n+------------------------------------------------------+\n| FROM_UNIXTIME(UNIX_TIMESTAMP(''2007-11-30 10:30:19'')) |\n+------------------------------------------------------+\n| 2007-11-30 10:30:19.000000 |\n+------------------------------------------------------+\n \nSELECT FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(''2007-11-30\n10:30:19'')));\n+-------------------------------------------------------------+\n| FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(''2007-11-30\n10:30:19''))) |\n+-------------------------------------------------------------+\n| 2007-11-30 10:30:19 |\n+-------------------------------------------------------------+
[UPDATEXML]
declaration=xml_target, xpath_expr, new_xml
category=String Functions
description=This function replaces a single portion of a given fragment\nof XML markup\nxml_target with a new XML fragment new_xml, and then returns\nthe\nchanged XML. The portion of xml_target that is replaced\nmatches an XPath\nexpression xpath_expr supplied by the user. If no expression\nmatching\nxpath_expr is found, or if multiple matches are found, the\nfunction returns\nthe original xml_target XML fragment. All three arguments\nshould be\nstrings.\n \n\nSELECT\n UpdateXML(''ccc'', ''/a'', ''fff'') AS val1,\n UpdateXML(''ccc'', ''/b'', ''fff'') AS val2,\n UpdateXML(''ccc'', ''//b'', ''fff'') AS val3,\n UpdateXML(''ccc'', ''/a/d'', ''fff'') AS val4,\n UpdateXML(''ccc'', ''/a/d'', ''fff'') AS val5\n \G\n*************************** 1. row\n***************************\nval1: fff\nval2: ccc\nval3: fff\nval4: cccfff\nval5: ccc\n1 row in set (0.00 sec)
[UPPER]
declaration=str
category=String Functions
description=Returns the string str with all characters changed to\nuppercase\naccording to the current character set mapping. The default\nis latin1\n(cp1252 West European).\n \nSELECT UPPER(surname), givenname FROM users ORDER BY\nsurname;\n \n+----------------+------------+\n| UPPER(surname) | givenname |\n+----------------+------------+\n| ABEL | Jacinto |\n| CASTRO | Robert |\n| COSTA | Phestos |\n| MOSCHELLA | Hippolytos |\n+----------------+------------+\n \nUPPER() is ineffective when applied to binary strings\n(BINARY,\nVARBINARY, BLOB). The description of \nLOWER() shows how to\nperform lettercase conversion of binary strings.
[USER]
declaration=
category=Information Functions
description=Returns the current MariaDB user name and host name, given\nwhen authenticating to MariaDB, as a string in the utf8\ncharacter set.\n \nNote that the value of USER() may differ from the value of\nCURRENT_USER(), which is the user used to authenticate the\ncurrent client. \nCURRENT_ROLE() returns the current active role.\n \nSYSTEM_USER() and SESSION_USER are synonyms for USER().\n \nStatements using the USER() function or one of its synonyms\nare not safe for statement level replication.\n \n\nshell> mysql --user="anonymous"\n \nMariaDB [(none)]> select user(),current_user();\n+---------------------+----------------+\n| user() | current_user() |\n+---------------------+----------------+\n| anonymous@localhost | @localhost |\n+---------------------+----------------+
[UUID]
declaration=
category=Miscellaneous Functions
description=Returns a Universal Unique Identifier (UUID) generated\naccording to "DCE 1.1:\nRemote Procedure Call" (Appendix A) CAE (Common\nApplications Environment)\nSpecifications published by The Open Group in October\n1997 \n(Document Number C706).\n \nA UUID is designed as a number that is globally unique in\nspace and time. Two\ncalls to UUID() are expected to generate two different\nvalues, even if these calls are performed on two separate\ncomputers that are\nnot connected to each other.\n \nA UUID is a 128-bit number represented by a utf8 string of\nfive\nhexadecimal numbers in aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee\nformat:\nThe first three numbers are generated from a timestamp.\nThe fourth number preserves temporal uniqueness in case the\ntimestamp value\n loses monotonicity (for example, due to daylight saving\ntime).\nThe fifth number is an IEEE 802 node number that provides\nspatial uniqueness.\n A random number is substituted if the latter is not\navailable (for example,\n because the host computer has no Ethernet card, or we do\nnot know how to find\n the hardware address of an interface on your operating\nsystem). In this case,\n spatial uniqueness cannot be guaranteed. Nevertheless, a\ncollision should\n have very low probability.\n \nCurrently, the MAC address of an interface is taken into\naccount only on FreeBSD and Linux. On other operating\nsystems, MariaDB uses a randomly generated 48-bit number.\n \nStatements using the UUID() function are not safe for\nreplication.\n \nUUID() results are intended to be unique, but cannot always\nbe relied upon to unpredictable and unguessable, so should\nnot be relied upon for these purposes.\n \n\nSELECT UUID();\n+--------------------------------------+\n| UUID() |\n+--------------------------------------+\n| cd41294a-afb0-11df-bc9b-00241dd75637 |\n+--------------------------------------+
[UUID_SHORT]
declaration=
category=Miscellaneous Functions
description=Returns a "short" universal identifier as a 64-bit\nunsigned integer (rather\nthan a string-form 128-bit identifier as returned by the\nUUID() function).\n \nThe value of UUID_SHORT() is guaranteed to be unique if the\nfollowing conditions hold:\nThe server_id of the current host is unique among your set\nof master and\n slave servers\nserver_id is between 0 and 255\nYou don''t set back your system time for your server between\nmysqld restarts\nYou do not invoke UUID_SHORT() on average more than 16\n million times per second between mysqld restarts\n \nThe UUID_SHORT() return value is constructed this way:\n \n (server_id & 255)
[VARBINARY]
declaration=M
category=Data Types
description=The VARBINARY type is similar to the VARCHAR type, but\nstores binary byte strings rather than non-binary character\nstrings. M represents the maximum column length in bytes. \n \nIt contains no character set, and comparison and sorting are\nbased on the numeric value of the bytes.\n \nIf the maximum length is exceeded, and SQL strict mode is\nnot enabled , the extra characters will be dropped with a\nwarning. If strict mode is enabled, an error will occur.\n \nUnlike BINARY values, VARBINARYs are not right-padded when\ninserting.\n \nOracle Mode\n \nIn Oracle mode from MariaDB 10.3, RAW is a synonym for\nVARBINARY.\n \n\nInserting too many characters, first with strict mode off,\nthen with it on:\n \nCREATE TABLE varbins (a VARBINARY(10));\n \nINSERT INTO varbins VALUES(''12345678901'');\nQuery OK, 1 row affected, 1 warning (0.04 sec)\n \nSELECT * FROM varbins;\n \n+------------+\n| a |\n+------------+\n| 1234567890 |\n+------------+\n \nSET sql_mode=''STRICT_ALL_TABLES'';\n \nINSERT INTO varbins VALUES(''12345678901'');\nERROR 1406 (22001): Data too long for column ''a'' at row 1\n \nSorting is performed with the byte value:\n \nTRUNCATE varbins;\n \nINSERT INTO varbins VALUES(''A''),(''B''),(''a''),(''b'');\n \nSELECT * FROM varbins ORDER BY a;\n \n+------+\n| a |\n+------+\n| A |\n| B |\n| a |\n| b |\n+------+\n \nUsing CAST to sort as a CHAR instead:\n \nSELECT * FROM varbins ORDER BY CAST(a AS CHAR);\n+------+\n| a |\n+------+\n| a |\n| A |\n| b |\n| B |\n+------+
[VARIANCE]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the population standard variance of expr. This is an\nextension to\nstandard SQL. The standard SQL function VAR_POP() can be\nused\ninstead.\n \nVariance is calculated by\nworking out the mean for the set\nfor each number, subtracting the mean and squaring the\nresult\ncalculate the average of the resulting differences\n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, VARIANCE() can be used as a window\nfunction.\n \nVARIANCE() returns NULL if there were no matching rows.\n \n\nCREATE TABLE v(i tinyint);\n \nINSERT INTO v VALUES(101),(99);\n \nSELECT VARIANCE(i) FROM v;\n \n+-------------+\n| VARIANCE(i) |\n+-------------+\n| 1.0000 |\n+-------------+\n \nINSERT INTO v VALUES(120),(80);\n \nSELECT VARIANCE(i) FROM v;\n \n+-------------+\n| VARIANCE(i) |\n+-------------+\n| 200.5000 |\n+-------------+\n \nAs an aggregate function:\n \nCREATE OR REPLACE TABLE stats (category VARCHAR(2), x INT);\n \nINSERT INTO stats VALUES \n (''a'',1),(''a'',2),(''a'',3),\n (''b'',11),(''b'',12),(''b'',20),(''b'',30),(''b'',60);\n \nSELECT category, STDDEV_POP(x), STDDEV_SAMP(x), VAR_POP(x) \n FROM stats GROUP BY category;\n \n+----------+---------------+----------------+------------+\n| category | STDDEV_POP(x) | STDDEV_SAMP(x) | VAR_POP(x) |\n+----------+---------------+----------------+------------+\n| a | 0.8165 | 1.0000 | 0.6667 |\n| b | 18.0400 | 20.1693 | 325.4400 |\n+----------+---------------+----------------+------------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\n \nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, VAR_POP(score) \n OVER (PARTITION BY test) AS variance_results FROM\nstudent_test;\n \n+---------+--------+-------+------------------+\n| name | test | score | variance_results |\n+---------+--------+-------+------------------+\n| Chun | SQL | 75 | 287.1875 |\n| Chun | Tuning | 73 | 582.0000 |\n| Esben | SQL | 43 | 287.1875 |\n| Esben | Tuning | 31 | 582.0000 |\n| Kaolin | SQL | 56 | 287.1875 |\n| Kaolin | Tuning | 88 | 582.0000 |\n| Tatiana | SQL | 87 | 287.1875 |\n+---------+--------+-------+------------------+
[VAR_POP]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the population standard variance of expr. It\nconsiders rows as\nthe whole population, not as a sample, so it has the number\nof rows as\nthe denominator. You can also use VARIANCE(), which is\nequivalent but\nis not standard SQL.\n \nVariance is calculated by\nworking out the mean for the set\nfor each number, subtracting the mean and squaring the\nresult\ncalculate the average of the resulting differences\n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, VAR_POP() can be used as a window\nfunction.\n \nVAR_POP() returns NULL if there were no matching rows.\n \n\nCREATE TABLE v(i tinyint);\n \nINSERT INTO v VALUES(101),(99);\n \nSELECT VAR_POP(i) FROM v;\n \n+------------+\n| VAR_POP(i) |\n+------------+\n| 1.0000 |\n+------------+\n \nINSERT INTO v VALUES(120),(80);\n \nSELECT VAR_POP(i) FROM v;\n \n+------------+\n| VAR_POP(i) |\n+------------+\n| 200.5000 |\n+------------+\n \nAs an aggregate function:\n \nCREATE OR REPLACE TABLE stats (category VARCHAR(2), x INT);\n \nINSERT INTO stats VALUES \n (''a'',1),(''a'',2),(''a'',3),\n (''b'',11),(''b'',12),(''b'',20),(''b'',30),(''b'',60);\n \nSELECT category, STDDEV_POP(x), STDDEV_SAMP(x), VAR_POP(x) \n FROM stats GROUP BY category;\n \n+----------+---------------+----------------+------------+\n| category | STDDEV_POP(x) | STDDEV_SAMP(x) | VAR_POP(x) |\n+----------+---------------+----------------+------------+\n| a | 0.8165 | 1.0000 | 0.6667 |\n| b | 18.0400 | 20.1693 | 325.4400 |\n+----------+---------------+----------------+------------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\n \nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, VAR_POP(score) \n OVER (PARTITION BY test) AS variance_results FROM\nstudent_test;\n \n+---------+--------+-------+------------------+\n| name | test | score | variance_results |\n+---------+--------+-------+------------------+\n| Chun | SQL | 75 | 287.1875 |\n| Chun | Tuning | 73 | 582.0000 |\n| Esben | SQL | 43 | 287.1875 |\n| Esben | Tuning | 31 | 582.0000 |\n| Kaolin | SQL | 56 | 287.1875 |\n| Kaolin | Tuning | 88 | 582.0000 |\n| Tatiana | SQL | 87 | 287.1875 |\n+---------+--------+-------+------------------+
[VAR_SAMP]
declaration=expr
category=Functions and Modifiers for Use with GROUP BY
description=Returns the sample variance of expr. That is, the\ndenominator is the number of rows minus one.\n \nIt is an aggregate function, and so can be used with the\nGROUP BY clause.\n \nFrom MariaDB 10.2.2, VAR_SAMP() can be used as a window\nfunction.\n \nVAR_SAMP() returns NULL if there were no matching rows.\n \n\nAs an aggregate function:\n \nCREATE OR REPLACE TABLE stats (category VARCHAR(2), x INT);\n \nINSERT INTO stats VALUES \n (''a'',1),(''a'',2),(''a'',3),\n (''b'',11),(''b'',12),(''b'',20),(''b'',30),(''b'',60);\n \nSELECT category, STDDEV_POP(x), STDDEV_SAMP(x), VAR_POP(x) \n FROM stats GROUP BY category;\n \n+----------+---------------+----------------+------------+\n| category | STDDEV_POP(x) | STDDEV_SAMP(x) | VAR_POP(x) |\n+----------+---------------+----------------+------------+\n| a | 0.8165 | 1.0000 | 0.6667 |\n| b | 18.0400 | 20.1693 | 325.4400 |\n+----------+---------------+----------------+------------+\n \nAs a window function:\n \nCREATE OR REPLACE TABLE student_test (name CHAR(10), test\nCHAR(10), score TINYINT);\n \nINSERT INTO student_test VALUES \n (''Chun'', ''SQL'', 75), (''Chun'', ''Tuning'', 73), \n (''Esben'', ''SQL'', 43), (''Esben'', ''Tuning'', 31), \n (''Kaolin'', ''SQL'', 56), (''Kaolin'', ''Tuning'', 88), \n (''Tatiana'', ''SQL'', 87);\n \nSELECT name, test, score, VAR_SAMP(score) \n OVER (PARTITION BY test) AS variance_results FROM\nstudent_test;\n \n+---------+--------+-------+------------------+\n| name | test | score | variance_results |\n+---------+--------+-------+------------------+\n| Chun | SQL | 75 | 382.9167 |\n| Chun | Tuning | 73 | 873.0000 |\n| Esben | SQL | 43 | 382.9167 |\n| Esben | Tuning | 31 | 873.0000 |\n| Kaolin | SQL | 56 | 382.9167 |\n| Kaolin | Tuning | 88 | 873.0000 |\n| Tatiana | SQL | 87 | 382.9167 |\n+---------+--------+-------+------------------+
[VERSION]
declaration=
category=Information Functions
description=Returns a string that indicates the MariaDB server version.\nThe string\nuses the utf8 character set.\n \n\nSELECT VERSION();\n+------------------------------+\n| VERSION() |\n+------------------------------+\n| 10.0.3-MariaDB-1~precise-log |\n+------------------------------+\n \nThe VERSION() string may have one or more of the following\nsuffixes:\n \nSuffix | Description | \n \n-embedded | The server is an embedded server (libmysqld). | \n \n-log | General logging, slow logging or binary (replication)\nlogging is enabled. | \n \n-debug | The server is compiled for debugging. | \n \n-valgrind |  The server is compiled to be instrumented with\nvalgrind. | \n \nChanging the Version String\n \nSome old legacy code may break because they are parsing the\nVERSION string and expecting a MySQL string or a simple\nversion\nstring like Joomla til API17, see MDEV-7780.\n \nIn MariaDB 10.2 one can fool these applications by setting\nthe version string from the command line or the my.cnf files\nwith --version=....
[WEEKDAY]
declaration=date
category=Date and Time Functions
description=Returns the weekday index for date \n(0 = Monday, 1 = Tuesday, ... 6 = Sunday).\n \nThis contrasts with DAYOFWEEK() which follows the ODBC\nstandard\n(1 = Sunday, 2 = Monday, ..., 7 = Saturday).\n \n\nSELECT WEEKDAY(''2008-02-03 22:23:00'');\n+--------------------------------+\n| WEEKDAY(''2008-02-03 22:23:00'') |\n+--------------------------------+\n| 6 |\n+--------------------------------+\n \nSELECT WEEKDAY(''2007-11-06'');\n+-----------------------+\n| WEEKDAY(''2007-11-06'') |\n+-----------------------+\n| 1 |\n+-----------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d FROM t1 where WEEKDAY(d) = 6;\n \n+---------------------+\n| d |\n+---------------------+\n| 2011-10-30 06:31:41 |\n| 2011-01-30 14:03:25 |\n+---------------------+
[WEEKOFYEAR]
declaration=date
category=Date and Time Functions
description=Returns the calendar week of the date as a number in the\nrange from 1\nto 53. WEEKOFYEAR() is a compatibility function that is\nequivalent to\nWEEK(date,3).\n \n\nSELECT WEEKOFYEAR(''2008-02-20'');\n+--------------------------+\n| WEEKOFYEAR(''2008-02-20'') |\n+--------------------------+\n| 8 |\n+--------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \n select * from t1;\n \n+---------------------+\n| d |\n+---------------------+\n| 2007-01-30 21:31:07 |\n| 1983-10-15 06:42:51 |\n| 2011-04-21 12:34:56 |\n| 2011-10-30 06:31:41 |\n| 2011-01-30 14:03:25 |\n| 2004-10-07 11:19:34 |\n+---------------------+\n \nSELECT d, WEEKOFYEAR(d), WEEK(d,3) from t1;\n \n+---------------------+---------------+-----------+\n| d | WEEKOFYEAR(d) | WEEK(d,3) |\n+---------------------+---------------+-----------+\n| 2007-01-30 21:31:07 | 5 | 5 |\n| 1983-10-15 06:42:51 | 41 | 41 |\n| 2011-04-21 12:34:56 | 16 | 16 |\n| 2011-10-30 06:31:41 | 43 | 43 |\n| 2011-01-30 14:03:25 | 4 | 4 |\n| 2004-10-07 11:19:34 | 41 | 41 |\n+---------------------+---------------+-----------+
[WEEK]
declaration=date[,mode]
category=Date and Time Functions
description=This function returns the week number for date. The\ntwo-argument form of\nWEEK() allows you to specify whether the week starts on\nSunday or Monday\nand whether the return value should be in the range from 0\nto 53 or from 1 to\n53. If the mode argument is omitted, the value of the\ndefault_week_format system variable is used.\n \nModes\n \nMode | 1st day of week | Range | Week 1 is the 1st week with\n| \n \n0 | Sunday | 0-53 | a Sunday in this year | \n \n1 | Monday | 0-53 | more than 3 days this year | \n \n2 | Sunday | 1-53 | a Sunday in this year | \n \n3 | Monday | 1-53 | more than 3 days this year | \n \n4 | Sunday | 0-53 | more than 3 days this year | \n \n5 | Monday | 0-53 | a Monday in this year | \n \n6 | Sunday | 1-53 | more than 3 days this year | \n \n7 | Monday | 1-53 | a Monday in this year | \n \n\nSELECT WEEK(''2008-02-20'');\n+--------------------+\n| WEEK(''2008-02-20'') |\n+--------------------+\n| 7 |\n+--------------------+\n \nSELECT WEEK(''2008-02-20'',0);\n+----------------------+\n| WEEK(''2008-02-20'',0) |\n+----------------------+\n| 7 |\n+----------------------+\n \nSELECT WEEK(''2008-02-20'',1);\n+----------------------+\n| WEEK(''2008-02-20'',1) |\n+----------------------+\n| 8 |\n+----------------------+\n \nSELECT WEEK(''2008-12-31'',0);\n+----------------------+\n| WEEK(''2008-12-31'',0) |\n+----------------------+\n| 52 |\n+----------------------+\n \nSELECT WEEK(''2008-12-31'',1);\n+----------------------+\n| WEEK(''2008-12-31'',1) |\n+----------------------+\n| 53 |\n+----------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT d, WEEK(d,0), WEEK(d,1) from t1;\n \n+---------------------+-----------+-----------+\n| d | WEEK(d,0) | WEEK(d,1) |\n+---------------------+-----------+-----------+\n| 2007-01-30 21:31:07 | 4 | 5 |\n| 1983-10-15 06:42:51 | 41 | 41 |\n| 2011-04-21 12:34:56 | 16 | 16 |\n| 2011-10-30 06:31:41 | 44 | 43 |\n| 2011-01-30 14:03:25 | 5 | 4 |\n| 2004-10-07 11:19:34 | 40 | 41 |\n+---------------------+-----------+-----------+
[WEIGHT_STRING]
declaration=str [AS {CHAR|BINARY}(N)] [LEVEL levels] [flags]
category=String Functions
description=Returns a binary string representing the string''s sorting\nand comparison value. A string with a lower result means\nthat for sorting purposes the string appears before a string\nwith a higher result.\n \nWEIGHT_STRING() is particularly useful when adding new\ncollations, for testing purposes.\n \nIf str is a non-binary string (CHAR, VARCHAR or TEXT),\nWEIGHT_STRING returns the string''s collation weight. If str\nis a binary string (BINARY, VARBINARY or BLOB), the return\nvalue is simply the input value, since the weight for each\nbyte in a binary string is the byte value.\n \nWEIGHT_STRING() returns NULL if given a NULL input. \n \nThe optional AS clause permits casting the input string to a\nbinary or non-binary string, as well as to a particular\nlength.\n \nAS BINARY(N) measures the length in bytes rather than\ncharacters, and right pads with 0x00 bytes to the desired\nlength. \n \nAS CHAR(N) measures the length in characters, and right pads\nwith spaces to the desired length.\n \nN has a minimum value of 1, and if it is less than the\nlength of the input string, the string is truncated without\nwarning.\n \nThe optional LEVEL clause specifies that the return value\nshould contain weights for specific collation levels. The\nlevels specifier can either be a single integer, a\ncomma-separated list of integers, or a range of integers\nseparated by a dash (whitespace is ignored). Integers can\nrange from 1 to a maximum of 6, dependent on the collation,\nand need to be listed in ascending order.\n \nIf the LEVEL clause is no provided, a default of 1 to the\nmaximum for the collation is assumed.\n \nIf the LEVEL is specified without using a range, an optional\nmodifier is permitted.\n \nASC, the default, returns the weights without any\nmodification.\n \nDESC returns bitwise-inverted weights.\n \nREVERSE returns the weights in reverse order.\n \n\nThe examples below use the HEX() function to represent\nnon-printable results in hexadecimal format.\n \nSELECT HEX(WEIGHT_STRING(''x''));\n+-------------------------+\n| HEX(WEIGHT_STRING(''x'')) |\n+-------------------------+\n| 0058 |\n+-------------------------+\n \nSELECT HEX(WEIGHT_STRING(''x'' AS BINARY(4)));\n+--------------------------------------+\n| HEX(WEIGHT_STRING(''x'' AS BINARY(4))) |\n+--------------------------------------+\n| 78000000 |\n+--------------------------------------+\n \nSELECT HEX(WEIGHT_STRING(''x'' AS CHAR(4)));\n+------------------------------------+\n| HEX(WEIGHT_STRING(''x'' AS CHAR(4))) |\n+------------------------------------+\n| 0058002000200020 |\n+------------------------------------+\n \nSELECT HEX(WEIGHT_STRING(0xaa22ee LEVEL 1));\n+--------------------------------------+\n| HEX(WEIGHT_STRING(0xaa22ee LEVEL 1)) |\n+--------------------------------------+\n| AA22EE |\n+--------------------------------------+\n \nSELECT HEX(WEIGHT_STRING(0xaa22ee LEVEL 1 DESC));\n+-------------------------------------------+\n| HEX(WEIGHT_STRING(0xaa22ee LEVEL 1 DESC)) |\n+-------------------------------------------+\n| 55DD11 |\n+-------------------------------------------+\n \nSELECT HEX(WEIGHT_STRING(0xaa22ee LEVEL 1 REVERSE));\n+----------------------------------------------+\n| HEX(WEIGHT_STRING(0xaa22ee LEVEL 1 REVERSE)) |\n+----------------------------------------------+\n| EE22AA |\n+----------------------------------------------+
[WITHIN]
declaration=g1,g2
category=Geometry Relations
description=Returns 1 or 0 to indicate whether g1 is spatially within\ng2.\nThis tests the opposite relationship as Contains().\n \nWITHIN() is based on the original MySQL implementation, and\nuses object bounding rectangles, while ST_WITHIN() uses\nobject shapes.\n \n\nSET @g1 = GEOMFROMTEXT(''POINT(174 149)'');\nSET @g2 = GEOMFROMTEXT(''POINT(176 151)'');\nSET @g3 = GEOMFROMTEXT(''POLYGON((175 150, 20 40, 50 60, 125\n100, 175 150))'');\n \nSELECT within(@g1,@g3);\n+-----------------+\n| within(@g1,@g3) |\n+-----------------+\n| 1 |\n+-----------------+\n \nSELECT within(@g2,@g3);\n+-----------------+\n| within(@g2,@g3) |\n+-----------------+\n| 0 |\n+-----------------+
[YEARWEEK1]
name=YEARWEEK
declaration=date
category=Date and Time Functions
description=Returns year and week for a date. The mode argument works\nexactly like the mode\nargument to WEEK(). The year in the result may be different\nfrom the\nyear in the date argument for the first and the last week of\nthe year.\n \n\nSELECT YEARWEEK(''1987-01-01'');\n+------------------------+\n| YEARWEEK(''1987-01-01'') |\n+------------------------+\n| 198652 |\n+------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT * FROM t1;\n \n+---------------------+\n| d |\n+---------------------+\n| 2007-01-30 21:31:07 |\n| 1983-10-15 06:42:51 |\n| 2011-04-21 12:34:56 |\n| 2011-10-30 06:31:41 |\n| 2011-01-30 14:03:25 |\n| 2004-10-07 11:19:34 |\n+---------------------+\n6 rows in set (0.02 sec)\n \nSELECT YEARWEEK(d) FROM t1 WHERE YEAR(d) = 2011;\n \n+-------------+\n| YEARWEEK(d) |\n+-------------+\n| 201116 |\n| 201144 |\n| 201105 |\n+-------------+\n3 rows in set (0.03 sec)
[YEARWEEK2]
name=YEARWEEK
declaration=date,mode
category=Date and Time Functions
description=Returns year and week for a date. The mode argument works\nexactly like the mode\nargument to WEEK(). The year in the result may be different\nfrom the\nyear in the date argument for the first and the last week of\nthe year.\n \n\nSELECT YEARWEEK(''1987-01-01'');\n+------------------------+\n| YEARWEEK(''1987-01-01'') |\n+------------------------+\n| 198652 |\n+------------------------+\n \nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT * FROM t1;\n \n+---------------------+\n| d |\n+---------------------+\n| 2007-01-30 21:31:07 |\n| 1983-10-15 06:42:51 |\n| 2011-04-21 12:34:56 |\n| 2011-10-30 06:31:41 |\n| 2011-01-30 14:03:25 |\n| 2004-10-07 11:19:34 |\n+---------------------+\n6 rows in set (0.02 sec)\n \nSELECT YEARWEEK(d) FROM t1 WHERE YEAR(d) = 2011;\n \n+-------------+\n| YEARWEEK(d) |\n+-------------+\n| 201116 |\n| 201144 |\n| 201105 |\n+-------------+\n3 rows in set (0.03 sec)
[YEAR]
declaration=date
category=Date and Time Functions
description=Returns the year for the given date, in the range 1000 to\n9999, or 0 for the\n"zero" date.\n \n\nCREATE TABLE t1 (d DATETIME);\nINSERT INTO t1 VALUES\n ("2007-01-30 21:31:07"),\n ("1983-10-15 06:42:51"),\n ("2011-04-21 12:34:56"),\n ("2011-10-30 06:31:41"),\n ("2011-01-30 14:03:25"),\n ("2004-10-07 11:19:34");\n \nSELECT * FROM t1;\n \n+---------------------+\n| d |\n+---------------------+\n| 2007-01-30 21:31:07 |\n| 1983-10-15 06:42:51 |\n| 2011-04-21 12:34:56 |\n| 2011-10-30 06:31:41 |\n| 2011-01-30 14:03:25 |\n| 2004-10-07 11:19:34 |\n+---------------------+\n \nSELECT * FROM t1 WHERE YEAR(d) = 2011;\n \n+---------------------+\n| d |\n+---------------------+\n| 2011-04-21 12:34:56 |\n| 2011-10-30 06:31:41 |\n| 2011-01-30 14:03:25 |\n+---------------------+\n \nSELECT YEAR(''1987-01-01'');\n+--------------------+\n| YEAR(''1987-01-01'') |\n+--------------------+\n| 1987 |\n+--------------------+