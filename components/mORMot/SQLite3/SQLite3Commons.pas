/// Common ORM and SOA classes
// - this unit is a part of the freeware Synopse mORMot framework,
// licensed under a MPL/GPL/LGPL tri-license; version 1.17
unit SQLite3Commons;

(*
    This file is part of Synopse mORMot database framework.

    Synopse mORMot framework. Copyright (C) 2012 Arnaud Bouchez
      Synopse Informatique - http://synopse.info

  *** BEGIN LICENSE BLOCK *****
  Version: MPL 1.1/GPL 2.0/LGPL 2.1

  The contents of this file are subject to the Mozilla Public License Version
  1.1 (the "License"); you may not use this file except in compliance with
  the License. You may obtain a copy of the License at
  http://www.mozilla.org/MPL

  Software distributed under the License is distributed on an "AS IS" basis,
  WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  for the specific language governing rights and limitations under the License.

  The Original Code is Synopse SQLite3/mORMot database framework.

  The Initial Developer of the Original Code is Arnaud Bouchez.

  Portions created by the Initial Developer are Copyright (C) 2012
  the Initial Developer. All Rights Reserved.

  Contributor(s):
  Alternatively, the contents of this file may be used under the terms of
  either the GNU General Public License Version 2 or later (the "GPL"), or
  the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  in which case the provisions of the GPL or the LGPL are applicable instead
  of those above. If you wish to allow use of your version of this file only
  under the terms of either the GPL or the LGPL, and not to allow others to
  use your version of this file under the terms of the MPL, indicate your
  decision by deleting the provisions above and replace them with the notice
  and other provisions required by the GPL or the LGPL. If you do not delete
  the provisions above, a recipient may use your version of this file under
  the terms of any one of the MPL, the GPL or the LGPL.

  ***** END LICENSE BLOCK *****


       Commons routines for a SQLite3-based database framework
      *********************************************************

    - fast UTF-8 / Unicode / WinAnsi types and conversion routines
    - RawUnicode support (similar to UnicodeString in Delphi 2009)
    - ISO 8601:2004 functions to properly handle date/time values in TEXT field
    - TSQLTable class to handle SQLite3-like table results (can then be
      displayed with SQLite3UI unit, or search - with Soundex if wanted)
    - TSQLTableJSON and TSQLJSONWriter classes to transmit results in JSON format
    - inherit TSQLRecord to define Table structure once in some published
      properties and easily interact with the server (alla Ruby on Rails),
      making this framework implements a full Object-relational mapping
    - TSQLRestClient and TSQLRestServer to handle a REST client/server protocol
      with GET/POST/PUT/DELETE methods
    - if REST protocol is not enough (JOIN e.g.) a full SQL statement can be used
    - locking is handled at record level, with new LOCK and UNLOCK REST methods
      (SQLite3 only handle database level lock)
    - fast transaction is available, with new BEGIN, END and ABORT REST methods
    - after a record deletion, ensure relational database coherency
    - TSQLRestServerStaticInMemory implements a basic REST in-memory database
      engine (no need to use SQLite3 database engine for simplier applications)
    - client/server access can be used through a fast direct local DLL export
    - client/server local or remote access can be used through a named pipe
      or HTTP/1.1 protocol (with unit SQLite3HttpServer/SQlite3HttpClient)
    - smart update of any result table or record (retrieve data only if changed)
    - very fast "stored procedure" feature, coded in Delphi

      Initial version: 2008 March, by Arnaud Bouchez

    Version 1.1 - 14 January 2010:
    - SQLite3 database layer updated to version 3.6.22
    - new communication layer, to be used on a local computer: windows messages
      (see TSQLRestClientURIMessage class). On a local machine, this is faster
      than named pipes and http, for small messages (quite as fast as direct
      access); but named pipes seems to be better for bigger messages
    - allow to get rid of our Enhanced Runtime Library dependency if not available
      (e.g. for FPC or on cross-platform, or on Delphi version newer than Delphi
      2007): just define the ENHANCEDRTL conditional below if installed it
      (always undefined if UNICODE is defined)
    - attempt to reach Delphi 2009/2010 compilation (string=UnicodeString):
      the UNICODE conditional will adapt the framework to these compilers
      (you shouldn't have to change any conditional define below)
    - attempt to reach Free Pascal Compiler 2.4.0 compatibility
    - all asm code equivalence in pure pascal code for 64 bits compatibility
      (always slower, but always portable to all CPUs)
    - use of PtrUInt / PtrInt for 64 bits compatibility
    - in case of FPC, the typinfo.pp unit is used: so all published properties
      in any TSQLRecord descendant must have a setter (i.e. a "write fValue"
      statement); the FPC's RTTI is not the same as Delphi's: it's a shame :(

    Version 1.2 - 16 January 2010
    - compatibility tested up to Delphi 2009 (that is tested with Delphi 7,
      Delphi 2007 and Delphi 2009), with or without our Enhanced
      Run Time Library (which now compiles up to Delphi 2007) - by default, the
      ENHANCEDRTL compiler conditional is not defined;
    - lot of rewrite made for the Unicode version of the compiler (tested with
      Delphi 2009) - it was quite difficult to avoid most implicit conversions...
      the compiler is a bit tricky, as soon as you want to use the UTF-8 encoding
      (as we do, since JSON and HTTP do like this encoding, together as SQLite3),
      and not Unicode (which is in fact UTF-16);
    - can create an internal TSQLRestClientURIMessage messaging window, if
      you don't have any User Interface (so you don't have to add Forms unit)
    - named pipe speed improvement (10 times faster) under Vista and Seven

    Version 1.3 - January 22, 2010
    - disconnect piped name client after 30 min of inactivity to free the
      corresponding thread resource if the client failed to close cleanly
    - some small fixes (e.g. integer to and from string conversion, GPF) and
      multi-compiler (Delphi 2009/2010, especialy with TypInfo define) compatibility
    - compiler conditional renamed ENHANCEDRTL instead of ENHANCEDTRTL
    - new TSQLTable.GetRowValues overloaded methods

    Version 1.3.1 - January 23, 2010
    - some Pos() overload problem under Delphi 20007 compiler; since
      this Pos() is seldom used, it was decided to only define it under
      Delphi 2009/2010 (which expect such a RawUTF8 specific overloaded version)
    - source code adaptation to use only ASCII 7 bits characters: should be OK
      with asiatic MBCS text encoding and such IDE

    Version 1.3.2 - January 24, 2010
    - new StringToUTF8() and UTF8ToString() functions; it's prefered to use
    TLanguageFile.StringToUTF8() method from SQLite3i18n, which will handle full
    i18n of your application; these functions use the current RTL codepage
    under Delphi 3-2007

    Version 1.4 - February 8, 2010
    - whole Synopse SQLite3 database framework released under the GNU Lesser
      General Public License version 3, instead of generic "Public Domain"

    Version 1.5 - March 10, 2010
    - SQLite3 database layer updated to version 3.6.23
    - User Interface Query action implementation
    - added security attributes to the named pipes creation: now this
      communication layer can work as a windows service, under Vista or Seven
      (thanks to esmond comment in our blog for the tip)
    - added new FastCGI server (not 100% tested)
    - first attempt to add REST paging requests for 'GET ModelRoot/TableName',
      as expected by the YUI DataSource Request Syntax for data pagination:
      see http://developer.yahoo.com/yui/datatable/#data

    Version 1.6
    - SQLite3 database layer updated to version 3.6.23.1
    - most useful functions are now shared in a separate SynCommons unit
    - the framework is now licensed under a MPL/GPL/LGPL tri-license
    - obscure JSON parsing bug fixed (when a field content finished with '\')

    Version 1.7
    - alter table with newly added fields to a TSQLRecord (see GetSQLAddField()
      methods)
    - some compatibility fixes for Delphi 2009/2010
    - fixed bug: negative numbers were not updated when calling *.Update()

    Version 1.8
    - includes Unitary Testing class and functions
    - update engine to version 3.7.0
    - new direct methods to handle BLOB fields from clients or servers
    - new URI to GET or PUT BLOB fields: ModelRoot/TableName/ID/BlobFieldName
    - fixed bug in TSQLTable.GetJSONValues: FirstRow parameter not used
    - TTextWriter class moved from SQLite3Commons to SynCommons
    - new ModelRoot/[TableName/ID/]MethodName RESTful GET/PUT request
     (see TSQLRestServerCallBack definition and comments): implements some custom
     Client/Server request, similar to the DataSnap technology, but in a KISS way;
     it's fully integrated in the Client/Server architecture of our framework,
     and extend its ORM feature to Object-less communication - see new
     ModelRoot/Stat method implement in TSQLRestServer
    - floating point numbers are now encoded using new ExtendedStr[ing] methods:
     such values are now encoded in a more human readable way in the JSON content
    - new tests added (mostly relative to the new functions or classes)

    Version 1.9
    - update engine to version 3.7.1
    - fixed error calling a TSQLRestServerCallBack with both record & parameters
    - TSQLRecordSigned must now be signed with a specified content (content
      was formerly a fixed field of type RawUTF8, but it didn't apply in
      all cases, e.g. if content field is defined as TSQLRawBlob)
    - new TSQLRestClientURI.ForceBlobTransfert property which enable to
      get and set BLOB fields values with usual Add/Update/Retrieve methods
    - new TSQLRestClientURI.RetrieveBlobFields/UpdateBlobFields methods
      for retrieving/updating all BLOB fields of a record at once
    - better handling of sftID in the User Interface and database use (e.g.
      creates a dedicated index for the TSQLRecord published fields)
    - some code rewrite in order to avoid any implicit conversion from/to
      integer/cardinal after new definition of PtrInt/PtrUInt (matching
      NativeInt/NativeUInt types, available since Delphi 2007)
    - updated TSQLRibbonTabParameters object, with some new fields dedicated
      to the automatic edition of records, via the new SQLite3UIEdit unit
    - new sftSet SQL field kind, handling a TSQLRecord published property
      with a set of enumeration as Delphi type (stored as bit-mapped INTEGER)
    - handle now RowID as a valid alias to the ID field (needed for TSQLRecordFTS3)
    - defines a new TSQLRecordFTS3 type, for defining a FTS3 virtual table,
      i.e. implementing full-text search

    Version 1.9.1
    - update engine to version 3.7.2: an obscure but very old bug makes
      SQLite authors recommend to use 3.7.2  for all new development.
      Upgrading from all prior SQLite versions is also recommended.

    Version 1.9.2
    - WriteObject and CopyObject functions now handle Int64 properties,
      as TJSONWriter.WriteObject method does now also
    - new TSQLRestServerStatic.GetOne and TSQLRestServerStatic.UpdateOne methods,
      methods available since a TSQLRestServerStatic instance may be created
      stand-alone, i.e. without any associated Model/TSQLRestServer
    - diverse fixes in TSQLRestServerStatic which could occur in not expected
      behavior if security events are enabled for this table (wrong IDToIndex)
    - new TSQLRecordLog.CreateFrom method used to append some log records
      to an existing JSON log content

    Version 1.10
    - code modifications to compile with Delphi 6 compiler (Delphi 5 failed due
      to some obscure compiler bugs in SynCrypto.pas)
    - update SQLite3 engine to version 3.7.3

    Version 1.11
    - update SQLite3 engine to version 3.7.4
    - new TSQLRecordProperties class, used internally by TSQLRecord to access
      to the RTTI via some high-level structures (therefore save memory for each
      TSQLRecord instance, and make operations faster)
    - new TSQLRecordFill class, used internally by TSQLRecord.FillPrepare()
      to save memory: a TSQLRecord instance has now only 20 bytes of InstanceSize
    - TSQLRecord.ID reader has now a GetID() getter which can handle the fact that
      a published property declared as TSQLRecord (sftID type) contains not a
      true TSQLRecord instance, but the ID of this record: you can use
      aProperty.ID method in order to get the idea - but prefered method is to
      typecast it via PtrInt(aProperty), because GetID() relies on some low-level
      windows memory mapping trick
    - new TSQLRecordMany to handle "has many" and "has many through" relationships
    - TSQLRestServer.AfterDeleteForceCoherency now handles specifically
      TRecordReference, TSQLRecord (fixed) and new 'has many' Source/Dest fields
      (this is our internal "FOREIGN KEY" implementation - we choose not to
      rely on the database engine for that, in order to be engine-independent...
      and SQLite3 introduced FOREIGN KEY in 3.6.19 version only)
    - TSQLRestServer.AfterDeleteForceCoherency now synchronizes as expected
      TSQLRestServerStatic table content
    - new TSQLRestServerStatic.SearchField method, for fast retrieval of
      all IDs matching a field of a TSQLRestServerStatic table (faster than
      using any OneFieldValues method, which creates a temporary JSON content)
    - TSQLRecord.FillRow method has been made virtual, so that some calculated
      field can be initialize during table content enumeration
    - corrected possible GPF error in TSQLRestServer.Retrieve
    - sftMany/TSQLRecordMany field type handled as a not simple field
    - new TSQLRecord.SimplePropertiesFill() method, to fill the simple properties
      with a given list of const parameters, following the declared order of
      published properties of the supplied table
    - new TSQLRest.Add(aTable: TSQLRecordClass; const aSimpleFields: array of const)
      overloaded method to add a record from a supplied list of const parameters
    - new TSQLRest.Update(aTable: TSQLRecordClass; aID: integer; const aSimpleFields: array of const)
      overloaded method to update a record from a supplied list of const parameters
    - new class function TSQLRecord.SimpleFieldsCount
    - FTS3Match method renamed FTSMatch, in order to be used without hesitation
      for both FTS3 and FTS4 classes
    - new overloaded FTSMatch method, accepting ranking of MATCH, using the
      new RANK internal function - see http://www.sqlite.org/draft/fts3.html#appendix_a
    - new TSQLRecordFTS4 class, to handle new FTS4 extension module  - see
      http://sqlite.org/fts3.html#section_1_1 - which is available since 3.7.4
    - new TSQLRecord.FillClose method
    - new TSQLRecord.CreateAndFillPrepare() methods, to makes loop into records
      easier (an hidden TSQLTable is created and released by TSQLRecord.Destroy)
    - new overloaded TSQLRestServer.CreateSQLIndex() method, accepting an array
      of field names
    - new TSQLRecord.FillPrepare(const aIDs: TIntegerDynArray) overloaded method,
      which can be handy to loop into some records via an IDs set
    - new TSQLTable.OwnerMustFree property for generic owning of a TSQLTable
      by a record - used for both CreateAndFillPrepare and TSQLRecordMany.FillMany
    - better non-ascii search handling in TSQLTable.SearchValue
    - source code modified to be 7 bit Ansi (so will work with all encodings)

    Version 1.12
    - now handle automaticaly prepared SQL statements: the parameters must
      be surrounded with :(...): in order to use an internal pool of prepared
      TSQLRequest statements; example of possible inlined values are :(1234):
      :(12.34): :(12E-34): :("text"): or :('text'): (with double quoting
      inside the text, just like any SQL statement)
    - with Delphi 2009+, you can define any string parameter in your
      TSQLRecord definition (will be handled as sftUTF8Text field)
    - with Delphi 2009+, WriteObject, ReadObject and CopyObject functions
      now handle string (UnicodeString) properties, as TINIWriter.WriteObject
      method does also: UTF-8 encoding is used at the storage level
    - new function SQLParamContent() to retrieve :(...): param content and type
    - another review of Pos() calls in the code (now use our fast PosEx)
    - some functions or type/const definitions moved to SynCommons in order
      to introduce new TSynTable class (TJSONWriter, IsRowID, GotoNextJSONField,
      TSynTableStatement...)
    - new TSQLRestServer.CreateSQLMultiIndex method
    - new TSQLTable.GetString and TSQLTable.GetVariant methods
    - new TPropInfo.SetVariant/GetVariant/CopyValue methods
    - new GetFieldValue/SetFieldValue and GetFieldVariant/SetFieldVariant
      methods for TSQLRecord
    - fixed issue in TSQLTable.GetWP(), which truncated data in Grid display
    - fixed issue in TSQLRestServerNamedPipe[Response] multi-thread architecture:
      FastMM in full debug mode detected that a block has been modified after
      being freed - now TSQLRestServerNamedPipeResponse is fully stand-alone

    Version 1.13
    - the ORM will now include all published properties of the parents, up to
      TSQLRecord, to the database fields (it was only using the published
      properties at the topmost class level)
    - dynamic arrays can now be specified for TSQLRecord published properties:
      a new sftBlobDynArray field kind has been added - will be stored as BLOB in
      the database (following the TDynArray.SaveTo binary stream layout), and
      will be transmitted as Base64 encoded in the JSON stream - we implemented
      a sftBlobRecord field kind, but Delphi RTTI is not generated for published
      properties of records: so our code is disabled (see PUBLISHRECORD
      conditional) :( - but you can use dynamic arrays of records
    - TPersistent can be now be specified for TSQLRecord published properties:
      a new sftObject field kind has been added - will be stored as TEXT in the
      database (following the ObjectToJSON serialization format) - TStrings or
      TRawUTF8List will be stored as a JSON array of string, and TCollection
      as a JSON array of objects, other TPersistent classes will have their
      published properties serialized as a JSON object  
    - introducing direct content filtering and validation using
      TSynFilterOrValidate dedicated classes
    - filtering is handled directly in the new TSQLRecord.Filter virtual method,
      or via some TSynFilter classes - TSynFilterUpperCase, TSynFilterUpperCaseU,
      TSynFilterLowerCase, TSynFilterLowerCaseU and TSynFilterTrim e.g.
    - validation is handled in the new TSQLRecord.Validate virtual method,
      or via some TSynValidate classes - TSynValidateRest, TSynValidateIPAddress,
      TSynValidateEmail, TSynValidatePattern, TSynValidatePatternI,
      TSynValidateText, TSynValidatePassWord e.g.
    - introducing TSQLRecordRTree to implement R-Tree virtual tables - and new
      TSQLRecordVirtual parent table for all virtual tables like TSQLRecordFTS*
    - new TSQLRestClientURI methods to implement BATCH sequences to speed up
      database modifications: after a call to BatchStart, database modification
      statements are added to the sequence via BatchAdd/BatchUpdate/BatchDelete,
      then all statments are sent as once to the remote server via BatchSend -
      this is MUCH faster than individual calls to Add/Update/Delete in case
      of a slow remote connection (typically HTTP over Internet)
    - introducing TSQLVirtualTableModule / TSQLVirtualTable /
      TSQLVirtualTableCursor classes for a generic Virtual table mechanism
      (used e.g. by TSQLVirtualTableModuleDB in the SQLite3 unit)
    - new TSQLRecordVirtualTableAutoID and TSQLRecordVirtualTableForcedID
      classes, used to access any TSQLVirtualTable in our ORM
    - security and per-user access rights is now implemented in the framework
      core using per-User authentication via in-memory sessions (stored as
      TAuthSession), with group-defined associated security parameters (via
      TSQLAuthUser and TSQLAuthGroup tables), and RESTful Query Authentication
      via URI signature; should avoid most MITM and replay attacks
    - new TJSONSerializer class and ObjectToJSON/JSONToObject method
      (handles also dynamic arrays following the TTextWriter.AddDynArrayJSON
      format, i.e. plain JSON array for common types aka '[1,2,3]', but Base64
      encoded stream aka '["\uFFF0base64encodedbinary"]' for other arrays) and
      corresponding UrlDecodeObject() function (to be called by RESTful Services
      implementation on Server side)
    - wider usage of TSQLRecordProperties, for faster RTTI access, via the new
      class function TSQLRecord.RecordProps: TSQLRecordProperties: only
      virtual class function or procedure are now defined in TSQLRecord
    - enhanced TPropInfo.GetLongStrValue/SetLongStrValue methods, now converting
      RawUnicode, WinAnsiString, TSQLRawBlob and AnsiString properties
    - now ensure that no published property named ID or RowID was defined (this
      unique primary key field must be handled directly by TSQLRecord)
    - MAX_SQLFIELDS default is still 64, but can now be set to any value (64,
      128, 192 and 256 have optimized fast code) so that you can have any number
      of fields in a Table
    - MAX_SQLTABLES default is now 256, i.e. you can have up to 256 tables in a
      TSQLModel instance (you can set any other value, on need)
    - TSQLModel implementation speed up, in case of a huge number of registered
      TSQLRecord in the database Model (since MAX_SQLTABLES=256 by default)
    - enhanced TSQLRecordMany.DestGetJoinedTable method to handle custom fields
    - TSQLRecordMany.DestGetJoined* methods now accept generic TSQLRest class
    - new aCustomFieldsCSV parameter for FillPrepare / CreateAndFillPrepare
      methods of TSQLRecord, to retrieve only neeeded fields: be aware that
      not specified fields will be left untouched, so a later Update() call may
      corrupt the row data - this optional parameter is about to save bandwidth
      when retrieving records field in a loop 
    - TSQLRestServerStaticInMemory can now store its content into UTF-8 JSON
      or an optimized (SynLZ) compressed binary format - associated TPropInfo
      GetBinary/SetBinary and TSQLRecord GetBinaryValues/SetBinaryValues methods
    - the generic TVarData type is now used as a standard way of fast values
      communication: only handled VType are varNull, varInt64, varDouble,
      varString (mapping a constant PUTF8Char), and varAny (BLOB with size =
      VLongs[0]) - used e.g. by SQLite3 unit (VarDataToContext/VarDataFromValue)
    - new TSQLRest.Retrieve(aPublishedRecord, aValue: TSQLRecord) and
      TSQLRecord.Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord..) methods
    - ExecuteList defined in TSQLRest, so now available also in TSQLRestServer
    - added a magic pattern check to ignore broadcasted WM_COPYDATA message
    - fixed issue in serializing sftCurrency type in TSQLRecord.GetJSONValue

  Version 1.14
    - new TPropInfo.GetCurrencyValue method
    - fixed issue in produced JSON stream using '=' instead of ':'

  Version 1.15
    - unit now tested with Delphi XE2 (32 Bit)
    - new sftModTime / TModTime published field type in TSQLRecord, which will
      be set to the current server time stamp before update/adding
    - new sftCreateTime / TCreateTime published field type in TSQLRecord, which
      will be set to the current server time stamp at record creation
    - new TSQLRest.ServerTimeStamp property, which will return the current
      server time as TTimeLog/Int64 value (will use the new /TimeStamp RESTful
      service to retrieve the exact server time)
    - TSQLRestServerStaticInMemory uses a per-Table Critical Section to have
      its EngineList, EngineRetrieve, EngineAdd, EngineUpdate, EngineDelete,
      EngineRetrieveBlob, EngineUpdateBlob methods begin thread-safe
    - enhanced TSQLRestServer.URI thread-safety (e.g. Sessions access)
    - TSQLTable.InitFieldTypes will now also use column type retrieved during
      JSON parsing
    - new TSQLTable.GetCSVValues method
    - GetJSONValues() is now using an internal TRawByteStringStream when
      the expected result is a RawUTF8 (avoid copying content twice, and is
      perfectly thread-safe)
    - the shared fTempMemoryStream is not available any more (not thread-safe)
    - new TSQLRest.AcquireWrite/ReleaseWrite protected methods, used by
      TSQLRestServer.URI to safely write to the DB (e.g. for POST/PUT/DELETE...)
      with TSQLRest.AcquireWriteTimeOut, both thread-safe and transaction-safe
    - TSQLRest.TransactionBegin / Commit / RollBack methods now expect a
      SessionID parameter in order to allow safe concurent access: writing to
      the database is queued within a single client session
    - CreateSQLMultiIndex and CreateSQLIndex methods now working on external
      DB virtual tables (using SynDB.TSQLDBConnectionProperties.SQLAddIndex)
    - new TSQLRecordProperties.ExternalTableName and ExternalDatabase fields
      used by SQLite3DB to handle external SynDB-based database access
    - code refactoring to make TSQLRestServerStatic more generic (for SQLite3DB)
    - TSQLRestServer.UpdateField now accepts to search by ID or by value (used
      e.g. by rewritten TSQLRestServer.AfterDeleteForceCoherency method)
    - introducing TSQLRecordExternal kind of record, able to use any SynDB
      external database engine (e.g. OleDB/MSSQL/Oracle/SQLite3)
    - new ExtractInlineParameters procedure to handle :(1234): SQL statements
    - new MakePrivateCopy property in TSQLTableJSON.Create, which will avoid
      creating a private copy of the JSON (used e.g. in SynDBExplorer to handle
      very large result sets, with half the memory)
    - new TSQLRecordProperties.SQLUpdateSet, SQLInsertSet and AppendFieldName
      properties/method (used for external DB handling)
    - new TSQLRecord.Create, TSQLRecord.FillPrepare,
      TSQLRecord.CreateAndFillPrepare, TSQLRest.OneFieldValue,
      TSQLRest.MultiFieldValues, TSQLRestClient.EngineExecuteFmt and
      TSQLRestClient.ListFmt overloaded methods, accepting both '%' and '?'
      characters in the SQL WHERE format text, inlining '?' parameters
      with :(...): and auto-quoting strings
    - new UnicodeComparison parameter in TSQLTable.SearchValue to handle
      property non WinAnsi (code page 1252) characters
    - fixed issue in TPropInfo.GetBinary method with dynamic arrays (used e.g.
      by TSQLRestServerStaticInMemory.SaveToBinary)
    - fixed issue with TAuthSession.IDCardinal=0 or 1 after 76 connections
    - fixed issue in SetInt64Prop() with a setter method
    - fixed potential issue in TSQLTable.SearchValue in case of invalid Client
      supplied parameter (now checks TSQLRest class type)

  Version 1.16
    - mORMot framework now implements Client-Server service implementation
      using regular Delphi interfaces (over a RESTful or JSON-RPC protocol),
      using TServiceContainer / TServiceFactory classes, accessible via
      TSQLRest.Services property, on both client and server side, with
      auto-marshaling, JSON serialization, and built-in security 
    - added dedicated Exception classes (EORMException, EParsingException,
      ESecurityException, ECommunicationException, EBusinessLayerException,
      EServiceException) all inheriting from SynCommons.ESynException
    - added a generic JSON error message mechanism within the framework
      (including error code as integer and text, with custom error messages
      in RecordCanBeUpdated method and also in TSQLRestServerCallBackParams)
    - added TSQLRestServerFullMemory class to implement a basic REST server
      using only in-memory tables (will only handle CRUD commands, but is
      enough to handle authentication with optional persistence in JSON file)
    - added TSQLRestServerRemoteDB class to implement a REST server using a
      remote TSQLRestClient connection for all its ORM process: can be used
      e.g. to publish services with a dedicated process in a DMZ
    - deep refactoring of TSQLRestClient / TSQLRestClientURI methods, for
      better compliance with the Liskov substitution principle (LSP) 
    - TSQLRestServer published method names are now hash-stored for speed
    - the TSQLRestServerCallBack method prototype has been modified to supply
      "var aParams: TSQLRestServerCallBackParams: cardinal" as unique parameter:
      this is a CODE BREAK change and you shall refresh ALL your server-side
      code to match the new signature (using a record passed by value as
      parameter will ensure faster code and seamless evolution of this structure) 
    - new TSQLRestServer.SessionGetUser method to be used e.g. by any
      TSQLRestServerCallBack method implementation to retrieve the connected user
    - now the TSQLAuthUser instance retrieved during the session opening will
      retrieve the Data BLOB field (ready to be consummed on the server side)
    - introduced TSQLRestServerSessionContext structure to include current User
      and Group ID to the execution context (in addition to the Session ID)
    - TSQLRestServerStaticInMemory binary format changed: now will store its
      content per field (to ensure better compression) - magic identifier changed 
    - now TSQLRestClientURI BATCH sequences methods will allow to mix several
      TSQLRecord in its sequence of BatchAdd/BatchUpdate/BatchDelete calls - if
      initiated as BatchStart(nil)
    - code clean-up of TSQLRestClientURI.SetUser + added aHashedPassword optional
      parameter (to use already hashed password) 
    - added TSQLOccasion to handle the special case of field type (like
      TCreateTime) in case of Upate/Insert/Select
    - TCreateTime published fields now are not modified at update
    - fixed unexpected exception raised in TSQLRecord.FillOne if FillPrepare
      was successfull, but did not return any row
    - introducing TSQLRest.Cache and TSQLRestCache class to handle Client or
      Server side fast in-memory cache (with tuned configuration and timeout)
    - associated TSQLRestServer.CacheFlush service for flushing the Server cache,
      and remote TSQLRestClientURI.ServerCacheFlush() method for the client
    - fixed issue in TSQLRecord.FillPrepare when the table has less columns
      that the filling TSQLTable (can occur e.g. when using aCustomFieldsCSV
      parameter in FillPrepare method)
    - EngineList methods (including TSQLRestServerStaticInMemory class) now
      handles an optional integer pointer, to return the count of row data
    - uses new generic TSynAnsiConvert classes for code page process: that is,
      SQLite3i18n S2U() and U2S() match the SynCommons StringToUTF8() and
      UTF8ToString() functions - therefore, the TUTF8ToStringEvent parameter is
      not useful any more
    - more than MAX_SQLFIELDS-1 columns (by default, 63) will raise an exception
    - added TJSONSerializer.RegisterCustomSerializer() method to allow JSON
      serialization of any class (thanks Pavel "aka mpv" for the idea and patch)
    - added TSQLRestServer.ServiceMethodByPassAuthentication method in order to
      allow by-pass of the RESTful authentication scheme for some methods (can
      be used e.g. to server some HTML content for a non SOA client)
    - fix issue about missing last item in JSONToObject() function
    - fix issue when handling null JSON objects in GetJSONObjectAsSQL() function
    - JSON functions now handle '0' as number according to http://json.org specs
    - fix issue about record locking in TSQLRestClientURI.Retrieve method
    - fix execution issue in TSQLRestServer.AfterDeleteForceCoherency()
    - fix issue about abusive session timeout: TSQLRestServer.SessionGet is now
      renamed SessionAccess and refreshes the session access timestamp each time
      a session is retrieved (+internal implementation fix)
    - fix issue in SetInt64Prop() procedure which failed the update of a property
      with no explicit setter
    - fix issue in TSQLRecord.FillFrom() which forgot to update InternalState
    - fix issue in TPropInfo.SetValue + TSQLRecord.ClearProperties with Value=nil 
    - fix potential formating issue in TSQLTable.GetJSONValues/GetCSVValues
      methods which may create some wrong formating if TEXT is null/false/true
      (were formerly recognized as JSON keywords, whereas it should have already
      been transformed into nil, '0' or '1')
    - fix issue of unhandled buffer in TSQLTableJSON.UpdateFrom()
    - fix issue about transactions not working with TSQLRestServerStaticInMemory
    - fix issue in TSQLRestServerStaticInMemory on SELECT with only one column
    - fix TSQLTable.GetCSVValues() format (adding UTF-8 BOM)
    - TSQLRestServer.URI now returns "Location:" header without the digital
      signature (e.g. 'Location: People/11012') for a POST (=CRUD create/add)
    - TSQLRestClient.List and ListFmt methods now use TSQLRecordClass open
      array instead of TClass (for consistency)
    - new global RecordClassesToClasses() wrapper function to convert an
      array of TSQLRecordClass into the expected array of TClass
    - TPropInfo.CopyValue method now specifically handle copy of TCollection
      published properties items (used e.g. in TSQLRecord.FillFrom)
    - new GetEnumNameTrimed() wrapper function
    - new TRecordType definition, and TTypeinfo.RecordType associated method
    - now JSONToObject/ObjectToJSON functions and WriteObject method will handle
      standard TPersistent class serialization into/from JSON object
    - now ObjectToJSON/JSONToObject will unserialize sets and enumerations
      as an array of string, if HumanReadable is set to TRUE
    - now TSQLRestServer.Auth service returns true JSON response as specified
      by its content type (for better AJAX compatibility)
    - re-declared TSQLAccessRights record as an object, and added some
      dedicated methods: FromString, ToString, Edit
    - faster and more generic TSQLRecord.FillPrepare/FillRow implementation,
      including enhanced TSQLRecordFill class
    - faster TSQLRestServerStaticInMemory.LoadFromJSON and LoadFromBinary methods
    - reUrlEncodedSQL remote access right allows execution of SQL statement from
      a GET with the content encoded on the URI (as from XMLHTTPRequest)
    - new TSQLRest.EngineUpdateField protected method for a field content update
      (with PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..)
    - new TSQLRecord.CreateAndFillPrepareMany and FillPrepareMany methods, able
      to create a JOINed SELECT statement including all nested TSQLRecordMany
      properties (including custom WHERE clause if necessary)
    - now nested TCollection and TStringList/TRawUTF8List objects are
      transmitted as true JSON arrays or objects for adding (POST) and update
      (PUT) - this will save bandwidth and increase compatibility
      with AJAX clients (they were formerly transmitted as JSON strings) - note
      that retrieval (GET) is not yet implemented, since it is faster to transmit
      directly the TEXT value as stored within the database
    - new TSQLRest.MainFieldIDs() method
    - new ForceID parameter for TSQLRest.Add() and TSQLRestClientURI.BatchAdd()
      to allow adding a record with a given ID
    - added TSQLRestClientURI.OnSetUser notification event (called from SetUser)
    - now TSQLRestClientURI.BatchUpdate() will set only ID, TModTime and mapped
      fields when called over a TSQLRecord on which a FillPrepare() was made
      (and no FillClose was performed)
    - now TSQLRestServerStats is a plain TPersistent class, and will be sent
      as a JSON object to the client
    - added function IsNotAjaxJSON() function - formerly internal IsExpanded()
    - added RecordManySourceProp / RecordManyDestProp / RecordManySourceClass /
      RecordManyDestClass to the TSQLRecordProperties
    - TSQLRestClientURI.CallBackPut() will now return any HTTP response content
      (even if it is not HTTP/1.1 compliant, and not work over some networks)
    - circumvent some bugs of Delphi XE2 background compiler (main compiler is OK)

  Version 1.17
    - TSQLRecord.Create/FillPrepare/CreateAndFillPrepare and
      TSQLRest.OneFieldValue/MultiFieldValues methods signature BREAKING CHANGE:
      array of const used to be ParamsSQLWhere and expecting '%' in the
      FormatSQLWhere statement, is now called BoundsSQLWhere, and expects bound
      parameters specified as '?' in the FormatSQLWhere statement - this is less
      confusing for new users, and more close to the usual way of preparing
      database queries; but your existing user code SHALL BE CHECKED and fixed
    - fixed issue in TSQLTable.GetJSONValues about JSON number encoding
    - added optional "rowCount": in TSQLRestServerStaticInMemory.GetJSONValues,
      TSQLTable.GetJSONValues and in TSQLTableJSON.ParseAndConvert for about
      5% faster process of huge content (mpv proposal)
    - fixed issue about BLOB unproperly serialized into JSON (e.g. now uses null)
    - fixed issue about harcoded 'ID' column, not compatible with virtual tables
    - fixed issue about pessimistic TSQLRestServerStaticInMemory.fIDSorted value
    - fixed random issue in TSQLRest.GetServerTimeStamp method (using wrongly
      TTimeLog direct arithmetic, therefore raising EncodeTime() errors)
    - fixed ticket [fdf7158601] - about incorrect null value parsing in
      JSONToObject when isObj = oCustom (fix by mpv - thanks!)
    - fixed ticket [a1d9e9148e] - about incorrect reading empty JSON object by
      JSONToObject (fix by mpv - thanks!)
    - fixed ticket [4f5df7f18f] - about potential overflow of TSQLRestServerStats
      values (changed to QWord kind of property)
    - implemented feature request [7f6828999d] - about the possibility to use
      standard read/write in conjunction with custom read/write in JSONToObject
      and ObjectToJSON (mpv proposal - thanks!)
    - JSONToObject is now able to un-serialize a TObjectList class, when a class
      for its items is supplied as TObjectListItemClass optional parameter
    - ExtractInlineParameters() and SQLParamContent() decode ':("\uFFF12012-05-04"):'
      inlined parameters (i.e. text starting with JSON_SQLDATE_MAGIC after UTF-8
      encoding) as sftDateTime kind of parameter
    - internal cache added in TSQLRest.GetServerTimeStamp method for better speed
    - added TSQLRest.Retrieve() overloaded method for easy parameter binding
    - added TSQLRest.Delete() overloaded method with a WHERE clause parameter
    - implemented transaction process for (external database) virtual tables
    - added ReplaceRowIDWithID optional parameter to GetJSONObjectAsSQL(), in
      order to allow working with external DB not allowing RowID (e.g. Oracle)
    - TSQLRestCache.Notify*() methods made public for low-level potential use
    - made URI check case-insensitive (as for official RFC)
    - new TPropInfo.GetHash and TPropInfo.SameValue methods, with optional
      case sentivity handling
    - changed TSQLRecordProperties.BlobFieldsBits property into BlobFields,
      as an array of PPropInfo (for faster process)
    - added TSQLRecordProperties.HasTypeFields containing set of field types
      appearing in the record - replaces HasModTimeFields and HasCreateTimeField
    - new TListFieldHash class for efficient O(1) search using hashing handling
    - now unique fields are hashed in TSQLRestServerStaticInMemory implementation:
      "stored: false" properties are now checked for unicity before adding or
      update, and search will use the hash table for very fast O(1) process
    - speed optimization: all TSQLRestServerStaticInMemory search methods will
      now call a generic FindWhereEqual() for better code speed and maintenance
    - added ObjectFromInterface() function working also with TInterfacedObjectFake
    - introducing SetWeak() function to handle Weak interface assignment
    - added SetWeakZero() function and TObject class helper to handle ZEROed
      Weak interface assignment (with small performance penalty and memory use),
      corresponding to the ARC's Zeroing Weak pointers model
    - CopyObject() procedure now handle TCollection kind of object not only
      as sub properties
    - introducing TInterfacedCollection dedicated class, properly handling
      collection item creation on the Server side, with interface-based services:
      all contract operations shall use it instead of TCollection
    - changed the non expanded JSON format to use lowercase first column names:
      {"fieldCount":1,"values":["col1"... instead of {"FieldCount":1,"Values":[..
    - added TSQLTable.FieldLengthMax() and ExpandAsSynUnicode() methods
    - added BlobToBytes() function and TSQLTable.GetBytes/GetStream methods
    - added virtual TSQLRestServer.FlushInternalDBCache method and dedicated
      TSQLRestServerStaticInMemoryExternal class, to properly handle external
      DB modification for virtual tables (i.e. flush SQL/JSON cache as expected)
    - added virtual TSQLRestServer.BeginCurrentThread method 
    - added virtual TSQLRestServer.EndCurrentThread method which will be called
      e.g. by TSQLite3HttpServer or TSQLRestServerNamedPipeResponse for each
      terminating threads, to release any thread-specific resources (like
      external DB connections defined in SQlite3DB)
    - added new TServiceMethod.ExecutionOptions member, and the new
      TServiceMethodExecutionOption[s] types - used by ExecuteInMainThread() 
    - added TServiceFactoryServer.ExecuteInMainThread() method, to force a method
      to be executed with RunningThread.Synchronize() call on multi-thread server
      instances (e.g. TSQLite3HttpServer or TSQLRestServerNamedPipeResponse)
    - refactoring of TServiceMethod.InternalExecute low-level asm code, and
      changed the Instance parameter to be specified as an open array for
      fast execution over multiple instances of implementation classes
    - 'SELECT *' statements on virtual/external tables will by-pass the SQLite3
      virtual table module: TSQLRecord.FillPrepare can be up to 30% faster -
      added TSQLRestServerStatic.AdaptSQLForEngineList virtual method to
      handle most generic SELECT cases (overriden e.g. in SQLite3DB unit)
    - TSQLRestServerStaticInMemory.GetJSONValues will now generate expanded
      JSON content, if specified (only non-expanded format was implemented),
      via the new TSQLRestServerStaticInMemory.ExpandedJSON property
    - added TSQLRestServerStatic.InternalBatchStart / InternalBatchStop methods
      to handle fast grouped sending to remote database engine (e.g. Oracle
      bound arrays or MS SQL bulk insert via SynDB)
    - fixed issue in TSQLRestClientURI.EngineAdd() when server returned -1
    - changed TSQLRestServerCallBackParams content to be used as a generic
      parameters wrapper for both method callbacks and interface-based services:
      now aParams.Context.ID is to be used insted of aParams.ID
    - added TJSONObjectDecoder record/object helper for JSON object decoding
      (used e.g. by GetJSONObjectAsSQL() function, and for SQlite3DB process)
    - removed TSQLRecordExternal class type, to allow any TSQLRecord (e.g.
      TSQLRecordMany) to be used with VirtualTableExternalRegister() - there was
      indeed no implementation requirement to force a specific class type
    - added aUseBatchMode optional parameter to TSQLRecordMany.ManyDelete() method
    - now JSON parser will handle #1..' ' chars as whitespace (not only ' ')
    - now huge service JSON response is truncated (to default 20 KB) in logs


  String usage in the Synopse SQLite3 database framework:
    - RawUTF8 is used for every internal data usage, since both SQLite3 and
      JSON do expect UTF-8 encoding
    - WinAnsiString where WinAnsi-encoded AnsiString (code page 1252) are needed
    - generic string for i18n (in unit SQLite3i18n), i.e. text ready to be
      used within the VCL, as either AnsiString (for Delphi 2 to 2007) or
      UnicodeString (for Delphi 2009+)
    - RawUnicode in some technical places (e.g. direct Win32 *W() API call in
      Delphi 7) - note: this type is NOT compatible with Delphi 2009+
      UnicodeString (our RawUnicode is an AnsiString, i.e. with elemSize=1,
      whereas UnicodeString has elemSize=2)
    - RawByteString for byte storage (e.g. for FileFromString() function)
    - SynUnicode is the fastest available Unicode native string type:
      this type is native to the compiler, so you can use Length() Copy() and
      such functions with it (this is not possible with RawUnicodeString type),
      but it will map slow WideString before Delphi 2009
    - use special conversion functions for Delphi 2009+ UnicodeString
      (defined inside {$ifdef UNICODE}...{$endif} blocks below)
    - TFileName for file names
    - never use AnsiString directly, but only specific RawUTF8, WinAnsiString,
      RawUnicode, RawByteString sub-types
    - our Synopse PDF Library use its own PDFString type

  TODO:
    - test and enhance Free Pascal Compiler compatibiliby (2.4.0 and later)
    - port to other OS, using CrossKylix or Free Pascal Compiler

*)


{$I Synopse.inc} // define HASINLINE USETYPEINFO CPU32 CPU64

{.$define PUREPASCAL}  // define for debugg, not on production
{.$define USETYPEINFO} // define for debugg, not on production

{$ifdef MSWINDOWS}

  {.$define ANONYMOUSNAMEDPIPE}
  // if defined, the security attributes of the named pipe will use an
  // anonymous connection - it should allow access to a service initialized
  // named pipe on a remote computer.
  // - I tried to implement the code as detailed in this Microsoft article:
  // http://support.microsoft.com/kb/813414 but it didn't work as
  // expected: see our forum http://synopse.info/forum/viewtopic.php?id=43
  // - don't define it, because it's still buggy, and consider using HTTP
  // connection for remote access over the network

{$endif}


interface

uses
{$ifdef MSWINDOWS}
  Windows,
  Messages,
{$endif}
{$ifdef LINUX} // for Kylix
  Libc,
  Types,
{$endif}
  Classes,
  SynZip, // use crc32 for internal TDynArray hasher + TSQLRestClientURI.SetUser
{$ifdef USETYPEINFO}
  // some pure pascal version must handle the 64-bits ordinal values or
  // a not-Delphi RTTI layout of the underlying compiler (e.g. FPC)
  TypInfo,
{$endif}
{$ifndef LVCL}
  Contnrs, // for TObjectList
  {$ifdef USEVARIANTS}
    Variants,
  {$endif}
{$endif}
  SysUtils,
  SynCommons;



{ ************ classes to access ORM database data }

{.$define PUBLISHRECORD}
// - if defined, a sftBlobRecord will be defined in order to serialize published
// properties with some record type: but even if such properties can be defined,
// there is no RTTI generated for them: so it won't work :( see
// http://docwiki.embarcadero.com/RADStudio/en/Classes_and_Objects#Published_Members
// - should be defined globaly, e.g. in Synopse.inc

const
  /// maximum number of Tables in a Database Model
  // - this constant is used internaly to optimize memory usage in the
  // generated asm code
  // - you should not change it to a value lower than expected in an existing
  // database (e.g. as expected by TSQLAccessRights or such)
  MAX_SQLTABLES = 256;


  /// the used TAuthSession.IDCardinal value if the session not started yet
  // - i.e. if the session handling is still in its handshaking phase
  CONST_AUTHENTICATION_SESSION_NOT_STARTED = 0;

  /// the used TAuthSession.IDCardinal value if authentication mode is not set
  // - i.e. if TSQLRest.HandleAuthentication equals FALSE
  CONST_AUTHENTICATION_NOT_USED = 1;

type
  /// used to store bit set for all available Tables in a Database Model
  TSQLFieldTables = set of 0..MAX_SQLTABLES-1;

  /// a String used to store the BLOB content
  // - equals RawByteString for byte storage, to force no implicit charset
  // conversion, thatever the codepage of the resulting string is
  // - will identify a sftBlob field type, if used to define such a published
  // property
  // - by default, the BLOB fields are not retrieved or updated with raw
  // TSQLRest.Retrieve() method, that is "Lazy loading" is enabled by default
  // for blobs, unless TSQLRestClientURI.ForceBlobTransfert property is TRUE;
  // so use RetrieveBlob() methods for handling BLOB fields
  TSQLRawBlob = type RawByteString;

  /// a reference to another record in any table in the database Model
  // - stored as an 32 bits unsigned integer (i.e. a pointer=TObject)
  // - type cast any value of TRecordReference with the RecordRef object below
  // for easy access to its content
  // - use TSQLRest.Retrieve(Reference) to get a record value
  // - don't change associated TSQLModel tables order, since TRecordReference
  // depends on it to store the Table type in its highest bits
  TRecordReference = type PtrUInt;

  /// an Int64-encoded date and time of the latest update of a record
  // - can be used as published property field in TSQLRecord for sftModTime
  // - use internally for computation an abstract "year" of 16 months of 32 days
  // of 32 hours of 64 minutes of 64 seconds - same as Iso8601ToSeconds()
  // - type cast any value of TModTime/TCreateTime/TTimeLog with the Iso8601
  // object below for easy access to its content
  TModTime = type TTimeLog;

  /// an Int64-encoded date and time of the record creation 
  // - can be used as published property field in TSQLRecord for sftCreateTime
  // - use internally for computation an abstract "year" of 16 months of 32 days
  // of 32 hours of 64 minutes of 64 seconds - same as Iso8601ToSeconds()
  // - type cast any value of TModTime/TCreateTime/TTimeLog with the Iso8601
  // object below for easy access to its content
  TCreateTime = type TTimeLog;

  /// the available types for any SQL field property, as managed with the
  // database driver
  TSQLFieldType = (
    /// unknown or not defined field type
    sftUnknown,
    /// a WinAnsi encoded TEXT: force a NOCASE collation
    // (TSQLRecord Delphi property was declared as AnsiString or string before
    // Delphi 2009)
    sftAnsiText,
    /// UTF-8 encoded TEXT: force a SYSTEMNOCASE collation, i.e. using UTF8IComp()
    // (TSQLRecord property was declared as RawUTF8 or RawUnicode - or string
    // in Delphi 2009+)
    sftUTF8Text,
    /// an INTEGER value corresponding to an index in any enumerate Delphi type
    // - storage is an INTEGER value (fast, easy and storage efficient)
    // - display convert this integer index into the left-trimed lowercased chars
    // of the enumerated type text conversion: TOpenType(1) = otDone -> 'Done'
    sftEnumerate,
    // an INTEGER value corresponding to a bitmaped set of enumeration
    // - storage is an INTEGER value (fast, easy and storage efficient)
    // - displayed as an integer by default
    // - sets with an enumeration type with up to 32 elements is allowed 
    sftSet,
    /// an INTEGER (Int64 precision, as expected by SQLite3) field
    sftInteger,
    /// an INTEGER field pointing to the ID/ROWID of another record of a table
    // defined by the class type of the TSQLRecord inherited property
    // - coherency is always ensured: after a delete, all values pointing to
    // it is reset to 0
    sftID,
    /// an INTEGER field pointing to the ID/ROWID of another record
    // (TRecordReference=PtrUInt Delphi property which can be typecasted to RecordRef)
    // - coherency is always ensured: after a delete, all values pointing to
    // it is reset to 0
    sftRecord,
    /// an INTEGER field for a boolean value: 0 is FALSE, anything else TRUE
    // (encoded as JSON 'true' or 'false' constants)
    sftBoolean,
    /// a FLOAT (floating point double precision, cf. SQLite3) field
    sftFloat,
    /// a ISO 8601 encoded TEXT field - SQLite3 compatible;
    // a ISO8601 collation is forced
    // (TDateTime Delphi property)
    sftDateTime,
    /// an INTEGER field for coding a date and time - not SQLite3 compatible
    // - TTimeLog=Int64 Delphi property which can be typecasted to Iso8601
    sftTimeLog,
    /// a FLOAT containing a 4 decimals floating point value
    // (Currency Delphi property minimizes rounding errors in monetary
    // calculations which may occur with sftFloat type)
    sftCurrency,
    /// a TEXT containing an ObjectToJSON serialization
    // - able to handle published properties of any not TPersistent as JSON object,
    // TStrings, TRawUTF8List or TCollection as arrays of strings or objects
    sftObject,
    /// a BLOB field (TSQLRawBlob Delphi property)
    // - not retrieved by default
    sftBlob,
    /// a dynamic array, stored as BLOB field
    // - is retrieved by default, i.e. is recognized as a "simple" field
    // - will use Base64 encoding in JSON content
    sftBlobDynArray,
    {$ifdef PUBLISHRECORD}
    /// a Delphi record, stored as BLOB field
    // - is retrieved by default, i.e. is recognized as a "simple" field
    // - will use Base64 encoding in JSON content
    sftBlobRecord,
    {$endif PUBLISHRECORD}
    /// a 'many to many' field (TSQLRecordMany Delphi property)
    // - nothing is stored in the table row, but in a separate pivot table: so
    // there is nothing to retrieve here
    // - in contrast to other TSQLRecord properties, which contains an INTEGER
    // ID, the TSQLRecord.Create will instanciate a TSQLRecordMany instance
    // to handle this pivot table via its dedicated ManyAdd/FillMany/ManySelect methods
    sftMany,
    /// an INTEGER field containing the TModTime time of the record latest update
    // - TModTime=TCreateTime=TTimeLog=Int64 Delphi property which can be
    // typecasted to Iso8601
    // - the value of this field is automatically updated with the current
    // date and time each time a record is updated (with external DB, it will
    // use the Server time, as retrieved from SynDB) - see ComputeFieldsBeforeWrite
    // virtual method of TSQLRecord
    // - note only RESTful PUT/POST access will change this field value: manual
    // SQL statements (like 'UPDATE Table SET Column=0') won't change its content
    // - note also that this is automated on Delphi client side, so only within
    // TSQLRecord ORM use (an AJAX application should handle this explicitely)
    sftModTime,
    /// an INTEGER field containing the TCreateTime time of the record creation
    // - TModTime=TCreateTime=TTimeLog=Int64 Delphi property which can be
    // typecasted to Iso8601
    // - the value of this field is automatically updated with the current
    // date and time when the record is created (with external DB, it will
    // use the Server time, as retrieved from SynDB) - see ComputeFieldsBeforeWrite
    // virtual method of TSQLRecord
    // - note only RESTful PUT/POST access will set this field value: manual
    // SQL statements (like 'INSERT INTO Table ...') won't set its content
    // - note also that this is automated on Delphi client side, so only within
    // TSQLRecord ORM use (an AJAX application should handle this explicitely)
    sftCreateTime);

  /// set of available SQL field property types
  TSQLFieldTypes = set of TSQLFieldType;

  //// a fixed array of SQL field property types
  TSQLFieldTypeArray = array[0..MAX_SQLFIELDS] of TSQLFieldType;

  /// contains the parameters used for sorting
  // - FieldCount is 0 if was never sorted
  // - used to sort data again after a successfull data update with TSQLTableJSON.FillFrom()
  TSQLTableSortParams = record
    FieldCount, FieldIndex: integer;
    FieldType: TSQLFieldType;
    Asc: boolean;
  end;

  /// used to define the triggered Event types for TNotifySQLEvent
  // - some Events can be trigerred via TSQLRestServer.OnUpdateEvent when
  // a Table is modified, and actions can be authorized via overriding the
  // TSQLRest.RecordCanBeUpdated method
  // - OnUpdateEvent is called BEFORE deletion, and AFTER insertion or update; it
  // should be used only server-side, not to synchronize some clients: the framework
  // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
  // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
  // - is used also by TSQLRecord.ComputeFieldsBeforeWrite virtual method
  TSQLEvent = (
    seAdd,
    seUpdate,
    seDelete);

  /// used to defined the associated SQL statement of a command
  // - used e.g. by TSQLRecord.GetJSONValues methods and SimpleFieldsBits[] array
  // (in this case, soDelete is never used, since deletion is global for all fields)
  // - also used for cache content notification
  TSQLOccasion = (
    soSelect,
    soInsert,
    soUpdate,
    soDelete);

  /// abstract array of classes, will be filled e.g. with TSQLRecord descendants
  TClasses = array of TClass;

  /// wrapper to an ORM result table, staticaly stored as UTF-8 text
  // - contain all result in memory, until destroyed
  // - first row contains the field names
  // - following rows contains the data itself
  // - GetA() or GetW() can be used in a TDrawString
  // - will be implemented as TSQLTableDB for direct SQLite3 database engine call,
  //  or as TSQLTableJSON for remote access through optimized JSON messages
  TSQLTable = class
  private
    fQueryTables: TClasses;
    fQuerySQL: RawUTF8;
    fFieldLengthMean: TIntegerDynArray;
    fFieldLengthMeanSum: integer;
  protected
    fRowCount,
    fFieldCount: integer;
    /// contains the data, as returned by sqlite3_get_table()
    fResults: PPUTF8CharArray;
    /// contains the TSQLFieldType and TypeInfo(enumerate), after calculation
    // from the fQueryTables values
    fFieldType: array of record
      // the field kind
      ContentType: TSQLFieldType;
      // initialized for both sftEnumerate and sftSet field kinds
      EnumTypeInfo: pointer;
      // the corresponding index in fQueryTables[]
      TableIndex: integer;
    end;
    /// bit set at parsing to mark was a string value (e.g. "..." in JSON)
    fFieldParsedAsString: set of 0..255;
    /// contain the fResults[] pointers, after a IDColumnHide() call
    fIDColumn, fNotIDColumn: array of PUTF8Char;
    /// the internal state counter of the database when the data was retrieved
    fInternalState: cardinal;
    /// contains the parameters used for sorting
    fSortParams: TSQLTableSortParams;
    /// contains the TSQLRecord instances created by NewRecord method
    fOwnedRecords: TObjectList;
    /// if the TSQLRecord is the owner of this table, i.e. if it must free it  
    fOwnerMustFree: Boolean;
    /// fill the fFieldType[] array (from fQueryTables[] or fResults[] content)
    procedure InitFieldTypes;
  public
    /// initialize the result table
    // - you can use RecordClassesToClasses() wrapper function to convert an
    // array of TSQLRecordClass into the expected array of TClass
    constructor Create(const Tables: array of TClass; const aSQL: RawUTF8);
    /// free associated memory and owned records
    destructor Destroy; override;
    {/ read-only access to a particular field value, as UTF-8 encoded text
     - points to memory buffer allocated by Init() }
    function Get(Row,Field: integer): PUTF8Char;
    {/ read-only access to a particular field value, as RawUTF8 text }
    function GetU(Row,Field: integer): RawUTF8;
    {/ read-only access to a particular field value, as Win Ansi text }
    function GetA(Row,Field: integer): WinAnsiString;
    {/ read-only access to a particular field value, as Win Ansi text shortstring}
    function GetS(Row,Field: integer): shortstring;
    {$ifdef USEVARIANTS}
    {/ read-only access to a particular field value, as a Variant
     - will try to use the most approriate Variant type for conversion (will
       use e.g. TDateTime for sftDateTime or sftTimeLog, Extended for sftFloat...)
     - will handle any necessary conversion to VCL string text, ready to be displayed
     - the global UTF8ToString() function will be used for the conversion:
     for proper i18n handling before Delphi 2009, you should use the
     overloaded method with aUTF8ToString=Language.UTF8ToString }
    function GetVariant(Row,Field: integer; Client: TObject): variant;
    {$endif}
    {/ read-only access to a particular field value, as VCL string text
     - the global UTF8ToString() function will be used for the conversion:
     for proper i18n handling before Delphi 2009, you should use the
     overloaded method with aUTF8ToString=Language.UTF8ToString }
    function GetString(Row,Field: integer): string; 
    {/ fill a unicode buffer with a particular field value
      - return number of wide characters written in Dest^ }
    function GetWP(Row,Field: integer; Dest: PWideChar; MaxDestChars: cardinal): integer;
    {/ read-only access to a particular field value, as UTF-16 Unicode text
      - Raw Unicode is WideChar(zero) terminated
      - its content is allocated to contain all WideChars (not trimed to 255,
       like GetWP() above }
    function GetW(Row,Field: integer): RawUnicode;
    {/ read-only access to a particular field value, as integer value }
    function GetAsInteger(Row,Field: integer): integer;
      {$ifdef HASINLINE}inline;{$endif}
    {/ read-only access to a particular field value, ready to be displayed
      - mostly used with Row=0, i.e. to get a display value from a field name
      - use "string" type, i.e. UnicodeString for Delphi 2009+
      - value is first un-camel-cased: 'OnLine' value will return 'On line' e.g.
      - then System.LoadResStringTranslate() is called if available }
    function GetCaption(Row,Field: integer): string;
    {/ read-only access to a particular Blob value
     - a new TSQLRawBlob is created
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetBlob(Row,Field: integer): TSQLRawBlob;
    {/ read-only access to a particular Blob value
     - a new TBytes is created
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetBytes(Row,Field: integer): TBytes;
    {/ read-only access to a particular Blob value
     - a new TCustomMemoryStream is created - caller shall free its instance
     - Blob data is converted from SQLite3 BLOB literals (X'53514C697465' e.g.)
       or Base-64 encoded content ('\uFFF0base64encodedbinary')
     - prefered manner is to directly use REST protocol to retrieve a blob field }
    function GetStream(Row,Field: integer): TStream;
    {/ read-only access to a particular field value, as VCL text
     - Client is one TSQLClient instance (used to display TRecordReference via
       the associated TSQLModel)
     - returns the Field Type
     - return generic string Text, i.e. UnicodeString for Delphi 2009+,
       ready to be displayed to the VCL, for sftEnumerate, sftTimeLog
       and sftRecord/sftID
     - returns '' as string Text, if text can by displayed directly
       with Get*() methods above
     - returns '' for other properties kind, if UTF8ToString is nil,
       or the ready to be displayed value if UTF8ToString event is set
       (to be used mostly with Language.UTF8ToString) }
    function ExpandAsString(Row,Field: integer; Client: TObject; out Text: string): TSQLFieldType;
    {/ read-only access to a particular field value, as VCL text
     - this method is just a wrapper around ExpandAsString method, returning
       the content as a SynUnicode string type (i.e. UnicodeString since Delphi
       2009, and WideString for non Unicode versions of Delphi)
     - it is used by the reporting layers of the framework (e.g. TSQLRibbon.AddToReport) }
    function ExpandAsSynUnicode(Row,Field: integer; Client: TObject; out Text: SynUnicode): TSQLFieldType;
    {/ read-only access to a particular DateTime field value
     - expect SQLite3 TEXT field in ISO 8601 'YYYYMMDD hhmmss' or
      'YYYY-MM-DD hh:mm:ss' format }
    function GetDateTime(Row,Field: integer): TDateTime;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ read-only access to a particular TTimeLog field value
      - return the result as Iso8601.Text() Iso-8601 encoded text }
    function GetTimeLog(Row,Field: integer; Expanded: boolean; FirstTimeChar: AnsiChar = 'T'): RawUTF8;
    {/ widechar length (UTF-8 decoded) of a particular field value }
    function LengthW(Row,Field: integer): integer;
    {/ get all values for a specified field into a dynamic RawUTF8 array
     - don't perform any conversion, but just create an array of raw PUTF8Char data }
    procedure GetRowValues(Field: integer; out Values: TRawUTF8DynArray); overload;
    {/ get all values for a specified field into a dynamic Integer array }
    procedure GetRowValues(Field: integer; out Values: TIntegerDynArray); overload;
    {/ get all values for a specified field as CSV
     - don't perform any conversion, but create a CSV from raw PUTF8Char data }
    function GetRowValues(Field: integer; Sep: AnsiChar=','): RawUTF8; overload;

    /// save the table values in JSON format
    // - JSON data is added to TStream, with UTF-8 encoding
    // - if Expand is true, JSON data is an array of objects, for direct use
    // with any Ajax or .NET client:
    // & [ {"col1":val11,"col2":"val12"},{"col1":val21,... ]
    // - if Expand is false, JSON data is serialized (used in TSQLTableJSON)
    // & { "fieldCount":1,"values":["col1","col2",val11,"val12",val21,..] }
    // - RowFirst and RowLast can be used to ask for a specified row extent
    // of the returned data (by default, all rows are retrieved)
    procedure GetJSONValues(JSON: TStream; Expand: boolean;
      RowFirst: integer=0; RowLast: integer=0); overload;
    /// same as above, but returning result into a RawUTF8
    function GetJSONValues(Expand: boolean): RawUTF8; overload;
    /// save the table in CSV format
    // - if Tab=TRUE, will use TAB instead of ',' between columns
    // - you can customize the ',' separator - use e.g. the global ListSeparator
    // variable (from SysUtils) to reflect the current system definition (some
    // country use ',' as decimal separator, for instance our "douce France")
    // - AddBOM will add a UTF-8 Byte Order Mark at the beginning of the content
    procedure GetCSVValues(Dest: TStream; Tab: boolean; CommaSep: AnsiChar=',';
      AddBOM: boolean=false);

    {/ get the Field index of a FieldName
     - return -1 if not found, index (0..FieldCount-1) if found }
    function FieldIndex(FieldName: PUTF8Char): integer; overload;
    {/ get the Field index of a FieldName
     - return -1 if not found, index (0..FieldCount-1) if found }
    function FieldIndex(const FieldName: shortstring): integer; overload;
    {/ get the Field content (encoded as UTF-8 text) from a property name
     - return nil if not found }
    function FieldValue(const FieldName: shortstring; Row: integer): PUTF8Char;
    {/ Field index of a the 'ID' field, -1 if none }
    function FieldIndexID: integer;
    {/ sort result Rows, according to a specific field
     - default is sorting by ascending order (Asc=true)
     - you can specify a Row index to be updated during the sort in PCurrentRow
     - sort is very fast, even for huge tables (more faster than any indexed
       SQL query): 500,000 rows are sorted instantly
     - this optimized sort implementation does the comparaison first by the
     designed field, and, if the field value is identical, the ID value is
     used (it will therefore sort by time all identical values) }
    procedure SortFields(Field: integer; Asc: boolean=true;
      PCurrentRow: PInteger=nil; FieldType: TSQLFieldType=sftUnknown);
    {/ sort result Rows, according to the Bits set to 1 first }
    procedure SortBitsFirst(var Bits);
    {/ guest the field type from first non null data row
     - if QueryTables[] are set, exact field type and enumerate TypeInfo() is
       retrieved from the Delphi RTTI; otherwize, get from the cells content
     - return sftUnknown is all data fields are null
     - sftBlob is returned if the field is encoded as SQLite3 BLOB literals
       (X'53514C697465' e.g.)
     - since TSQLTable data is PUTF8Char, string type is sftUTF8Text only }
    function FieldType(Field: integer; EnumTypeInfo: PPointer): TSQLFieldType;
    {/ get the appropriate Sort comparaison function for a field,
      nil if not available (bad field index or field is blob)
      - field type is guessed from first data row }
    function SortCompare(Field: integer): TUTF8Compare;
    /// get the mean of characters length of all fields
    // - the character length is for the first line of text only (stop counting
    // at every newline character, i.e. #10 or #13 char)
    // - return the sum of all mean of character lengths
    function CalculateFieldLengthMean(var aResult: TIntegerDynArray;
      FromDisplay: boolean=false): integer;
    /// get the mean of characters length of this field
    // - the character length is for the first line of text only (stop counting
    // at every newline character, i.e. #10 or #13 char)
    // - very fast: calculated only once for all fields
    function FieldLengthMean(Field: integer): cardinal;
    /// get the sum of all mean of characters length of all fields
    // - very fast: calculated only once for all fields
    function FieldLengthMeanSum: cardinal;
    /// get the maximum number of characters of this field
    function FieldLengthMax(Field: integer; NeverReturnsZero: boolean=false): cardinal;
    /// get the record class (i.e. the table) associated to a field
    // - is nil if this table has no QueryTables property
    // - very fast: calculated only once for all fields
    function FieldTable(Field: integer): TClass;
    /// force the mean of characters length for every field
    // - expect as many parameters as fields in this table
    // - override internal fFieldLengthMean[] and fFieldLengthMeanSum values
    procedure SetFieldLengthMean(const Lengths: array of cardinal);
    /// increase a particular Field Length Mean value
    // - to be used to customize the field appareance (e.g. for adding of left
    // checkbox for Marked[] fields)
    procedure FieldLengthMeanIncrease(aField, aIncrease: integer);
    {/ copy the parameters of a TSQLTable into this instance
     - the fResults remain in the source TSQLTable: source TSQLTable has not to
      be destroyed before this TSQLTable }
    procedure Assign(source: TSQLTable);
    /// search a text value inside the table data in a specified field
    // - the text value must already be uppercased 7-bits ANSI encoded
    // - return the Row on success, 0 on error
    // - search only in the content of FieldIndex data
    // - you can specify a Soundex pronunciation to use, or leave as sndxNone for
    // standard case insensitive character match; aUpperValue can optional
    // indicate a Soundex search, by predeceding the searched text with % for
    // English, %% for French or %%% for Spanish (only works with WinAnsi
    // char set - i.e. code page 1252)
    // - if UnicodeComparison is set to TRUE, search will use low-level Windows
    // API for Unicode-level conversion - it will be much slower, but accurate
    // for the whole range of UTF-8 encoding
    // - if UnicodeComparison is left to FALSE, UTF-8 decoding will be done only
    // if necessary: it will work only with standard western-occidental alphabet
    // (i.e. WinAnsi - code page 1252), but it will be very fast
    function SearchValue(const aUpperValue: RawUTF8; StartRow, FieldIndex: integer;
      Client: TObject; Lang: TSynSoundExPronunciation=sndxNone;
      UnicodeComparison: boolean=false): integer; overload;
    /// search a text value inside the table data in all fields
    // - the text value must already be uppercased 7-bits ANSI encoded
    // - return the Row on success, 0 on error
    // - search on all fields, returning field found in FieldIndex (if not nil)
    // - you can specify a Soundex pronunciation to use, or leave as sndxNone for
    // standard case insensitive character match; aUpperValue can optional
    // indicate a Soundex search, by predeceding the searched text with % for
    // English, %% for French or %%% for Spanish (only works with WinAnsi
    // char set - i.e. code page 1252)
    // - if UnicodeComparison is set to TRUE, search will use low-level Windows
    // API for Unicode-level conversion - it will be much slower, but accurate
    // for the whole range of UTF-8 encoding
    // - if UnicodeComparison is left to FALSE, UTF-8 decoding will be done only
    // if necessary: it will work only with standard western-occidental alphabet
    // (i.e. WinAnsi - code page 1252), but it will be very fast
    function SearchValue(const aUpperValue: RawUTF8; StartRow: integer;
      FieldIndex: PInteger; Client: TObject; Lang: TSynSoundExPronunciation=sndxNone;
      UnicodeComparison: boolean=false): integer; overload;
    /// search for a value inside the raw table data
    // - returns 0 if not found, or the matching Row number otherwise
    function SearchFieldEquals(const aValue: RawUTF8; FieldIndex: integer): integer;
    /// if the ID column is available, hides it from fResults[]
    // - usefull for simplier UI, with a hidden ID field
    // - use IDColumnHiddenValue() to get the ID of a specific row
    // - return true is ID was succesfully hidden, false if not possible
    function IDColumnHide: boolean;
    /// return the (previously hidden) ID value, 0 on error
    function IDColumnHiddenValue(Row: integer): integer;
    /// return all (previously hidden) ID values
    procedure IDColumnHiddenValues(var IDs: TIntegerDynArray);
    /// get all IDs where individual bit in Bits are set
    procedure IDArrayFromBits(const Bits; var IDs: TIntegerDynArray);
    /// get all individual bit in Bits corresponding to the supplied IDs
    // - warning: IDs integer array will be sorted within this method call
    procedure IDArrayToBits(var Bits; var IDs: TIntegerDynArray);
    /// get the Row index corresponding to a specified ID
    // - return the Row number, from 1 to RowCount
    // - return RowCount (last row index) if this ID was not found or no
    // ID field is available
    function RowFromID(aID: integer): integer;

    /// delete the specified data Row from the Table
    // - only overwrite the internal fResults[] pointers, don't free any memory,
    // nor modify the internal DataSet
    procedure DeleteRow(Row: integer);
    /// delete the specified Column text from the Table
    // - don't delete the Column: only delete UTF-8 text in all rows for this
    // field
    procedure DeleteColumnValues(Field: integer);
{
    /// change an Integer cell content in the internal DataSet
    // - those modifications will be tracked internally, allowing further post
    // to a remote database
    procedure DataSetUpdate(Row,Field: integer; Value: Int64); overload;
    /// change a Floating-Point cell content in the internal DataSet
    // - those modifications will be tracked internally, allowing further post
    // to a remote database
    procedure DataSetUpdate(Row,Field: integer; Value: Double); overload;
    /// change a Currency cell content in the internal DataSet
    // - those modifications will be tracked internally, allowing further post
    // to a remote database
    procedure DataSetUpdate(Row,Field: integer; Value: Currency); overload;
    /// change a string cell content in the internal DataSet
    // - those modifications will be tracked internally, allowing further post
    // to a remote database
    procedure DataSetUpdate(Row,Field: integer; const Value: RawUTF8); overload;
    /// delete a row in the internal DataSet
    // - those modifications will be tracked internally, allowing further post
    // to a remote database
    procedure DataSetDelete(Row: integer);
    /// insert a row in the internal DataSet
    // - returns the added row number
    // - data is to be set later with DataSetUpdate() overloaded methods
    function DataSetInsert: integer;
    /// insert a row in the internal DataSet
    // - returns the added row number
    // - data of each column is to be supplied at call: if the count does not
    // match the TSQLTable layout (minus the ID column), an exception is raised
    function DataSetAdd(const Values: array of const): integer;
    /// retrieve all modified rows of the internal DataSet containing all
    // changes made to it since it was loaded or since DataSetAcceptChanges
    // was last called
    procedure DataSetGetChangedRows(out Rows: TIntegerArray);
}
    /// retrieve QueryTables[0], if existing
    function QueryRecordType: TClass;
    /// create a new TSQLRecord instance for a specific Table
    // - set a fixed TSQLRecord class or leave it nil to create one instance
    // of the first associated record class (from QueryTables[])
    // - use this method to create a working copy of a table's record, e.g.
    // - the record will be freed when the TSQLTable will be destroyed:
    // you don't need to make a Try..Finally..Free..end block with it
    function NewRecord(RecordType: TClass=nil): TObject;

    /// contains the associated record class on Query
    property QueryTables: TClasses read fQueryTables;
    /// contains the associated SQL statement on Query
    property QuerySQL: RawUTF8 read fQuerySQL;
    {/ read-only access to the number of data Row in this table
     - first row contains field name
     - then 1..RowCount rows contain the data itself }
    property RowCount: integer read fRowCount;
    {/ read-only access to the number of fields for each Row in this table }
    property FieldCount: integer read fFieldCount;
    {/ this property contains the internal state counter of the server database
      when the data was retrieved from it
      - can be used to check if retrieved data may be out of date }
    property InternalState: cardinal read fInternalState write fInternalState;
    /// if the TSQLRecord is the owner of this table, i.e. if it must free it
    property OwnerMustFree: Boolean read fOwnerMustFree write fOwnerMustFree;
  end;

  { Why use JSON?
    - The JavaScript Object Notation (JSON) is a lightweight computer data
     interchange format
    - Like XML, it's a text-based, human-readable format for representing
     simple data structures and associative arrays (called objects)
    - It's easier to read, quicker to implement and smaller in size than XML
    - It's a very efficient format for cache
    - It's natively supported by the JavaScript language, making it a perfect
     serialization format for any Ajax application
    - The JSON format is specified in http://tools.ietf.org/html/rfc4627
    - The default text encoding for both JSON and SQLite3 is UTF-8, which
     allows the full Unicode charset to be stored and communicated
    - It is the default data format used by ASP.NET AJAX services created in
     Windows Communication Foundation (WCF) since .NET framework 3.5
    - For binary blob transmission, we simply encode the binary data as hexa
     using the SQLite3 BLOB literals format : hexadecimal data preceded by
     a single "x" or "X" character (for example: X'53514C697465') }

  /// get a SQL result from a JSON message, and store it into its own memory
  TSQLTableJSON = class(TSQLTable)
  protected
    /// used if a private copy of the JSON buffer is needed
    fPrivateCopy: RawUTF8;
    /// contains the pointers of start of every field value in JSONData
    fJSONResults: array of PUTF8Char;
    /// contain the hash value of the last JSON data sent to ContentChanged()
    // - used to don't repeat parsing if data has not been changed
    fPrivateCopyHash: cardinal;
    /// fill the result table content from a JSON-formated Data message
    // - returns TRUE on parsing success
    // - returns FALSE if no valid JSON data was found
    // - update all content fields (fResults[], fRowCount, fFieldCount, etc...)
    // - expect the UTF-8 Buffer in either TSQLRequest.EngineExecute(DB,SQL,JSON)
    // format (i.e. expanded) or either in a not expanded format (as an
    // AJAX-ready array of objects)
    // - the conversion into PPUTF8CharArray is made inplace and is very fast
    // (no additional memory buffer is allocated)
    function ParseAndConvert(Buffer: PUTF8Char; BufferLen: integer): boolean;
    /// will check then set (if needed) internal fPrivateCopy[Hash] values
    // - returns TRUE if content changed (then fPrivateCopy+fPrivateCopyHash
    // will be updated)
    function PrivateCopyChanged(aJSON: PUTF8Char; aLen: integer): boolean;
  public
    /// create the result table from a JSON-formated Data message
    // - the JSON data is parsed and formatted in-place
    // - please note that the supplied JSON buffer content will be changed:
    // if you want to reuse this JSON content, you shall make a private copy
    // before calling this constructor and you shall NOT release the corresponding
    // variable (fResults/JSONResults[] will point inside this memory buffer):
    // use instead the overloaded Create constructor expecting aJSON parameter
    // making a private copy of the data
    // - you can use RecordClassesToClasses() wrapper function to convert an
    // array of TSQLRecordClass into the expected array of TClass
    constructor Create(const Tables: array of TClass; const aSQL: RawUTF8;
      JSONBuffer: PUTF8Char; JSONBufferLen: integer); overload;
    /// create the result table from a JSON-formated Data message
    // - the JSON data is parsed and formatted in-place, after having been
    // copied in the protected fPrivateCopy variable
    // - you can use RecordClassesToClasses() wrapper function to convert an
    // array of TSQLRecordClass into the expected array of TClass
    constructor Create(const Tables: array of TClass; const aSQL, aJSON: RawUTF8); overload;
    /// update the result table content from a JSON-formated Data message
    // - return true on parsing success, false if no valid JSON data was found
    // - set Refreshed to true if the content changed
    // - update all content fields (fResults[], fRowCount, fFieldCount, etc...)
    // - call SortFields() or IDColumnHide if was already done for this TSQLTable
    // - the conversion into PPUTF8CharArray is made inplace and is very fast
    // (only one memory buffer is allocated for the whole data)
    function UpdateFrom(const aJSON: RawUTF8; var Refreshed: boolean;
      PCurrentRow: PInteger): boolean;
    /// the private copy of the processed data buffer
    // - available e.g. for Create constructor using aJSON parameter,
    // or after the UpdateFrom() process
    // - this buffer is not to be access directly: this won't be a valid JSON
    // content, but a processed buffer, on which fResults[] elements point to
    property PrivateInternalCopy: RawUTF8 read fPrivateCopy;
  end;

const
  /// kind of fields not retrieved during normal query, update or adding
  NOT_SIMPLE_FIELDS: TSQLFieldTypes =
    [sftUnknown, sftBlob, sftMany];

  /// kind of fields which can be copied from one TSQLRecord instance to another
  COPIABLE_FIELDS: TSQLFieldTypes =
    [low(TSQLFieldType)..high(TSQLFieldType)] - [sftUnknown, sftMany];

  /// kind of fields which will contain TEXT content when converted to JSON
  TEXT_FIELDS: TSQLFieldTypes =
    [sftAnsiText, sftUTF8Text, sftDateTime, sftObject];

type
  TJSONObjectDecoderParams = (pInlined, pQuoted, pNonQuoted);
  
  /// record/object helper to handle JSON object decoding
  // - used e.g. by GetJSONObjectAsSQL() function
  TJSONObjectDecoder = {$ifdef UNICODE}record{$else}object{$endif}
    /// contains the decoded field names or value
    FieldNames, FieldValues: array[0..MAX_SQLFIELDS-1] of RawUTF8;
    /// Decode() will set a bit for each field set JSON null value
    FieldNull: TSQLFieldBits;
    /// number of fields decoded in FieldNames[] and FieldValues[]
    FieldCount: integer;
    /// size of the TEXT data (in bytes) in FieldValues[]
    FieldLen: integer;
    /// set to TRUE if parameters are to be :(...): inlined
    InlinedParams: boolean;
    /// internal pointer over field names to be used
    // - either FieldNames, either Fields[] array as defined in Decode()
    DecodedFieldNames: PRawUTF8Array;
    /// decode the JSON object fields into FieldNames[] and FieldValues[]
    // - if Fields=nil, P should be a true JSON object, i.e. defined
    // as "COL1"="VAL1" pairs, stopping at '}' or ']'; otherwise, Fields[]
    // contains column names and expects a JSON array as "VAL1","VAL2".. in P
    // - P returns the next object start or nil on unexpected end of input
    // - if InlineParams is TRUE, FieldValues[] strings will be quoted
    // - if RowID is set, a RowID column will be added within the returned content
    procedure Decode(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
      Params: TJSONObjectDecoderParams; RowID: integer=0; ReplaceRowIDWithID: Boolean=false); overload;
    /// decode the JSON object fields into FieldNames[] and FieldValues[]
    // - overloaded method expecting a RawUTF8 buffer, calling Decode(P: PUTF8Char)
    procedure Decode(JSON: RawUTF8; const Fields: TRawUTF8DynArray;
      Params: TJSONObjectDecoderParams; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false); overload;
    /// encode as a SQL-ready INSERT or UPDATE statement
    // - after a successfull call to Decode()
    // - escape SQL strings, according to the official SQLite3 documentation
    // (i.e. ' inside a string is stored as '')
    // - if InlinedParams was TRUE, it will create prepared parameters like
    // 'COL1=:("VAL1"):, COL2=:(VAL2):'
    // - called by GetJSONObjectAsSQL() function
    function EncodeAsSQL(Update: boolean): RawUTF8;
    /// encode as a SQL-ready INSERT or UPDATE statement with ? as values
    // - after a successfull call to Decode()
    // - FieldValues[] content will be ignored
    function EncodeAsSQLPrepared(const TableName: RawUTF8; Update: boolean): RawUTF8;
    /// set the specified array to the fields names
    // - after a successfull call to Decode()
    procedure AssignFieldNamesTo(var Fields: TRawUTF8DynArray);
    /// returns TRUE if the specified array match the decoded fields names
    // - after a successfull call to Decode()
    function SameFieldNames(const Fields: TRawUTF8DynArray): boolean;
  end;

/// decode JSON fields object into an UTF-8 encoded SQL-ready statement
// - this function decodes in the P^ buffer memory itself (no memory allocation
// or copy), for faster process - so take care that it is an unique string
// - P contains the next object start or nil on unexpected end of input
// - if Fields is void, expects expanded "COL1"="VAL1" pairs in P^, stopping at '}' or ']'
// - otherwize, Fields[] contains the column names and expects "VAL1","VAL2".. in P^
// - returns 'COL1="VAL1", COL2=VAL2' if UPDATE is true (UPDATE SET format)
// - returns '(COL1, COL2) VALUES ("VAL1", VAL2)' otherwize (INSERT format)
// - escape SQL strings, according to the official SQLite3 documentation
// (i.e. ' inside a string is stored as '')
// - if InlinedParams is set, will create prepared parameters like
// 'COL1=:("VAL1"):, COL2=:(VAL2):'
// - if RowID is set, a RowID column will be added within the returned content
function GetJSONObjectAsSQL(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Update, InlinedParams: boolean; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;

/// decode JSON fields object into an UTF-8 encoded SQL-ready statement
// - expect JSON expanded object as "COL1"="VAL1",...} pairs
// - make its own temporary copy of JSON data before calling GetJSONObjectAsSQL() above
// - returns 'COL1="VAL1", COL2=VAL2' if UPDATE is true (UPDATE SET format)
// - returns '(COL1, COL2) VALUES ("VAL1", VAL2)' otherwize (INSERT format)
// - if InlinedParams is set, will create prepared parameters like 'COL2=:(VAL2):'
// - if RowID is set, a RowID column will be added within the returned content
function GetJSONObjectAsSQL(JSON: RawUTF8; Update, InlinedParams: boolean;
  RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;

/// get the FIRST field value of the FIRST row, from a JSON content
// - e.g. usefull to get an ID without converting a JSON content into a TSQLTableJSON
function UnJSONFirstField(var P: PUTF8Char): RawUTF8;

/// returns TRUE if the JSON content is in expanded format
// - i.e. as plain [{"ID":10,"FirstName":"John","LastName":"Smith"}...]
// - i.e. not as '{"fieldCount":3,"values":["ID","FirstName","LastName",...']}
function IsNotAjaxJSON(P: PUTF8Char): Boolean;

/// get the number of rows stored in the not-expanded JSON content
function GetRowCountNotExpanded(P: PUTF8Char; FieldCount: integer; var RowCount: integer): PUTF8Char;

/// go to the end of a field name in a JSON '"FieldName":Value' pair
// - returns nil if P was not formatted as expected
// - returns the position of Value
function JSONIgnoreFieldName(P: PUTF8Char): PUTF8Char;

/// go to the end of a value in a JSON '"FieldName":Value,' pair
// - returns nil if P was not formatted as expected
// - returns the position of the expected ending ',' or '}' delimiter
function JSONIgnoreFieldValue(P: PUTF8Char): PUTF8Char;

/// go to the end of a JSON '{"Name":Value,....}' object
// - returns nil if P was not formatted as expected
// - returns the position after the expected ending '}' delimiter
function JSONIgnoreObject(P: PUTF8Char): PUTF8Char;

/// retrieve a JSON '{"Name":Value,....}' object
// - P is nil in return in case of an invalid object
// - returns the UTF-8 encoded JSON object, including first '{' and last '}'
// - if ExtractID is set, it will contain the "ID":203 field value, and this
// field won't be included in thre resulting UTF-8 encoded JSON object (will
// expect this "ID" property to be the FIRST in the "Name":Value pairs
function JSONGetObject(var P: PUTF8Char; ExtractID: PInteger;
  var EndOfObject: AnsiChar): RawUTF8;

/// fill a TSQLRawBlob from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
function BlobToTSQLRawBlob(P: PUTF8Char): TSQLRawBlob;

/// create a TBytes from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
function BlobToBytes(P: PUTF8Char): TBytes;

/// create a memory stream from TEXT-encoded blob data
// - blob data can be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.) or
// or Base-64 encoded content ('\uFFF0base64encodedbinary') or plain TEXT
// - the caller must free the stream instance after use
function BlobToStream(P: PUTF8Char): TStream;

/// creates a TEXT-encoded version of blob data from a TSQLRawBlob
// - TEXT will be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function TSQLRawBlobToBlob(const RawBlob: TSQLRawBlob): RawUTF8; overload;
  {$ifdef HASINLINE}inline;{$endif}

/// creates a TEXT-encoded version of blob data from a memory data
// - same as TSQLRawBlob, but with direct memory access via a pointer/byte size pair
// - TEXT will be encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function TSQLRawBlobToBlob(RawBlob: pointer; RawBlobLength: integer): RawUTF8; overload;


/// return true if the TEXT is encoded as SQLite3 BLOB literals (X'53514C697465' e.g.)
function isBlobHex(P: PUTF8Char): boolean; {$ifdef HASINLINE}inline;{$endif}


/// guess the content type of an UTF-8 encoded field value, as used in TSQLTable.Get()
// - if P if nil or 'null', return sftUnknown
// - otherwize, guess its type from its value characters
// - sftBlob is returned if the field is encoded as SQLite3 BLOB literals
// (X'53514C697465' e.g.) or with '\uFFF0' magic code
// - since P is PUTF8Char, string type is sftUTF8Text only
// - sftFloat is returned for any floating point value, even if it was
// declared as sftCurrency type
// - sftInteger is returned for any INTEGER stored value, even if it was declared
// as sftEnumerate, sftSet, sftID, sftRecord, sftBoolean or
// sftModTime / sftCreateTime / sftTimeLog type
function UTF8ContentType(P: PUTF8Char): TSQLFieldType;

/// guess the content type of an UTF-8 SQL value, in :(....): format
// - will be used e.g. by ExtractInlineParameters() to un-inline a SQL statement
// - sftInteger is returned for an INTEGER value, e.g. :(1234):
// - sftFloat is returned for any floating point value (i.e. some digits
// separated by a '.' character), e.g. :(12.34): or :(12E-34):
// - sftUTF8Text is returned for :("text"): or :('text'):, with double quoting
// inside the value
// - sftBlob will be recognized from the ':("\uFFF0base64encodedbinary"):'
// pattern (or ':(null):'), and return raw binary (for direct blob parameter assignment)
// - sftDateTime will be recognized from ':(\uFFF1"2012-05-04"):' pattern,
// i.e. JSON_SQLDATE_MAGIC-prefixed string as returnded by DateToSQL() or
// DateTimeToSQL() functions
// - sftUnknown is returned on invalid content
// - if ParamValue is not nil, the pointing RawUTF8 string is set with the
// value inside :(...): without double quoting in case of sftUTF8Text
function SQLParamContent(P: PUTF8Char; out ParamType: TSQLFieldType; out ParamValue: RawUTF8): PUTF8Char;


/// read an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and string properties (excluding WideString, but including UnicodeString)
// - read only the published properties of the current class level (do NOT
// read the properties content published in the parent classes)
// - "From" must point to the [section] containing the object properties
// - for integers and enumerates, if no value is stored in From (or From is ''),
// the default value from the property definition is set
procedure ReadObject(Value: TObject; From: PUTF8Char; const SubCompName: RawUTF8=''); overload;

/// read an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and string properties (excluding WideString, but including UnicodeString)
// - read only the published properties of the current class level (do NOT
// read the properties content published in the parent classes)
// - for integers, if no value is stored in FromContent, the default value is set
// - this version gets the appropriate section from [Value.ClassName]
// - this version doesn't handle embedded objects
procedure ReadObject(Value: TObject; const FromContent: RawUTF8;
  const SubCompName: RawUTF8=''); overload;

/// write an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and string properties (excluding WideString, but including UnicodeString)
// - write only the published properties of the current class level (do NOT
// write the properties content published in the parent classes)
// - direct update of INI-like content
// - for integers, value is always written, even if matches the default value
procedure WriteObject(Value: TObject; var IniContent: RawUTF8;
  const Section: RawUTF8; const SubCompName: RawUTF8=''); overload;

/// write an object properties, as saved by TINIWriter.WriteObject() method
// - i.e. only Integer, Int64, enumerates (including boolean), floating point values
// and string properties (excluding WideString, but including UnicodeString)
// - write only the published properties of the current class level (do NOT
// write the properties content published in the parent classes)
// - return the properties as text Name=Values pairs, with no section
// - for integers, if the value matches the default value, it is not added to the result
function WriteObject(Value: TObject): RawUTF8; overload;

/// copy object properties
// - copy only Integer, Int64, enumerates (including boolean), object properties
// and string properties (excluding WideString, but including UnicodeString)
// - TCollection items can be copied also, if they are of the same exact class
// - object properties instances are created in aTo if the objects are not
// TSQLRecord children (in this case, these are not class instances, but
// INTEGER reference to records, so only the integer value is copied), that is
// for regular Delphi classes
procedure CopyObject(aFrom, aTo: TObject);

/// set any default integer or enumerates (including boolean) published
// properties values for an object
// - reset only the published properties of the current class level (do NOT
// reset the properties content published in the parent classes)
procedure SetDefaultValuesObject(Value: TObject);

/// will serialize any TObject into its UTF-8 JSON representation
/// - serialize as JSON the published integer, Int64, floating point values,
// TDateTime (stored as ISO 8601 text), string and enumerate (e.g. boolean)
// properties of the object
// - won't handle variant, shortstring and widestring properties
// - the enumerates properties are stored with their integer index value
// - will write also the properties published in the parent classes
// - nested properties are serialized as nested JSON objects
// - any TCollection property will also be serialized as JSON arrays
// - you can add some custom serializers for ANY Delphi class, via the
// TJSONSerializer.RegisterCustomSerializer() class method
// - call internaly TJSONSerializer.WriteObject
function ObjectToJSON(Value: TObject; HumanReadable: boolean=false;
   DontStoreDefault: boolean=true): RawUTF8;

/// encode supplied parameters to be compatible with URI encoding
// - parameters must be supplied two by two, as Name,Value pairs, e.g.
// ! url := UrlEncodeFull(['select','*','where','ID=12','offset',23,'object',aObject]);
// - parameters can be either textual, integer or extended, or any TObject
// (standard UrlEncode() will only handle
// - TObject serialization into UTF-8 will be processed by the ObjectToJSON()
// function
function UrlEncode(const NameValuePairs: array of const): RawUTF8; overload;

/// read an object properties, as saved by ObjectToJSON function
// - ObjectInstance must be an existing TObject instance
// - the data inside From^ is modified (unescaped and transformed): don't call
// JSONToObject(pointer(JSONRawUTF8)) but makes a temporary copy of the
// JSONRawUTF8 text before calling this function
// - handle Integer, Int64, enumerate (including boolean), set, floating point,
// TDateTime, TCollection, TStrings, TRawUTF8List, and string properties
// (excluding ShortString and WideString, but including UnicodeString under
// Delphi 2009+)
// - won't handle TList/TObjectList (even if ObjectToJSON is able to serialize
// them) since has now way of knowing the object type to add (TCollection.Add
// is missing), unless you set the TObjectListItemClass property as expected,
// and provide a TObjectList object (TList won't be handled since it may leak
// memory when calling TList.Clear) 
// - will release any previous TCollection objects, and convert any null JSON
// basic type into nil - e.g. if From='null', will call FreeAndNil(Value)
// - you can add some custom (un)serializers for ANY Delphi class, via the
// TJSONSerializer.RegisterCustomSerializer() class method
// - set Valid=TRUE on success, Valid=FALSE on error, and the main function
// will point in From at the syntax error place (e.g. on any unknown property name)
// - caller should explicitely perform a SetDefaultValuesObject(Value) if
// the default values are expected to be set before JSON parsing
function JSONToObject(var ObjectInstance; From: PUTF8Char; var Valid: boolean;
  TObjectListItemClass: TClass=nil): PUTF8Char;

/// decode a specified parameter compatible with URI encoding into its original
// object contents
// - ObjectInstance must be an existing TObject instance
// - will call internaly JSONToObject() function to unserialize its content
// - UrlDecodeExtended('price=20.45&where=LastName%3D%27M%C3%B4net%27','PRICE=',P,@Next)
// will return Next^='where=...' and P=20.45
// - if Upper is not found, Value is not modified, and result is FALSE
// - if Upper is found, Value is modified with the supplied content, and result is TRUE
function UrlDecodeObject(U, Upper: PUTF8Char; var ObjectInstance; Next: PPUTF8Char=nil): boolean;


{ ************ some RTTI and SQL mapping routines }

{ type definitions below were adapted from TypInfo.pas
 - this implementation doesn't require to include Variant.pas any more (which
  allow easy server-side compile with LVCL, e.g.)
 - some code was rewritten in an object orientation manner (declared as objects
  instead of records) to avoid use of global function/procedure
 - allows easy published properties enumeration with ClassProp()
 - if a property doesn't have a write attribute (i.e. no setter), its value
  is set using the field adress itself (from read f* getter)
 - some usefull but not implemented functions were added in optimized assembler }

type
{$ifdef FPC}
  /// available type families for Free Pascal RTTI values
  // - values differs from Delphi, and are taken from FPC typinfo.pp unit
  TTypeKind = (tkUnknown,tkInteger,tkChar,tkEnumeration,tkFloat,
    tkSet,tkMethod,tkSString,tkLString,tkAString,
    tkWString,tkVariant,tkArray,tkRecord,tkInterface,
    tkClass,tkObject,tkWChar,tkBool,tkInt64,tkQWord,
    tkDynArray,tkInterfaceRaw,tkProcVar,tkUString,tkUChar,tkHelper);
{$else}
  /// available type families for Delphi 6 up to XE values
  TTypeKind = (tkUnknown, tkInteger, tkChar, tkEnumeration, tkFloat,
    tkString, tkSet, tkClass, tkMethod, tkWChar, tkLString, tkWString,
    tkVariant, tkArray, tkRecord, tkInterface, tkInt64, tkDynArray
    {$ifdef UNICODE}, tkUString{$endif});
{$endif}

  /// specify ordinal (tkInteger and tkEnumeration) storage size and sign
  // - note: Int64 is stored as its own TTypeKind, not as tkInteger
  TOrdType = (otSByte, otUByte, otSWord, otUWord, otSLong, otULong);

  /// specify floating point (ftFloat) storage size and precision
  TFloatType = (ftSingle, ftDouble, ftExtended, ftComp, ftCurr);

  PPTypeInfo = ^PTypeInfo;

{$ifdef FPC}
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
{$PACKRECORDS C}
{$else}
{$A-}
{$endif}
{$else}
{$A-} { Delphi compiler use packed storage for this internal types, not aligned data }
{$endif}

  PPropInfo = ^TPropInfo;
  PMethodInfo = ^TMethodInfo;

  /// pointer to TClassProp
  PClassProp = ^TClassProp;
  /// a wrapper to published properties of a class
  // - start enumeration by getting a PClassProp with ClassProp()
  // - use PropCount, P := @PropList to get the first PPropInfo, and then P^.Next
  // - this enumeration is very fast and doesn't require any temporary memory,
  //  as in the TypInfo.GetPropInfos() PPropList usage
  // - for TSQLRecord, you should better use the RecordProps.Fields[] array,
  // which is faster and contains the properties published in parent classes
  TClassProp = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// number of published properties in this object
    PropCount: Word;
    /// point to a TPropInfo packed array
    // - layout is as such, with variable TPropInfo storage size:
    // ! PropList: array[1..PropCount] of TPropInfo
    // - use TPropInfo.Next to get the next one:
    // ! P := @PropList;
    // ! for i := 1 to PropCount do begin
    // !   // ... do something with P
    // !   P := P^.Next;
    // ! end;
    PropList: record end;
    /// retrieve a Field property RTTI information from a Property Name
    function FieldProp(const PropName: shortstring): PPropInfo;
    /// return the total count of the published properties in this class
    // and all its parents
    function FieldCountWithParents: integer;
  end;

  PClassType = ^TClassType;
  /// a wrapper to class type information, as defined by the Delphi RTTI
  TClassType = {$ifndef ISDELPHI2010}object{$else}record{$endif}
     /// the class type
     ClassType: TClass;
     /// the parent class type information
     ParentInfo: PPTypeInfo;
     /// the number of published properties
     PropCount: SmallInt;
     /// the name (without .pas extension) of the unit were the class was defined
     // - then the PClassProp follows: use the method ClassProp to retrieve its
     // address
     UnitName: string[255];
     /// get the information about the published properties of this class
     // - stored after UnitName memory
     function ClassProp: PClassProp;
       {$ifdef HASINLINE}inline;{$endif}
     /// fast and easy find if this class inherits from a specific class type
     function InheritsFrom(AClass: TClass): boolean;
     /// return the size (in bytes) of this class type information
     // - can be used to create class types at runtime
     function RTTISize: integer;
  end;

  PEnumType = ^TEnumType;
  /// a wrapper to enumeration type information, as defined by the Delphi RTTI
  // - we use this to store the enumeration values as integer, but easily provide
  // a text equivalent, translated if necessary, from the enumeration type
  // definition itself
  TEnumType = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// specify ordinal storage size and sign
    OrdType: TOrdType;
    /// first value of enumeration type, typicaly 0
    MinValue: Longint;
    /// same as ord(high(type)): not the enumeration count, but the highest index
    MaxValue: Longint;
    /// the base type of this enumeration
    /// - always use PEnumType(typeinfo(TEnumType))^.BaseType or more usefull
    // method PTypeInfo(typeinfo(TEnumType))^.EnumBaseType before calling
    // any of the methods below
    BaseType: PPTypeInfo;
    /// a concatenation of shortstrings, containing the enumeration names
    NameList: string[255];
    /// get the corresponding enumeration name
    // - return the first one if Value is invalid (>MaxValue)
    function GetEnumNameOrd(Value: Integer): PShortString;
    /// get the corresponding enumeration name
    // - return the first one if Value is invalid (>MaxValue)
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetEnumName(const Value): PShortString;
       {$ifdef HASINLINE}inline;{$endif}
    /// get the corresponding enumeration ordinal value, from its name
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameValue(const EnumName: ShortString): Integer; overload;
    /// get the corresponding enumeration ordinal value, from its name
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameValue(Value: PUTF8Char): Integer; overload;
    /// get the corresponding enumeration name, without the first lowercase chars
    // (otDone -> 'Done')
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetEnumNameTrimed(const Value): RawUTF8;
       {$ifdef HASINLINE}inline;{$endif}
    ///  get the corresponding caption name, without the first lowercase chars
    // (otDone -> 'Done')
    // - return "string" type, i.e. UnicodeString for Delphi 2009+
    // - internally call UnCamelCase() then System.LoadResStringTranslate() if available
    // - Value will be converted to the matching ordinal value (byte or word)
    function GetCaption(const Value): string;
    /// get all caption names, ready to be display, as lines separated by #13#10
    // - return "string" type, i.e. UnicodeString for Delphi 2009+
    // - if UsedValuesBits is not nil, only the corresponding bits set are added
    function GetCaptionStrings(UsedValuesBits: Pointer=nil): string;
    /// add caption names, ready to be display, to a TStrings class
    // - add pointer(ord(element)) as Objects[] value
    // - if UsedValuesBits is not nil, only the corresponding bits set are added
    procedure AddCaptionStrings(Strings: TStrings; UsedValuesBits: Pointer=nil);
    /// get the corresponding enumeration ordinal value, from its name without
    // its first lowercase chars ('Done' will find otDone e.g.)
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameTrimedValue(const EnumName: ShortString): Integer; overload;
    /// get the corresponding enumeration ordinal value, from its name without
    // its first lowercase chars ('Done' will find otDone e.g.)
    // - return -1 if not found (don't use directly this value to avoid any GPF)
    function GetEnumNameTrimedValue(Value: PUTF8Char): Integer; overload;
  end;


{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  TRecordField = packed record
    TypeInfo: PPTypeInfo;
    Offset: Cardinal;
  end;
  TRecordType = packed record
    Size: cardinal;
    Count: integer;
    Fields: array[word] of TRecordField;
  end;
  PRecordField = ^TRecordField;
  PRecordType = ^TRecordType;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  PTypeInfo = ^TTypeInfo;
  /// a wrapper containing type information definition
  // - user types defined as an alias don't have this type information:
  // & type NewType = OldType;
  // - user types defined as new types have this type information:
  // & type NewType = type OldType;
  TTypeInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the value type family
    Kind: TTypeKind;
    /// the declared name of the type ('String','Word','RawUnicode'...)
    Name: ShortString;
    /// get the class type information
    function ClassType: PClassType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    /// get the SQL type of this Delphi class type
    function ClassSQLFieldType: TSQLFieldType;
       {$ifdef HASINLINE}inline;{$endif}
    /// for ordinal types, get the storage size and sign
    function OrdType: TOrdType;
      {$ifdef HASINLINE}inline;{$endif}
    /// for set types, get the type information of the corresponding enumeration
    function SetEnumType: PEnumType;
    /// for gloating point types, get the storage size and procision
    function FloatType: TFloatType;
      {$ifdef HASINLINE}inline;{$endif}
    /// get the SQL type of this Delphi type, as managed with the database driver
    function SQLFieldType: TSQLFieldType;
     /// fast and easy find if a class type inherits from a specific class type
    function InheritsFrom(AClass: TClass): boolean;
    /// get the enumeration type information
    function EnumBaseType: PEnumType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    /// get the record type information
    function RecordType: PRecordType;
      {$ifdef FPC}inline;{$endif} {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper containing a property definition, with GetValue() and SetValue()
    functions for direct Delphi / UTF-8 SQL type mapping/conversion:
    - handle byte, word, integer, cardinal, Int64 properties as INTEGER
    - handle boolean properties as INTEGER (0 is false, anything else is true)
    - handle enumeration properties as INTEGER, storing the ordinal value of the
      enumeration (i.e. starting at 0 for the first element)
    - handle enumerations set properties as INTEGER, each bit corresponding to
      an enumeration (therefore a set of up to 64 elements can be stored in such
      a field)
    - handle RawUTF8 properties as TEXT (UTF-8 encoded) - this is the preferred
      field type for storing some textual content in the ORM
    - handle WinAnsiString properties as TEXT (UTF-8 decoded in WinAnsi char set)
    - handle RawUnicode properties as TEXT (UTF-8 decoded as UTF-16 Win32 unicode)
    - handle Single, Double and Extended properties as FLOAT
    - handle TDateTime properties as ISO-8061 encoded TEXT
    - handle TTimeLog properties as properietary fast INTEGER date time
    - handle Currency property as FLOAT (safely converted to/from currency)
    - handle TSQLRecord descendant properties as INTEGER ROWID index to another record
     (warning: the value contains pointer(ROWID), not a valid object memory - you
     have to manually retrieve the record, using a integer(IDField) typecast)
    - handle TSQLRecordMany descendant properties as an "has many" instance (this
     is a particular case of TSQLRecord: it won't contain pointer(ID), but an object)
    - handle TRecordReference properties as INTEGER RecordRef-like value
      (use TSQLRest.Retrieve(Reference) to get a record content)
    - handle TSQLRawBlob properties as BLOB
    - handle dynamic arrays as BLOB, in the TDynArray.SaveTo binary format (is able
      to handle dynamic arrays of records, with records or strings within records)
    - handle records as BLOB, in the RecordSave binary format (our code is ready
      for that, but Delphi doesn't create the RTTI for records so it won't work)
    - WideString, shortstring, UnicodeString (i.e. Delphi 2009+ generic string),
      indexed properties are not handled yet (use faster RawUnicodeString instead
      of WideString and UnicodeString) - in fact, the generic string type is handled  }
  TPropInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the type definition of this property
    PropType: PPTypeInfo;
    /// contains the offset of a field, or the getter method set by 'read' Delphi declaration
    GetProc: PtrInt;
    /// contains the offset of a field, or the setter method set by 'write' Delphi declaration
    // - if this field is nil (no 'write' was specified), SetValue() use GetProc to
    // get the field memory address to save into
    SetProc: PtrInt;
    /// contains the 'stored' boolean value/method (used in TPersistent saving)
    // - either integer(True) - the default, integer(False), reference to a Boolean
    // field, or reference to a parameterless method that returns a Boolean value
    // - if a property is marked as "stored false", it is created as UNIQUE
    // in the SQL database and its bit is set in Model.fIsUnique[]
    StoredProc: PtrInt;
    /// contains the index value of an indexed class data property
    // - outside SQLite3, this can be used to define a VARCHAR() length value
    // for the textual field definition (sftUTF8Text/sftAnsiText); e.g.
    // the following will create a NAME VARCHAR(40) field:
    // ! Name: RawUTF8 index 40 read fName write fName;
    // - is used by a dynamic array property for fast usage of the
    // TSQLRecord.DynArray(DynArrayFieldIndex) method
    Index: Integer;
    /// contains the default value (2147483648=$80000000 indicates nodefault)
    // when an ordinal or set property is saved as TPersistent
    Default: Longint;
    /// default name index value is 0
    NameIndex: SmallInt;
{$ifdef FPC}
    /// contains the type of the Get/Set/Storedproc, see also ptxxx
    // bit 0..1 GetProc
    //     2..3 SetProc
    //     4..5 StoredProc
    //     6 : true, constant index property
    PropProcs : Byte;
{$endif}
    /// the property definition Name
    Name: ShortString;

    /// get the next property information
    // - no range check: use ClassProp()^.PropCount to determine the properties count
    // - get the first PPropInfo with ClassProp()^.PropList
    function Next: PPropInfo;
      {$ifdef FPC}inline;{$else}{$ifdef HASINLINE}inline;{$endif} {$endif}
    /// return FALSE if was marked as "stored false", or TRUE by default
    function IsStored: boolean; {$ifdef HASINLINE}inline;{$endif}
    /// convert UTF-8 encoded text into the published property value
    // - setter method (write Set*) is called if available
    // - if no setter exists (no write declaration), the getted field address is used
    // - handle UTF-8 SQL to Delphi values conversion
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    // or base-64 encoded stream for JSON ("\uFFF0base64encodedbinary") - i.e.
    // both format supported by BlobToTSQLRawBlob() function
    // - handle TPersistent, TCollection, TRawUTF8List or TStrings with JSONToObject
    procedure SetValue(Instance: TObject; Value: PUTF8Char);
    /// convert the published property value into an UTF-8 encoded text
    // - if ToSQL is true, result is on SQL form (false->'0' e.g.)
    // - if ToSQL is false, result is on JSON form (false->'false' e.g.)
    // - BLOB field returns SQlite3 BLOB literals ("x'01234'" e.g.) if ToSQL is
    // true, or base-64 encoded stream for JSON ("\uFFF0base64encodedbinary")
    // - getter method (read Get*) is called if available
    // - handle Delphi values into UTF-8 SQL conversion
    // - sftBlobDynArray or sftBlobRecord are returned as BLOB literals
    // ("X'53514C697465'") if ToSQL is true, or base-64 encoded stream for JSON
    // ("\uFFF0base64encodedbinary")
    // - handle TPersistent, TCollection, TRawUTF8List or TStrings with ObjectToJSON
    function GetValue(Instance: TObject; ToSQL: boolean; wasSQLString: PBoolean=nil): RawUTF8;
      {$ifdef HASINLINE}inline;{$endif}
    /// convert the published property value into an UTF-8 encoded text
    // - this method is the same as GetValue(), but avoid assigning the result
    // string variable (some speed up on multi-core CPUs, since avoid a CPU LOCK)
    procedure GetValueVar(Instance: TObject; ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
    /// append the published property value into a binary buffer
    procedure GetBinary(Instance: TObject; W: TFileBufferWriter);
    /// read the published property value from a binary buffer
    // - returns next char in input buffer on success, or nil in case of invalid
    // content supplied e.g.
    function SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
    /// copy a published property value from one instance to another
    // - this method use direct copy of the low-level binary content, and is
    // therefore faster than a SetValue(Dest,GetValue(Source)) call
    procedure CopyValue(Source, Dest: TObject);
    {$ifdef USEVARIANTS}
    /// retrieve the published property value into a Variant
    // - will set the Variant type to the best matching kind according to the
    // property type
    // - BLOB field returns SQlite3 BLOB textual literals ("x'01234'" e.g.)
    // - dynamic array field is returned as a variant array
    procedure GetVariant(Instance: TObject; var Dest: Variant);
    /// set the published property value from a Variant value
    // - dynamic array field must be set from a variant array
    // - will convert other properties from the variant type into UTF-8 text
    // before setting the value (so will work with any kind of Variant)
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    procedure SetVariant(Instance: TObject; const Source: Variant);
    {$endif}
    /// normalize the content of Value, so that GetValue(Object,true) should return the
    // same content (true for ToSQL format)
    procedure NormalizeValue(var Value: RawUTF8);
    /// retrieve an unsigned 32 bit hash of the corresponding property
    // - not all kind of properties are handled: only main types
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    // - note that this method can return a hash value of 0
    function GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
    /// compare the content of the property of two object
    // - not all kind of properties are handled: only main types (like GetHash)
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    function SameValue(Item1,Item2: TObject; CaseInsensitive: boolean): boolean;
    /// return true if this property is a valid simple field (INTEGER,FLOAT,TEXT)
    // but not a BLOB (TSQLRawBlob)
    // - use directly TSQLRecord.GetBit64(fJSONFields,i) if possible (faster)
    function IsSimpleField: boolean; {$ifdef HASINLINE}inline;{$endif}
    /// return true if this property is a BLOB (TSQLRawBlob)
    function IsBlob: boolean; {$ifdef HASINLINE}inline;{$endif}
    /// return Text+Name[+Optional]
    procedure AppendName(var Text: RawUTF8; const Optional: RawUTF8='');
    ///  get the corresponding caption name, from the property name
    // - return generic "string" type, i.e. UnicodeString for Delphi 2009+
    // - internally call UnCamelCase() then System.LoadResStringTranslate() if available
    function GetCaption: string;
    /// return the field value as SQL statement ready
    // - e.g. round strings with the ' character, and escape the text using
    // double quotes, according to the official SQLite3 documentation
    // - expect enumerates (and boolean) values already encoded as integer
    function GetSQLFromFieldValue(const FieldValue: RawUTF8): RawUTF8;

    /// low-level getter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    // - return -1 on any error
    function GetOrdValue(Instance: TObject): Integer;
    /// low-level getter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    // - ordinal properties smaller than tkInt64 will return an Int64-converted
    // value (e.g. tkInteger)
    // - return 0 on any error
    function GetInt64Value(Instance: TObject): Int64;
    /// low-level getter of the currency property value of a given instance
    // - this method will check if the corresponding property is exactly currency
    // - return 0 on any error
    function GetCurrencyValue(Instance: TObject): Currency;
    /// low-level getter of the floating-point property value of a given instance
    // - this method will check if the corresponding property is floating-point
    // - return 0 on any error
    function GetExtendedValue(Instance: TObject): Extended;
    /// low-level setter of the floating-point property value of a given instance
    // - this method will check if the corresponding property is floating-point
    procedure SetExtendedValue(Instance: TObject; const Value: Extended);
    /// low-level getter of the long string property value of a given instance
    // - this method will check if the corresponding property is a Long String,
    // and will return '' if it's not the case
    // - it will convert the property content into RawUTF8, for RawUnicode,
    // WinAnsiString, TSQLRawBlob and generic Delphi 6-2007 string property
    function GetLongStrValue(Instance: TObject): RawUTF8;
    /// low-level setter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    procedure SetOrdValue(Instance: TObject; Value: Integer);
    /// low-level setter of the ordinal property value of a given instance
    // - this method will check if the corresponding property is ordinal
    procedure SetInt64Value(Instance: TObject; Value: Int64);
    /// low-level setter of the long string property value of a given instance
    // - this method will check if the corresponding property is a Long String
    // - it will convert the property content into RawUTF8, for RawUnicode,
    // WinAnsiString, TSQLRawBlob and generic Delphi 6-2007 string property
    procedure SetLongStrValue(Instance: TObject; const Value: RawUTF8);
    /// low-level setter of the string property value of a given instance
    // - uses the generic string type: to be used within the VCL
    // - this method will check if the corresponding property is a Long String
    // or an UnicodeString (for Delphi 2009+), and will call the corresponding
    // SetLongStrValue() or SetUnicodeStrValue() method
    procedure SetGenericStringValue(Instance: TObject; const Value: string);
    /// low-level getter of the long string property value of a given instance
    // - uses the generic string type: to be used within the VCL
    // - this method will check if the corresponding property is a Long String,
    // or an UnicodeString (for Delphi 2009+),and will return '' if it's
    // not the case
    function GetGenericStringValue(Instance: TObject): string;
{$ifdef UNICODE}
    /// low-level setter of the Unicode string property value of a given instance
    // - this method will check if the corresponding property is a Unicode String
    procedure SetUnicodeStrValue(Instance: TObject; const Value: UnicodeString);
    /// low-level getter of the Unicode string property value of a given instance
    // - this method will check if the corresponding property is a Unicode String
    function GetUnicodeStrValue(Instance: TObject): UnicodeString;
{$endif}
    /// low-level getter of a dynamic array wrapper
    // - this method will NOT check if the property is a dynamic array: caller
    // must have already checked that PropType^^.Kind=tkDynArray
    function GetDynArray(Instance: TObject): TDynArray;
      {$ifdef HASINLINE}inline;{$endif}
{$ifndef USETYPEINFO}
    /// low-level getter of the field value memory pointer
    // - return NIL if there a getter method
    function GetFieldAddr(Instance: TObject): pointer;
{$endif}
  end;

  /// the available methods calling conventions
  // - this is by design only relevant to the x86 model
  // - Win64 has one unique calling convention
  TCallingConvention = (ccRegister, ccCdecl, ccPascal, ccStdCall, ccSafeCall);

  /// the available kind of method parameters
  TParamFlag = (pfVar, pfConst, pfArray, pfAddress, pfReference, pfOut, pfResult);

  /// a set of kind of method parameters
  TParamFlags = set of TParamFlag;

  PReturnInfo = ^TReturnInfo;
  PParamInfo  = ^TParamInfo;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around method returned result definition }
  TReturnInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// RTTI version
    // - 2 up to Delphi 2010, 3 for Delphi XE and up
    Version: byte;
    /// expected calling convention (only relevant for x86 mode)
    CallingConvention: TCallingConvention;
    /// the expected type of the returned function result
    // - is nil for procedure
    ReturnType: ^PTypeInfo;
    /// total size of data needed for stack parameters + 8 (ret-addr + pushed EBP)
    ParamSize: Word;
    /// number of expected parameters
    ParamCount: Byte;
    /// access to the first method parameter definition
    function Param: PParamInfo; {$ifdef HASINLINE}inline;{$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around an individual method parameter definition }
  TParamInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the kind of parameter
    Flags: TParamFlags;
    /// the parameter type information
    ParamType: PPTypeInfo;
    /// parameter offset
    // - 0 for EAX, 1 for EDX, 2 for ECX
    // - any value >= 8 for stack-based parameter
    Offset: Word;
    /// parameter name
    Name: ShortString;
    /// get the next parameter information
    // - no range check: use TReturnInfo.ParamCount to determine the appropriate count
    function Next: PParamInfo; {$ifdef HASINLINE}inline;{$endif}
  end;

{$A-} { Delphi and FPC compiler use packed storage for this internal type }
  {/ a wrapper around a method definition }
  TMethodInfo = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    {$ifdef FPC}
    /// method name
    Name: PShortString;
    /// the associated method code address
    Addr: Pointer;
    {$else}
    /// size (in bytes) of this TMethodInfo block
    Len: Word;
    /// the associated method code address
    Addr: Pointer;
    /// method name
    Name: ShortString;
    {$endif}
    /// retrieve the associated return information
    function ReturnInfo: PReturnInfo; {$ifdef HASINLINE}inline;{$endif}
    /// wrapper returning nil and avoiding a GPF if @self=nil
    function MethodAddr: Pointer; {$ifdef HASINLINE}inline;{$endif}
  end;

{$ifdef FPC}
{$PACKRECORDS 8}
{$else}
{$A+} { default aligned data }
{$endif}

  /// simple writer to a Stream, specialized for writing an object as INI
  // - resulting content will be UTF-8 encoded
  // - use an internal buffer, faster than string+string
  TINIWriter = class(TTextWriter)
    /// write the published integer, Int64, floating point values, string and
    // enumerates (e.g. boolean) properties of the object
    // - won't handle variant, shortstring and widestring properties
    // - add a new INI-like section with [Value.ClassName] if WithSection is true
    // - the object must have been compiled with the $M+ define, i.e. must
    // inherit from TPersistent or TSQLRecord
    // - the enumerates properties are stored with their integer index value
    procedure WriteObject(Value: TObject; const SubCompName: RawUTF8='';
      WithSection: boolean=true); reintroduce;
  end;

  TJSONSerializer = class;
  
  /// method prototype to be used for custom serialization of a class
  // - to be used with TJSONSerializer.RegisterCustomSerializer() method
  // - note that the generated JSON content is not required to start with '{',
  // as a normal JSON object (you may e.g. write a JSON string for some class) -
  // as a consequence, custom code could explicitely start with Add('{')
  // - implementation code shall follow function TJSONSerializer.WriteObject()
  // patterns, i.e. aSerializer.Add/AddInstanceName/AddJSONEscapeString...
  // - implementation code shall follow the same exact format for the
  // associated TJSONSerializerCustomReader callback
  TJSONSerializerCustomWriter = procedure(const aSerializer: TJSONSerializer;
    aValue: TObject; aHumanReadable, aDontStoreDefault, aFullExpand: Boolean) of object;
  /// method prototype to be used for custom un-serialization of a class
  // - to be used with TJSONSerializer.RegisterCustomSerializer() method
  // - note that the read JSON content is not required to start with '{',
  // as a normal JSON object (you may e.g. read a JSON string for some class) -
  // as a consequence, custom code could explicitely start with "if aFrom^='{'..."
  // - implementation code shall follow function JSONToObject() patterns, i.e.
  // calling low-level GetJSONField() function to decode the JSON content
  // - implementation code shall follow the same exact format for the
  // associated TJSONSerializerCustomWriter callback
  TJSONSerializerCustomReader = function(const aValue: TObject; aFrom: PUTF8Char;
    var aValid: Boolean): PUTF8Char of object;

  /// simple writer to a Stream, specialized for writing an object as JSON
  // - resulting JSON content will be UTF-8 encoded
  // - use an internal buffer, faster than string+string
  TJSONSerializer = class(TJSONWriter)
  protected
    fHumanReadableLevel: integer;
    /// used by WriteObjectAsString method
    fInternalJSONWriter: TJSONWriter;
  public
    /// serialize as JSON the published integer, Int64, floating point values,
    // TDateTime (stored as ISO 8601 text), string and enumerate (e.g. boolean)
    // properties of the object
    // - won't handle variant, shortstring and widestring properties
    // - the object must have been compiled with the $M+ define, i.e. must
    // inherit from TPersistent or TSQLRecord
    // - the enumerates properties are stored with their integer index value by
    // default, but will be written as text if FullExpand is true: in this case,
    // the resulting content WON'T be readable with JSONToObject() function
    // - TList objects are not handled by default - they will be written only
    // if FullExpand is set to true (and JSONToObject won't be able to read it)
    // - nested properties are serialized as nested JSON objects
    // - any TCollection property will also be serialized as JSON array
    // - any TStrings or TRawUTF8List property will also be serialized as
    // JSON string array
    // - you can add some custom serializers via the RegisterCustomSerializer()
    // class method, to serialize any Delphi class
    // - will write also the properties published in the parent classes
    procedure WriteObject(Value: TObject; HumanReadable: boolean=false;
      DontStoreDefault: boolean=true; FullExpand: boolean=false); override;
    /// same as WriteObject(), but will double all internal " and bound with "
    // - this implementation will avoid most memory allocations
    procedure WriteObjectAsString(Value: TObject; HumanReadable: boolean=false;
      DontStoreDefault: boolean=true; FullExpand: boolean=false);
    /// relase all used memory and handles
    destructor Destroy; override;
    /// define a custom serialization for a given class
    // - by default, TSQLRecord, TPersistent, TStrings, TCollection classes
    // are processed: but you can specify here some callbacks to perform
    // the serialization process for any class
    // - any previous registration is overriden
    // - setting both aReader=aWriter=nil will return back to the default class
    // serialization (i.e. published properties serialization)
    // - note that any inherited classes will be serialized as the parent class
    class procedure RegisterCustomSerializer(aClass: TClass;
      aReader: TJSONSerializerCustomReader; aWriter: TJSONSerializerCustomWriter);
  end;


/// retreive a Field property index from a Property Name
function ClassFieldIndex(ClassType: TClass; const PropName: shortstring): integer;

/// retrieve a Field property RTTI information from a Property Name
function ClassFieldProp(ClassType: TClass; const PropName: shortstring): PPropInfo;

/// retrieve a Field property RTTI information from a Property Name
// - this special version also search into parent properties (default is only current)
function ClassFieldPropWithParents(aClassType: TClass; const PropName: shortstring): PPropInfo;

/// retrieve a Field property RTTI information from a Property Name
// - this special version also search into parent properties (default is only current)
function ClassFieldPropWithParentsFromUTF8(aClassType: TClass; PropName: PUTF8Char): PPropInfo;

/// retrieve an object's component from its property name and class
// - usefull to set User Interface component, e.g.
function GetObjectComponent(Obj: TPersistent; const ComponentName: shortstring;
  ComponentClass: TClass): pointer;

/// retrieve the class property RTTI information for a specific class
function InternalClassProp(ClassType: TClass): PClassProp;
  {$ifdef FPC}inline;{$endif}

/// retrieve a method RTTI information for a specific class
function InternalMethodInfo(aClassType: TClass; const aMethodName: ShortString): PMethodInfo;

/// retrieve the ready to be displayed text of an enumeration
// - will "uncamel" then translate into a generic VCL string
// - aIndex will be converted to the matching ordinal value (byte or word)
function GetEnumCaption(aTypeInfo: PTypeInfo; const aIndex): string;

/// get the corresponding enumeration name, without the first lowercase chars
// (otDone -> 'Done')
// - aIndex will be converted to the matching ordinal value (byte or word)
// - this will return the code-based English text; use GetEnumCaption() to
// retrieve the enumeration display text
function GetEnumNameTrimed(aTypeInfo: PTypeInfo; const aIndex): RawUTF8;


{$ifdef MSWINDOWS}
{$ifdef CONDITIONALEXPRESSIONS}
{$if CompilerVersion >= 22.0} // fix Delphi XE imcompatilibility
type
  TSecurityAttributes = packed record
    nLength: DWORD;
    lpSecurityDescriptor: Pointer;
    bInheritHandle: BOOL;
  end;

const
  SECURITY_DESCRIPTOR_REVISION = 1;
  SECURITY_DESCRIPTOR_MIN_LENGTH = 20;
{$ifend}
{$endif}
{$endif}

const
  /// maximum number of the locked record in a Table (used in TSQLLocks)
  // - code is somewhat faster and easier with a fixed cache size
  // - 512 seems big enough on practice
  MAX_SQLLOCKS = 512;

  /// maximum handled dimension for TSQLRecordRTree
  // - this value is the one used by SQLite3 R-Tree virtual table
  RTREE_MAX_DIMENSION = 5;


type
  /// generic parent class of all custom Exception types of this unit
  EORMException = class(ESynException);

  /// exception raised in case of wrong Model definition
  EModelException = class(EORMException);

  /// exception raised in case of unexpected parsing error
  EParsingException = class(EORMException);

  /// exception raised in case of a Client-Server communication error
  ECommunicationException = class(EORMException);

  /// exception raised in case of an error in project implementation logic
  EBusinessLayerException = class(EORMException);

  /// exception raised in case of any authentication error
  ESecurityException = class(EORMException);

  /// exception dedicated to interface based service implementation
  EServiceException = class(EORMException);

  TSQLModel = class;
  TSQLRest = class;
  TSQLRestClient = class;

{$M+} { we need the RTTI information to be compiled for the published
        properties of these classes and their children (like TPersistent),
        to enable ORM - must be defined at the forward definition level }
  TSQLRecord = class;      // published properties = ORM fields/columns
  TSQLAuthUser = class;
  TSQLRestServer = class;  // published methods = RESTful callbacks handlers
  TSQLRestClientURI = class;
{$M-}

  /// class-reference type (metaclass) of TSQLRecord
  TSQLRecordClass = class of TSQLRecord;

  PSQLRecordClass = ^TSQLRecordClass;

  /// class-refrence type (metaclass) for a TSynFilter or a TSynValidate
  TSynFilterOrValidateClass = class of TSynFilterOrValidate;

  /// a dynamic array used to store the TSQLRecord classes in a Database Model
  TSQLRecords = array of TSQLRecordClass;

  /// the kind of SQlite3 (virtual) table
  // - TSQLRecordFTS3 will be associated with vFTS3, TSQLRecordFTS4 with vFTS4,
  // TSQLRecordRTree with vRTree, any native SQlite3 table as vSQLite3, and
  // a TSQLRecordVirtualTable*ID with rCustomForcedID/rCustomAutoID
  // - a plain TSQLRecord class can be defined as rCustomForcedID (e.g. for
  // TSQLRecordMany) after registration for an external DB via a call to
  // VirtualTableExternalRegister() from SQLite3DB unit
  TSQLRecordVirtualKind = (
    rSQLite3, rFTS3, rFTS4, rRTree, rCustomForcedID, rCustomAutoID);

  /// some information about a given TSQLRecord class properties
  // - used internaly by TSQLRecord, via a global cache handled by this unit:
  // you can access to each record's properties via TSQLRecord.RecordProps class
  // - such a global cache saves some memory for each TSQLRecord instance,
  // and allows faster access to most wanted RTTI properties
  TSQLRecordProperties = class
  protected
    /// for fastest Field name lookup via binary search
    fFieldsNameSorted: TRawUTF8DynArray;
    fFieldsNameIndex: TIntegerDynArray;
    fSQLFillPrepareMany: RawUTF8;
    fRecordManySourceProp: PPropInfo;
    fRecordManyDestProp: PPropInfo;
    fRecordManySourceClass: TSQLRecordClass;
    fRecordManyDestClass: TSQLRecordClass;
    fWeakZeroClass: TObject;
    fKind: TSQLRecordVirtualKind;
    procedure SetKind(Value: TSQLRecordVirtualKind);
    /// set the W.ColNames[] array content + W.AddColumns
    procedure SetJSONWriterColumnNames(W: TJSONSerializer; KnownRowsCount: integer);
  public
    /// the TSQLRecord class
    Table: TSQLRecordClass;
    {/ the Table name in the database, associated with this TSQLRecord class
     - 'TSQL' or 'TSQLRecord' chars are trimmed at the beginning of the ClassName
     - or the ClassName is returned as is, if no 'TSQL' or 'TSQLRecord' at first }
    SQLTableName: RawUTF8;
    {/ the Table name in the database in uppercase with a final '.'
     - e.g. 'TEST.' for TSQLRecordTest class
     - can be used with IdemPChar() for fast check of a table name }
    SQLTableNameUpperWithDot: RawUTF8;
    /// fast access to the RTTI properties attribute
    ClassProp: PClassProp;
    /// fast access to the SQL Field Type of all published properties
    FieldType: array of TSQLFieldType;
    /// if this class has any BLOB or TSQLRecodMany fields
    // - i.e. some fields to be ignored
    HasNotSimpleFields: boolean;
    /// set of field types appearing in this record
    HasTypeFields: TSQLFieldTypes;
    /// list all fields, as retrieved from RTTI
    Fields: array of PPropInfo;
    /// list all fields names, as retrieved from RTTI
    // - FieldsName[] := RawUTF8(Fields[]^.Name);
    FieldsName: TRawUTF8DynArray;
    /// list all "simple" fields of this TSQLRecord
    // - by default, the TSQLRawBlob and TSQLRecordMany fields are not included
    // into this set: they must be read specificaly (in order to spare
    // bandwidth for BLOBs)
    // - dynamic arrays belong to simple fields: they are sent with other
    // properties content
    SimpleFields: array of PPropInfo;
    /// list all TSQLRecordMany fields of this TSQLRecord
    ManyFields: array of PPropInfo;
    /// list of all sftBlobDynArray fields of this TSQLRecord
    DynArrayFields: array of PPropInfo;
    /// list all BLOB fields of this TSQLRecord
    // - i.e. generic sftBlob fields (not sftBlobDynArray or sftBlobRecord)
    BlobFields: array of PPropInfo;
    /// bit set to 1 for indicating fields to export, i.e. "simple" fields
    // - this array will handle special cases, like the TCreateTime fields
    // which shall not be included in soUpdate but soInsert and soSelect e.g.
    SimpleFieldsBits: array [TSQLOccasion] of TSQLFieldBits;
    /// bit set to 1 for an unique field
    // - an unique field is defined as "stored false" in its property definition
    IsUniqueFieldsBits: TSQLFieldBits;
    /// contains the main field index (e.g. mostly 'Name')
    // - the [boolean] is for [ReturnFirstIfNoUnique] version
    // - contains -1 if no field matches
    MainField: array[boolean] of integer;
    {/ the simple field names in a SQL SELECT compatible format: 'COL1,COL2' e.g.
     - format is
     ! SQLTableSimpleFields[withID: boolean; withTableName: boolean]
     - returns '*' if no field is of TSQLRawBlob/TSQLRecordMany kind
     - returns 'COL1,COL2' with all COL* set to simple field names if withID is false
     - returns 'ID,COL1,COL2' with all COL* set to simple field names if withID is true
     - returns 'Table.ID,Table.COL1,Table.COL2' if withTableName and withID are true }
    SQLTableSimpleFields: array[boolean,boolean] of RawUTF8;
    /// the SQL statement for reading all simple fields
    // - SQLSelectAll[false] with RowID (i.e. SQLFromSelectWhere('*','') content)
    // - SQLSelectAll[true] with ID and potentialy external table name
    // - to be checked if we may safely call EngineList()
    SQLSelectAll: array[boolean] of RawUTF8;
    /// the updated fields exposed as 'COL1=?,COL2=?'
    // - SQLUpdateSet[false]=simple fields, SQLUpdateSet[true]=all fields
    // excluding ID (but including TCreateTime fields - as used in
    // TSQLVirtualTableExternal.Update method)
    // - to be used e.g. for UPDATE statements
    SQLUpdateSet: array[boolean] of RawUTF8;
    /// all fields, excluding the ID field, exposed as 'COL1,COL2'
    // - to be used e.g. for INSERT statements
    SQLInsertSet: RawUTF8;
    /// all TSynFilter or TSynValidate instances registered per each field
    // - since validation and filtering are used within some CPU-consuming
    // part of the framework (like UI edition), both filters and validation
    // rules are grouped in the same TObjectList - for TSynTableFieldProperties
    // there are separated Filters[] and Validates[] array, for better performance
    Filters: array of TObjectList;
    /// the associated TSQLModel instance
    // - if this record is associated to multiple TSQLModels, the latest
    // registered will be stored here
    Model: TSQLModel;
    /// the index in the Model.Tables[] array
    // - e.g. allow O(1) search of a TSQLRecordClass in a model 
    ModelTableIndex: integer;
    /// used on the Server side to specify the external DB table name
    // - e.g. for including a schema name or an existing table name, with an
    // OleDB/MSSQL/Oracle/Jet/SQLite3 backend
    // - equals SQLTableName by default (may be overriden e.g. by SQLite3DB's
    // VirtualTableExternalRegister procedure)
    ExternalTableName: RawUTF8;
    /// opaque structure used on the Server side to specify e.g. the DB connection
    // - will define such a generic TObject, to avoid any unecessary dependency
    // to the SynDB unit in SQLite3Commons
    // - in practice, will be assigned by VirtualTableExternalRegister() to
    // a TSQLDBConnectionProperties instance
    ExternalDatabase: TObject;
    /// for a TSQLRecordMany class, points to the Source property RTTI
    property RecordManySourceProp: PPropInfo read fRecordManySourceProp;
    /// for a TSQLRecordMany class, points to the Dest property RTTI
    property RecordManyDestProp: PPropInfo read fRecordManyDestProp;
    /// for a TSQLRecordMany class, points to the Source property class
    property RecordManySourceClass: TSQLRecordClass read fRecordManySourceClass;
    /// for a TSQLRecordMany class, points to the Dest property class
    property RecordManyDestClass: TSQLRecordClass read fRecordManyDestClass;
    /// define if a normal table (rSQLite3), an FTS3/FTS4/R-Tree virtual table
    // or a custom TSQLVirtualTable*ID (rCustomForcedID/rCustomAutoID)
    // - when set, all internal SQL statements will be (re)created, depending of
    // the expected ID/RowID column name expected (i.e. SQLTableSimpleFields[]
    // and SQLSelectAll[] - SQLUpdateSet and SQLInsertSet do not include ID)
    property Kind: TSQLRecordVirtualKind read fKind write SetKind;

    /// initialize the properties content
    constructor Create(aTable: TSQLRecordClass);
    /// release associated used memory
    destructor Destroy; override;
    {/ return the Field Index number in published properties of this record
      - returns -1 if not found
      - warning: also returns -1 if PropName is 'ID', which is a correct field name
       but not a published property }
    function FieldIndex(const PropName: shortstring): integer;
    {/ return the Field Index number in published properties of this record
      - returns -1 if not found
      - warning: also returns -1 if PropName is 'ID', which is a correct field name
       but not a published property }
    function FieldIndexFromRawUTF8(const PropName: RawUTF8): integer;
    /// set all bits corresponding to the supplied field names
    // - returns TRUE on success, FALSE if any field name is not existing
    function FieldIndexsFromRawUTF8(const aFields: array of RawUTF8;
      var Bits: TSQLFieldBits): boolean;
    {/ retrieve a Field property RTTI information from a Property Name }
    function FieldProp(const PropName: shortstring): PPropInfo;
    {/ retrieve a Field property RTTI information from a Property Name }
    function FieldPropFromRawUTF8(const PropName: RawUTF8): PPropInfo;
    {/ retrieve a Field property RTTI information from a Property Name
      - this version returns nil if the property is not a BLOB field }
    function BlobFieldPropFromRawUTF8(const PropName: RawUTF8): PPropInfo;
    /// return TRUE if the given name is either ID/RowID, either a property name
    function IsFieldName(const PropName: RawUTF8): boolean;
    /// append a field name to a RawUTF8 Text buffer
    // - if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN (-1), appends 'RowID' or
    // 'ID' (if ForceNoRowID=TRUE) to Text
    // - on error (i.e. if FieldIndex is out of range) will return TRUE
    // - otherwise, will return FALSE and append the field name to Text
    function AppendFieldName(FieldIndex: Integer; var Text: RawUTF8; ForceNoRowID: boolean): boolean;

    /// compute the SQL statement to be executed for a specific SELECT
    function SQLFromSelectWhere(const SQLSelect, SQLWhere: RawUTF8): RawUTF8;
    {/ return the UTF-8 encoded SQL statement source to alter the table for
      adding the specified field }
    function SQLAddField(FieldIndex: integer): RawUTF8;
    /// create a TJSONWriter, ready to be filled with TSQLRecord.GetJSONValues(W)
    function CreateJSONWriter(JSON: TStream; Expand: boolean; withID: boolean;
      const aFields: TSQLFieldBits; KnownRowsCount: integer): TJSONSerializer;
    /// initialize the JSON writer parameters with simple fields
    // - recreate especially the ColNames[] and other necessary properties
    // - is used e.g. in TSQLRestClientURI.BatchUpdate and BatchAdd methods
    procedure SetSimpleFieldsExpandedJSONWriter(W: TJSONWriter; withID: boolean;
      Occasion: TSQLOccasion);
    /// register a custom filter or validation rule to the class for a specified
    // field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    // - will return nil in case of an invalid field index
    function AddFilterOrValidate(aFieldIndex: integer;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate; overload;
    /// register a custom filter or Validate to the class for a specified field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    function AddFilterOrValidate(const aFieldName: RawUTF8;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate; overload;
      {$ifdef HASINLINE}inline;{$endif}
  end;

  TAuthSession = class;

  /// the available THTTP methods transmitted between client and server 
  TSQLURIMethod = (mNone, mGET, mPOST, mPUT, mDELETE, mBEGIN, mEND,
    mABORT, mLOCK, mUNLOCK, mSTATE);

  /// used to store the current execution context of a remote request
  // - if RESTful authentication is enabled, it will be filled as expected
  TSQLRestServerSessionContext = record
    /// the corresponding session TAuthSession.IDCardinal value
    // - equals 0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED) if the session
    // is not started yet - i.e. if still in handshaking phase
    // - equals 1 (CONST_AUTHENTICATION_NOT_USED) if authentication mode
    // is not enabled - i.e. if TSQLRest.HandleAuthentication = FALSE
    Session: cardinal;
    /// the corresponding TAuthSession.User.ID value
    // - is undefined if Session is 0 or 1 (no authentication running)
    User: integer;
    /// the corresponding TAuthSession.User.GroupRights.ID value
    // - is undefined if Session is 0 or 1 (no authentication running)
    Group: integer;
    /// the associated TSQLRecord.ID, as decoded from URI scheme
    // - this property will be set from incoming URI, even if RESTful
    // authentication is not enabled
    ID: integer;
    /// the used Client-Server method (matching the corresponding HTTP Verb)
    // - this property will be set from incoming URI, even if RESTful
    // authentication is not enabled
    Method: TSQLURIMethod;
  end;

  /// store all parameters for a TSQLRestServerCallBack event handler
  // - having a dedicated record avoid changing the implementation methods
  // signature if the framework add some parameters to this structure
  // - see TSQLRestServerCallBack for general code use
  TSQLRestServerCallBackParams = record
    /// the corresponding authentication session ID
    // - Context.Session=1 (CONST_AUTHENTICATION_NOT_USED) if authentication
    // mode is not enabled
    // - Context.Session=0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED) if the
    // session not started yet
    // - if authentication is enabled, Context.User and Context.Group can be
    // checked to perform security during service execution
    // - Context.ID is the record ID as specified at the URI level (if any)
    Context: TSQLRestServerSessionContext;
    /// the Table as specified at the URI level (if any)
    Table: TSQLRecordClass;
    /// the index in the Model of the Table specified at the URI level (if any)
    TableIndex: integer;
    /// the index of the callback published method within the internal class list
    MethodIndex: integer;
    /// URI inlined parameters
    // - use UrlDecodeValue*() functions to retrieve the values
    Parameters: PUTF8Char;
    /// the URI address, just before parameters
    // - can be either the table name (in RESTful protocol), or a service name
    URI: RawUTF8;
    /// the message body (e.g. HTTP body) as send by the client
    SentData: RawUTF8;
    /// the response to be sent back to the client
    Resp: RawUTF8;
    /// a pointer to the Header to be sent back to the client
    // - you can use this value e.g. to change the result mime-type
    Head: PRawUTF8;
    /// a pointer to an optional error message to be sent back to the client
    // - to be used to specify the numerical error message returned as
    // integer result of the TSQLRestServerCallBack function
    ErrorMsg: PRawUTF8;
  end;
  
  (*/ method prototype which must be used to implement the Server-Side
     ModelRoot/[TableName/ID/]MethodName RESTful GET/PUT request of the Framework
   - this mechanism is able to handle some custom Client/Server request, similar
     to the DataSnap technology, but in a KISS way; it's fully integrated in the
     Client/Server architecture of our framework
   - just add a published method of this type to any TSQLRestServer descendant
   - when TSQLRestServer.URI receive a request for ModelRoot/MethodName
     or ModelRoot/TableName/ID/MethodName, it will check for a published method
     in its self instance named MethodName which MUST be of TSQLRestServerCallBack
     type (not checked neither at compile time neither at runtime: beware!) and
     call it to handle the request
   - important warning: the method implementation MUST be thread-safe
   - when TSQLRestServer.URI receive a request for ModelRoot/MethodName,
     it calls the corresponding published method with aRecord set to nil
   - when TSQLRestServer.URI receive a request for ModelRoot/TableName/ID/MethodName,
     it calls the corresponding published method with aRecord pointing to a
     just created instance of the corresponding class,  with its field ID set;
     note that the only set field is ID: other fields of aRecord are not set, but
     must secificaly be retrieved on purpose
   - for ModelRoot/TableName/ID/MethodName, the just created instance will be
     freed by TSQLRestServer.URI when the method returns
   - aParams.Parameters values are set from incoming URI, and each parameter can be
     retrieved with a loop like this:
     !  if not UrlDecodeNeedParameters(aParams.Parameters,'SORT,COUNT') then
     !    exit;
     !  while aParams.Parameters<>nil do begin
     !    UrlDecodeValue(aParams.Parameters,'SORT=',aSortString);
     !    UrlDecodeValueInteger(aParams.Parameters,'COUNT=',aCountInteger,@aParams.Parameters);
     !  end;
   - aParams.SentData is set with incoming data from the GET/PUT method
   - aParams.Context will identify to the authentication session of the remote client
     (CONST_AUTHENTICATION_NOT_USED=1 if authentication mode is not enabled or
     CONST_AUTHENTICATION_SESSION_NOT_STARTED=0 if the session not started yet) -
     code may use SessionGetUser() protected method to retrieve the user details
   - aParams.Context.Method will indicate the used HTTP verb (e.g. GET/POST/PUT..)
   - implementation must return the HTTP error code (e.g. 200/HTML_SUCCESS) as
     an integer value, and any response in aParams.Resp as a JSON object by
     default (using e.g. TSQLRestServer.JSONEncodeResult), since default mime-type
     is JSON_CONTENT_TYPE:
     $ {"result":"OneValue"}
     or a JSON object containing an array:
     $ {"result":["One","two"]}
   - implementation can return an optional HTTP header (useful to set the response
     mime-type - see e.g. the TEXT_CONTENT_TYPE_HEADER constant) in aParams.Head^
   - implementation can return an optional error text in aParams.ErrorMsg^ in
     order to specify the HTTP error code with plain text (which will be sent
     as JSON error object into the client)
   - a typical implementation may be:
     ! function TSQLRestServerTest.Sum(var aParams: TSQLRestServerCallBackParams): Integer;
     ! var a,b: Extended;
     ! begin
     !   if not UrlDecodeNeedParameters(aParams.Parameters,'A,B') then begin
     !     result := HTML_NOTFOUND; // invalid Request
     !     aParams.ErrorMsg^ := 'Missing Parameter';
     !     exit;
     !   end;
     !   while Params.Parameters<>nil do begin
     !     UrlDecodeExtended(aParams.Parameters,'A=',a);
     !     UrlDecodeExtended(aParams.Parameters,'B=',b,@aParams.Parameters);
     !   end;
     !   aParams.Resp := JSONEncodeResult([a+b]);
     !   // same as : aParams.Resp := JSONEncode(['result',a+b]);
     !   result := HTML_SUCCESS; 
     ! end;
   - Client-Side can be implemented as you wish. By convention, it could be
     appropriate to define in either TSQLRestServer (if to be called as
     ModelRoot/MethodName), either TSQLRecord (if to be called as
     ModelRoot/TableName/MethodName[/ID]) a custom public or protected method,
     calling TSQLRestClientURI.URL with the appropriate parameters, and named
     (by convention) as MethodName; TSQLRestClientURI has dedicated methods
     like CallBackGetResult, CallBackGet, and CallBackPut; see also
     TSQLModel.getURICallBack and JSONDecode function
     ! function TSQLRecordPeople.Sum(aClient: TSQLRestClientURI; a, b: double): double;
     ! var err: integer;
     ! begin
     !   val(aClient.CallBackGetResult('sum',['a',a,'b',b]),result,err);
     ! end; *)
  TSQLRestServerCallBack = function(var aParams: TSQLRestServerCallBackParams): Integer of object;

  /// the possible options for handling table names
  TSQLCheckTableName = (ctnNoCheck,ctnMustExist,ctnTrimExisting);

  TSQLRecordMany = class;

  /// internal data used by TSQLRecord.FillPrepare()/FillPrepareMany() methods
  // - using a dedicated class will reduce memory usage for each TSQLRecord
  // instance (which won't need these properties most of the time)
  TSQLRecordFill = class
  protected
    /// associated table
    fTable: TSQLTable;
    /// current retrieved row
    fFillCurrentRow: integer;
    {/ number of used items in TableMap[] array
      - calculated in FillPrepare() or FillPrepareMany() methods }
    fTableMapCount: integer;
    /// set by TSQLRecord.FillPrepareMany() to release M.fDestID^ instances
    fTableMapRecordManyInstances: array of TSQLRecordMany;
    {/ map the published fields index
      - calculated in FillPrepare() or FillPrepareMany() methods
      - static array of MAX_SQLFIELDS items }
    fTableMap: array[0..MAX_SQLFIELDS-1] of record
      /// the class instance to be filled from the TSQLTable
      // - can be a TSQLRecordMany instance after FillPrepareMany() method call
      Dest: TSQLRecord;
      /// the published property RTTI to be filled from the TSQLTable
      // - is nil for the RowID/ID field
      DestField: PPropInfo;
      /// the column index in TSQLTable
      TableIndex: integer;
    end;
    /// mark all mapped or TModTime fields
    fTableMapFields: TSQLFieldBits;
    /// index in RecordProps.Fields[] of latest mapped field
    fTableMapFieldsMax: integer;
    /// list all mapped or TModTime fields as in TJSONWriter.AddColumns
    fTableMapFieldsColNames: TRawUTF8DynArray;
    /// add a property to the fTableMap[] array
    // - aIndex is the column index in TSQLTable
    // - will log an explicit error message if fTableMap[] is full, but won't
    // raise any exception
    procedure AddMap(aRecord: TSQLRecord; aField: PPropInfo; aIndex: integer); overload;
    /// add a property to the fTableMap[] array
    // - aIndex is the column index in TSQLTable
    // - will log an explicit error message if fTableMap[] is full, but won't
    // raise any exception
    procedure AddMap(aRecord: TSQLRecord; const aFieldName: ShortString; aIndex: integer); overload;
    /// initialize the JSON writer parameters with mapped fields, including ID
    // and any TModTime field
    // - recreate especially the ColNames[] and other necessary properties
    // - current implementation only handle FillPrepare() mapping (i.e. JOINed
    // FillPrepareMany mapping will raise an exception - method will check for
    // fTableMapRecordManyInstances to be [])
    // - is used e.g. in TSQLRestClientURI.BatchUpdate method
    procedure SetMappedFieldsExpandedJSONWriter(aClass: TSQLRecordClass; W: TJSONWriter);
  public
    /// finalize the mapping
    destructor Destroy; override;
    /// map all columns of a TSQLTable to a record mapping
    procedure Map(aRecord: TSQLRecord; aTable: TSQLTable; aCheckTableName: TSQLCheckTableName);
    /// reset the mapping
    // - is called e.g. by TSQLRecord.FillClose
    // - will free any previous Table if necessary
    // - will release TSQLRecordMany.Dest instances as set by TSQLRecord.FillPrepareMany()
    procedure UnMap;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - use the mapping prepared with Map() method
    function Fill(aRow: integer): Boolean; overload; {$ifdef HASINLINE}inline;{$endif}
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - use the mapping prepared with Map() method
    // - aTableRow will point to the first column of the matching row
    procedure Fill(aTableRow: PPUtf8CharArray); overload;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - overloaded method using a specified destination record to be filled
    // - won't work with cross-reference mapping (FillPrepareMany)
    // - use the mapping prepared with Map() method
    // - aTableRow will point to the first column of the matching row
    procedure Fill(aTableRow: PPUtf8CharArray; aDest: TSQLRecord); overload;
    /// fill a TSQLRecord published properties from a TSQLTable row
    // - overloaded method using a specified destination record to be filled
    // - won't work with cross-reference mapping (FillPrepareMany)
    // - use the mapping prepared with Map() method
    function Fill(aRow: integer; aDest: TSQLRecord): Boolean; overload; {$ifdef HASINLINE}inline;{$endif}

    {/ the TSQLTable stated as FillPrepare() parameter
      - the internal temporary table is stored here for TSQLRecordMany
      - this instance is freed by TSQLRecord.Destroy if fTable.OwnerMustFree=true }
    property Table: TSQLTable read fTable;
    /// the current Row during a Loop
    property FillCurrentRow: integer read fFillCurrentRow;
  end;

  {/ root class for defining and mapping database records
   - inherits a class from TSQLRecord, and add published properties to describe
    the table columns (see TPropInfo for SQL and Delphi type mapping/conversion)
   - this published properties can be auto-filled from TSQLTable answer with
    FillPrepare() and FillRow(), or FillFrom() with TSQLTable or JSON data
   - this published properties can be converted back into UTF-8 encoded SQL
    source with GetSQLValues or GetSQLSet or into JSON format with GetJSONValues
   - BLOB fields are decoded to auto-freeing TSQLRawBlob }
  TSQLRecord = class(TObject)
  { note that every TSQLRecord has an Instance size of 20 bytes for private and
    protected fields (such as fID or fProps e.g.) }
  protected
    /// used by FillPrepare() and corresponding Fill*() methods
    fFill: TSQLRecordFill;
    /// internal properties getters (using fProps data for speed)
    function GetHasBlob: boolean;
    function GetSimpleFieldCount: integer; 
    function GetFillCurrentRow: integer;
    function GetTable: TSQLTable;
  protected
    fInternalState: cardinal;
    fID: integer;
  {$ifdef HASINLINE}public{$endif}
    /// trick to get the ID even in case of a sftID published property
    function GetID: integer; {$ifdef HASINLINE}inline;{$endif}
  public
    /// direct access to the TSQLRecord properties from RTTI
    // - TSQLRecordProperties is faster than e.g. the class function FieldProp()
    // - use internal the unused vmtAutoTable VMT entry to fast retrieve of a
    // class variable which is unique for each class ("class var" is unique only
    // for the class within it is defined, and we need a var for each class:
    // so even Delphi XE syntax is not powerful enough for our purpose, and the
    // vmtAutoTable trick if very fast, and works with all versions of Delphi -
    // including 64 bit target)
    class function RecordProps: TSQLRecordProperties;
      {$ifdef PUREPASCAL}{$ifdef HASINLINE}inline;{$endif}{$endif}
    {/ the Table name in the database, associated with this TSQLRecord class
     - 'TSQL' or 'TSQLRecord' chars are trimmed at the beginning of the ClassName
     - or the ClassName is returned as is, if no 'TSQL' or 'TSQLRecord' at first
     - is just a wrapper around RecordProps.SQLTableName }
    class function SQLTableName: RawUTF8; {$ifdef HASINLINE}inline;{$endif}
    /// register a custom filter or Validate to the class for a specified field
    // - this will be used by TSQLRecord.Filter and TSQLRecord.Validate
    // methods (in default implementation)
    // - will return the specified associated TSynFilterOrValidate instance
    // - this function is just a wrapper around RecordProps.AddFilterOrValidate
    class function AddFilterOrValidate(const aFieldName: RawUTF8;
      aFilter: TSynFilterOrValidate): TSynFilterOrValidate; {$ifdef HASINLINE}inline;{$endif}

    {/ get the captions to be used for this table
     - if Action is nil, return the caption of the table name
     - if Action is not nil, return the caption of this Action (lowercase left-trimed)
     - return "string" type, i.e. UnicodeString for Delphi 2009+
     - internally call UnCamelCase() then System.LoadResStringTranslate() if available
     - ForHint is set to TRUE when the record caption name is to be displayed inside
       the popup hint of a button (i.e. the name must be fully qualified, not
       the default short version)
     - is not part of TSQLRecordProperties because has been declared as virtual }
    class function CaptionName(Action: PShortString=nil; ForHint: boolean=false): string; virtual;
    {/ virtual method called when the associated table is created in the database
      - if FieldName is '', initialization regarding all fields must be made;
        if FieldName is specified, initialization regarding this field must be processed
      - override this method in order to initialize indexs or create default records
      - by default, create indexes for all TRecordReference properties, and
        for all TSQLRecord inherited properties (i.e. of sftID type, that is
        an INTEGER field containing the ID of the pointing record)
     - is not part of TSQLRecordProperties because has been declared as virtual }
    class procedure InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8); virtual;

    {/ filter the specified fields values of the current TSQLRecord instance
    - by default, this will perform all TSynFilter as registered by
      [RecordProps.]AddFilterOrValidate()
    - inherited classes may add some custom filtering here, if it's not needed
      nor mandatory to create a new TSynFilter class type: in this case, the
      function has to return TRUE if the filtering took place, and FALSE if
      any default registered TSynFilter must be processed
    - the default aFields parameter will process all fields }
    function Filter(const aFields: TSQLFieldBits=[0..MAX_SQLFIELDS-1]): boolean; overload; virtual;
    {/  filter the specified fields values of the current TSQLRecord instance
    - this version will call the overloaded Filter() method above
    - return TRUE if all field names were correct and processed, FALSE otherwise }
    function Filter(const aFields: array of RawUTF8): boolean; overload;
    {/ validate the specified fields values of the current TSQLRecord instance
    - by default, this will perform all TSynValidate as registered by
      [RecordProps.]AddFilterOrValidate()
    - it will also check if any UNIQUE field value won't be duplicated
    - inherited classes may add some custom validation here, if it's not needed
      nor mandatory to create a new TSynValidate class type: in this case, the
      function has to return an explicit error message (as a generic VCL string)
      if the custom validation failed, or '' if the validation was successful:
      in this later case, all default registered TSynValidate are processed
    - the default aFields parameter will process all fields
    - if aInvalidFieldIndex is set, it will contain the first invalid field
      index found
     - caller SHOULD always call the Filter() method before calling Validate() }
    function Validate(aRest: TSQLRest; const aFields: TSQLFieldBits=[0..MAX_SQLFIELDS-1];
      aInvalidFieldIndex: PInteger=nil): string; overload; virtual;
    {/  validate the specified fields values of the current TSQLRecord instance
    - this version will call the overloaded Validate() method above
    - returns '' if all field names were correct and processed, or an
      explicit error message (translated in the current language) on error
    - if aInvalidFieldIndex is set, it will contain the first invalid field
      index }
    function Validate(aRest: TSQLRest; const aFields: array of RawUTF8;
      aInvalidFieldIndex: PInteger=nil): string; overload;
    /// should modify the record content before writing to the Server
    // - this default implementation will update any sftModTime / TModTime and
    // sftCreateTime / TCreateTime properties content with the exact server time stamp
    // - you may override this method e.g. for custom calculated fields
    // - note that this is computed only on the Client side, before sending
    // back the content to the remote Server: therefore, TModTime / TCreateTime
    // fields are a pure client ORM feature - it won't work directly at REST level
    procedure ComputeFieldsBeforeWrite(aRest: TSQLRest; aOccasion: TSQLEvent); virtual;

    /// this constructor initializes the record
    // - auto-instanciate any TSQLRecordMany instance defined in published properties
    // - override this method if you want to use some internal objects (e.g. 
    // TStringList or TCollection as published property) 
    constructor Create; overload; virtual;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection
     - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
      the corresponding record, then retrieve its content; caller has to call
      UnLock() method after Value usage, to release the record }
    constructor Create(aClient: TSQLRest; aID: integer;
      ForUpdate: boolean=false); overload;
    {/ this constructor initializes the object and fills its content from a client
      or server connection, from a TSQLRecord published property content
     - is just a wrapper around Create(aClient,PtrInt(aPublishedRecord))
       or Create(aClient,aPublishedRecord.ID)
     - a published TSQLRecord property is not a class instance, but a typecast to
       TObject(RecordID) - you can also use its ID property
     - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
      the corresponding record, then retrieve its content; caller has to call
      UnLock() method after Value usage, to release the record }
    constructor Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord;
      ForUpdate: boolean=false); overload;
    /// this constructor initializes the object as above, and fills its content
    //  from a client or server connection, using a specified WHERE clause
    //  - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
    //  for better server speed - note that you can use FormatUTF8() as such:
    //  ! aRec := TSQLMyRec.Create(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    //  or call the overloaded contructor with BoundsSQLWhere array of parameters 
    constructor Create(aClient: TSQLRest; const aSQLWhere: RawUTF8); overload;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection, using a specified WHERE clause
      with parameters
    - for better server speed, the WHERE clause should use bound parameters
      identified as '?' in the FormatSQLWhere statement, which is expected to
      follow the order of values supplied in BoundsSQLWhere open array - use
      DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
      currency / RawUTF8 values to be bound to the request as parameters
    - note that this method prototype changed with revision 1.17 of the
      framework: array of const used to be ParamsSQLWhere and '%' in the
      FormatSQLWhere statement, whereas it now expects bound parameters as '?' }
    constructor Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const); overload;
    {/ this constructor initializes the object as above, and fills its content
      from a client or server connection, using a specified WHERE clause
      with parameters
      - the FormatSQLWhere clause will replace all '%' chars with the supplied
      ParamsSQLWhere[] values, and all '?' chars with BoundsSQLWhere[] values,
      as :(...): inlined parameters - you should either call:
      ! Rec := TSQLMyRecord.Create(aClient,'Count=:(%):'[aCount],[]);
      or (letting the inlined parameters being computed by FormatUTF8)
      !  Rec := TSQLMyRecord.Create(aClient,'Count=?',[],[aCount]);
      or even better, using the other Create overloaded constructor:
      !  Rec := TSQLMyRecord.Create(aClient,'Count=?',[aCount]);
      - using '?' and BoundsSQLWhere[] is perhaps more readable in your code, and
      will in all case create a request with :(..): inline parameters, with
      automatic RawUTF8 quoting if necessary }
    constructor Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
        for better server speed - note that you can use FormatUTF8() as such:
        ! aRec := TSQLMyRec.CreateAndFillPrepare(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
        or call the overloaded CreateAndFillPrepare() contructor directly with
        BoundsSQLWhere array of parameters
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
        (default is to retrieve all table fields, but you may need to access only
        one or several fields, and will save remote bandwidth by specifying the
        needed fields): notice that you should not use this optional parameter
        if you want to Update the retrieved record content later, since the
        missing fields will be left with previous values - but BatchUpdate() will
        set only ID, TModTime and mapped fields }
    constructor CreateAndFillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - for better server speed, the WHERE clause should use bound parameters
        identified as '?' in the FormatSQLWhere statement, which is expected to
        follow the order of values supplied in BoundsSQLWhere open array - use
        DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
        currency / RawUTF8 values to be bound to the request as parameters
      - note that this method prototype changed with revision 1.17 of the
        framework: array of const used to be ParamsSQLWhere and '%' in the
        FormatSQLWhere statement, whereas it now expects bound parameters as '?'
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
        (default is to retrieve all table fields, but you may need to access only
        one or several fields, and will save remote bandwidth by specifying the
        needed fields): notice that you should not use this optional parameter
        if you want to Update the retrieved record content later, since the
        missing fields will be left with previous values - but BatchUpdate() will
        set only ID, TModTime and mapped fields}
    constructor CreateAndFillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a statement using a specified WHERE clause
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the WHERE clause, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - the FormatSQLWhere clause will replace all '%' chars with the supplied
        ParamsSQLWhere[] supplied values, and bind all '?' chars as parameters
        with BoundsSQLWhere[] values
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
        (default is to retrieve all table fields, but you may need to access only
        one or several fields, and will save remote bandwidth by specifying the
        needed fields): notice that you should not use this optional parameter
        if you want to Update the retrieved record content later, since the
        missing fields will be left with previous values - but BatchUpdate() will
        set only ID, TModTime and mapped fields }
    constructor CreateAndFillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object as above, and prepares itself to
      loop through a given list of IDs
      - this method creates a TSQLTableJSON, retrieves all records corresponding
        to the specified IDs, then call FillPrepare - previous Create(aClient)
        methods retrieve only one record, this one more multiple rows
      - you should then loop for all rows using 'while Rec.FillOne do ...'
      - the TSQLTableJSON will be freed by TSQLRecord.Destroy
      - aCustomFieldsCSV can be used to specify which fields must be retrieved
        (default is to retrieve all table fields, but you may need to access only
        one or several fields, and will save remote bandwidth by specifying the
        needed fields): notice that you should not use this optional parameter
        if you want to Update the retrieved record content later, since the
        missing fields will be left with previous values - but BatchUpdate() will
        set only ID, TModTime and mapped fields }
    constructor CreateAndFillPrepare(aClient: TSQLRest; const aIDs: TIntegerDynArray;
      const aCustomFieldsCSV: RawUTF8=''); overload;
    {/ this constructor initializes the object including all TSQLRecordMany properties,
      and prepares itself to loop through a JOINed statement
      - the created instance will have all its TSQLRecordMany Dest property allocated
        with proper instance (and not only pointer(DestID) e.g.), ready to be
        consumed during a while FillOne do... loop (those instances will be
        freed by TSQLRecord.FillClose or Destroy) - and the Source property
        won't contain pointer(SourceID) but the main TSQLRecord instance
      - the aFormatSQLJoin clause will define a WHERE clause for an automated
        JOINed statement, including TSQLRecordMany published properties (and
        their nested properties)
      - a typical use could be the following:
        ! aProd := TSQLProduct.CreateAndFillPrepareMany(Database,
        !   'Owner=? and Categories.Dest.Name=? and (Sizes.Dest.Name=? or Sizes.Dest.Name=?)',[],
        !   ['mark','for boy','small','medium']);
        ! if aProd<>nil then
        ! try
        !   while aProd.FillOne do
        !     // here e.g. aProd.Categories.Dest are instantied (and Categories.Source=aProd)
        !     writeln(aProd.Name,' ',aProd.Owner,' ',aProd.Categories.Dest.Name,' ',aProd.Sizes.Dest.Name);
        !   // you may also use aProd.FillTable to fill a grid, e.g.
        !   // (do not forget to set aProd.FillTable.OwnerMustFree := false)
        ! finally
        !   aProd.Free; // will also free aProd.Categories/Sizes instances
        ! end;
        this will execute a JOINed SELECT statement similar to the following:
        $ select p.*, c.*, s.*
        $ from Product p, Category c, Categories cc, Size s, Sizes ss
        $ where c.id=cc.dest and cc.source=p.id and
        $  s.id=ss.dest and ss.source=p.id and
        $  p.Owner='mark' and c.Name='for boy' and (s.Name='small' or s.Name='medium')
      - you SHALL call explicitely the FillClose method before using any
        methods of nested TSQLRecordMany instances which may override the Dest
        instance content (e.g. ManySelect) to avoid any GPF
      - the aFormatSQLJoin clause will replace all '%' chars with the supplied
        aParamsSQLJoin[] supplied values, and bind all '?' chars as bound
        parameters with aBoundsSQLJoin[] values }
    constructor CreateAndFillPrepareMany(aClient: TSQLRest; aFormatSQLJoin: PUTF8Char;
      const aParamsSQLJoin, aBoundsSQLJoin: array of const);
    {/ this method create a clone of the current record, with same ID and properties
      - copy all COPIABLE_FIELDS, i.e. all fields excluding tftMany (because
        those fields don't contain any data, but a TSQLRecordMany instance
        which allow to access to the pivot table data) }
    function CreateCopy: TSQLRecord;
    /// release the associated memory
    // - in particular, release all TSQLRecordMany instance created by the
    // constructor of this TSQLRecord
    destructor Destroy; override;

    {/ return the UTF-8 encoded SQL source to create the table containing the
      published fields of a TSQLRecord child
     - a 'ID INTEGER PRIMARY KEY' field is always created first (mapping
       SQLite3 RowID)
     - AnsiString are created as TEXT COLLATE NOCASE (fast SQLite3 7bits compare)
     - RawUnicode and RawUTF8 are created as TEXT COLLATE SYSTEMNOCASE
       (i.e. use our fast UTF8IComp() for comparaison)
     - TDateTime are created as TEXT COLLATE ISO8601
      (which calls our very fast ISO TEXT to Int64 conversion routine)
     - an individual bit set in UniqueField forces the corresponding field to
      be marked as UNIQUE (an unique index is automaticaly created on the specified
      column); use TSQLModel fIsUnique[] array, which set the bits values
      to 1 if a property field was published with "stored false"
     - this method will handle TSQLRecordFTS* classes like FTS* virtual tables,
       TSQLRecordRTree as RTREE virtual table, and TSQLRecordVirtualTable*ID
       classes as corresponding Delphi designed virtual tables
     - is not part of TSQLRecordProperties because has been declared as virtual
       so that you could specify a custom SQL statement, per TSQLRecord type
     - anyway, don't call this method directly, but use TSQLModel.GetSQLCreate()
     - the aModel parameter is used to retrieve the Virtual Table module name,
       and can be ignored for regular (not virtual) tables }
    class function GetSQLCreate(aModel: TSQLModel): RawUTF8; virtual;
    {/ return the Class Type of the current TSQLRecord }
    function RecordClass: TSQLRecordClass;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ return the RTTI property information for this record }
    function ClassProp: PClassProp;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
    {/ return the TRecordReference pointing to this record }
    function RecordReference(Model: TSQLModel): TRecordReference;

    {/ return the UTF-8 encoded SQL source to INSERT the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields name (i.e. not TSQLRawBlob/TSQLRecordMany) are updated:
        BLOB fields are ignored (use direct update via dedicated methods instead)
      - format is '(COL1, COL2) VALUES ('VAL1', 'VAL2')' if some column was ignored (BLOB e.g.)
      - format is 'VALUES ('VAL1', 'VAL2')' if all columns values are available
      - is not used by the ORM (do not use prepared statements) - only here
        for conveniency }
    function GetSQLValues: RawUTF8;
    {/ return the UTF-8 encoded SQL source to UPDATE the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields name (i.e. not TSQLRawBlob/TSQLRecordMany) are retrieved:
        BLOB fields are ignored (use direct access via dedicated methods instead)
      - format is 'COL1='VAL1', COL2='VAL2''
      - is not used by the ORM (do not use prepared statements) - only here
        for conveniency }
    function GetSQLSet: RawUTF8;
    (** return the UTF-8 encoded JSON objects for the values contained
      in the current published fields of a TSQLRecord child
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are retrieved:
        BLOB fields are ignored (use direct access via dedicated methods instead)
      - if Expand is true, JSON data is an object, for direct use with any Ajax or .NET client:
      ! {"col1":val11,"col2":"val12"}
      - if Expand is false, JSON data is serialized (as used in TSQLTableJSON)
      ! { "fieldCount":1,"values":["col1","col2",val11,"val12",val21,..] }
      - if withID is true, then the first ID field value is included *)
    procedure GetJSONValues(JSON: TStream; Expand: boolean; withID: boolean;
      Occasion: TSQLOccasion); overload;
    /// same as above, but returning result into a RawUTF8
    // - if UsingStream is not set, it will use a temporary THeapMemoryStream instance
    function GetJSONValues(Expand: boolean; withID: boolean; Occasion: TSQLOccasion;
      UsingStream: TCustomMemoryStream=nil): RawUTF8; overload;
    /// same as above, but in a TJSONWriter (called by the first two overloaded
    // functions)
    procedure GetJSONValues(W: TJSONSerializer); overload;
    /// write the field values into the binary buffer
    // - won't write the ID field (should be stored before, with the Count e.g.)
    procedure GetBinaryValues(W: TFileBufferWriter);
    /// set the field values from a binary buffer
    // - won't read the ID field (should be read before, with the Count e.g.)
    // - returns true on success, or false in case of invalid content in P e.g.
    // - P is updated to the next pending content after the read values
    function SetBinaryValues(var P: PAnsiChar): Boolean;
    /// retrieve a field value into a custom TVarData sub type (not a true variant)
    // - the field values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - the temp RawByteString is used as a temporary storage for TEXT or BLOB
    // and should be available during all access to the TVarData content
    procedure GetFieldVarData(aFieldIndex: integer; var aValue: TVarData;
      var temp: RawByteString);
    /// set a field value from a custom TVarData sub type (not a true variant)
    // - the field values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    function SetFieldVarData(aFieldIndex: integer; const aValue: TVarData): boolean;
    /// set all field values from a supplied array of TVarData sub type
    // - the field values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - Values[] array must match the RecordProps.Field[] order: will return
    // false if the Values[].VType does not match RecordProps.FieldType[]
    function SetFieldVarDatas(const Values: TVarDataDynArray): boolean;
    {/ retrieve a field value from a given property name, as encoded UTF-8 text
      - you should use strong typing and direct property access, following
        the ORM approach of the framework; but in some cases (a custom Grid
        display, for instance), it could be usefull to have this method available
      - will return '' in case of wrong property name
      - BLOB and dynamic array fields are returned as '\uFFF0base64encodedbinary'  }
    function GetFieldValue(const PropName: RawUTF8): RawUTF8;
    {/ set a field value of a given property name, from some encoded UTF-8 text
      - you should use strong typing and direct property access, following
        the ORM approach of the framework; but in some cases (a custom Grid
        display, for instance), it could be usefull to have this method available
       - won't do anything in case of wrong property name 
       - expect BLOB and dynamic array fields encoded as SQlite3 BLOB literals
        ("x'01234'" e.g.) or '\uFFF0base64encodedbinary' }
    procedure SetFieldValue(const PropName: RawUTF8; Value: PUTF8Char);
    {$ifdef USEVARIANTS}
    /// retrieve the published property value into a Variant
    // - will set the Variant type to the best matching kind according to the
    // property type
    // - will return a null variant in case of wrong property name
    // - BLOB fields are returned as SQlite3 BLOB literals ("x'01234'" e.g.)
    // - dynamic array fields are returned as a Variant array
    function GetFieldVariant(const PropName: string): Variant;
    /// set the published property value from a Variant value
    // - will convert from the variant type into UTF-8 text before setting the
    // value (so will work with any kind of Variant)
    // - won't do anything in case of wrong property name
    // - expect BLOB fields encoded as SQlite3 BLOB literals ("x'01234'" e.g.)
    procedure SetFieldVariant(const PropName: string; const Source: Variant);
    {$endif}

    {/ prepare to get values from a TSQLTable result
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - the specified TSQLTable is stored in an internal fTable protected field
     - set aCheckTableName if you want e.g. the Field Names from the Table
       any pending 'TableName.' trimmed before matching to the current record }
    procedure FillPrepare(Table: TSQLTable; aCheckTableName: TSQLCheckTableName=ctnNoCheck); overload;
    {/ prepare to get values from a SQL where statement
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - if aSQLWhere is left to '', all rows are retrieved as fast as possible
       (e.g. by-passing SQLite3 virtual table modules for external databases)
     - the WHERE clause should use inlined parameters (like 'Name=:('Arnaud'):')
       for better server speed - note that you can use FormatUTF8() as such:
       ! aRec.FillPrepare(Client,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
       or call the overloaded FillPrepare() method directly with  BoundsSQLWhere
       array of parameters
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
       (default is to retrieve all table fields, but you may need to access only
       one or several fields, and will save remote bandwidth by specifying the
       needed fields): notice that you should not use this optional parameter
       if you want to Update the retrieved record content later, since the
       missing fields will be left with previous values - but BatchUpdate() can be
       safely used after FillPrepare (will set only ID, TModTime and mapped fields) }
    function FillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8='';
      const aCustomFieldsCSV: RawUTF8=''; aCheckTableName: TSQLCheckTableName=ctnNoCheck): boolean; overload;
    {/ prepare to get values using a specified WHERE clause with '%' parameters
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - for better server speed, the WHERE clause should use bound parameters
       identified as '?' in the FormatSQLWhere statement, which is expected to
       follow the order of values supplied in BoundsSQLWhere open array - use
       DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
       currency / RawUTF8 values to be bound to the request as parameters
     - note that this method prototype changed with revision 1.17 of the
       framework: array of const used to be ParamsSQLWhere and '%' in the
       FormatSQLWhere statement, whereas it now expects bound parameters as '?'
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
       (default is to retrieve all table fields, but you may need to access only
       one or several fields, and will save remote bandwidth by specifying the
       needed fields): notice that you should not use this optional parameter
       if you want to Update the retrieved record content later, since the
       missing fields will be left with previous values - but BatchUpdate() will
       set only ID, TModTime and mapped fields }
    function FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to get values using a specified WHERE clause with '%' and '?' parameters
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable
       protected field
     - the FormatSQLWhere clause will replace all '%' chars with the supplied
       ParamsSQLWhere[] supplied values, and bind all '?' chars as bound
       parameters with BoundsSQLWhere[] values
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
       (default is to retrieve all table fields, but you may need to access only
       one or several fields, and will save remote bandwidth by specifying the
       needed fields): notice that you should not use this optional parameter
       if you want to Update the retrieved record content later, since the
       missing fields will be left with previous values - but BatchUpdate() will
       set only ID, TModTime and mapped fields }
    function FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
      const ParamsSQLWhere, BoundsSQLWhere: array of const;
      const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to get values from a list of IDs
     - returns true in case of success, false in case of an error during SQL request
     - then call FillRow() to get Table.RowCount row values
     - you can also loop through all rows with
     ! while Rec.FillOne do
     !   dosomethingwith(Rec);
     - a temporary TSQLTable is created then stored in an internal fTable protected field
     - aCustomFieldsCSV can be used to specify which fields must be retrieved
       (default is to retrieve all table fields, but you may need to access only
       one or several fields, and will save remote bandwidth by specifying the
       needed fields): notice that you should not use this optional parameter
       if you want to Update the retrieved record content later, since the
       missing fields will be left with previous values - but BatchUpdate() will
       set only ID, TModTime and mapped fields }
    function FillPrepare(aClient: TSQLRest; const aIDs: TIntegerDynArray;
      const aCustomFieldsCSV: RawUTF8=''): boolean; overload;
    {/ prepare to loop through a JOINed statement including TSQLRecordMany fields
     - all TSQLRecordMany.Dest published fields will now contain a true TSQLRecord
       instance, ready to be filled with the JOINed statement results (these
       instances will be released at FillClose) - the same for Source which will
       point to the self instance
     - the aFormatSQLJoin clause will define a WHERE clause for an automated
       JOINed statement, including TSQLRecordMany published properties (and
       their nested properties)
     - returns true in case of success, false in case of an error during SQL request
     - a typical use could be the following:
       ! if aProd.FillPrepareMany(Database,
       !    'Owner=? and Categories.Dest.Name=? and (Sizes.Dest.Name=? or Sizes.Dest.Name=?)',[],
       !    ['mark','for boy','small','medium']) then
       !   while aProd.FillOne do
       !     // here e.g. aProd.Categories.Dest are instantied (and Categories.Source=aProd)
       !     writeln(aProd.Name,' ',aProd.Owner,' ',aProd.Categories.Dest.Name,' ',aProd.Sizes.Dest.Name);
       !   // you may also use aProd.FillTable to fill a grid, e.g.
       !   // (do not forget to set aProd.FillTable.OwnerMustFree := false)
       this will execute a JOINed SELECT statement similar to the following:
       $ select p.*, c.*, s.*
       $ from Product p, Category c, Categories cc, Size s, Sizes ss
       $ where c.id=cc.dest and cc.source=p.id and
       $  s.id=ss.dest and ss.source=p.id and
       $  p.Owner='mark' and c.Name='for boy' and (s.Name='small' or s.Name='medium')
     - the FormatSQLWhere clause will replace all '%' chars with the supplied
       ParamsSQLWhere[] supplied values, and bind all '?' chars as parameters
       with BoundsSQLWhere[] values
     - you SHALL call explicitely the FillClose method before using any
       methods of nested TSQLRecordMany instances which may override the Dest
       instance content (e.g. ManySelect) to avoid any GPF
     - is used by TSQLRecord.CreateAndFillPrepareMany constructor }
    function FillPrepareMany(aClient: TSQLRest; aFormatSQLJoin: PUTF8Char;
      const aParamsSQLJoin, aBoundsSQLJoin: array of const): boolean;
    {/ fill all published properties of an object from a TSQLTable prepared row
      - FillPrepare() must have been called before
      - if Dest is nil, this object values are filled
      - if Dest is not nil, this object values will be filled, but it won't
        work with TSQLRecordMany properties (i.e. after FillPrepareMany call)
      - ID field is updated if first Field Name is 'ID'
      - Row number is from 1 to Table.RowCount
      - setter method (write Set*) is called if available
      - handle UTF-8 SQL to Delphi values conversion (see TPropInfo mapping)
      - this method has been made virtual e.g. so that a calculated value can be
        used in a custom field }
    procedure FillRow(aRow: integer; aDest: TSQLRecord=nil); virtual;
    {/ fill all published properties of this object from the next available
      TSQLTable prepared row
      - FillPrepare() must have been called before
      - the Row number is taken from property FillCurrentRow
      - return true on success, false if no more Row data is available
      - call FillRow() to update published properties values }
    function FillOne: boolean;
    {/ go to the first prepared row, ready to loop through all rows with FillRow()
      - the Row number (property FillCurrentRow) is reset to 1
      - return true on success, false if no Row data is available }
    function FillRewind: boolean;
    {/ close any previous FillPrepare..FillOne loop
     - is called implicitely by FillPrepare() call to release any previous loop
     - release the internal hidden TSQLTable instance if necessary
     - is not mandatory if the TSQLRecord is released just after, since
       TSQLRecord.Destroy will call it
     - used e.g. by FillFrom methods below to avoid any GPF/memory confusion }
    procedure FillClose;

    {/ fill all published properties of this object from a TSQLTable result row
      - call FillPrepare() then FillRow() }
    procedure FillFrom(Table: TSQLTable; Row: integer); overload;
    {/ fill all published properties of this object from a JSON result row
     - create a TSQLTable from the JSON data
     - call FillPrepare() then FillRow() }
    procedure FillFrom(const JSONTable: RawUTF8; Row: integer); overload;
    {/ fill all published properties of this object from a JSON object result
      - use JSON data, as exported by GetJSONValues()
      - JSON data may be expanded or not
      - make an internal copy of the JSONTable RawUTF8 before calling
       FillFrom() below}
    procedure FillFrom(const JSONRecord: RawUTF8); overload;
    {/ fill all published properties of this object from a JSON result
      - the data inside P^ is modified (unescaped and transformed): don't call
       FillFrom(pointer(JSONRecordUTF8)) but FillFrom(JSONRecordUTF8) which makes
       a temporary copy of the JSONRecordUTF8 text
      - use JSON data, as exported by GetJSONValues()
      - JSON data may be expanded or not }
    procedure FillFrom(P: PUTF8Char); overload;
    {/ fill all published properties of this object from another object
      - source object must be a parent or of the same class as the current record 
      - copy all COPIABLE_FIELDS, i.e. all fields excluding tftMany (because
        those fields don't contain any data, but a TSQLRecordMany instance
        which allow to access to the pivot table data) }
    procedure FillFrom(aRecord: TSQLRecord); overload;
    {/ fill a published property value of this object from a UTF-8 encoded value
     - see TPropInfo about proper Delphi / UTF-8 type mapping/conversion
     - use this method to fill a BLOB property, i.e. a property defined with
       type TSQLRawBlob, since by default all BLOB properties are not
       set by the standard Retrieve() method (to save bandwidth) }
    procedure FillValue(const PropName: ShortString; Value: PUTF8Char);

    {/ return true if all published properties values in Other are identical to
     the published properties of this object
      - work with different classes: Reference properties name must just be
      present in the calling object
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are compared
      - compare the text representation of the values: fields may be of different
      type, encoding or precision, but still have same values }
    function SameValues(Reference: TSQLRecord): boolean;
    {/ return true if all published properties values in Other are identical to
      the published properties of this object
      - instances must be of the same class type
      - only simple fields (i.e. not TSQLRawBlob/TSQLRecordMany) are compared 
      - comparaison is much faster than SameValues() above }
    function SameRecord(Reference: TSQLRecord): boolean;
    /// clear the values of all published properties, and also the ID property
    procedure ClearProperties;
    /// set the simple fields with the supplied values
    // - the aSimpleFields parameters must follow explicitely the order of published
    // properties of the supplied aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields") - in particular,
    // parent properties must appear first in the list
    // - the aSimpleFields must have exactly the same count of parameters as there are
    // "simple fields" in the published properties
    // - return true on success, but be aware that the field list must match
    // the field layout, otherwise if may return true but will corrupt data
    function SimplePropertiesFill(const aSimpleFields: array of const): boolean;
    /// initialize a TDynArray wrapper to map dynamic array property values
    // - if the field name is not existing or not a dynamic array, result.IsVoid
    // will be TRUE
    function DynArray(const DynArrayFieldName: shortstring): TDynArray; overload;
    /// initialize a TDynArray wrapper to map dynamic array property values
    // - this overloaded version expect the dynamic array to have been defined
    // with a not null index attribute, e.g.
    // ! published
    // !   property Ints: TIntegerDynArray index 1 read fInts write fInts;
    // !   property Currency: TCurrencyDynArray index 2 read fCurrency write fCurrency;
    // - if the field index is not existing or not a dynamic array, result.IsVoid
    // will be TRUE
    function DynArray(DynArrayFieldIndex: integer): TDynArray; overload;

    {/ this property stores the record's integer ID
      - if this TSQLRecord is not a instance, but a field value in a published
        property of type sftID (i.e. TSQLRecord(aID)), this method will try
        to retrieve it; but prefered method is to typecast it via PtrInt(aProperty),
        because GetID() relies on some low-level Windows memory mapping trick, and
        will recognize an ID value up to 1,048,576 (i.e. $100000)
      - notice: the Setter should not be used usualy; you should not have to write
        aRecord.ID := someID in your code, since the ID is set during Retrieve or
        Add of the record }
    property ID: integer read GetID write fID;
    {/ this property is set to true, if any published property is a BLOB (TSQLRawBlob) }
    property HasBlob: boolean read GetHasBlob;
    {/ this property returns the published property count with any valid
      database field except TSQLRawBlob/TSQLRecordMany
    - by default, the TSQLRawBlob (BLOB) fields are not included into this set:
      they must be read specificaly (in order to spare bandwidth)
    - TSQLRecordMany fields are not accessible directly, but as instances
      created by TSQLRecord.Create }
    property SimpleFieldCount: integer read GetSimpleFieldCount;
    {/ this property contains the TSQLTable after a call to FillPrepare() }
    property FillTable: TSQLTable read GetTable;
    {/ this property contains the current row number (beginning with 1),
      initialized to 1 by FillPrepare(), which will be read by FillOne }
    property FillCurrentRow: integer read GetFillCurrentRow;
    {/ this property contains the internal state counter of the server database
      when the data was retrieved from it
      - may be used to check if retrieved data may be out of date }
    property InternalState: cardinal read fInternalState;
  published
    { define properties in children: they will be interpreted as SQL fields }
  end;

  PSQLLocks = ^TSQLLocks;
  /// used to store the locked record list, in a specified table
  // - the maximum count of the locked list if fixed to 512 by default,
  // which seems correct for common usage
  TSQLLocks = {$ifndef ISDELPHI2010}object{$else}record{$endif}
    /// the number of locked records stored in this object
    Count: integer;
    /// contains the locked record ID
    // - an empty position is marked with 0 after UnLock()
    ID: array[0..MAX_SQLLOCKS-1] of integer;
    /// contains the time and date of the lock
    // - filled internally by the very fast GetTickCount function (faster than
    // TDateTime or TSystemTime/GetLocalTime)
    // - used to purge to old entries - see PurgeOlderThan() method below
    Ticks: array[0..MAX_SQLLOCKS-1] of cardinal;
    /// lock a record, specified by its ID
    // - returns true on success, false if was already locked
    function Lock(aID: integer): boolean;
    /// unlock a record, specified by its ID
    // - returns true on success, false if was not already locked
    function UnLock(aID: integer): boolean;
    /// return true if a record, specified by its ID, is locked
    function isLocked(aID: integer): boolean;
    /// delete all the locked IDs entries, after a specified time
    // - to be used to release locked records if the client crashed
    // - default value is 30 minutes, which seems correct for common database usage
    // - also purge values where GetTickCount wrapped around to zero after 49.7 days
    // (for consistency)
    procedure PurgeOlderThan(MinutesFromNow: cardinal=30);
  end;

  TSQLLocksDynArray = array of TSQLLocks;

  /// UI Query comparison operators
  // - these operators are e.g. used to mark or unmark some lines in a UI Grid
  TSQLQueryOperator =
    (qoNone,
     qoEqualTo,
     qoNotEqualTo,
     qoLessThan,
     qoLessThanOrEqualTo,
     qoGreaterThan,
     qoGreaterThanOrEqualTo,
     qoEqualToWithCase,
     qoNotEqualToWithCase,
     qoContains,
     qoBeginWith,
     qoSoundsLikeEnglish,
     qoSoundsLikeFrench,
     qoSoundsLikeSpanish);

  /// set of UI Query comparison operators
  TSQLQueryOperators = set of TSQLQueryOperator;

  /// User Interface Query action evaluation function prototype
  // - Operator is ord(TSQLQueryOperator) by default (i.e. for class function
  // TSQLRest.QueryIsTrue), or is a custom enumeration index for custom queries
  // (see TSQLQueryCustom.EnumIndex below, and TSQLRest.QueryAddCustom() method)
  // - for default Operator as ord(TSQLQueryOperator), qoContains and qoBeginWith
  // expect the Reference to be already uppercase
  // - qoEqualTo to qoGreaterThanOrEqualTo apply to all field kind (work with
  // either numeric either UTF-8 values)
  // - qoEqualToWithCase to qoSoundsLikeSpanish handle the field as UTF-8 text,
  // and make the comparison using the phonetic algorithm corresponding to
  // a language family
  // - for default Operator as ord(TSQLQueryOperator), qoSoundsLike* operators
  // expect the Reference not to be a PUTF8Char, but a typecast of a prepared
  // TSynSoundEx object instance (i.e. pointer(@SoundEx)) by the caller
  // - for custom query (from TSQLQueryCustom below), the event must
  // handle a special first call with Value=nil to select if this custom
  // Operator/Query is available for the specified aTable: in this case,
  // returning true indicates that this custom query is available for this table
  // - for custom query (from TSQLQueryCustom below), the event is called with
  // FieldType := TSQLFieldType(TSQLQueryCustom.EnumIndex)+64
  TSQLQueryEvent = function(aTable: TSQLRecordClass; aID: integer;
    FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
    Reference: PUTF8Char): boolean of object;

  /// store one custom query parameters
  // - add custom query by using the TSQLRest.QueryAddCustom() method
  // - use EnumType^.GetCaption(EnumIndex) to retrieve the caption associated
  // to this custom query
  TSQLQueryCustom = record
    /// the associated enumeration type
    EnumType: PEnumType;
    /// the associated enumeration index in EnumType
    // - will be used to fill the Operator parameter for the Event call
    EnumIndex: integer;
    /// the associated evaluation Event handler
    // - the Operator parameter will be filled with the EnumIndex value
    Event: TSQLQueryEvent;
    /// User Interface Query action operators
    Operators: TSQLQueryOperators;
  end;

  /// standard actions for User Interface generation
  TSQLAction = (
    /// action not defined
    actNoAction,
    /// Mark rows (standard action)
    // - display sub-menu with actmarkAllEntries..actmarkBeforeOneYear items
    actMark,
    /// UnMark all rows (standard action)
    actUnmarkAll,
    /// Mark all rows
    actmarkAllEntries,
    /// Mark rows After one day
    actmarkOlderThanOneDay,
    /// Mark rows older than one week
    actmarkOlderThanOneWeek,
    /// Mark rows older than one month
    actmarkOlderThanOneMonth,
    /// Mark rows older than one half year
    actmarkOlderThanSixMonths,
    /// Mark rows older than one year
    actmarkOlderThanOneYear,
    /// Inverse Mark values (ON->OFF, OFF->ON)
    actmarkInverse);

  /// set of standard actions for User Interface generation
  TSQLActions = set of TSQLAction;

  /// defines the way the TDrawGrid is displayed by User Interface generation
  TSQLListLayout = (llLeft, llUp, llClient, llLeftUp);

  PSQLRibbonTabParameters = ^TSQLRibbonTabParameters;

  /// defines the settings for a Tab for User Interface generation
  // - used in SQLite3ToolBar unit and TSQLModel.Create() overloaded method
  TSQLRibbonTabParameters = object
  public
    /// the Table associated to this Tab
    Table: TSQLRecordClass;
    /// the caption of the Tab, to be translated on the screen
    // - by default, Tab name is taken from TSQLRecord.Caption(nil) method
    // - but you can override this value by setting a pointer to a resourcestring
    CustomCaption: PResStringRec;
    /// the hint type of the Tab, to be translated on the screen
    // - by default, hint will replace all %s instance by the Tab name, as taken
    // from TSQLRecord.Caption(nil) method
    // - but you can override this value by setting a pointer to a resourcestring
    CustomHint: PResStringRec;
    /// SQL fields to be displayed on the data lists
    // 'ID,' is always added at the beginning
    Select: RawUTF8;
     /// Tab Group number (index starting at 0)
    Group: integer;
    /// displayed field length mean, one char per field (A=1,Z=26)
    // - put lowercase character in order to center the field data
    FieldWidth: RawUTF8;
    /// if set, the ID column is shown
    ShowID: boolean;
    /// index of field used for displaying order
    OrderFieldIndex: integer;
    /// if set, the list is displayed in reverse order (i.e. decreasing)
    ReverseOrder: boolean;
    /// layout of the List, below the ribbon
    Layout: TSQLListLayout;
    /// width of the List, in percent of the client area
    // - default value (as stated in TSQLRibbonTab.Create) is 30%  
    ListWidth: integer;
    /// by default, the detail are displayed as a report (TGDIPages component)
    // - set this property to true to customize the details display
    // - this property is ignored if Layout is llClient (i.e. details hidden)
    NoReport: boolean;
    /// by default, the screens are not refreshed automaticaly
    // - but you can enable the auto-refresh feature by setting this
    // property to TRUE, and creating a WM_TIMER message handler for the form,
    // which will handle both WM_TIMER_REFRESH_SCREEN and WM_TIMER_REFRESH_REPORT
    // timers:
    // !procedure TMainForm.WMRefreshTimer(var Msg: TWMTimer);
    // !begin
    // !  Ribbon.WMRefreshTimer(Msg);
    // !end;
    AutoRefresh: boolean;
    /// the associated hints to be displayed during the edition of this table
    // - every field hint must be separated by a '|' character
    // (e.g. 'The First Name|Its Company Name')
    // - all fields need to be listed in this text resource, even if it won't
    // be displayed on screen (enter a void item like ||)
    // - you can define some value by setting a pointer to a resourcestring
    EditFieldHints: PResStringRec;
    /// write hints above field during the edition of this table
    // - if EditExpandFieldHints is TRUE, the hints are written as text on the
    // dialog, just above the field content; by default, hints are displayed as
    // standard delayed popup when the mouse hover the field editor
    EditExpandFieldHints: boolean;
    /// the associated field name width (in pixels) to be used for creating
    // the edition dialog for this table
    EditFieldNameWidth: integer;
    /// a CSV list of field names to be hidden in both editor and default report
    // - handy to hide fields containing JSON data or the name of another
    // sftRecord/sftID (i.e. TRecordReference/TSQLRecord published propet) fields
    // - list is to be separated by commas (e.g. "RunLogJSON,OrdersJSON" or
    // "ConnectionName")
    EditFieldNameToHideCSV: RawUTF8;
    /// if the default report must contain the edit field hints
    // - i.e. if the resourcestring pointed by EditFieldHints must be used
    // to display some text above every property value on the reports 
    EditFieldHintsToReport: boolean;
  end;

  /// parent of all virtual classes
  // - you can define a plain TSQLRecord class as virtual if needed  - e.g.
  // inheriting from TSQLRecordMany then calling VirtualTableExternalRegister() -
  // but using this class will seal its state to be virtual
  TSQLRecordVirtual = class(TSQLRecord);

  TSQLVirtualTable = class;
  TSQLVirtualTableClass = class of TSQLVirtualTable;

  /// a Database Model (in a MVC-driven way), for storing some tables types
  // as TSQLRecord classes
  // - share this Model between TSQLRest Client and Server
  // - use this class to access the table properties: do not rely on the
  // low-level database methods (e.g. TSQLDataBase.GetTableNames), since the
  // tables may not exist in the main SQLite3 database, but in-memory or external
  // - don't modify the order of Tables inside this Model, if you publish
  // some TRecordReference property in any of your tables
  TSQLModel = class(TObject)
  private
    fTables: TSQLRecords;
    fRoot: RawUTF8;
    fActions: PEnumType;
    fEvents: PEnumType;
    /// contains the caller of CreateOwnedStream()
    fOwner: TSQLRest;
    /// for every table, contains a locked record list
    // - very fast, thanks to the use of a dynamic array with one entry by table
    fLocks: TSQLLocksDynArray;
    /// for fastest SQL Table name lookup via binary search
    fTablesName: TRawUTF8DynArray;
    fTablesNameIndex: TIntegerDynArray;
    /// will contain the registered virtual table modules
    fVirtualTableModule: array of TSQLVirtualTableClass;
    procedure SetTableProps(aTable: TSQLRecordClass; aIndex: integer; Last, VirtualsRemain: boolean);
    function GetLocks(aTable: TSQLRecordClass): PSQLLocks;
    function GetTable(const SQLTableName: RawUTF8): TSQLRecordClass;
    function GetTableExactIndex(const TableName: RawUTF8): integer;
    function GetTableExactClass(const TableName: RawUTF8): TSQLRecordClass;
    function getURI(aTable: TSQLRecordClass): RawUTF8;
    function getURIID(aTable: TSQLRecordClass; aID: integer): RawUTF8;
    function getURICallBack(const aMethodName: RawUTF8; aTable: TSQLRecordClass; aID: integer): RawUTF8;
  public
    /// this array contain all TRecordReference and TSQLRecord properties
    // existing in the database model
    // - used in TSQLRestServer.Delete() to enforce relational database coherency
    // after deletion of a record: all other records pointing to it will be
    // reset to 0 by TSQLRestServer.AfterDeleteForceCoherency
    RecordReferences: array of record
      TableIndex: integer;
      FieldType: TSQLFieldType;
      FieldRecordClass: TSQLRecordClass;
      FieldName: PShortString;
    end;
    /// the associated information about all handled TSQLRecord class properties
    // - this TableProps[] array will map the Tables[] array, and will allow
    // fast direct access to the Tables[].RecordProps values
    TableProps: array of TSQLRecordProperties;
    /// initialize the Database Model
    // - set the Tables to be associated with this Model, as TSQLRecord classes
    // - set the optional Root URI path of this Model
    // - initialize the fIsUnique[] array from "stored false" published
    // properties of every TSQLRecordClass
    // - if aVirtualsRemain is FALSE this will reset all supplied classes to be
    // defined as non-virtual (i.e. Kind=rSQLite3): VirtualTableExternalRegister
    // explicit calls are to be made if expected
    constructor Create(const Tables: array of TSQLRecordClass; const aRoot: RawUTF8='root';
      aVirtualsRemain: boolean=false); reintroduce; overload;
    /// clone an existing Database Model
    // - all supplied classes won't be redefined as non-virtual:
    // VirtualTableExternalRegister explicit calls are not mandatory here
    constructor Create(CloneFrom: TSQLModel); overload;
    /// initialize the Database Model from an User Interface parameter structure
    // - this constructor will reset all supplied classes to be defined as
    // non-virtual (i.e. Kind=rSQLite3): VirtualTableExternalRegister explicit
    // calls are to be made if tables should be managed as external
    constructor Create(TabParameters: PSQLRibbonTabParameters;
      TabParametersCount, TabParametersSize: integer;
      const NonVisibleTables: array of TSQLRecordClass; const aRoot: RawUTF8='root'); overload;
    /// release associated memory
    destructor Destroy; override;
    /// add the class if it doesn't exist yet
    // - return true if not existing yet and successfully added (in this case,
    // aTableIndexCreated^ is set to the newly created index in Tables[])
    // - supplied class will be redefined as non-virtual: VirtualTableExternalRegister
    // explicit call is to be made if table should be managed as external 
    function AddTable(aTable: TSQLRecordClass; aTableIndexCreated: PInteger=nil): boolean;
    /// get the index of aTable in Tables[]
    function GetTableIndex(aTable: TSQLRecordClass): integer; overload;
    /// get the index of a table in Tables[]
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    function GetTableIndex(const SQLTableName: RawUTF8): integer; overload;
    /// get the index of a table in Tables[]
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    function GetTableIndex(SQLTableName: PUTF8Char): integer; overload;
    /// return the UTF-8 encoded SQL source to create the table
    function GetSQLCreate(aTableIndex: integer): RawUTF8;
    /// return the UTF-8 encoded SQL source to add the corresponding field
    // via a "ALTER TABLE" statement
    function GetSQLAddField(aTableIndex, aFieldIndex: integer): RawUTF8;
    {/ return the TRecordReference pointing to the specified record }
    function RecordReference(Table: TSQLRecordClass; ID: integer): TRecordReference;
    {/ return the first unique property of kind RawUTF8
      - this property is mainly the "Name" property, i.e. the one with
        "stored false" definition on most TSQLRecord
      - if ReturnFirstIfNoUnique is TRUE and no unique property is found,
        the first RawUTF8 property is returned anyway
      - returns '' if no matching field was found }
    function GetMainFieldName(Table: TSQLRecordClass;
      ReturnFirstIfNoUnique: boolean=false): RawUTF8;
    /// return TRUE if the specified field of this class was marked as unique
    // - an unique field is defined as "stored false" in its property definition
    // - reflects the internal private fIsUnique propery
    function GetIsUnique(aTable: TSQLRecordClass; aFieldIndex: integer): boolean;
    /// try to retrieve a table index from a SQL statement
    // - naive search of '... FROM TableName' pattern in the supplied SQL
    // - if EnsureUniqueTableInFrom is TRUE, it will check that only one Table
    // is in the FROM clause, otherwise it will return the first Table specified
    function GetTableIndexFromSQLSelect(const SQL: RawUTF8; EnsureUniqueTableInFrom: boolean): integer;

    /// assign an enumeration type to the possible actions to be performed
    // with this model
    // - call with the TypeInfo() pointer result of an enumeration type
    // - actions are handled by TSQLRecordForList in the SQLite3ToolBar unit
    procedure SetActions(aActions: PTypeInfo);
    /// assign an enumeration type to the possible events to be triggered
    // with this class model
    // - call with the TypeInfo() pointer result of an enumeration type
    procedure SetEvents(aEvents: PTypeInfo);
    /// get the text conversion of a given Action, ready to be displayed
    function ActionName(const Action): string;
    /// get the text conversion of a given Event, ready to be displayed
    function EventName(const Event): string;
    /// register a Virtual Table module for a specified class
    // - to be called server-side only (Client don't need to know the virtual
    // table implementation details, and it will increase the code size)
    // - aClass parameter could be either a TSQLRecordVirtual class, either
    // a TSQLRecord class which has its kind set to rCustomForcedID or
    // rCustomAutoID (e.g. TSQLRecordMany calling VirtualTableExternalRegister)
    // - call it before TSQLRestServer.Create()
    function VirtualTableRegister(aClass: TSQLRecordClass;
      aModule: TSQLVirtualTableClass): boolean;
    /// retrieve a Virtual Table module associated to a class
    function VirtualTableModule(aClass: TSQLRecordClass): TSQLVirtualTableClass;

    /// create a New TSQLRecord instance for a specific Table
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    // - use this to create a working copy of a table's record, e.g.
    // - don't forget to Free it when not used any more (use a try...finally
    // block)
    // - it's prefered in practice to directly call TSQLRecord*.Create()
    // in your code
    function NewRecord(const SQLTableName: RawUTF8): TSQLRecord;

    /// lock a record
    // - returns true on success, false if was already locked or if there's no
    // place more in the lock table (as fixed by MAX_SQLLOCKS contst, i.e. 512)
    function Lock(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// lock a record
    // - returns true on success, false if was already locked or if there's no
    // place more in the lock table (as fixed by MAX_SQLLOCKS contst, i.e. 512)
    function Lock(aTableIndex, aID: integer): boolean; overload;
    /// lock a record
    // - returns true on success, false if was already locked or if there's no
    // place more in the lock table (as fixed by MAX_SQLLOCKS contst, i.e. 512)
    function Lock(aRec: TSQLRecord): boolean; overload;
    /// unlock a specified record
    // - returns true on success, false if was not already locked
    function UnLock(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// unlock a specified record
    // - returns true on success, false if was not already locked
    function UnLock(aRec: TSQLRecord): boolean; overload;
    /// unlock all previously locked records
    procedure UnLockAll;
    /// return true if a specified record is locked
    function isLocked(aTable: TSQLRecordClass; aID: integer): boolean; overload;
    /// return true if a specified record is locked
    function isLocked(aRec: TSQLRecord): boolean; overload;
    /// delete all the locked IDs entries, after a specified time
    // - to be used to release locked records if the client crashed
    // - default value is 30 minutes, which seems correct for common usage
    procedure PurgeOlderThan(MinutesFromNow: cardinal=30);

    /// the Root URI path of this Database Model
    property Root: RawUTF8 read fRoot;
    /// get the classes list (TSQLRecord descendent) of all available tables
    property Tables: TSQLRecords read fTables;
    /// get a class from a table name
    // - expects SQLTableName to be SQL-like formated (i.e. without TSQL[Record])
    property Table[const SQLTableName: RawUTF8]: TSQLRecordClass read GetTable; default;
    /// get a class from a table TableName (don't truncate TSQLRecord* if necessary)
    property TableExact[const TableName: RawUTF8]: TSQLRecordClass read GetTableExactClass;
    /// get the URI for a class in this Model, as 'ModelRoot/SQLTableName'
    property URI[aClass: TSQLRecordClass]: RawUTF8 read getURI;
    /// get the enumerate type information about the possible actions to be
    // performed with this model
    // - Actions are e.g. linked to some buttons in the User Interface
    property Actions: PEnumType read fActions;
    /// get the enumerate type information about the possible Events to be
    // performed with this model
    // - Events can be linked to actions and custom status, to provide a
    // centralized handling of logging (e.g. in an Audit Trail table)
    property Events: PEnumType read fEvents;
    /// this property value is used to auto free the database Model class
    // - set this property after Owner.Create() in order to have
    // Owner.Destroy autofreeing it
    property Owner: TSQLRest read fOwner write fOwner;
    /// for every table, contains a locked record list
    // - very fast, thanks to the use one TSQLLocks entry by table
    property Locks: TSQLLocksDynArray read fLocks;
  end;

  PRecordRef = ^RecordRef;
  
  /// usefull object to type cast TRecordReference type value into explicit
  // TSQLRecordClass and ID
  // - use TSQLRest.Retrieve(Reference) to get a record value
  // - don't change associated TSQLModel tables order, since TRecordReference
  // depends on it to store the Table type
  // - since 6 bits are used for the table index, the corresponding table
  // MUST appear in the first 64 items of the associated TSQLModel.Tables[]
  RecordRef = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the value itself
    // - (value and 63) is the TableIndex in the current database Model
    // - (value shr 6) is the ID of the record in this table
    // - value=0 means no reference stored
    // - we use this coding and not the opposite (Table in MSB) to minimize
    // integer values; but special UTF8CompareRecord() function has to be used
    // for sorting
    Value: cardinal;
    /// return the index of the content Table in the TSQLModel
    function TableIndex: integer;
    /// return the class of the content in a specified TSQLModel
    function Table(Model: TSQLModel): TSQLRecordClass;
    /// return the ID of the content
    function ID: integer;
    /// fill Value with the corresponding parameters
    // - since 6 bits are used for the table index, aTable MUST appear in the
    // first 64 items of the associated TSQLModel.Tables[] array
    procedure From(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer);
    /// get a ready to be displayed text from the stored Table and ID
    // - display 'Record 2301' e.g.
    function Text(Model: TSQLModel): RawUTF8; overload;
    /// get a ready to be displayed text from the stored Table and ID
    // - display 'Record "RecordName"' e.g.
    function Text(Rest: TSQLRest): RawUTF8; overload;
  end;

  /// this kind of record array can be used for direct coordinates storage
  TSQLRecordTreeCoords = array[0..RTREE_MAX_DIMENSION-1] of packed record
    min, max: double; end;

  {/ a base record, corresponding to an R-Tree table
    - an R-Tree is a special index that is designed for doing range queries.
      R-Trees are most commonly used in geospatial systems where each entry is a
      rectangle with minimum and maximum X and Y coordinates. Given a query
      rectangle, an R-Tree is able to quickly find all entries that are contained
      within the query rectangle or which overlap the query rectangle. This idea
      is easily extended to three dimensions for use in CAD systems. R-Trees also
      find use in time-domain range look-ups. For example, suppose a database
      records the starting and ending times for a large number of events. A R-Tree
      is able to quickly find all events, for example, that were active at any
      time during a given time interval, or all events that started during a
      particular time interval, or all events that both started and ended within
      a given time interval. And so forth. See http://www.sqlite.org/rtree.html
    - any record which inherits from this class must have only sftFloat
      (double) fields, grouped by pairs, each as minimum- and maximum-value,
      up to 5 dimensions (i.e. 11 columns, including the ID property)
    - the ID: integer property must be set before adding a TSQLRecordRTree to
      the database, e.g. to link a R-Tree representation to a regular
      TSQLRecord table
    - queries against the ID or the coordinate ranges are almost immediate: so
      you can e.g. extract some coordinates box from the regular TSQLRecord
      table, then use a TSQLRecordRTree joined query to make the process faster;
      this is exactly what the TSQLRestClient.RTreeMatch method offers }
  TSQLRecordRTree = class(TSQLRecordVirtual)
  public
    { override this class function to implement a custom box coordinates
      from a given BLOB content
      - by default, the BLOB array will contain a simple array of double
      - but you can override this method to handle a custom BLOB field content,
        intended to hold some kind of binary representation of the precise
        boundaries of the object, and convert it into box coordinates as
        understood by the ContainedIn() class function
      - the number of pairs in OutCoord will be taken from the current number
        of published double properties
      - used e.g. by the TSQLRestClient.RTreeMatch method }
    class procedure BlobToCoord(const InBlob; var OutCoord: TSQLRecordTreeCoords); virtual;
    { override this class function to implement a custom SQL *_in() function
      - by default, the BLOB array will be decoded via the BlobToCoord class
        procedure, and will create a SQL function from the class name 
      - for instance, the following class will define a 2 dimensional
        MapBox_in() function
      ! TSQLRecordMapBox = class(TSQLRecordTree)
      ! protected
      !   fMinX, fMaxX, fMinY, fMaxY: double;
      ! published
      !   property MinX: double read fMinX write fMinX;
      !   property MaxX: double read fMaxX write fMaxX;
      !   property MinY: double read fMinY write fMinY;
      !   property MaxY: double read fMaxY write fMaxY;
      ! end;
      - used e.g. by the TSQLRestClient.RTreeMatch method   }
    class function ContainedIn(const BlobA,BlobB): boolean; virtual;
    /// will return 'MapBox_in' e.g. for TSQLRecordMapBox
    class function RTreeSQLFunctionName: RawUTF8;
  end;

  {/ a base record, corresponding to a FTS3 table, i.e. implementing full-text
    - FTS3/FTS4 table are SQLite virtual tables which allow users to perform
      full-text searches on a set of documents. The most common (and effective)
      way to describe full-text searches is "what Google, Yahoo and Altavista do
      with documents placed on the World Wide Web". Users input a term, or
      series of terms, perhaps connected by a binary operator or grouped together
      into a phrase, and the full-text query system finds the set of documents
      that best matches those terms considering the operators and groupings the
      user has specified. See http://sqlite.org/fts3.html
    - any record which inherits from this class must have only sftUTF8Text
      (RawUTF8) fields - with Delphi 2009+, you can have string fields
    - this record has its fID: integer property which may be published
      as DocID, to be consistent with SQLite3 praxis, and reflect that it
      points to an ID of another associated TSQLRecord
    - a good approach is to store your data in a regular TSQLRecord table, then
      store your text content in a separated FTS3 table, associated to this
      TSQLRecordFTS3 table via its ID/DocID
    - the ID/DocID property can be set when the record is added, to retrieve any
      associated TSQLRecord (note that for a TSQLRecord record,
      the ID property can't be set at adding, but is calculated by the engine)
    - static tables don't handle TSQLRecordFTS3 classes
    - by default, the FTS3 engine ignore all characters >= #80, but handle
      low-level case insentivity (i.e. 'A'..'Z') so you must keep your
      request with the same range for upper case
    - by default, the "simple" tokenizer is used, but you can inherits from
      TSQLRecordFTS3Porter class if you want a better English matching, using
      the Porter Stemming algorithm - see http://sqlite.org/fts3.html#tokenizer
    - you can select either the FTS3 engine, or the more efficient (and new)
      FTS4 engine (available since version 3.7.4), by using the TSQLRecordFTS4 type
    - in order to make FTS3/FTS4 queries, use the dedicated TSQLRest.FTSMatch
      method, with the MATCH operator (you can use regular queries, but you must
      specify 'RowID' instead of 'DocID' or 'ID' because of FTS3 Virtual
      table specificity):
       ! var IDs: TIntegerDynArray;
       ! if FTSMatch(TSQLMyFTS3Table,'text MATCH "linu*"',IDs) then
       !  // you've all matching IDs in IDs[]  }
  TSQLRecordFTS3 = class(TSQLRecordVirtual)
  public
     {/ optimize the FTS3 virtual table
     - this causes FTS3 to merge all existing index b-trees into a single large
       b-tree containing the entire index. This can be an expensive operation,
       but may speed up future queries. See http://sqlite.org/fts3.html#section_1_2
     - this method must be called server-side
     - returns TRUE on success }
     class function OptimizeFTS3Index(Server: TSQLRestServer): boolean;
     /// this DocID property map the internal Row_ID property
     // - but you can set a value to this property before calling the Add()
     // method, to associate this TSQLRecordFTS3 to another TSQLRecord
     // - ID property is read-only, but this DocID property can be written/set
     // - internaly, we use RowID in the SQL statements, which is compatible
     // with both TSQLRecord and TSQLRecordFTS3 kind of table
     property DocID: integer read GetID write fID;
  end;

  /// this base class will create a FTS3 table using the Porter Stemming algorithm
  // - see http://sqlite.org/fts3.html#tokenizer
  TSQLRecordFTS3Porter = class(TSQLRecordFTS3);

  TSQLRecordFTS3Class = class of TSQLRecordFTS3;

  TSQLRecordRTreeClass = class of TSQLRecordRTree;

  {/ a base record, corresdonding to a FTS4 table, which is an enhancement to FTS3
  - FTS3 and FTS4 are nearly identical. They share most of their code in common,
   and their interfaces are the same. The only difference is that FTS4 stores
   some additional information about the document collection in two of new FTS
   shadow tables. This additional information allows FTS4 to use certain
   query performance optimizations that FTS3 cannot use. And the added information
   permits some additional useful output options in the matchinfo() function.
  - For newer applications, TSQLRecordFTS4 is recommended; though if minimal disk
   usage or compatibility with older versions of SQLite are important, then
   TSQLRecordFTS3 will usually serve just as well.
  - see http://sqlite.org/fts3.html#section_1_1 }
  TSQLRecordFTS4 = class(TSQLRecordFTS3);
  /// this base class will create a FTS4 table using the Porter Stemming algorithm
  // - see http://sqlite.org/fts3.html#tokenizer
  TSQLRecordFTS4Porter = class(TSQLRecordFTS4);

  /// the kind of fields to be available in a Table resulting of
  // a TSQLRecordMany.DestGetJoinedTable() method call
  // - Source fields are not available, because they will be always the same for
  // a same SourceID, and they should be available from the TSQLRecord which
  // hold the TSQLRecordMany instance
  // - jkDestID and jkPivotID will retrieve only DestTable.ID and PivotTable.ID
  // - jkDestFields will retrieve DestTable.* simple fields, or the fields
  // specified by aCustomFieldsCSV (the Dest table name will be added: e.g.
  // for aCustomFieldsCSV='One,Two', will retrieve DestTable.One, DestTable.Two)
  // - jkPivotFields will retrieve PivotTable.* simple fields, or the fields
  // specified by aCustomFieldsCSV (the Pivot table name will be added: e.g.
  // for aCustomFieldsCSV='One,Two', will retrieve PivotTable.One, PivotTable.Two)
  // - jkPivotAndDestAllFields for PivotTable.* and DestTable.* simple fields,
  // or will retrieve the specified aCustomFieldsCSV fields (with
  // the table name associated: e.g. 'PivotTable.One, DestTable.Two')
  TSQLRecordManyJoinKind = (
    jkDestID, jkPivotID, jkDestFields, jkPivotFields, jkPivotAndDestFields);

  TSQLRecordManyClass = class of TSQLRecordMany;

  {/ handle "has many" and "has many through" relationships
   - many-to-many relationship is tracked using a table specifically for that
     relationship, turning the relationship into two one-to-many relationships
     pointing in opposite directions
   - by default, only two TSQLRecord (i.e. INTEGER) fields must be created,
     named "Source" and "Dest", the first pointing to the source record (the one
     with a TSQLRecordMany published property) and the second to the destination record
   - you should first create a type inheriting from TSQLRecordMany, which
     will define the pivot table, providing optional "through" parameters if needed
     ! TSQLDest = class(TSQLRecord);
     ! TSQLSource = class;
     ! TSQLDestPivot = class(TSQLRecordMany)
     ! private
     !  fSource: TSQLSource;
     !  fDest: TSQLDest;
     !  fTime: TDateTime;
     ! published
     !   property Source: TSQLSource read fSource; // map Source column
     !   property Dest: TSQLDest read fDest; // map Dest column
     !   property AssociationTime: TDateTime read fTime write fTime;
     ! end;
     ! TSQLSource = class(TSQLRecord)
     ! private
     !   fDestList: TSQLDestPivot;
     ! published
     !   DestList: TSQLDestPivot read fDestList;
     ! end;
   - in all cases, at leat two 'Source' and 'Dest' published properties must
     be declared as TSQLRecord children in any TSQLRecordMany descendant
     because they will always be needed for the 'many to many' relationship
   - when a TSQLRecordMany published property exists in a TSQLRecord, it is
     initialized automaticaly by TSQLRecord.Create
   - to add some associations to the pivot table, use the ManyAdd() method
   - to retrieve an association, use the ManySelect() method
   - to delete an association, use the ManyDelete() method
   - to read all Dest records IDs, use the DestGet() method
   - to read the Dest records and the associated "through" fields content, use
     FillMany then FillRow, FillOne and FillRewind methods to loop through records
   - to read all Source records and the associaed "through" fields content,
     FillManyFromDest then FillRow, FillOne and FillRewind methods
   - to read all Dest IDs after a join to the pivot table, use DestGetJoined }
  TSQLRecordMany = class(TSQLRecord)
  protected
    // internal fields initialized during TSQLRecord.Create
    // - map to the Source and Dest properties field values in TSQLRecord values
    fSourceID: PPtrInt;
    fDestID: PPtrInt;
    /// retrieve the TSQLRecordMany ID from a given source+dest IDs pair
    function InternalIDFromSourceDest(aClient: TSQLRest; aSourceID, aDestID: integer): integer;
    function InternalFillMany(aClient: TSQLRest; aID: integer;
      const aAndWhereSQL: RawUTF8; isDest: boolean): integer;
  public
    /// initialize this instance, and needed internal fields
    // - will set protected fSourceID/fDestID fields
    constructor Create; override;
    /// retrieve all records associated to a particular source record, which
    // has a TSQLRecordMany property
    // - returns the Count of records corresponding to this aSource record
    // - the records are stored in an internal TSQLTable, refered in the private
    // fTable field, and initialized via a FillPrepare call: all Dest items
    // are therefore accessible with standard FillRow, FillOne and FillRewind methods
    // - use a "for .." loop or a "while FillOne do ..." loop to iterate
    // through all Dest items, getting also any additional 'through' columns
    // - if source ID parameter is 0, the ID is taken from the fSourceID field
    // (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please specify aSourceID parameter with
    // the one just added/created
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // inlined parameters for faster processing on server, so you may call e.g.
    // ! aRec.FillMany(Client,0,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    function FillMany(aClient: TSQLRest; aSourceID: integer=0;
      const aAndWhereSQL: RawUTF8=''): integer;
    /// retrieve all records associated to a particular Dest record, which
    // has a TSQLRecordMany property
    // - returns the Count of records corresponding to this aSource record
    // - use a "for .." loop or a "while FillOne do ..." loop to iterate
    // through all Dest items, getting also any additional 'through' columns
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // inlined parameters for faster processing on server, so you may call e.g.
    // ! aRec.FillManyFromDest(Client,DestID,FormatUTF8('Salary>? AND Salary<?',[],[1000,2000]));
    function FillManyFromDest(aClient: TSQLRest; aDestID: integer;
      const aAndWhereSQL: RawUTF8=''): integer;
    /// retrieve all Dest items IDs associated to the specified Source
    function DestGet(aClient: TSQLRest; aSourceID: integer; out DestIDs: TIntegerDynArray): boolean; overload;
    /// retrieve all Dest items IDs associated to the current Source ID
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function DestGet(aClient: TSQLRest; out DestIDs: TIntegerDynArray): boolean; overload;
    /// retrieve all Source items IDs associated to the specified Dest ID
    function SourceGet(aClient: TSQLRest; aDestID: integer; out SourceIDs: TIntegerDynArray): boolean;
    /// retrieve all Dest items IDs associated to the current or
    // specified Source ID, adding a WHERE condition against the Dest rows
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    //  'Salary>:(1000): AND Salary<:(2000):' - note that you should better use
    // inlined parameters for faster processing on server, so you may use the
    // more convenient function
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    // - this is faster than a manual FillMany() then loading each Dest,
    // because the condition is executed in the SQL statement by the server
    function DestGetJoined(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer; out DestIDs: TIntegerDynArray): boolean; overload;
    /// create a Dest record, then FillPrepare() it to retrieve all Dest items
    // associated to the current or specified Source ID, adding a WHERE condition
    // against the Dest rows
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    // 'Salary>:(1000): AND Salary<:(2000):') according to TSQLRecordMany
    // properties - note that you should better use such inlined parameters as
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function DestGetJoined(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer): TSQLRecord; overload;
    /// create a TSQLTable, containing all specified Fields, after a JOIN
    // associated to the current or specified Source ID
    // - the Table will have the fields specified by the JoinKind parameter
    // - aCustomFieldsCSV can be used to specify which fields must be retrieved
    // (for jkDestFields, jkPivotFields, jkPivotAndDestFields) - default is all
    // - if aSourceID is 0, the value is taken from current fSourceID field
    // (set by TSQLRecord.Create)
    // - aDestWhereSQL can specify the Dest table name in the statement, e.g.
    // 'Salary>:(1000): AND Salary<:(2000):') according to TSQLRecordMany
    // properties - note that you should better use such inlined parameters as
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function DestGetJoinedTable(aClient: TSQLRest; const aDestWhereSQL: RawUTF8;
      aSourceID: Integer; JoinKind: TSQLRecordManyJoinKind;
      const aCustomFieldsCSV: RawUTF8=''): TSQLTable;
    /// add a Dest record to the Source record list
    // - returns TRUE on success, FALSE on error
    // - if NoDuplicates is TRUE, the existence of this Source/Dest ID pair
    // is first checked
    // - current Source and Dest properties are filled with the corresponding
    // TRecordReference values corresponding to the supplied IDs
    // - any current value of the additional fields are used to populate the
    // newly created content (i.e. all published properties of this record)
    function ManyAdd(aClient: TSQLRest; aSourceID, aDestID: Integer;
      NoDuplicates: boolean=false): boolean; overload;
    /// add a Dest record to the current Source record list
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function ManyAdd(aClient: TSQLRest; aDestID: Integer;
      NoDuplicates: boolean=false): boolean; overload;
    /// will delete the record associated with a particular Source/Dest pair
    // - will return TRUE if the pair was found and successfully deleted
    // - if aUseBatchMode is TRUE, it will use aClient.BatchDelete() instead
    // of the slower aClient.Delete() method - but you shall call it within
    // a BatchStart / BatchSend block
    function ManyDelete(aClient: TSQLRest; aSourceID, aDestID: Integer;
      aUseBatchMode: boolean=false): boolean; overload;
    /// will delete the record associated with the current source and a specified Dest
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    // - if aUseBatchMode is TRUE, it will use aClient.BatchDelete() instead
    // of the slower aClient.Delete() method - but you shall call it within
    // a BatchStart / BatchSend block
    function ManyDelete(aClient: TSQLRest; aDestID: Integer;
      aUseBatchMode: boolean=false): boolean; overload;
    /// will retrieve the record associated with a particular Source/Dest pair
    // - will return TRUE if the pair was found
    // - in this case, all "through" columns are available in the TSQLRecordMany
    // field instance
    function ManySelect(aClient: TSQLRest; aSourceID, aDestID: Integer): boolean; overload;
    /// will retrieve the record associated with the current source and a specified Dest
    // - source ID is taken from the fSourceID field (set by TSQLRecord.Create)
    // - note that if the Source record has just been added, fSourceID is not
    // set, so this method will fail: please call the other overloaded method
    function ManySelect(aClient: TSQLRest; aDestID: Integer): boolean; overload;

    // get the SQL WHERE statement to be used to retrieve the associated
    // records according to a specified ID
    // - search for aID as Source ID if isDest is FALSE
    // - search for aID as Dest ID if isDest is TRUE
    // - the optional aAndWhereSQL parameter can be used to add any additional
    // condition to the WHERE statement (e.g. 'Salary>:(1000): AND Salary<:(2000):')
    // according to TSQLRecordMany properties - note that you should better use
    // such inlined parameters e.g. calling
    // ! FormatUTF8('Salary>? AND Salary<?',[],[1000,2000])
    function IDWhereSQL(aClient: TSQLRest; aID: integer; isDest: boolean;
      const aAndWhereSQL: RawUTF8=''): RawUTF8;
  end;

  /// a base record, with a JSON-logging capability
  // - used to store a log of events into a JSON text, easy to be displayed
  // with a TSQLTableToGrid
  // - this log can then be stored as a RawUTF8 field property into a result
  // record, e.g.
  TSQLRecordLog = class(TSQLRecord)
  protected
    /// store the Log Table JSON content
    fLogTableStorage: TMemoryStream;
    /// used by Log() to add the value of OneLog to fLogTableStorage
    fLogTableWriter: TJSONSerializer;
    /// current internal row count
    fLogTableRowCount: integer;
    /// maximum rows count
    fMaxLogTableRowCount: integer;
  public
    /// initialize the internal storage with a supplied JSON content
    // - this JSON content must follow the format retrieved by
    // LogTableJSON and LogTableJSONFrom methods
    constructor CreateFrom(OneLog: TSQLRecord; const aJSON: RawUTF8);
    /// release the private fLogTableWriter and fLogTableStorage objects
    destructor Destroy; override;
    /// add the value of OneLog to the Log Table JSON content
    // - the ID property of the supplied OneLog record is incremented before adding
    procedure Log(OneLog: TSQLRecord);
    /// returns the JSON data as added by previous call to Log()
    // - JSON data is in not-expanded format
    // - this function can be called multiple times
    function LogTableJSON: RawUTF8;
    /// returns the internal position of the Log content
    // - use this value to later retrieve a log range with LogTableJSONFrom()
    function LogCurrentPosition: integer;
    /// returns the log JSON data from a given start position
    // - StartPosition was retrieved previously with LogCurrentPosition
    // - if StartPosition=0, the whole Log content is returned
    // - multiple instances of LogCurrentPosition/LogTableJSONFrom() can be
    // used at once
    function LogTableJSONFrom(StartPosition: integer): RawUTF8;
    /// the current associated Log Table rows count value
    // - is incremented every time Log() method is called
    // - will be never higher than MaxLogTableRowCount below (if set)
    property LogTableRowCount: integer read fLogTableRowCount;
    /// if the associated Log Table rows count reachs this value, the
    // first data row will be trimed
    // - do nothing is value is left to 0 (which is the default)
    // - total rows count won't never be higher than this value
    // - used to spare memory usage
    property MaxLogTableRowCount: integer read fMaxLogTableRowCount;
  end;

  /// common ancestor for tables with digitally signed RawUTF8 content
  // - content is signed according to a specific User Name and the digital
  // signature date and time
  // - internaly uses the very secure SHA-256 hashing algorithm for performing
  // the digital signature
  TSQLRecordSigned = class(TSQLRecord)
  protected
    /// time and date of signature
    fSignatureTime: TTimeLog;
    /// hashed signature
    fSignature: RawUTF8;
  public
    /// time and date of signature
    // - if the signature is invalid, this field will contain numerical 1 value
    // - this property is defined here to allow inherited to just declared the name
    // in its published section:
    // ! property SignatureTime;
    property SignatureTime: TTimeLog read fSignatureTime write fSignatureTime;
    /// as the Content of this record is added to the database,
    // its value is hashed and stored as 'UserName/03A35C92....' into this property
    // - very secured SHA-256 hashing is used internaly
    // - digital signature is allowed only once: this property is written only once
    // - this property is defined here to allow inherited to just declared the name
    // in its published section:
    // ! property SignatureTime;
    property Signature: RawUTF8 read fSignature write fSignature;
  public
    /// use this procedure to sign the supplied Content of this record for a
    // specified UserName, with the current Date and Time  (SHA-256 hashing is used
    // internaly)
    // - returns true if signed successfully (not already signed)
    function SetAndSignContent(const UserName: RawUTF8;
      const Content: RawByteString; ForcedSignatureTime: Int64=0): boolean;
    /// returns true if this record content is correct according to the
    // stored digital Signature
    function CheckSignature(const Content: RawByteString): boolean;
    /// retrieve the UserName who digitally signed this record
    // - returns '' if was not digitally signed
    function SignedBy: RawUTF8;
    /// reset the stored digital signature
    // - SetAndSignContent() can be called after this method
    procedure UnSign;
  end;

  /// the possible Server-side instance implementation patterns for Services
  // - each interface-based service will be implemented by a corresponding
  // class instance on the server: this parameter is used to define how
  // class instances are created and managed
  // - on the Client-side, each instance will be handled depending on the
  // server side implementation (i.e. with sicClientDriven behavior if necessary)
  // - sicSingle: one object instance is created per call - this is the
  // most expensive way of implementing the service, but is safe for simple
  // workflows (like a one-type call); this is the default setting for
  // TSQLRestServer.ServiceRegister method
  // - sicShared: one object instance is used for all incoming calls and is
  // not recycled subsequent to the calls - the implementation should be
  // thread-safe on the server side
  // - sicClientDriven: one object instance will be created in synchronization
  // with the client-side lifetime of the corresponding interface: when the
  // interface will be released on client, it will be released on the server
  // side - a numerical identifier will be transmitted for all JSON requests
  // - sicPerSession, sicPerUser and sicPerGroup modes will maintain one
  // object instance per running session / user / group (only working if
  // RESTful authentication is enabled) - since it may be shared among users or
  // groups, the sicPerUser and sicPerGroup implementation should be thread-safe
  TServiceInstanceImplementation = (
    sicSingle, sicShared, sicClientDriven, sicPerSession, sicPerUser, sicPerGroup);

  /// handled kind of parameters for a service provider method
  // - we do not handle all kind of Delphi variables, but provide some
  // enhanced types handled by JSONToObject/ObjectToJSON functions (smvObject)
  // or TDynArray.LoadFromJSON / TTextWriter.AddDynArrayJSON methods (smvDynArray)
  // - records will be serialized as Base64 string, with our RecordSave/RecordLoad
  // low-level format by default, or as true JSON objects, after registration
  // via a TTextWriter.RegisterCustomJSONSerializer call
  TServiceMethodValueType = (
    smvNone,
    smvSelf,
    smvBoolean,
    smvEnum,
    smvSet,
    smvInteger,
    smvCardinal,
    smvInt64,
    smvDouble,
    smvDateTime,
    smvCurrency,
    smvRawUTF8,
    smvString,
    smvWideString,
    smvRecord,
    smvObject,
    smvDynArray);

  /// handled kind of parameters internal variables
  // - reference-counted variables will have their own storage
  // - all non referenced-counted variables are stored within some 64 bit content
  TServiceMethodValueVar = (
    smvvNone, smvvSelf, smvv64, smvvRawUTF8, smvvString, smvvWideString,
    smvvRecord, smvvObject, smvvDynArray);

  /// set of parameters for a service provider method
  TServiceMethodValueTypes = set of TServiceMethodValueType;

  /// handled kind of parameters direction for a service provider method
  // - IN, IN/OUT, OUT directions can be applied to arguments, and will
  // be available through our JSON-serialized remote access: smdVar and smdOut
  // kind of parameters will be returned within the "result": JSON array
  // - smdResult is used for a function method, to handle the returned value
  TServiceMethodValueDirection = (
    smdConst,
    smdVar,
    smdOut,
    smdResult);

  /// describe a service provider method argument
  TServiceMethodArgument = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the argument name, as declared in Delphi
    ParamName: PShortString;
    /// the type name, as declared in Delphi
    TypeName: PShortString;
    /// the low-level RTTI information of this argument
    TypeInfo: PTypeInfo;
    /// we do not handle all kind of Delphi variables
    ValueType: TServiceMethodValueType;
    /// how the variable may be stored
    ValueVar: TServiceMethodValueVar;
    /// how the variable is to be passed (by value vs by reference)
    ValueDirection: TServiceMethodValueDirection;
    /// true for smvRawUTF8, smvString, smvWideString and  kind of parameter 
    // - smvRecord has it to false, even if they are Base-64 encoded within
    // the JSON content
    ValueIsString: boolean;
    /// byte offset in the CPU stack of this argument
    //  - if -1 for EAX, -2 for EDX and -3 for ECX registers
    OffsetInStack: integer;
    /// size (in bytes) of this argument on the stack
    SizeInStack: integer;
    /// size (in bytes) of this smvv64 ordinal value
    // - e.g. depending of the associated kind of enumeration
    SizeInStorage: integer;
    /// index of the associated variable in the local array[ArgsUsedCount[]]
    // - for smdConst argument, contains -1 (no need to a local var: the value
    // will be on the stack only)
    IndexVar: integer;
    /// serialize the argument into the TServiceContainer.Contract JSON format
    // - non standard types (e.g. clas, enumerate, dynamic array or record)
    // are identified by their type identifier - so contract does not extend
    // up to the content of such high-level structures
    function SerializeToContract: RawUTF8;
  end;

  /// describe a service provider method arguments
  TServiceMethodArgumentDynArray = array of TServiceMethodArgument;

  /// possible service provider method execution options
  TServiceMethodExecutionOption = (execInMainThread);

  /// set of per-method execution options for a service provider
  TServiceMethodExecutionOptions = set of TServiceMethodExecutionOption;

  /// describe a service provider method
  TServiceMethod = {$ifndef UNICODE}object{$else}record{$endif}
  public
    /// the method URI
    // - basicaly the method name as declared in Delphi code (e.g. 'Add' for
    // ICalculator.Add)
    // - this property value is hashed internaly for faster access
    URI: RawUTF8;
    /// describe expected method arguments
    // - Args[0] always is smvSelf
    // - if method is a function, an additional smdResult argument is appended
    Args: TServiceMethodArgumentDynArray;
    /// the index of the result pseudo-argument in Args[]
    // - is -1 if the method is defined as a (not a function)
    ArgsResultIndex: integer;
    /// true if the result is a TServiceCustomAnswer record
    // - that is, a custom Header+Content BLOB transfert, not a JSON object
    ArgsResultIsServiceCustomAnswer: boolean;
    /// needed CPU stack size (in bytes) for all arguments
    ArgsSizeInStack: cardinal;
    /// contains all used kind of arguments
    ArgsUsed: set of TServiceMethodValueType;
    /// contains the count of variables for all used kind of arguments
    ArgsUsedCount: array[TServiceMethodValueVar] of integer;
    /// method index in the original interface
    // - our custom methods start at index 3, since QueryInterface, _AddRef,
    // and _Release methods are always defined by default
    MethodIndex: integer;
    /// the list of denied TSQLAuthGroup ID(s)
    // - used on server side within TSQLRestServer.LaunchService method
    // - bit 0 for client TSQLAuthGroup.ID=1 and so on...
    // - is therefore able to store IDs up to 256
    // - void by default, i.e. no denial = all groups allowed for this method
    ExecutionDenied: set of 0..255;
    /// execution options for this method
    // - you can e.g. force a method to be executed in the main thread
    // by calling TServiceFactoryServer.ExecuteInMainThread() 
    ExecutionOptions: TServiceMethodExecutionOptions;
    /// for better alignment of the fMethods[] items
    Padding: array[0..2] of byte;
    /// execute the corresponding method of a given TInterfacedObject instance
    // - will retrieve a JSON array of parameters from Par
    // - will append a JSON array of results in Res, or set an Error message
    function InternalExecute(Instances: array of pointer; Par: PUTF8Char;
      Res: TTextWriter; var aHead: RawUTF8): boolean;
  end;

  /// describe a service provider methods
  TServiceMethodDynArray = array of TServiceMethod;

  /// a record type to be used as result for a function method for custom content
  // - all answers are pure JSON object by default: using this kind of record
  // as result will allow a response of any type (e.g. binary, HTML or text)
  // - this kind of answer will be understood by our TServiceContainerClient
  // implementation, and it may be used with plain AJAX or HTML requests
  // (via POST), to retrieve some custom content
  TServiceCustomAnswer = record
    /// the response type, as encoded in the HTTP header
    // - useful to set the response mime-type - see e.g. the
    // TEXT_CONTENT_TYPE_HEADER or HTML_CONTENT_TYPE_HEADER constants or
    // GetMimeContentType() function
    // - in order to be handled as expected, this field SHALL be set (<>'')
    // (otherwise it will transmitted with default JSON object format)
    Header: RawUTF8;
    /// the response body
    Content: RawByteString;
  end;

  PServiceCustomAnswer = ^TServiceCustomAnswer;

  {$ifndef LVCL}
  /// any TCollection used between client and server shall inherit from this class
  // - you should override the GetClass virtual method to provide the
  // expected collection item class to be used on server side
  TInterfacedCollection = class(TCollection)
  protected
    /// you shall override this abstract method
    function GetClass: TCollectionItemClass; virtual; abstract;
  public
    /// this constructor which will call GetClass to initialize the collection
    constructor Create; reintroduce; virtual;
  end;
  {$endif LVCL}

  /// a common ancestor for any class needing interface RTTI
  TInterfaceFactory = class
  protected
    fInterfaceTypeInfo: PTypeInfo;
    fInterfaceIID: TGUID;
    fMethodsCount: cardinal;
    fMethods: TServiceMethodDynArray;
    fMethod: TDynArrayHashed;
    procedure AddMethodsFromTypeInfo(aInterface: PTypeInfo);
  public
    /// initialize the internal properties from the supplied interface RTTI
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for later use
    constructor Create(aInterface: PTypeInfo);
    /// find the index of a particular method in internal Methods[] list
    function FindMethodIndex(const aMethodName: RawUTF8): integer;
    /// the declared internal methods
    // - list list does not contain the default AddRef/
    property Methods: TServiceMethodDynArray read fMethods;
  end;

  /// an abstract service provider, as registered in TServiceContainer
  // - each registered interface has its own TServiceFactory instance, available
  // as one TSQLServiceContainer item from TSQLRest.Services property
  // - this will be either implemented by a registered TInterfacedObject on the
  // server, or by a on-the-fly generated fake TInterfacedObject class
  // communicating via JSON on a client
  // - TSQLRestServer will have to register an interface implementation as:
  // ! Server.ServiceRegister(TServiceCalculator,[TypeInfo(ICalculator)],sicShared);
  // - TSQLRestClientURI will have to register an interface remote access as:
  // ! Client.ServiceRegister([TypeInfo(ICalculator)],sicShared));
  // note that the implementation (TServiceCalculator) remain on the server side
  // only: the client only needs the ICalculator interface
  // - then TSQLRestServer and TSQLRestClientURI will both have access to the
  // service, via their Services property, e.g. as:
  // ! if Services.GUID(IID_ICalculator).Get(I) then
  // !   result := I.Add(10,20);
  TServiceFactory = class(TInterfaceFactory)
  protected
    fInterfaceURI: RawUTF8;
    fInterfaceMangledURI: RawUTF8;
    fInstanceCreation: TServiceInstanceImplementation;
    fRest: TSQLRest;
    fSharedInstance: TObject;
    fContract: RawUTF8;
    fContractHash: RawUTF8;
    fContractExpected: RawUTF8;
  public
    /// initialize the service provider parameters
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for its serialized execution
    constructor Create(aRest: TSQLRest; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation);
    /// retrieve an instance of this interface
    // - this virtual method will be overriden to reflect the expected
    // behavior of client or server side
    function Get(out Obj): Boolean; virtual; abstract;
    /// retrieve the published signature of this interface
    // - is always available on TServiceFactoryServer, but TServiceFactoryClient
    // will be able to retrieve it only if TServiceContainerServer.PublishSignature
    // is set to TRUE (which is not the default setting, for security reasons)
    function RetrieveSignature: RawUTF8; virtual; abstract;
    /// the associated RESTful instance
    property Rest: TSQLRest read fRest;
    /// the registered Interface low-level Delphi RTTI type
    property InterfaceTypeInfo: PTypeInfo read fInterfaceTypeInfo;
    /// the registered Interface GUID
    property InterfaceIID: TGUID read fInterfaceIID;
    /// the registered Interface URI
    // - in fact this is the Interface name without the initial 'I', e.g.
    // 'Calculator' for ICalculator
    property InterfaceURI: RawUTF8 read fInterfaceURI;
    /// the registered Interface mangled URI
    // - in fact this is encoding the GUID using BinToBase64URI(), e.g.
    // ! ['{c9a646d3-9c61-4cb7-bfcd-ee2522c8f633}'] into '00amyWGct0y_ze4lIsj2Mw'
    // - can be substituted to the clear InterfaceURI name
    property InterfaceMangledURI: RawUTF8 read fInterfaceMangledURI;
    /// how each class instance is to be created
    // - only relevant on the server side; on the client side, this class will
    // be accessed only to retrieve a remote access instance, i.e. sicSingle
    property InstanceCreation: TServiceInstanceImplementation read fInstanceCreation;
    (*/ the service contract, serialized as a JSON object
    - a "contract" is in fact the used interface signature, i.e. its
      implementation mode (InstanceCreation) and all its methods definitions
    - a possible value for a one-method interface defined as such:
    ! function ICalculator.Add(n1,n2: integer): integer;
    may be returned as the following JSON object:
    $ {"contract":"Calculator","implementation":"shared",
    $  "methods":[{"method":"Add",
    $  "arguments":[{"argument":"Self","direction":"in","type":"self"},
    $               {"argument":"n1","direction":"in","type":"integer"},
    $               {"argument":"n2","direction":"in","type":"integer"},
    $               {"argument":"Result","direction":"out","type":"integer"}
    $ ]}]} *)
    property Contract: RawUTF8 read fContract;
    /// a hash of the service contract, serialized as a JSON string
    // - this may be used instead of the JSON signature, to enhance security
    // (i.e. if you do not want to publish the available methods, but want
    // to check for the proper synchronization of both client and server)
    // - a possible value may be: "C351335A7406374C"
    property ContractHash: RawUTF8 read fContractHash;
    /// the published service contract, as expected by both client and server
    // - by default, will contain ContractHash property value (for security)
    // - but you can override this value using plain Contract or any custom
    // value (e.g. a custom version number) - in this case, both TServiceFactoryClient
    // and TServiceFactoryServer instances must have a matching ContractExpected
    // - this value is returned by a '_contract_' pseudo-method name, with the URI:
    // $ POST /root/Interface._contract_
    // or (if rmJSON_RPC is used):
    // $ POST /root/Interface
    // $ (...)
    // $ {"method":"_contract_","params":[]}
    // (e.g. to be checked in TServiceFactoryClient.Create constructor)
    property ContractExpected: RawUTF8 read fContractExpected write fContractExpected;
  end;

  /// server-side service provider uses this to store one internal instance
  // - used by TServiceFactoryServer in sicClientDriven, sicPerSession,
  // sicPerUser or sicPerGroup mode
  TServiceFactoryServerInstance = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// the internal Instance ID, as remotely sent in "id":1
    // - is set to 0 when an entry in the array is free
    InstanceID: Cardinal;
    /// last time stamp access of this instance
    LastAccess: Cardinal;
    /// the implementation instance itself
    Instance: TObject;
    /// used to catch and ignore any exception in Instance.Free
    procedure SafeFreeInstance;
  end;

  /// server-side service provider uses this to store its internal instances
  // - used by TServiceFactoryServer in sicClientDriven, sicPerSession,
  // sicPerUser or sicPerGroup mode
  TServiceFactoryServerInstanceDynArray = array of TServiceFactoryServerInstance;

  /// a service provider implemented on the server side
  // - each registered interface has its own TServiceFactoryServer instance,
  // available as one TSQLServiceContainerServer item from TSQLRest.Services property
  // - will handle the implementation class instances of a given interface
  // - by default, all methods are allowed to execution: you can call AllowAll,
  // DenyAll, Allow or Deny in order to specify your exact security policy
  TServiceFactoryServer = class(TServiceFactory)
  protected
    fInstances: TServiceFactoryServerInstanceDynArray;
    fInstance: TDynArray;
    fInstancesCount: integer;
    fInstanceCurrentID: integer;
    fInstanceTimeOut: cardinal;
    fInstanceLock: TRTLCriticalSection;
    fImplementationClass: TClass;
    fSharedInterface: IInterface;
    /// get an implementation Inst.Instance for the given Inst.InstanceID
    // - is called by ExecuteMethod() in sicClientDrive mode
    // - returns true for successfull {"method":"_free_".. call (aMethodIndex=-1)
    // - otherwise, fill Inst.Instance with the matching implementation (or nil)
    function InternalInstanceRetrieve(var Inst: TServiceFactoryServerInstance;
      aMethodIndex: integer): boolean;
    /// call a given method of this service provider
    // - aMethodIndex is the index in Methods[]
    // - if aMethodIndex=-1, then it will free/release corresponding aInstanceID
    // (is called  e.g. from {"method":"_free_", "params":[], "id":1234} )
    // - aParamsJSONArray is e.g. '[1,2]' i.e. a true JSON array, which will
    // contain the incoming parameters in the same exact order than the
    // corresponding implemented interface method
    // - aInstanceID is an optional number, to be used in case of sicClientDriven
    // kind of InstanceCreation
    // - returns 200/HTML_SUCCESS on success, or an HTTP error status, with an
    // optional error message in aErrorMsg
    // - on success, aResp shall contain a serialized JSON object with one
    // nested result property, which may be a JSON array, containing the
    // all "var" or "out" parameters values, and then the method main result -
    // for instance, ExecuteMethod(..,'[1,2]') over ICalculator.Add will return:
    // $ {"result":[3],"id":0}
    // the returned "id" number is the Instance identifier to be used for any later
    // sicClientDriven remote call - or just 0 in case of sicSingle or sicShared
    function ExecuteMethod(const aContext: TSQLRestServerSessionContext;
      aMethodIndex, aInstanceID: cardinal; aParamsJSONArray: PUTF8Char;
      var aResp, aHead, aErrorMsg: RawUTF8): cardinal;
    /// this method will create an implementation instance
    function CreateInstance: TObject;
  public
    /// initialize the service provider on the server side
    // - expect an implementation class
    // - for sicClientDriven, sicPerSession, sicPerUser or sicPerGroup modes,
    // a time out (in seconds) can be defined - if the time out is 0, interface
    // will be forced in sicSingle mode
    // - you should usualy have to call the TSQLRestServer.ServiceRegister()
    // method instead of calling this constructor directly 
    constructor Create(aRestServer: TSQLRestServer; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      aImplementationClass: TClass;
      aTimeOutSec: cardinal=30*60); reintroduce;
    /// release all used memory
    // - e.g. any internal TServiceFactoryServerInstance instances (any shared
    // instance, and all still living instances in sicClientDrive mode)
    destructor Destroy; override;

    /// allow all methods execution for all TSQLAuthGroup
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAll: TServiceFactoryServer; 
    /// allow all methods execution for the specified TSQLAuthGroup ID(s)
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAllByID(const aGroupID: array of integer): TServiceFactoryServer;
    /// allow all methods execution for the specified TSQLAuthGroup names
    // - is just a wrapper around the other AllowAllByID() method, retrieving the
    // Group ID from its main field
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// deny all methods execution for all TSQLAuthGroup
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAll: TServiceFactoryServer;
    /// deny all methods execution for the specified TSQLAuthGroup ID(s)
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAllByID(const aGroupID: array of integer): TServiceFactoryServer;
    /// dent all methods execution for the specified TSQLAuthGroup names
    // - is just a wrapper around the other DenyAllByID() method, retrieving the
    // Group ID from its main field
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// allow specific methods execution for the all TSQLAuthGroup
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function Allow(const aMethod: array of RawUTF8): TServiceFactoryServer;
    /// allow specific methods execution for the specified TSQLAuthGroup ID(s)
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - the specified group ID(s) will be used to authorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
    /// allow specific methods execution for the specified TSQLAuthGroup name(s)
    // - is just a wrapper around the other AllowByID() method, retrieving the
    // Group ID from its main field
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function AllowByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// deny specific methods execution for the all TSQLAuthGroup
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - all Groups will be affected by this method (on both client and server sides)
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function Deny(const aMethod: array of RawUTF8): TServiceFactoryServer;
    /// deny specific methods execution for the specified TSQLAuthGroup ID(s)
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - the specified group ID(s) will be used to unauthorize remote service
    // calls from the client side
    // - you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fServer.MainFieldID(TSQLAuthGroup,'User');
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer; overload;
    /// deny specific methods execution for the specified TSQLAuthGroup name(s)
    // - is just a wrapper around the other DenyByID() method, retrieving the
    // Group ID from its main field
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - this method returns self in order to allow direct chaining of security
    // calls, in a fluent interface
    function DenyByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
    /// force a method to be executed in the main thread
    // - by default, service methods are called within the thread which received
    // them, on multi-thread server instances (e.g. TSQLite3HttpServer or
    // TSQLRestServerNamedPipeResponse), for better response time and CPU use -
    // methods have to handle multi-threading safety carefully, e.g. by using
    // TRTLCriticalSection mutex on purpose
    // - ExecuteInMainThread() will force the method to be called within a
    // RunningThread.Synchronize() call - it can be used e.g. if your
    // implementation rely heavily on COM servers
    // - methods names should be specified as an array (e.g. ['Add','Multiply'])
    // - if not method name is specified (i.e. []), all methods will be set
    // - if Enable is left to TRUE default value, it will force main-thread
    // execution; if set to FALSE, it will set it back to in-thread faster
    // method execution
    // - this method returns self in order to allow direct chaining of setting
    // calls for the service, in a fluent interface
    function ExecuteInMainThread(const aMethod: array of RawUTF8; Enable: boolean=true): TServiceFactoryServer;

    /// retrieve an instance of this interface from the server side
    // - sicShared mode will retrieve the shared instance
    // - all other kind of instance creation will behave the same as sicSingle
    // when accessed directly from this method, i.e. from server side
    function Get(out Obj): Boolean; override;
    /// retrieve the published signature of this interface
    // - is always available on TServiceFactoryServer, but TServiceFactoryClient
    // will be able to retrieve it only if TServiceContainerServer.PublishSignature
    // is set to TRUE (which is not the default setting, for security reasons)
    function RetrieveSignature: RawUTF8; override;

    /// just typecast the associated TSQLRest instance to a true TSQLRestServer
    function RestServer: TSQLRestServer;
      {$ifdef HASINLINE}inline;{$endif}
  end;

  /// a service provider implemented on the client side
  // - each registered interface has its own TServiceFactoryClient instance,
  // available as one TSQLServiceContainerClient item from TSQLRest.Services property
  // - will emulate "fake" implementation class instance of a given interface
  // and call remotely the server to process the actual implementation
  TServiceFactoryClient = class(TServiceFactory)
  protected
    fClient: TSQLRestClientURI;
    fFakeVTable: array of pointer;
    fFakeStub: PByteArray;
    function CallClient(const aMethod: RawUTF8; aErrorMsg: PRawUTF8=nil;
      const aParams: RawUTF8=''; aResult: PRawUTF8=nil; aClientDrivenID: PCardinal=nil;
      aServiceCustomAnswer: PServiceCustomAnswer=nil): boolean;
  public
    /// initialize the service provider parameters
    // - it will check and retrieve all methods of the supplied interface,
    // and prepare all internal structures for its serialized execution
    // - it will also ensure that the corresponding TServiceFactory.Contract
    // matches on both client and server sides, either by comparing the default
    // signature (based on methods and arguments), either by using the supplied
    // expected contract (which may be a custom version number)
    constructor Create(aRest: TSQLRest; aInterface: PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      const aContractExpected: RawUTF8='');
    /// finalize the service provider used structures
    // - especially the internal shared VTable and code Stub
    destructor Destroy; override;
    /// retrieve an instance of this interface from the server side
    function Get(out Obj): Boolean; override;
    /// retrieve the published signature of this interface
    // - TServiceFactoryClient will be able to retrieve it only if
    // TServiceContainerServer.PublishSignature is set to TRUE (which is not the
    // default setting, for security reasons) - this function is always available
    // on TServiceFactoryServer side
    function RetrieveSignature: RawUTF8; override;
  end;

  /// the routing mode of the service remote request
  // - by default, will use an URI-based layout (rmREST), in which the service
  // will be identified within the URI, as
  // $ /Model/Interface.Method[/ClientDrivenID]
  // e.g. for ICalculator.Add:
  // $ POST /root/Calculator.Add
  // $ (...)
  // $ [1,2]
  // or, for a sicClientDriven mode service:
  // $ POST /root/ComplexNumber.Add/1234
  // $ (...)
  // $ [20,30]
  // in this case, the sent content will be a JSON array of [parameters...]
  // (one benefit of using URI is that it will be more secured in our RESTful
  // authentication scheme: each method and even client driven session will
  // be signed properly)
  // - if rmJSON_RPC is used, the URI will define the interface, then the
  // method name will be inlined with parameters, e.g.
  // $ POST /root/Calculator
  // $ (...)
  // $ {"method":"Add","params":[1,2]}
  // or, for a sicClientDriven mode service:
  // $ POST /root/ComplexNumber
  // $ (...)
  // $ {"method":"Add","params":[20,30],"id":1234}
  TServiceRoutingMode = (rmREST, rmJSON_RPC);

  /// a global services provider class
  // - used to maintain a list of interfaces implementation
  TServiceContainer = class
  protected
    fRest: TSQLRest;
    fList: TRawUTF8ListHashed;
    fListInterfaceMethod: TRawUTF8ListHashed;
    fExpectMangledURI: boolean;
    procedure SetExpectMangledURI(aValue: Boolean);
    procedure CheckInterface(const aInterfaces: array of PTypeInfo);
    function AddServiceInternal(aService: TServiceFactory): integer;
    /// retrieve a service provider from its URI
    function GetService(const aURI: RawUTF8): TServiceFactory;
  public
    /// initialize the list
    constructor Create(aRest: TSQLRest);
    /// release all registered services
    destructor Destroy; override;
    /// return the number of registered service interfaces
    function Count: integer;
    /// method called on the client side to register a service via its interface(s)
    // - will add a TServiceFactoryClient instance to the internal list
    // - is called e.g. by TSQLRestClientURI.ServiceRegister or even by
    // TSQLRestServer.ServiceRegister(aClient: TSQLRest...) for a remote access -
    // use TServiceContainerServer.AddImplementation() instead for normal
    // server side implementation
    // - will raise an exception on error
    // - will return true if some interfaces have been added
    // - will check for the availability of the interfaces on the server side,
    // with an optional custom contract to be used instead of methods signature
    // (only for the first interface)
    function AddInterface(const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation;
      aContractExpected: RawUTF8=''): boolean;
    /// retrieve a service provider from its index in the list
    // - returns nil if out of range index
    function Index(aIndex: integer): TServiceFactory; overload; {$ifdef HASINLINE}inline;{$endif}
    /// retrieve a service provider from its GUID
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the GUID does not match any registered interface
    function GUID(const aGUID: TGUID): TServiceFactory; overload;
    /// retrieve a service provider from its type information
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the type information does not match any registered interface
    function Info(aTypeInfo: PTypeInfo): TServiceFactory; overload; virtual;
    /// retrieve a service provider from its URI
    // - it expects the supplied URI variable  to be e.g. '00amyWGct0y_ze4lIsj2Mw'
    // or 'Calculator', depending on the ExpectMangledURI property
    // - on match, it  will return the service the corresponding interface factory
    // - returns nil if the URI does not match any registered interface
    property Services[const aURI: RawUTF8]: TServiceFactory read GetService; default;
    /// the associated RESTful instance
    property Rest: TSQLRest read fRest;
    /// set if the URI is expected to be mangled from the GUID
    // - by default (FALSE), the clear service name is expected to be supplied at
    // the URI level (e.g. 'Calculator')
    // - if this property is set to TRUE, the mangled URI value will be expected
    // instead (may enhance security) - e.g. '00amyWGct0y_ze4lIsj2Mw'
    property ExpectMangledURI: boolean read fExpectMangledURI write SetExpectMangledURI;
  end;

  /// a services provider class to be used on the server side
  // - this will maintain a list of true implementation classes
  TServiceContainerServer = class(TServiceContainer)
  protected
    fPublishSignature: boolean;
    /// make some garbage collection when session is finished
    procedure OnCloseSession(aSessionID: cardinal); virtual;
  public
    /// method called on the server side to register a service via its
    // interface(s) and a specified implementation class
    // - will add a TServiceFactoryServer instance to the internal list
    // - will raise an exception on error
    // - will return the first of the registered TServiceFactoryServer created
    // on success (i.e. the one corresponding to the first item of the aInterfaces
    // array), or nil if registration failed (e.g. if any of the supplied interfaces
    // is not implemented by the given class)
    // - the same implementation class can be used to handle several interfaces
    // (just as Delphi allows to do natively)
    function AddImplementation(aImplementationClass: TClass;
      const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation): TServiceFactoryServer;
    /// defines if the "method":"_signature_" or /root/Interface._signature
    // pseudo method is available to retrieve the whole interface signature,
    // encoded as a JSON object
    // - is set to FALSE by default, for security reasons: only "_contract_"
    // pseudo method is available - see TServiceContainer.ContractExpected
    property PublishSignature: boolean read fPublishSignature write fPublishSignature;
  end;

  /// a services provider class to be used on the client side
  // - this will maintain a list of fake implementation classes, which will
  // remotely call the server to make the actual process
  TServiceContainerClient = class(TServiceContainer)
  protected
  public
    /// retrieve a service provider from its type information
    // - this overriden method will register the interface, if was not yet made
    // - in this case, the interface will be registered with sicClientDriven
    // implementation method
    function Info(aTypeInfo: PTypeInfo): TServiceFactory; overload; override;
  end;

  /// for TSQLRestCache, stores a table values
  TSQLRestCacheEntryValue = record
    /// corresponding ID
    ID: integer;
    /// GetTickCount value when this cached value was stored
    // - equals 0 licwhen there is no JSON value cached
    TimeStamp: cardinal; 
    /// JSON encoded UTF-8 serialization of the record
    JSON: RawUTF8;
  end;

  /// for TSQLRestCache, stores all tables values
  TSQLRestCacheEntryValueDynArray = array of TSQLRestCacheEntryValue;

  /// for TSQLRestCache, stores a table settings and values
  TSQLRestCacheEntry = {$ifndef UNICODE}object{$else}record{$endif}
  public
    /// TRUE if this table should use caching
    // - i.e. if was not set, or worth it for this table (e.g. in-memory table)
    CacheEnable: boolean;
    /// the whole specified Table content will be cached
    CacheAll: boolean;
    /// time out value (in ms)
    // - if 0, caching will never expire
    TimeOut: Cardinal;
    /// the number of entries stored in Values[]
    Count: integer;
    /// all cached IDs and JSON content
    Values: TSQLRestCacheEntryValueDynArray;
    /// TDynArray wrapper around the Values[] array
    Value: TDynArray;
    /// used to lock the table cache for multi thread safety
    Mutex: TRTLCriticalSection;
    /// flush cache for a given Value[] index
    procedure FlushCacheEntry(Index: Integer);
    /// flush cache for all Value[]
    procedure FlushCacheAllEntries;
    /// update/refresh the cached JSON serialization of a given ID 
    procedure SetJSON(aID: integer; const aJSON: RawUTF8); overload;
    /// update/refresh the cached JSON serialization of a supplied Record
    procedure SetJSON(aRecord: TSQLRecord); overload;
    /// retrieve a JSON serialization of a given ID from cache
    function RetrieveJSON(aID: integer; var aJSON: RawUTF8): boolean; overload;
    /// unserialize a JSON cached record of a given ID
    function RetrieveJSON(aID: integer; aValue: TSQLRecord): boolean; overload;
  end;

  {/ implement a fast cache content at the TSQLRest level
   - purpose of this caching mechanism is to speed up retrieval of some common
     values at either Client or Server level (like configuration settings)
   - only caching synchronization is about the following RESTful basic commands:
     RETRIEVE, ADD, DELETION and UPDATE (that is, a complex direct SQL UPDATE
     or via TSQLRecordMany pattern won't be taken in account)
   - only Simple fields are cached: e.g. the BLOB fields are not stored
   - this cache is thread-safe (access is locked per table)
   - this caching will be located at the TSQLRest level, that is no automated
     synchronization is implemented between TSQLRestClient and TSQLRestServer:
     you shall ensure that your code won't fail due to this restriction }
  TSQLRestCache = class(TObject)
  protected
    fRest: TSQLRest;
    /// fCache[] follows fModel.Tables[] array
    fCache: array of TSQLRestCacheEntry;
    /// retrieve a record specified by its ID from cache into JSON content
    // - return '' if the item is not in cache
    function Retrieve(aTableIndex, aID: integer): RawUTF8; overload;
    /// fill a record specified by its ID from cache into a new TSQLRecord instance
    // - return false if the item is not in cache
    // - this method will call RetrieveJSON method, unserializing the cached
    // JSON content into the supplied aValue instance
    function Retrieve(aID: Integer; aValue: TSQLRecord): boolean; overload;
  public
    /// create a cache instance
    // - the associated TSQLModel will be used internaly
    constructor Create(aRest: TSQLRest); reintroduce;
    /// release the cache instance
    destructor Destroy; override;
    /// flush the cache
    // - this will flush all stored JSON content, but keep the settings
    // (SetCache/SetTimeOut) as before
    procedure Flush; overload; 
    /// flush the cache for a given table
    // - this will flush all stored JSON content, but keep the settings
    // (SetCache/SetTimeOut) as before for this table
    procedure Flush(aTable: TSQLRecordClass); overload; 
    /// flush the cache for a given record
    // - this will flush the stored JSON content for this record (and table
    // settings will be kept)
    procedure Flush(aTable: TSQLRecordClass; aID: integer); overload;
    /// flush the cache, and destroy all settings
    // - this will flush all stored JSON content, AND destroy the settings
    // (SetCache/SetTimeOut) to default (i.e. no cache enabled)
    procedure Clear;
    {/ activate the internal caching for a whole Table
     - any cached item of this table will be flushed
     - return true on success }
    function SetCache(aTable: TSQLRecordClass): boolean; overload;
     {/ activate the internal caching for a given TSQLRecord
     - if this item is already cached, do nothing
     - return true on success }
    function SetCache(aTable: TSQLRecordClass; aID: Integer): boolean; overload;
     {/ activate the internal caching for a given TSQLRecord
     - will cache the specified aRecord.ID item
     - if this item is already cached, do nothing
     - return true on success }
    function SetCache(aRecord: TSQLRecord): boolean; overload;
    {/ set the internal caching time out delay (in ms) for a given table
     - time out setting is common to all items of the table
     - if aTimeOut is left to its default 0 value, caching will never expire
     - return true on success }
    function SetTimeOut(aTable: TSQLRecordClass; aTimeout: Integer): boolean;
    /// returns the number of JSON serialization records within this cache
    function CachedEntries: cardinal;
    /// returns the memory used by JSON serialization records within this cache
    function CachedMemory: cardinal;
    /// read-only access to the associated TSQLRest instance
    property Rest: TSQLRest read fRest;
  public { TSQLRest low level methods which are not to be called usualy: } 
    /// TSQLRest instance shall call this method when a record is added or updated
    // - this overloaded method expects the content to be specified as JSON object
    procedure Notify(aTable: TSQLRecordClass; aID: integer; const aJSON: RawUTF8;
     aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is retrieved,
    // added or updated
    // - this overloaded method expects the content to be specified as JSON object,
    // and TSQLRecordClass to be specified as its index in Rest.Model.Tables[]
    procedure Notify(aTableIndex: integer; aID: integer; const aJSON: RawUTF8;
      aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is added or updated
    // - this overloaded method will call the other Trace method, serializing
    // the supplied aRecord content as JSON (not in the case of seDelete)
    procedure Notify(aRecord: TSQLRecord; aAction: TSQLOccasion); overload;
    /// TSQLRest instance shall call this method when a record is deleted
    // - this method is dedicated for a record deletion
    procedure NotifyDeletion(aTable: TSQLRecordClass; aID: integer); overload;
    /// TSQLRest instance shall call this method when a record is deleted
    // - this method is dedicated for a record deletion
    // - TSQLRecordClass to be specified as its index in Rest.Model.Tables[]
    procedure NotifyDeletion(aTableIndex, aID: integer); overload;
  end;

  TSQLRestClass = class of TSQLRest;

  /// a generic REpresentational State Transfer (REST) client/server class
  TSQLRest = class(TObject)
  protected
    fModel: TSQLModel;
    fCache: TSQLRestCache;
    fTransactionActive: cardinal;
    fTransactionTable: TSQLRecordClass;
    fTransactionCriticalSession: TRTLCriticalSection;
    fAcquireWriteTimeOut: cardinal;
    fServerTimeStampOffset: TDateTime;
    fServerTimeStampCacheTix: cardinal;
    fServerTimeStampCacheValue: Iso8601;
    fServices: TServiceContainer;
    fRouting: TServiceRoutingMode;
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions below
    // - overriden in TSQLRestClientURI and TSQLRestServer with proper method
    function InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
      overload; virtual; abstract;
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions below
    // - call virtual abstract InternalListJSON() method to get the list content
    // - FieldName can be a CSV list of needed field names, if needed
    function InternalListJSON(Table: TSQLRecordClass; const FieldName, WhereClause: RawUTF8): TSQLTableJSON; overload;
    /// retrieve all fields for a list of members JSON encoded data
    // - this special method gets all fields content for a specified table:
    // the resulting TSQLTableJSON content can be used to fill whole records
    // instances by using the TSQLRecord.FillPrepare() and TSQLRecord.FillRow()
    // methods
    // - call virtual abstract InternalListJSON() method to get the list content
    function InternalListRecordsJSON(Table: TSQLRecordClass; const WhereClause: RawUTF8): TSQLTableJSON;
    /// override this method to guess if this record can be updated or deleted
    // - this default implementation returns always true
    // - e.g. you can add digital signature to a record to disallow record editing
    // - the ErrorMsg can be set to a variable, which will contain an explicit
    // error message
    function RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
      ErrorMsg: PRawUTF8 = nil): boolean; virtual;
    /// internal method used by Delete(Table,SQLWhere) method
    function InternalDelete(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      var IDs: TIntegerDynArray): boolean; 
    /// wait for the transaction critical section to be acquired
    // - used to implement a thread-safe and transaction-safe write to the DB
    // - returns FALSE in case of time out (see AcquireWriteTimeOut property)
    // - returns TRUE if it's safe to write to the DB - in this case, you must
    // call ReleaseWrite when done to release the fTransactionCriticalSession
    function AcquireWrite(const aContext: TSQLRestServerSessionContext): Boolean;
    /// release the fTransactionCriticalSession
    procedure ReleaseWrite;
    /// retrieve the server time stamp
    // - default implementation will use fServerTimeStampOffset to compute
    // the value from PC time (i.e. Now+fServerTimeStampOffset as TTimeLog)
    // - inherited classes may override this method, or set the appropriate
    // value in fServerTimeStampOffset protected field
    function GetServerTimeStamp: TTimeLog; virtual;
    /// compute the server time stamp offset from the given
    procedure SetServerTimeStamp(const Value: TTimeLog);
    /// handle Client or Server side fast in-memory cache
    // - creates the internal fCache instance, if necessary
    function GetCache: TSQLRestCache;
    /// returns TRUE if this table is worth caching (e.g. not in memory)
    // - this default implementation always returns TRUE (always allow cache)
    function CacheWorthItForTable(aTableIndex: cardinal): boolean; virtual;
 protected // these abstract methods must be inherited by real database engine
    /// retrieve a list of members as JSON encoded data (implements REST GET Collection)
    // - returns '' on error, or JSON data, even with no result rows
    // - override this method for direct data retrieval from the database engine
    // and direct JSON export, avoiding a TSQLTable which allocates memory for every
    // field values before the JSON export
    // - can be called for a single Table (ModelRoot/Table), or with low level SQL
    // query (ModelRoot + SQL sent as request body)
    // - if ReturnedRowCount points to an integer variable, it must be filled with
    // the number of row data returned (excluding field names)
    // - this method must be implemented in a thread-safe manner
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; virtual; abstract;
    /// create a new member (implements REST POST Collection)
    // - SentData can contain the JSON object with field values to be added
    // - class is taken from Model.Tables[TableModelIndex]
    // - returns the TSQLRecord ID/ROWID value, 0 on error
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; virtual; abstract;
    /// update a member (implements REST PUT Member)
    // - SentData can contain the JSON object with field values to be added
    // - returns true on success
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; virtual; abstract;
    /// delete a member (implements REST DELETE Member)
    // - returns true on success
    // - override this method for proper calling the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; virtual; abstract;
    /// delete several members, from a WHERE clause
    // - IDs[] contains the already-computed matching IDs for SQLWhere
    // - returns true on success
    // - override this method for proper calling the database engine, i.e.
    // using either IDs[] or a faster SQL statement
    // - this method must be implemented in a thread-safe manner
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; virtual; abstract;
    /// get a blob field content from its member ID and field name
    // - implements REST GET member with a supplied blob field name
    // - returns TRUE on success
    // - returns the data of this blob as raw binary (not JSON) in BlobData
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; virtual; abstract;
    /// update a blob field content from its member ID and field name
    // - implements REST PUT member with a supplied blob field name
    // - returns TRUE on success
    // - the data of this blob must be specified as raw binary (not JSON) in BlobData
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; virtual; abstract;
    /// update an individual record field value from a specified ID or Value
    // - return true on success
    // - will allow execution of requests like
    // $ UPDATE tablename SET setfieldname=setvalue WHERE wherefieldname=wherevalue
    // - SetValue and WhereValue parameters must match our inline format, i.e.
    // by double quoted with " for strings, or be plain text for numbers - e.g.
    // $ Client.EngineUpdateField(TSQLMyRecord,'FirstName','"Smith"','RowID','10')
    // - this method must be implemented in a thread-safe manner
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; virtual; abstract;
  public
    /// initialize the class, and associate it to a specified database Model
    constructor Create(aModel: TSQLModel);
    /// release internal used instances
    // - e.g. release associated TSQLModel or TServiceContainer
    destructor Destroy; override;
    /// the Database Model associated with this REST Client or Server
    property Model: TSQLModel read fModel;
  public
    /// get the row count of a specified table
    // - return -1 on error
    // - return the row count of the table on success
    // - calls internaly the "SELECT Count(*) FROM TableName;" SQL statement
    function TableRowCount(Table: TSQLRecordClass): integer; virtual;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - example of use - including inlined parameters via :(...):
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=:(23):')
    // you should better call the corresponding overloaded method as such:
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=?',[aID])
    // which is the same as calling:
    // ! aClient.OneFieldValue(TSQLRecord,'Name',FormatUTF8('ID=?',[],[23]))
    // - call internaly InternalListJSON() to get the value
    function OneFieldValue(Table: TSQLRecordClass;
      const FieldName, WhereClause: RawUTF8): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, binding all '?' chars with Args[] values
    // - example of use:
    // ! aClient.OneFieldValue(TSQLRecord,'Name','ID=?',[aID])
    // - call internaly InternalListJSON() to get the value
    // - note that this method prototype changed with revision 1.17 of the
    // framework: array of const used to be Args and '%' in the FormatSQLWhere
    // statement, whereas it now expects bound parameters as '?'
    function OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
      FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field with a Where Clause
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! OneFieldValue(TSQLRecord,'Name','%=?',['ID'],[aID])
    // - call internaly InternalListJSON() to get the value
    function OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
      WhereClauseFmt: PUTF8Char; const Args, Bounds: array of const): RawUTF8; overload;
    /// get the UTF-8 encoded value of an unique field from its ID
    // - example of use: OneFieldValue(TSQLRecord,'Name',23)
    // - call internaly InternalListJSON() to get the value
    function OneFieldValue(Table: TSQLRecordClass;
      const FieldName: RawUTF8; WhereID: integer): RawUTF8; overload;
    /// get the UTF-8 encoded value of some fields with a Where Clause
    // - example of use: MultiFieldValue(TSQLRecord,['Name'],Name,'ID=:(23):')
    // (using inlined parameters via :(...): is always a good idea)
    // - FieldValue[] will have the same length as FieldName[]
    // - return true on success, false on SQL error or no result
    // - call internaly InternalListJSON() to get the list
    function MultiFieldValue(Table: TSQLRecordClass;
      const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
      const WhereClause: RawUTF8): boolean; overload;
    /// get the UTF-8 encoded value of some fields from its ID
    // - example of use: MultiFieldValue(TSQLRecord,['Name'],Name,23)
    // - FieldValue[] will have the same length as FieldName[]
    // - return true on success, false on SQL error or no result
    // - call internaly InternalListJSON() to get the list
    function MultiFieldValue(Table: TSQLRecordClass;
      const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
      WhereID: integer): boolean; overload;
    /// get the UTF-8 encoded values of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecord,'FirstName','Name=:("Smith"):',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly InternalListJSON() to get the list
    // - returns TRUE on success, FALSE if no data was retrieved
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8; var Data: TRawUTF8DynArray): boolean; overload;
    /// get the integer value of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecordPeople,'ID','Name=:("Smith"):',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly InternalListJSON() to get the list
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8; var Data: TIntegerDynArray): boolean; overload;
    /// dedicated method used to retrieve free-text matching DocIDs
    // - this method will work for both TSQLRecordFTS3 and TSQLRecordFTS4
    // - this method expects the column/field names to be supplied in the MATCH
    // statement clause
    // - example of use:  FTSMatch(TSQLMessage,'Body MATCH :("linu*"):',IntResult)
    // (using inlined parameters via :(...): is always a good idea)
    function FTSMatch(Table: TSQLRecordFTS3Class; const WhereClause: RawUTF8;
      var DocID: TIntegerDynArray): boolean; overload;
    /// dedicated method used to retrieve free-text matching DocIDs with
    // enhanced ranking information
    // - this method will work for both TSQLRecordFTS3 and TSQLRecordFTS4
    // - this method will search in all FTS3 columns, and except some floating-point
    // constants for weigthing each column (there must be the same number of
    // PerFieldWeight parameters as there are columns in the TSQLRecordFTS3 table)
    // - example of use:  FTSMatch(TSQLDocuments,'"linu*"',IntResult,[1,0.5])
    // which will sort the results by the rank obtained with the 1st column/field
    // beeing given twice the weighting of those in the 2nd (and last) column
    // - FTSMatch(TSQLDocuments,'linu*',IntResult,[1,0.5]) will perform a
    // SQL query as such, which is the fastest way of ranking according to
    // http://www.sqlite.org/fts3.html#appendix_a
    // $ SELECT RowID FROM Documents WHERE Documents MATCH 'linu*'
    // $ ORDER BY rank(matchinfo(Documents),1.0,0.5) DESC
    function FTSMatch(Table: TSQLRecordFTS3Class; const MatchClause: RawUTF8;
      var DocID: TIntegerDynArray; const PerFieldWeight: array of double): boolean; overload;
    /// get the CSV-encoded UTF-8 encoded values of an unique field with a Where Clause
    // - example of use: OneFieldValue(TSQLRecord,'FirstName','Name=:("Smith")',Data)
    // (using inlined parameters via :(...): is always a good idea)
    // - leave WhereClause void to get all records
    // - call internaly InternalListJSON() to get the list
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function OneFieldValues(Table: TSQLRecordClass; const FieldName: RawUTF8;
      const WhereClause: RawUTF8=''; const Separator: RawUTF8=','): RawUTF8; overload;
    /// get the string-encoded values of an unique field into some TStrings
    // - Items[] will be filled with string-encoded values of the given field)
    // - Objects[] will be filled with pointer(ID)
    // - call internaly InternalListJSON() to get the list
    // - returns TRUE on success, FALSE if no data was retrieved
    // - if IDToIndex is set, its value will be replaced with the index in
    // Strings.Objects[] where ID=IDToIndex^
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function OneFieldValues(Table: TSQLRecordClass;
      const FieldName, WhereClause: RawUTF8; Strings: TStrings;
      IDToIndex: PInteger=nil): Boolean; overload;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - return a result table on success, nil on failure
    // - if FieldNames='', all simple fields content is retrieved
    // - call internaly InternalListJSON() to get the list
    // - using inlined parameters via :(...): in WhereClause is always a good idea
    function MultiFieldValues(Table: TSQLRecordClass; FieldNames: RawUTF8;
       const WhereClause: RawUTF8=''): TSQLTableJSON; overload; virtual;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - return a result table on success, nil on failure
    // - if FieldNames='', all simple fields content is retrieved
    // - this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, binding all '?' chars with Args[] values
    // - example of use:
    // ! aList := aClient.MultiFieldValues(TSQLRecord,'Name,FirstName','Salary>=?',[aMinSalary]);
    // - call internaly MultiFieldValues() to get the list
    // - note that this method prototype changed with revision 1.17 of the
    // framework: array of const used to be Args and '%' in the WhereClauseFormat
    // statement, whereas it now expects bound parameters as '?'
    function MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
      WhereClauseFormat: PUTF8Char; const BoundsSQLWhere: array of const): TSQLTableJSON; overload;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - return a result table on success, nil on failure
    // - if FieldNames='', all simple fields content is retrieved
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! Table := MultiFieldValues(TSQLRecord,'Name','%=?',['ID'],[aID]);
    // - call internaly MultiFieldValues() to get the list
    function MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
      WhereClauseFormat: PUTF8Char; const Args, Bounds: array of const): TSQLTableJSON; overload;
    /// retrieve the main field (mostly 'Name') value of the specified record
    // - use Model.GetMainFieldName() method to get the main field name
    // - use OneFieldValue() method to get the field value
    // - return '' if no such field or record exists
    // - if ReturnFirstIfNoUnique is TRUE and no unique property is found,
    //   the first RawUTF8 property is returned anyway
    function MainFieldValue(Table: TSQLRecordClass; ID: Integer;
      ReturnFirstIfNoUnique: boolean=false): RawUTF8;
    {/ return the ID of the record which main field match the specified value
      - search field is mainly the "Name" property, i.e. the one with
        "stored false" definition on most TSQLRecord
      - returns 0 if no matching record was found }
    function MainFieldID(Table: TSQLRecordClass; const Value: RawUTF8): integer;
    {/ return the IDs of the record which main field match the specified values
      - search field is mainly the "Name" property, i.e. the one with
        "stored false" definition on most TSQLRecord
      - if any of the Values[] is not existing, then no ID will appear in the
        IDs[] array - e.g. it will return [] if no matching record was found
      - returns TRUE if any matching ID was found (i.e. if length(IDs)>0) }
    function MainFieldIDs(Table: TSQLRecordClass; const Values: array of RawUTF8;
      var IDs: TIntegerDynArray): boolean;
  public // here are REST basic direct calls (works with Server or Client)
    /// get a member from a SQL statement (implements REST GET member)
    // - return true on success
    // - Execute 'SELECT * FROM TableName WHERE SQLWhere LIMIT 1' SQL Statememt
    // (using inlined parameters via :(...): in SQLWhere is always a good idea)
    // - since no record is specified, locking is pointless here
    // - default implementation call InternalListJSON(), and fill Value from a
    // temporary TSQLTable
    // - the TSQLRawBlob (BLOB) fields are not retrieved by this method, to
    // preserve bandwidth: use the RetrieveBlob() methods for handling
    // BLOB fields, or set globaly the TSQLRestClientURI.ForceBlobTransfert
    // property to TRUE
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord): boolean; overload; virtual;
    /// get a member from a SQL statement (implements REST GET member)
    // - return true on success
    // - same as Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord) method, but
    // this overloaded function will call FormatUTF8 to create the Where Clause
    // from supplied parameters, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    function Retrieve(WhereClauseFmt: PUTF8Char; const Args,Bounds: array of const;
      Value: TSQLRecord): boolean; overload;
    /// get a member from its ID
    // - return true on success
    // - Execute 'SELECT * FROM TableName WHERE ID=:(aID): LIMIT 1' SQL Statememt
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    // - this method is defined as abstract, i.e. there is no default implementation -
    // it must be implemented 100% RestFul with a GET ModelRoot/TableName/ID
    // and handle the LOCK command if necessary: real RESTful class
    // should implement a GET member from URI in an overriden method
    // - the TSQLRawBlob (BLOB) fields are not retrieved by this method, to
    // preserve bandwidth:
    // use the RetrieveBlob() methods for handling BLOB fields, or set globaly
    // the TSQLRestClientURI.ForceBlobTransfert property to TRUE (that is, by
    // default "Lazy loading" is enabled, but can be disabled on purpose)
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
   function Retrieve(aID: integer; Value: TSQLRecord;
      ForUpdate: boolean=false): boolean; overload; virtual; abstract;
    /// get a member from its TRecordReference property content
    // - instead of the other Retrieve() methods, this implementation Create an
    // instance, with the appropriated class stored in Reference
    // - returns nil on any error (invalid Reference e.g.)
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    // - the TSQLRawBlob(BLOB) fields are not retrieved by this method, to
    // preserve bandwidth:
    // use the RetrieveBlob() methods for handling BLOB fields, or set globaly
    // the TSQLRestClientURI.ForceBlobTransfert property to TRUE
    // - the TSQLRecordMany fields are not retrieved either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Retrieve(Reference: TRecordReference;
      ForUpdate: boolean=false): TSQLRecord; overload; virtual;
    /// get a member from a published property TSQLRecord
    // - those properties are not class instances, but TObject(aRecordID)
    // - is just a wrapper around Retrieve(aPublishedRecord.ID,aValue)
    // - return true on success
    function Retrieve(aPublishedRecord, aValue: TSQLRecord): boolean; overload;
    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    function ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; virtual; abstract;
    /// unlock the corresponding record
    // - use our custom UNLOCK REST-like method
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; overload; virtual; abstract;
    /// unlock the corresponding record
    // - use our custom UNLOCK REST-like method
    // - calls internally UnLock() above
    // - returns true on success
    function UnLock(Rec: TSQLRecord): boolean; overload;
    /// create a new member (implements REST POST Collection)
    // - if SendData is true, client sends the current content of Value with the
    // request, otherwize record is created with default values
    // - if ForceID is true, client sends the Value.ID field to use this ID for
    // adding the record (instead of a database-generated ID)
    // - on success, returns the new ROWID value; on error, returns 0
    // - on success, Value.ID is updated with the new ROWID
    // - the TSQLRawBlob(BLOB) fields values are not set by this method, to
    // preserve bandwidth
    // - the TSQLRecordMany fields are not set either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer; overload; virtual; abstract;
    /// create a new member, from a supplied list of field values
    // - the aSimpleFields parameters must follow explicitely the order of published
    // properties of the supplied aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields")
    // - the aSimpleFields must have exactly the same count of parameters as
    // there are "simple fields" in the published properties
    // - if ForcedID is set to non null, client sends this ID to be used
    // when adding the record (instead of a database-generated ID)
    // - on success, returns the new ROWID value; on error, returns 0
    // - call internaly the Add virtual method above
    function Add(aTable: TSQLRecordClass; const aSimpleFields: array of const; ForcedID: integer=0): integer; overload;
    /// update a record from Value fields content
    // - implements REST PUT Member
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if the action is
    // allowed - this method must be overriden to provide effective data update
    // - the TSQLRawBlob(BLOB) fields values are not updated by this method, to
    // preserve bandwidth: use the UpdateBlob() methods for handling BLOB fields
    // - the TSQLRecordMany fields are not set either: they are separate
    // instances created by TSQLRecordMany.Create, with dedicated methods to
    // access to the separated pivot table
    function Update(Value: TSQLRecord): boolean; overload; virtual;
    /// update a record from a supplied list of field values
    // - implements REST PUT Member
    // - the aSimpleFields parameters must follow explicitely the order of published
    // properties of the supplied aTable class, excepting the TSQLRawBlob and
    // TSQLRecordMany kind (i.e. only so called "simple fields")
    // - the aSimpleFields must have exactly the same count of parameters as there are
    // "simple fields" in the published properties
    // - return true on success
    // - call internaly the Update virtual method above
    function Update(aTable: TSQLRecordClass; aID: integer; const aSimpleFields: array of const): boolean; overload;
    /// delete a member (implements REST DELETE Member)
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if it is possible
    function Delete(Table: TSQLRecordClass; ID: integer): boolean; overload; virtual;
    /// delete a member with a WHERE clause (implements REST DELETE Member)
    // - return true on success
    // - this default method call OneFieldValues() to retrieve all matching IDs,
    // then will delete each row using protected EngineDeleteWhere() virtual method
    function Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean; overload; virtual;
    /// delete a member with a WHERE clause (implements REST DELETE Member)
    // - return true on success
    // - for better server speed, the WHERE clause should use bound parameters
    //   identified as '?' in the FormatSQLWhere statement, which is expected to
    //   follow the order of values supplied in BoundsSQLWhere open array - use
    //   DateToSQL/DateTimeToSQL for TDateTime, or directly any integer / double /
    //   currency / RawUTF8 values to be bound to the request as parameters
    // - it will run Delete(Table,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere))
    function Delete(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
      const BoundsSQLWhere: array of const): boolean; overload;

    {/ access the internal caching parameters for a given TSQLRecord
     - purpose of this caching mechanism is to speed up retrieval of some
       common values at either Client or Server level (like configuration
       settings)
     - only caching synchronization is about the direct RESTful/CRUD commands:
       RETRIEVE, ADD, UPDATE and DELETE (that is, a complex direct SQL UPDATE or
       via TSQLRecordMany pattern won't be taken in account - only exception is
       TSQLRestServerStatic tables accessed as SQLite3 virtual table)
     - this caching will be located at the TSQLRest level, that is no automated
       synchronization is implemented between TSQLRestClient and TSQLRestServer:
       you shall ensure that your code won't fail due to this restriction
     - use Cache.SetCache() and Cache.SetTimeOut() methods to set the appropriate
       configuration for this particular TSQLRest instance }
    property Cache: TSQLRestCache read GetCache;

    /// get a blob field content from its record ID and supplied blob field name
    // - implements REST GET member with a supplied member ID and a blob field name
    // - return true on success
    // - this method is defined as abstract, i.e. there is no default implementation:
    // it must be implemented 100% RestFul with a GET ModelRoot/TableName/ID/BlobFieldName
    // request for example
    // - this method retrieve the blob data as a TSQLRawBlob string
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean; overload; virtual; abstract;
    /// get a blob field content from its record ID and supplied blob field name
    // - implements REST GET member with a supplied member ID and a blob field name
    // - return true on success
    // - this method will create a TStream instance (which must be freed by the
    // caller after use) and fill it with the blob data
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobStream: THeapMemoryStream): boolean; overload;
    /// update a blob field from its record ID and supplied blob field name
    // - implements REST PUT member with a supplied member ID and field name
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if the action is
    // allowed
    // - this method expect the Blob data to be supplied as TSQLRawBlob
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean; overload; virtual; abstract;
    /// update a blob field from its record ID and blob field name
    // - implements REST PUT member with a supplied member ID and field name
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if the action is
    // allowed
    // - this method expect the Blob data to be supplied as a TStream: it will
    // send the whole stream content (from its beginning position upto its
    // current size) to the database engine
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; BlobData: TStream): boolean; overload;
    /// update a blob field from its record ID and blob field name
    // - implements REST PUT member with a supplied member ID and field name
    // - return true on success
    // - this default method call RecordCanBeUpdated() to check if the action is
    // allowed
    // - this method expect the Blob data to be supplied as direct memory pointer
    // and size
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; BlobData: pointer; BlobSize: integer): boolean; overload;

    {/ begin a transaction (implements REST BEGIN Member)
     - to be used to speed up some SQL statements like Add/Update/Delete methods
     above
     - in the current implementation, the aTable parameter is not used yet
     - in the current implementation, nested transactions are not allowed
     - must be ended with Commit on success
     - must be aborted with Rollback if any SQL statement failed
     - default implementation just handle the protected fTransactionActive flag
     - return true if no transaction is active, false otherwize
     - in a multi-threaded or Client-Server with multiple concurent Client
     connections, you should check the returned value, as such:
      !if Client.TransactionBegin(TSQLRecordPeopleObject) then
      !try
      !  //.... modify the database content, raise exceptions on error
      !  Client.Commit;
      !except
      !  Client.RollBack; // in case of error
      !end;
     - in aClient-Server environment with multiple Clients connected at the
       same time, you can use the dedicated TSQLRestClientURI.
       TransactionBeginRetry() method
     - the supplied SessionID will allow multi-user transaction safety on the
       Server-Side: all database modification from another session will wait
       for the global transaction to be finished; on Client-side, the SessionID
       is just ignored (TSQLRestClient will override this method with a default
       SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter) }
    function TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal): boolean; virtual;
    {/ end a transaction (implements REST END Member)
     - write all pending SQL statements to the disk
     - default implementation just reset the protected fTransactionActive flag
     - the supplied SessionID will allow multi-user transaction safety on the
       Server-Side: all database modification from another session will wait
       for the global transaction to be finished; on Client-side, the SessionID
       is just ignored (TSQLRestClient will override this method with a default
       SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter) }
    procedure Commit(SessionID: cardinal); virtual;
    {/ abort a transaction (implements REST ABORT Member)
     - restore the previous state of the database, before the call to TransactionBegin
     - default implementation just reset the protected fTransactionActive flag 
     - the supplied SessionID will allow multi-user transaction safety on the
       Server-Side: all database modification from another session will wait
       for the global transaction to be finished; on Client-side, the SessionID
       is just ignored (TSQLRestClient will override this method with a default
       SessionID=CONST_AUTHENTICATION_NOT_USED=1 parameter) }
    procedure RollBack(SessionID: cardinal); virtual;

    {/ the time (in mili seconds) which the server will wait for acquiring a
       write acccess to the database
     - in order to handle safe transactions and multi-thread safe writing, the
       server will identify transactions using the client Session ID: this
       property will set the time out wait period
     - default value is 2000, i.e. TSQLRestServer.URI will wait up to 2 seconds
       in order to acquire the right to write on the database before returning
       a "408 Request Time-out" status error }
    property AcquireWriteTimeOut: cardinal read fAcquireWriteTimeOut write fAcquireWriteTimeOut;
    /// the current Date and Time, as retrieved from the server
    // - this property will return the timestamp as TTimeLog / Iso8601 / Int64
    // after correction from the Server returned time-stamp (if any)
    // - is used e.g. by TSQLRecord.ComputeFieldsBeforeWrite to update TModTime
    // and TCreateTime published fields
    // - default implementation will return the executable time, i.e. Iso8601Now
    // - you can set the server-side time offset by setting a value to this
    // property (e.g. using TSQLDBConnection.ServerTimeStamp property for
    // Oracle, MSSQL and MySQL external databases)
    property ServerTimeStamp: TTimeLog read GetServerTimeStamp write SetServerTimeStamp;
    /// access to the interface-based services list
    // - may be nil if no service interface has been registered yet
    property Services: TServiceContainer read fServices;
    /// the routing mode of the service remote request
    // - by default, will use an URI-based layout (rmREST), which is more secure
    // (since will use our RESTful authentication scheme), and also 10% faster
    // - but rmJSON_RPC can be set (on BOTH client and server sides), if the
    // client would rather use this alternative pattern
    property ServicesRouting: TServiceRoutingMode read fRouting write fRouting;
  public
    /// the custom queries parameters for User Interface Query action
    QueryCustom: array of TSQLQueryCustom;
    /// evaluate a basic operation for implementing User Interface Query action
    // - expect both Value and Reference to be UTF-8 encoded (as in TSQLTable
    // or TSQLTableToGrid)
    // - aID parameter is ignored in this function implementation (expect only
    // this parameter to be not equal to 0)
    // - is TSQLQueryEvent prototype compatible
    // - for qoContains and qoBeginWith, the Reference is expected to be
    // already uppercase
    // - for qoSoundsLike* operators, Reference is not a PUTF8Char, but a
    // typecase of a prepared TSynSoundEx object instance (i.e. pointer(@SoundEx))
    class function QueryIsTrue(aTable: TSQLRecordClass; aID: integer;
      FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
      Reference: PUTF8Char): boolean;
    /// add a custom query
    // - one event handler with an enumeration type containing all available
    // query names
    // - and associated operators
    procedure QueryAddCustom(aTypeInfo: pointer; aEvent: TSQLQueryEvent;
      const aOperators: TSQLQueryOperators);
  end;

{$ifdef MSWINDOWS}
  /// Server thread accepting connections from named pipes
  TSQLRestServerNamedPipe = class(TThread)
  private
  protected
    fServer: TSQLRestServer;
    fChild: TList;
    fChildCount: integer;
    fPipeName: TFileName;
    procedure Execute; override;
  public
    /// create the server thread
    constructor Create(aServer: TSQLRestServer; const PipeName: TFileName);
    /// release all associated memory, and wait for all
    // TSQLRestServerNamedPipeResponse children to be terminated
    destructor Destroy; override;
    /// the associated pipe name
    property PipeName: TFileName read fPipeName;
  end;

  /// Server child thread dealing with a connection through a named pipe
  TSQLRestServerNamedPipeResponse = class(TThread)
  private
  protected
    fServer: TSQLRestServer;
    fPipe: cardinal;
    fMasterThread: TSQLRestServerNamedPipe;
    fMasterThreadChildIndex: Integer;
    procedure Execute; override;
    {$ifndef LVCL}
    // will release any thread-specific resource (e.g. external DB connection)
    procedure DoTerminate; override;
    {$endif}
  public
    /// create the child connection thread
    constructor Create(aServer: TSQLRestServer; aMasterThread: TSQLRestServerNamedPipe;
      aPipe: cardinal);
    /// release all associated memory, and decrement fMasterThread.fChildCount
    destructor Destroy; override;
  end;

{$ifdef FPC}
  TWMCopyData = packed record
    Msg: Cardinal;
    From: HWND;
    CopyDataStruct: PCopyDataStruct;
    Result: Longint;
  end;
{$endif}
{$endif}

  /// function prototype for remotly calling a TSQLRestServer
  // - use PUTF8Char instead of string: no need to share a memory manager, and can
  // be used with any language (even C or .NET, thanks to the cdecl calling convention)
  // - you can specify some POST/PUT data in SendData (leave as nil otherwize)
  // - returns in result.Lo the HTTP STATUS integer error or success code
  // - returns in result.Hi the server database internal status
  // - on success, allocate and store the resulting JSON body into Resp^, headers in Head^
  // - use a GlobalFree() function to release memory for Resp and Head responses
  TURIMapRequest = function(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;

{$ifdef MSWINDOWS}
  {$define WITHSTATPROCESS}
  // if defined, the server statistics will contain precise working time process
{$endif}

  /// used for statistics update in TSQLRestServer.URI()
  TSQLRestServerStats = class(TPersistent)
  private
    /// used to determine if something changed
    fLastIncomingBytes: QWord;
    /// current count of connected clients
    fClientsCurrent,
    /// max count of connected clients
    fClientsMax,
    /// count of invalid request
    fInvalid,
    /// count of valid responses (returned status code 200/HTML_SUCCESS or 201/HTML_CREATED)
    fResponses,
    /// count of requests which modified the data
    fModified,
    /// size of data requests processed in bytes (without the transfert protocol overhead)
    fIncomingBytes,
    /// size of data responses generated in bytes (without the transfert protocol overhead)
    fOutcomingBytes,
    /// count of the remote service calls
    fServices: QWord;
{$ifdef WITHSTATPROCESS}
    /// time used to process the requests, with appended unit ('0.13 ms' e.g.)
    function GetProcessTimeString: RawUTF8;
{$endif}
  public
{$ifdef WITHSTATPROCESS}
    /// high-resolution performance counter of the time used to process the requests
    // - this value depend on the high-resolution performance counter frequency
    // - use ProcessTime property below to get the time in seconds
    ProcessTimeCounter: Int64;
{$endif}
    /// update ClientsCurrent and ClientsMax
    procedure ClientConnect;
    /// update ClientsCurrent and ClientsMax
    procedure ClientDisconnect;
    /// get a standard message to be displayed with the above statistics
    // - return the published properties of this class as a JSON object
    function DebugMessage: RawUTF8;
    /// percent (0..100) of request which modified the data
    function ModifPercent: cardinal;
    /// return true if IncomingBytes value changed since last call
    function Changed: boolean;
  published
    /// current count of connected clients
    property ClientsCurrent: QWord read fClientsCurrent;
    /// max count of connected clients
    property ClientsMax: QWord read fClientsMax;
    /// count of invalid request
    property Invalid: QWord read fInvalid;
    /// count of valid responses (returned status code 200/HTML_SUCCESS or 201/HTML_CREATED)
    property Responses: QWord read fResponses;
    /// count of requests which modified the data
    property Modified: QWord read fModified;
    /// size of data requests processed in bytes (without the transfert protocol overhead)
    property IncomingBytes: QWord read fIncomingBytes;
    /// size of data responses generated in bytes (without the transfert protocol overhead)
    property OutcomingBytes: QWord read fOutcomingBytes;
    /// count of the remote service calls
    property ServiceCalls: QWord read fServices;
{$ifdef WITHSTATPROCESS}
    /// the global time spent in the server process
    property ProcessTime: RawUTF8 read GetProcessTimeString;
{$endif}
  end;

  ///  used to define how to trigger Events on record update
  // - see TSQLRestServer.OnUpdateEvent property
  // - returns true on success, false if an error occured (but action must continue)
  // - to be used only server-side, not to synchronize some clients: the framework
  // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
  // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
  TNotifySQLEvent = function(Sender: TSQLRestServer; Event: TSQLEvent;
    aTable: TSQLRecordClass; aID: integer): boolean of object;

  /// a set of potential actions to be executed from the server
  // - reSQL will indicate the right to execute any POST SQL statement (not only
  // SELECT statements)
  // - reService will indicate the right to execute the interface-based JSON-RPC
  // service implementation
  // - reUrlEncodedSQL will indicate the right to execute a SQL query encoded
  // at the URI level, for a GET (to be used e.g. with XMLHTTPRequest, which
  // forced SentData='' by definition), encoded as sql=.... inline parameter
  // - reUrlEncodedDelete will indicate the right to delete items using a
  // WHERE clause for DELETE verb at /root/TableName?WhereClause 
  TSQLAllowRemoteExecute = set of (
    reSQL, reService, reUrlEncodedSQL, reUrlEncodedDelete);

  /// set the User Access Rights, for each Table
  // - one property for every and each URI method (GET/POST/PUT/DELETE)
  // - one bit for every and each Table in Model.Tables[]
  {$ifdef UNICODE}
  TSQLAccessRights = record
  {$else}
  TSQLAccessRights = object
  {$endif}
    /// set of allowed actions on the server side
    AllowRemoteExecute: TSQLAllowRemoteExecute;
    /// GET method (retrieve record) table access bits
    // - note that a GET request with a SQL statement without a table (i.e.
    // on 'ModelRoot' URI with a SQL statement as SentData, as used in
    // TSQLRestClientURI.UpdateFromServer) is always valid, whatever the bits
    // here are: since TSQLRestClientURI.UpdateFromServer() is called only
    // for refreshing a direct statement, it will be OK; you can improve this
    // by overriding the TSQLRestServer.URI() method
    // - if the REST request is LOCK, the PUT access bits will be read instead
    // of the GET bits value
    GET: TSQLFieldTables;
    /// POST method (create record) table access bits
    POST: TSQLFieldTables;
    /// PUT method (update record) table access bits
    // - if the REST request is LOCK, the PUT access bits will be read instead
    // of the GET bits value
    PUT: TSQLFieldTables;
    /// DELETE method (delete record) table access bits
    DELETE: TSQLFieldTables;
    /// wrapper method which can be used to set the CRUD abilities over a table
    // - C=Create, R=Read, U=Update, D=Delete rights
    procedure Edit(aTableIndex: integer; C, R, U, D: Boolean);
    /// serialize the content as TEXT
    // - use the TSQLAuthGroup.AccessRights CSV format
    function ToString: RawUTF8;
    /// unserialize the content from TEXT
    // - use the TSQLAuthGroup.AccessRights CSV format
    procedure FromString(P: PUTF8Char);
  end;

  PSQLAccessRights = ^TSQLAccessRights;

  TSQLRestServerStatic = class;
  TSQLRestServerStaticClass = class of TSQLRestServerStatic;
  TSQLRestServerStaticInMemory = class;
  TSQLVirtualTableModule = class;


  {/ table containing the available user access rights for authentication
    - this class should be added to the TSQLModel, together with TSQLAuthUser,
      to allow authentication support
    - by default, it won't be accessible remotely by anyone }
  TSQLAuthGroup = class(TSQLRecord)
  private
    fIdent: RawUTF8;
    fSessionTimeOut: integer;
    fAccessRights: RawUTF8;
    function GetSQLAccessRights: TSQLAccessRights;
    procedure SetSQLAccessRights(const Value: TSQLAccessRights);
  public
    /// called when the associated table is created in the database
    // - on a new database, if TSQLAuthUser and TSQLAuthGroup tables are defined
    // in the associated TSQLModel, it this will add 'Admin', 'Supervisor',
    // and 'User' rows in the AuthUser table (with 'synopse' as default password),
    // and associated 'Admin', 'Supervisor', 'User' and 'Guest' groups, with the
    // following access rights to the AuthGroup table:
    // $           POST SQL  Service  Auth R  Auth W  Tables R  Tables W
    // $ Admin        Yes      Yes     Yes     Yes      Yes      Yes
    // $ Supervisor   No       Yes     Yes     No       Yes      Yes
    // $ User         No       Yes     No      No       Yes      Yes
    // $ Guest        No       No      No      No       Yes      No
    // 'Admin' will be the only able to execute remote not SELECT SQL statements
    // for POST commands (reSQL in TSQLAccessRights.AllowRemoteExecute) and
    // modify the Auth tables (i.e. AuthUser and AuthGroup), and Guest won't have
    // access to the interface-based remote JSON-RPC service (no reService)
    // - you MUST override those default 'synopse' password to a custom value
    // - of course, you can change and tune the settings of the AuthGroup and
    // AuthUser tables, but only 'Admin' group users will be able to remotly
    // modify the content of those table
    class procedure InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8); override;
    /// corresponding TSQLAccessRights for this authentication group
    // - content is converted into/from text format via AccessRight DB property
    // (so it will be not fixed e.g. by the binary TSQLFieldTables layout, i.e.
    // the MAX_SQLTABLES constant value)
    property SQLAccessRights: TSQLAccessRights read GetSQLAccessRights write SetSQLAccessRights;
  published
    /// the access right identifier, ready to be displayed
    // - the same identifier can be used only once (this column is marked as
    // unique via a "stored false" attribute)
    // - so you can retrieve a TSQLAuthGroup ID from its identifier, as such:
    // ! UserGroupID := fClient.MainFieldID(TSQLAuthGroup,'User');
    property Ident: RawUTF8 read fIdent write fIdent stored false;
    /// the number of minutes a session is kept alive
    property SessionTimeout: integer read fSessionTimeOut write fSessionTimeOut;
    /// a textual representation of a TSQLAccessRights buffer
    property AccessRights: RawUTF8 read fAccessRights write fAccessRights;
  end;

  {/ table containing the Users registered for authentication
    - this class should be added to the TSQLModel, together with TSQLAuthGroup,
      to allow authentication support
    - by default, it won't be accessible remotely by anyone
    - to enhance security, you could use the TSynValidatePassWord filter to
      this table  }
  TSQLAuthUser = class(TSQLRecord)
  protected
    fLogonName: RawUTF8;
    fPasswordHashHexa: RawUTF8;
    fDisplayName: RawUTF8;
    fGroup: TSQLAuthGroup;
    fData: TSQLRawBlob;
    procedure SetPasswordPlain(const Value: RawUTF8);
  public
    /// able to set the PasswordHashHexa field from a plain password content
    // - in fact, PasswordHashHexa := SHA256('salt'+PasswordPlain) in UTF-8
    property PasswordPlain: RawUTF8 write SetPasswordPlain;
  published
    /// the User identification Name, as entered at log-in
    // - the same identifier can be used only once (this column is marked as
    // unique via a "stored false" attribute), and therefore indexed
    property LogonName: RawUTF8 read fLogonName write fLogonName stored false;
    /// the User Name, as may be displayed or printed
    property DisplayName: RawUTF8 read fDisplayName write fDisplayName;
    /// the hexa encoded associated SHA-256 hash of the password
    property PasswordHashHexa: RawUTF8 read fPasswordHashHexa write fPasswordHashHexa;
    /// the associated access rights of this user
    // - access rights are managed by group
    // - in TAuthSession.User instance, GroupRights property will contain a
    // real TSQLAuthGroup instance for fast retrieval in TSQLRestServer.URI
    // - note that 'Group' field name is not allowed by SQLite
    property GroupRights: TSQLAuthGroup read fGroup write fGroup;
    /// some custom data, associated to the User
    // - Server application may store here custom data
    // - its content is not used by the framework but 'may' be used by your
    // application
    property Data: TSQLRawBlob read fData write fData;
  end;

  {/ class used to maintain in-memory sessions
    - this is not a TSQLRecord table so won't be remotely accessible, for
      performance and security reasons
    - the User field is a true instance, copy of the corresponding database
      content (for better speed) }
  TAuthSession = class
  private
    fUser: TSQLAuthUser;
    fLastAccess: cardinal;
    fID: RawUTF8;
    fIDCardinal: cardinal;
    fTimeOut: cardinal;
    fAccessRights: TSQLAccessRights;
    fPrivateKey: RawUTF8;
    fPrivateSalt: RawUTF8;
    fPrivateSaltHash: Cardinal;
    fLastTimeStamp: Cardinal;
  public
    /// initialize a session instance with the supplied TSQLAuthUser instance
    // - this aUser instance will be handled by the class until Destroy
    // - raise an exception on any error
    // - on success, will also retrieve the aUser.Data BLOB field content
    constructor Create(aServer: TSQLRestServer; aUser: TSQLAuthUser);
    /// will release the User and User.GroupRights instances
    destructor Destroy; override;
    /// check if the session_signature=... parameter is correct
    // - session_signature=... is expected at the end of the URL, i.e.
    // aURL[aURLLength+1] will point e.g. to '?session_signature=...':
    // the caller must ensure that aURL[] follows this expected layout
    // - will expect the format as generated by TSQLRestClientURI.SessionSign()
    function IsValidURL(const aURL: RawUTF8; aURLlength: integer): boolean;
  public
    /// the session ID number, as text
    property ID: RawUTF8 read fID;
    /// the session ID number, as numerical value
    // - never equals to 1 (CONST_AUTHENTICATION_NOT_USED, i.e. authentication
    // mode is not enabled), nor 0 (CONST_AUTHENTICATION_SESSION_NOT_STARTED,
    // i.e. session still in handshaking phase)
    property IDCardinal: cardinal read fIDCardinal;
    /// the associated User
    // - this is a true TSQLAuthUser instance, and User.GroupRights will contain
    // also a true TSQLAuthGroup instance
    property User: TSQLAuthUser read fUser;
    /// set by the Access method to the current time stamp
    property LastAccess: cardinal read fLastAccess;
    /// copy of the associated user access rights
    // - extracted from User.TSQLAuthGroup.SQLAccessRights
    property AccessRights: TSQLAccessRights read fAccessRights;
    /// the number of millisedons a session is kept alive
    // - extracted from User.TSQLAuthGroup.SessionTimeout
    // - allow direct comparison with GetTickCount API call
    property Timeout: cardinal read fTimeOut;
    /// the hexadecimal private key as returned to the connected client
    // as 'SessionID+PrivateKey'
    property PrivateKey: RawUTF8 read fPrivateKey;
  end;

  { we need the RTTI information to be compiled for the published methods
    of this TSQLRestServer class and its children (like TPersistent), to
    enable Server-Side ModelRoot/[TableName/[ID/]]MethodName requests
      -> see TSQLRestServerCallBack }

  /// a generic REpresentational State Transfer (REST) server
  // - descendent must implement the protected EngineList() Retrieve() Add()
  // Update() Delete() methods
  // - automatic call of this methods by a generic URI() RESTful function
  // - any published method of descendants must match TSQLRestServerCallBack
  // prototype, and is expected to be thread-safe
  TSQLRestServer = class(TSQLRest)
  protected
    fStats: TSQLRestServerStats;
    fVirtualTableDirect: boolean;
    fNoAJAXJSON: boolean;
    fHandleAuthentication: Boolean;
    /// fast access to the TSQLAuthUser and TSQLAuthGroup table in Model.Tables[]
    fAuthUserIndex, fAuthGroupIndex: integer;
    /// will contain the in-memory representation of some static tables
    // - this array has the same length as the associated Model.Tables[]
    // - fStaticData[] will contain pure in-memory tables, not declared as
    // SQLite3 virtual tables, therefore not available from joined SQL statements
    fStaticData: array of TSQLRestServerStatic;
    /// map TSQLRestServerStaticInMemory or TSQLRestServerStaticExternal engines
    // - this array has the same length as the associated Model.Tables[]
    // - fStaticVirtualTable[] will contain in-memory or external tables declared
    // as SQLite3 virtual tables, therefore available from joined SQL statements
    fStaticVirtualTable: array of TSQLRestServerStatic;
    /// in-memory storage of TAuthSession instances
    fSessions: TObjectList;
    /// used to compute genuine TAuthSession.ID cardinal value
    fSessionCounter: cardinal;
    /// mutex used to make fSessions[] use thread-safe
    fSessionCriticalSection: TRTLCriticalSection;
{$ifdef MSWINDOWS}
    /// thread initialized by ExportServerNamedPipe() to response to client through a pipe
    fExportServerNamedPipeThread: TSQLRestServerNamedPipe;
    /// internal server window handle, initialized by ExportServerMessage() method
    fServerWindow: HWND;
    /// internal server window class name, initialized by ExportServerMessage() method
    // - use "string" type, i.e. UnicodeString for Delphi 2009+, in order
    // to call directly the correct FindWindow?()=FindWindow Win32 API
    fServerWindowName: string;
{$endif}
    fPublishedMethods: TSynNameValue;
    fPublishedMethodsUnauthenticated: TIntegerDynArray;
    fPublishedMethodsUnauthenticatedCount: integer;
    /// fast get the associated static server, if any
    function GetStaticDataServer(aClass: TSQLRecordClass): TSQLRestServerStatic;
    /// retrieve a TSQLRestServerStatic instance associated to a Virtual Table
    // - is e.g. TSQLRestServerStaticInMemory instance associated to a
    // TSQLVirtualTableBinary or TSQLVirtualTableJSON class
    // - may be a TSQLRestServerStaticExternal (as defined in SQLite3DB unit)
    // for a virtual table giving access to an external database
    function GetVirtualTable(aClass: TSQLRecordClass): TSQLRestServerStatic;
    /// fast get the associated static server or Virtual table, if any
    // - this can be used to call directly the TSQLRestServerStatic instance
    // on the server side
    // - same as a dual call to StaticDataServer[aClass] + StaticVirtualTable[aClass]
    // - TSQLRestServer.URI will make a difference between the a static server
    // or a TSQLVirtualTable, but this method won't
    function GetStaticDataServerOrVirtualTable(aClass: TSQLRecordClass): TSQLRestServerStatic; overload;
    /// overloaded method using table index in associated Model
    function GetStaticDataServerOrVirtualTable(aTableIndex: integer): TSQLRestServerStatic; overload;
       {$ifdef HASINLINE}inline;{$endif}
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions
    function InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    /// this method is overriden for setting the NoAJAXJSON field
    // of all associated TSQLRestServerStatic servers
    procedure SetNoAJAXJSON(const Value: boolean); virtual;
    /// search for the corresponding TSQLRestServerCallBack in its published methods,
    // then launch it
    // - the aParams parameters will be used to set a default header for the callback
    // - return TRUE if the method was found and run, FALSE if method was not found
    function LaunchCallBack(var aParams: TSQLRestServerCallBackParams;
      var aResp: RawUTF8; var aResult: Cardinal): boolean;
    /// try to call a Service from a given URI
    // - this method will call any interface-based service previously registered
    // via ServerRegister()
    // - returns TRUE if the supplied method was a service name, and an error
    // code is returned in aResult (with an optional message in aErrorMsg)
    // - is in fact used internaly by the URI method: you are not likely to call
    // this method, but should rather call e.g. Services['Calculator'].Get(I)
    // to retrieve a working service interface to work with
    function LaunchService(const aParams: TSQLRestServerCallBackParams;
      var aResp: RawUTF8; var aResult: cardinal): boolean;
    /// execute a BATCH sequence
    // - expect input as generated by TSQLRestClientURI.Batch*() methods:
    // & '{"Table":["cmd":values,...]}'
    // or, in a table-independent way:
    // & '["cmd@table":values,...]'
    // - returns an array of integers: '[200,200,...]'
    function RunBatch(aStatic: TSQLRestServerStatic; aTable: TSQLRecordClass;
      Sent: PUTF8Char; var Resp, ErrorMsg: RawUTF8): boolean;
    /// fill the supplied context from the supplied aContext.Session ID
    // - returns nil if not found, or fill aContext.User/Group values if matchs
    // - this method will also check for outdated sessions, and delete them
    // - this method is not thread-safe: caller should use fSessionCriticalSection
    function SessionAccess(var aContext: TSQLRestServerSessionContext): TAuthSession;
    /// delete a session from its index in fSessions[]
    // - will perform any needed clean-up, and log the event
    // - this method is not thread-safe: caller should use fSessionCriticalSection
    procedure SessionDelete(aSessionIndex: integer);
    /// returns a copy of the user associated to a session ID
    // - returns nil if the session does not exist (e.g. if authentication is
    // disabled)
    // - caller MUST release the TSQLAuthUser instance returned (if not nil)
    // - this method IS thread-safe, and call internaly fSessionCriticalSection
    // (the returned TSQLAuthUser is a private copy from fSessions[].User instance,
    // in order to be really thread-safe)
    // - the returned TSQLAuthUser instance will have GroupRights=nil but will
    // have ID, LogonName, DisplayName, PasswordHashHexa and Data fields available
    function SessionGetUser(aSessionID: Cardinal): TSQLAuthUser;
    /// returns TRUE if this table is worth caching (e.g. already in memory)
    // - this overriden implementation returns FALSE for TSQLRestServerStaticInMemory
    function CacheWorthItForTable(aTableIndex: cardinal): boolean; override;
    /// get a member from its ID (implements REST GET member)
    // - returns the data of this object as JSON
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    // - ForUpdate parameter is used only on Client side
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; virtual; abstract;
  public
    /// this integer property is incremented by the database engine when any SQL
    // statement changes the database contents (i.e. on any not SELECT statement)
    // - its value can be published to the client on every remote request
    // - it may be used by client to avoid retrieve data only if necessary
    // - if its value is 0, this feature is not activated on the server, and the
    // client must ignore it and always retrieve the content
    InternalState: Cardinal;
    /// a method can be specified here to trigger events after any table update
    // - is called BEFORE deletion, and AFTER insertion or update 
    // - to be used only server-side, not to synchronize some clients: the framework
    // is designed around a stateless RESTful architecture (like HTTP/1.1), in which
    // clients ask the server for refresh (see TSQLRestClientURI.UpdateFromServer)
    OnUpdateEvent: TNotifySQLEvent;

    /// implement Server-Side TSQLRest Retrieval (GET or LOCK methods)
    // - uses internally EngineRetrieve() function for calling the database engine
    // (via fStaticData[] if the table is stored as Static)
    // - handles locking if necessary
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    function Retrieve(aID: integer; Value: TSQLRecord; ForUpdate: boolean=false): boolean; override;
    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    // - will call EngineList() abstract method to retrieve its JSON content
    function ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    /// implement Server-Side TSQLRest adding
    // - uses internally EngineAdd() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    // - on success, returns the new ROWID value; on error, returns 0
    // - on success, Value.ID is updated with the new ROWID
    // - if aValue is TSQLRecordFTS3, Value.ID is stored to the virtual table
    function Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer; override;
    /// implement Server-Side TSQLRest update
    // - uses internally EngineUpdate() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    function Update(Value: TSQLRecord): boolean; override;
    /// implement Server-Side TSQLRest deletion
    // - uses internally EngineDelete() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    // - this record is also erased in all available TRecordReference properties
    // in the database Model, for relational database coherency
    function Delete(Table: TSQLRecordClass; ID: integer): boolean; override;
    /// implement Server-Side TSQLRest deletion with a WHERE clause
    // - will process all ORM-level validation, coherency checking and
    // notifications together with a low-level SQL deletion work (if possible) 
    function Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean; override;
    /// this method is called internally after any successfull deletion to
    // ensure relational database coherency
    // - delete all available TRecordReference properties pointing to this record
    // in the database Model, for database coherency
    // - delete all available TSQLRecord properties pointing to this record
    // in the database Model, for database coherency
    // - important notice: we don't use FOREIGN KEY constraints in this framework,
    // and handle all integrity check within this method (it's therefore less
    // error-prone, and more cross-database engine compatible)S
    function AfterDeleteForceCoherency(Table: TSQLRecordClass; aID: integer): boolean; virtual;
    /// implement Server-Side TSQLRest blob field content retrieval
    // - implements REST GET member with a supplied member ID and a blob field name
    // - uses internally EngineRetrieveBlob() function for calling the database engine
    // - call corresponding fStaticData[] if necessary
    // - this method retrieve the blob data as a TSQLRawBlob string
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean; override;
    /// implement Server-Side TSQLRest blob field content update
    // - implements REST PUT member with a supplied member ID and field name
    // - uses internally EngineUpdateBlob() function for calling the database engine
    // - this method expect the blob data to be supplied as a TSQLRawBlob string
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean; override;
    /// implement Server-Side TSQLRest unlocking
    // - implements our custom UNLOCK REST-like method
    // - locking is handled by TSQLServer.Model
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; override;
    {/ end a transaction (implements REST END Member)
     - write all pending TSQLVirtualTableJSON data to the disk }
    procedure Commit(SessionID: cardinal); override;
    /// Execute directly all SQL statement (POST SQL on ModelRoot URI)
    // - return true on success
    // - override this method for proper calling the database engine
    // - don't call this method in normal cases
    // - this method must be implemented to be thread-safe
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; virtual; abstract;

{$ifdef MSWINDOWS}
    /// declare the server on the local machine as a Named Pipe: allows
    // TSQLRestClientURINamedPipe local or remote client connection
    // - ServerApplicationName ('DBSERVER' e.g.) will be used to create a named
    // pipe server identifier, it is of UnicodeString type since Delphi 2009
    // (use of Unicode FileOpen() version)
    // - this server identifier is appended to '\\.\pipe\Sqlite3_' to obtain
    // the full pipe name to initiate ('\\.\pipe\Sqlite3_DBSERVER' e.g.)
    // - this server identifier may also contain a fully qualified path
    // ('\\.\pipe\ApplicationName' e.g.)
    // - allows only one ExportServer*() by running process
    // - returns true on success, false otherwize (ServerApplicationName already used?)
    function ExportServerNamedPipe(const ServerApplicationName: TFileName): boolean;
    /// end any currently initialized named pipe server
    function CloseServerNamedPipe: boolean;
    /// grant access to this database content from a dll using the global
    // URIRequest() function
    // - returns true if the URIRequest() function is set to this TSQLRestServer
    // - returns false if a TSQLRestServer was already exported
    // - client must release all memory acquired by URIRequest() with GlobalFree()
    function ExportServer: boolean; overload;
    /// declare the server on the local machine to be accessible for local
    // client connection, by using Windows messages
    // - the data is sent and received by using the standard and fast WM_COPYDATA message
    // - Windows messages are very fast (faster than named pipe and much faster
    // than HTTP), but only work localy on the same computer
    // - create a new Window Class with the supplied class name (UnicodeString
    // since Delphi 2009 for direct use of Wide Win32 API), and instanciate
    // a window which will handle pending WM_COPYDATA messages
    // - the main server instance has to process the windows messages regularely
    // (e.g. with Application.ProcessMessages)
    // - ServerWindowName ('DBSERVER' e.g.) will be used to create a
    // Window name identifier
    // - allows only one ExportServer*() by running process
    // - returns true on success, false otherwize (ServerWindowName already used?)
    function ExportServerMessage(const ServerWindowName: string): boolean;
    /// implement a message-based server response
    // - this method is called automaticaly if ExportServerMessage() method
    // was initilialized
    // - you can also call this method from the WM_COPYDATA message handler
    // of your main form, and use the TSQLRestClientURIMessage class to access
    // the server instance from your clients
    // - it will answer to the Client with another WM_COPYDATA message
    // - message oriented architecture doesn't need any thread, but will use
    // the main thread of your application
    procedure AnswerToMessage(var Msg: TWMCopyData); message WM_COPYDATA;
    /// end any currently initialized message-oriented server
    function CloseServerMessage: boolean;
{$endif}
    /// Server initialization with a specified Database Model
    // - if HandleUserAuthentication is false, will set URI access rights to
    // 'Supervisor' (i.e. all R/W access) by default
    // - if HandleUserAuthentication is true, will add TSQLAuthUser and
    // TSQLAuthGroup to the TSQLModel (if not already there)
    constructor Create(aModel: TSQLModel; aHandleUserAuthentication: boolean=false); reintroduce;
    /// release memory and any existing pipe initialized by ExportServer()
    destructor Destroy; override;
    /// create an external static in-memory database for a specific class
    // - call it just after Create, before TSQLRestServerDB.CreateMissingTables;
    // warning: if you don't call this method before CreateMissingTable method
    // is called, the table will be created as a regular table by the main
    // database engine, and won't be static
    // - can load the table content from a file if a file name is specified
    // (could be either JSON or compressed Binary format on disk)
    // - you can define a particular external engine by setting a custom class -
    // by default, it will create a TSQLRestServerStaticInMemory instance
    // - this data handles basic REST commands, since no complete SQL interpreter
    // can be implemented by TSQLRestServerStatic; to provide full SQL process,
    // you should better use a Virtual Table class, inheriting e.g. from
    // TSQLRecordVirtualTableAutoID associated with TSQLVirtualTableJSON/Binary
    // via a Model.VirtualTableRegister() call before TSQLRestServer.Create 
    // - return nil on any error
    function StaticDataCreate(aClass: TSQLRecordClass;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false;
      aServerClass: TSQLRestServerStaticClass=nil): TSQLRestServerStatic;
    /// call this method when the internal DB content is known to be invalid
    // - by default, all REST/CRUD requests and direct SQL statements are
    // scanned and identified as potentially able to change the internal SQL/JSON
    // cache used at SQLite3 database level; but some virtual tables (e.g.
    // TSQLRestServerStaticExternal classes defined in SQLite3DB) could flush
    // the database content without proper notification
    // - this default implementation just do nothing, but SQlite3 unit
    // will call TSQLDataBase.CacheFlush method
    procedure FlushInternalDBCache; virtual;
    /// you can call this method in TThread.Execute to ensure that
    // the thread will be taken in account during process
    // - caller must specify the TThread instance running
    // - used e.g. for execInMainThread option in TServiceMethod.InternalExecute
    // - this default implementation will call the methods of all its internal
    // TSQLRestServerStatic instances
    // - this method shall be called from the thread just initiated: e.g.
    // if you call it from the main thread, it may fail to prepare resources
    procedure BeginCurrentThread(Sender: TThread); virtual;
    /// you can call this method just before a thread is finished to ensure
    // e.g. that the associated external DB connection will be released
    // - this default implementation will call the methods of all its internal
    // TSQLRestServerStatic instances, allowing e.g. TSQLRestServerStaticExternal
    // instances to clean their thread-specific connections
    // - this method shall be called from the thread about to be terminated: e.g.
    // if you call it from the main thread, it may fail to release resources
    // - it is set e.g. by TSQLite3HttpServer to be called from HTTP threads,
    // or by TSQLRestServerNamedPipeResponse for named-pipe server cleaning
    procedure EndCurrentThread(Sender: TObject); virtual;

    /// implement a generic local, piped or HTTP/1.1 provider
    // - this is the main entry point of the server, from the client side
    // - some GET/POST/PUT JSON data can be specified in SentData
    // - return in result.Lo the HTTP STATUS integer error or success code:
    // 404/HTML_NOTFOUND e.g. if the url doesn't start with Model.Root (caller
    // can try another TSQLRestServer)
    // - return in result.Hi the database internal status
    // - store the data to be sent into Resp, some headers in Head
    // - default implementation calls protected methods EngineList() Retrieve()
    // Add() Update() Delete() UnLock() EngineExecute() above, which must be overriden by
    // the TSQLRestServer child
    // - see TSQLRestClient to check how data is expected in our RESTful format
    // - AccessRights must be handled by the TSQLRestServer child, according
    // to the Application Security Policy (user logging, authentification and
    // rights management) - making access rights a parameter allows this method
    // to be handled as pure stateless, thread-safe and session-free
    // - handle enhanced REST codes: LOCK/UNLOCK/BEGIN/END/ABORT
    // - for 'GET ModelRoot/TableName', url parameters can be either "select" and
    // "where" (to specify a SQL Query, from the SQLFromSelectWhere function),
    // either "sort", "dir", "startIndex", "results", as expected by the YUI
    // DataSource Request Syntax for data pagination - see
    // http://developer.yahoo.com/yui/datatable/#data
    function URI(const url, method, SentData: RawUTF8;
      out Resp, Head: RawUTF8; RestAccessRights: PSQLAccessRights): Int64Rec; virtual;

    /// create an index for the specific FieldName
    // - will call CreateSQLMultiIndex() internaly
    function CreateSQLIndex(Table: TSQLRecordClass; const FieldName: RawUTF8;
      Unique: boolean; const IndexName: RawUTF8=''): boolean; overload;
    /// create one or multiple index(es) for the specific FieldName(s)
    function CreateSQLIndex(Table: TSQLRecordClass; const FieldNames: array of RawUTF8;
      Unique: boolean): boolean; overload;
    /// create one index for all specific FieldNames at once
    function CreateSQLMultiIndex(Table: TSQLRecordClass; const FieldNames: array of RawUTF8;
      Unique: boolean; IndexName: RawUTF8=''): boolean; virtual;

    /// encode some value into a JSON "result":"value" UTF-8 encoded content
    // - wrapper around standard JSONEncode() function
    // - OneValue usually have only ONE parameter, e.g.:
    // ! result := JSONEncodeResult([Value]);
    // returned as '"result":100' if Value=100
    // - if OneValue has more than one parameter, returns a JSON array of values
    // like '"result":["value1",value2]'
    // - this method will work outside of a true TSQLRestServer instance: you
    // can use e.g.
    // ! TSQLRestServer.JSONEncodeResult(['value1',10])
    class function JSONEncodeResult(const OneValue: array of const): RawUTF8;
    /// call this method to disable Authentication method check for a given
    // published method name
    // - by default, only Auth and TimeStamp methods do not require the RESTful
    // authentication of the URI; you may call this method to add another method
    // to the list (e.g. for returning some HTML content from a public URI)
    procedure ServiceMethodByPassAuthentication(const aMethodName: RawUTF8);

    /// register a Service on the server side
    // - this methods expects a class to be supplied, and the exact list of
    // interfaces to be registered to the server (e.g. [TypeInfo(IMyInterface)])
    // and implemented by this class
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return the first of the registered TServiceFactoryServer created
    // on success (i.e. the one corresponding to the first item of the aInterfaces
    // array), or nil if registration failed (e.g. if any of the supplied interfaces
    // is not implemented by the given class)
    // - you can use the returned TServiceFactoryServer instance to set the
    // expected security parameters associated with this interface
    // - the same implementation class can be used to handle several interfaces
    // (just as Delphi allows to do natively)
    function ServiceRegister(aImplementationClass: TClass;
      const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle): TServiceFactoryServer; overload; virtual;
    /// register a remote Service via its interface
    // - this overloaded method will register a remote Service, accessed via the
    // supplied TSQLRest(ClientURI) instance: it can be available in the main
    // TSQLRestServer.Services property, but execution will take place on a
    // remote server - may be used e.g. for dedicated hosting of services (in
    // a DMZ for instance)
    // - this methods expects a list of interfaces to be registered to the client
    // (e.g. [TypeInfo(IMyInterface)])
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return true on success, false if registration failed (e.g. if any of
    // the supplied interfaces is not correct or is not available on the server)
    // - that is, server side will be called to check for the availability of
    // each interface
    // - you can specify an optional custom contract for the first interface
    function ServiceRegister(aClient: TSQLRest; const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle;
      const aContractExpected: RawUTF8=''): boolean; overload; virtual;

    /// set this property to true to transmit the JSON data in a "not expanded" format
    // - not directly compatible with Javascript object list decode: not to be
    // used in AJAX environnement (like in TSQLite3HttpServer)
    // - but transmitted JSON data is much smaller if set it's set to FALSE, and
    // if you use a Delphi Client, parsing will be also faster and memory usage
    // will be lower
    // - By default, the NoAJAXJSON property is set to TRUE in
    // TSQLRestServer.ExportServerNamedPipe: if you use named pipes for communication,
    // you probably won't use javascript because browser communicates via HTTP!
    // - But otherwise, NoAJAXJSON property is set to FALSE. You could force its
    // value to TRUE and you'd save some bandwidth if you don't use javascript:
    // even the parsing of the JSON Content will be faster with Delphi client
    // if JSON content is not expanded
    // - the "expanded" or standard/AJAX layout allows you to create pure JavaScript
    // objects from the JSON content, because the field name / JavaScript object
    // property name is supplied for every value
    // - the "not expanded" layout, NoAJAXJSON property is set to TRUE,
    // reflects exactly the layout of the SQL request - first line contains the
    // field names, then all next lines are the field content
    property NoAJAXJSON: boolean read fNoAJAXJSON write SetNoAJAXJSON;
    /// set to true if the server will handle per-user authentication and
    // access right management
    // - i.e. if the associated TSQLModel contains TSQLAuthUser and
    // TSQLAuthGroup tables (set by constructor)
    property HandleAuthentication: boolean read fHandleAuthentication;
    /// access to the Server statistics
    property Stats: TSQLRestServerStats read fStats;
    /// retrieve the TSQLRestServerStatic instance used to store and manage
    // a specified TSQLRecordClass in memory
    // - has been associated by the StaticDataCreate method
    property StaticDataServer[aClass: TSQLRecordClass]: TSQLRestServerStatic
      read GetStaticDataServer;
    /// retrieve a running TSQLRestServerStatic virtual table
    // - associated e.g. to a 'JSON' or 'Binary' virtual table module, or may
    // return a TSQLRestServerStaticExternal instance (as defined in SQLite3DB)
    // - this property will return nil if there is no Virtual Table associated
    // or if the corresponding module is not a TSQLVirtualTable
    // (e.g. "pure" static tables registered by StaticDataCreate would be
    // accessible only via StaticDataServer[], not via StaticVirtualTable[])
    // - has been associated by the TSQLModel.VirtualTableRegister method or
    // the VirtualTableExternalRegister() global function
    property StaticVirtualTable[aClass: TSQLRecordClass]: TSQLRestServerStatic
      read GetVirtualTable;
    /// this property can be left to its TRUE default value, to handle any
    // TSQLVirtualTableJSON static tables (module JSON or BINARY) with direct
    // calls to the storage instance
    // - is set to TRUE by default to enable faster Direct mode
    // - in Direct mode, GET/POST/PUT/DELETE of individual records (or BLOB fields)
    // from URI() will call directly the corresponding TSQLRestServerStatic
    // instance, for better speed for most used RESTful operations; but complex
    // SQL requests (e.g. joined SELECT) will rely on the main SQL engine
    // - if set to false, will use the main SQLite3 engine for all statements
    // (should not to be used normaly, because it will add unnecessary overhead)
    property StaticVirtualTableDirect: boolean read fVirtualTableDirect
      write fVirtualTableDirect;
  published
    /// this method will be accessible from ModelRoot/Stat URI, and
    // will retrieve some statistics as a JSON object
    // - method parameters signature matches TSQLRestServerCallBack type
    function Stat(var aParams: TSQLRestServerCallBackParams): Integer;
    /// this method will be accessible from ModelRoot/Auth URI, and
    // will be called by the client for authentication and session management
    // - method parameters signature matches TSQLRestServerCallBack type
    // - to be called in a two pass "challenging" algorithm:
    // $ GET ModelRoot/auth?UserName=...
    // $  -> returns an hexadecimal nonce contents (valid for 5 minutes)
    // $ GET ModelRoot/auth?UserName=...&PassWord=...&ClientNonce=...
    // $ -> if password OK, open the corresponding session
    // $    and returns 'SessionID+HexaSessionPrivateKey'
    // The Password parameter as sent for the 2nd request will be computed as
    // ! Sha256(ModelRoot+Nonce+ClientNonce+UserName+Sha256('salt'+PassWord))
    // - the returned HexaSessionPrivateKey content will identify the current
    // user logged and its corresponding session (the same user may have several
    // sessions opened at once, each with its own private key)
    // - then the private session key must be added to every query sent to
    // the server as a session_signature=???? parameter, which will be computed
    // as such:
    // $ ModelRoot/url?A=1&B=2&session_signature=012345670123456701234567
    // were the session_signature= parameter will be computed as such:
    // ! Hexa8(SessionID)+Hexa8(TimeStamp)+
    // ! Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
    // !  Hexa8(TimeStamp)+url))
    // ! with url='ModelRoot/url?A=1&B=2'
    // this query authentication uses crc32 for hashing instead of SHA-256 in
    // in order to lower the Server-side CPU consumption; the salted password
    // (i.e. TSQLAuthUser.PasswordHashHexa) and client-side TimeStamp are
    // inserted inside the session_signature calculation to prevent naive
    // man-in-the-middle attack (MITM)
    // - the session ID will be used to retrieve the rights associated with the
    // user which opened the session via a successful call to the Auth service
    // - when you don't need the session any more (e.g. if the TSQLRestClientURI
    // instance is destroyed), you can call the service as such:
    // $ GET ModelRoot/auth?UserName=...&Session=...
    // - for a way of computing SHA-256 in JavaScript, see for instance
    // @http://www.webtoolkit.info/javascript-sha256.html
    // - this global callback method is thread-safe
    function Auth(var aParams: TSQLRestServerCallBackParams): Integer;
    /// this method will be accessible from the ModelRoot/TimeStamp URI, and
    // will return the server time stamp TTimeLog/Int64 value as RawUTF8
    // - method parameters signature matches TSQLRestServerCallBack type
    function TimeStamp(var aParams: TSQLRestServerCallBackParams): Integer;
    /// this method will be accessible from the ModelRoot/CacheFlush URI, and
    // will flush the server cache
    // - this method shall be called by the clients when the Server cache could
    // be not refreshed
    // - ModelRoot/CacheFlush URI will flush the whole Server cache, for all tables
    // - ModelRoot/CacheFlush/TableName URI will flush the specified table cache
    // - ModelRoot/CacheFlush/TableName/ID URI will flush the content of the
    // specified record
    // - method parameters signature matches TSQLRestServerCallBack type
    function CacheFlush(var aParams: TSQLRestServerCallBackParams): Integer;
    /// this method will be accessible from the ModelRoot/Batch URI, and
    // will execute a set of RESTful commands
    // - expect input as JSON commands - see TSQLRestServer.RunBatch, i.e.
    // & '{"Table":["cmd":values,...]}'
    // or for multiple tables:
    // & '["cmd@Table":values,...]'
    // with cmd in POST/PUT with {object} as value or DELETE with ID
    // - only accepted context HTTP verb is PUT (for thread-safe and security
    // reasons)
    function Batch(var aParams: TSQLRestServerCallBackParams): Integer;
  end;

  /// REST server with direct access to an external database engine
  // - you can set an alternate per-table database engine by using this class
  // - this abstract class is to be overriden with a proper implementation (like
  // our TSQLRestServerStaticInMemory class)
  TSQLRestServerStatic = class(TSQLRestServer)
  protected
    fStoredClass: TSQLRecordClass;
    fStoredClassProps: TSQLRecordProperties;
    fFileName: TFileName;
    fModified: boolean;
    fOwner: TSQLRestServer;
    /// any set bit in this field indicates UNIQUE field value
    fIsUnique: TSQLFieldBits;
    procedure Lock(WillModifyContent: boolean);
    procedure UnLock;
    /// override this method if you want to update the refresh state
    // - returns FALSE if the static table content was not modified (default
    // method implementation is to always return FALSE)
    // - returns TRUE if the table has been refreshed and its content was modified:
    // therefore the client will know he'll need to refresh some content
    function RefreshedAndModified: boolean; virtual;
    /// overriden method calling the owner (if any) to guess if this record
    // can be updated or deleted
    function RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
      ErrorMsg: PRawUTF8 = nil): boolean; override;
    /// internal method called by TSQLRestServer.RunBatch() to process fast sending
    // to remote database engine (e.g. Oracle bound arrays or MS SQL Bulk insert)
    // - returns TRUE if this method is handled by the engine, or FALSE if
    // individual calls to Engine*() are expected
    // - this default implementation returns FALSE
    // - an overriden method returning TRUE shall ensure that calls to
    // EngineAdd / EngineUpdate / EngineDelete (depending of supplied Method)
    // will properly handle operations until InternalBatchStop is called
    function InternalBatchStart(Method: TSQLURIMethod): boolean; virtual;
    /// internal method called by TSQLRestServer.RunBatch() to process fast sending
    // to remote database engine (e.g. Oracle bound arrays or MS SQL Bulk insert)
    // - this default implementation does nothing (since InternalBatchStart
    // returns always FALSE)
    // - InternalBatchStart/Stop may safely use a lock for multithreading:
    // implementation in TSQLRestServer.RunBatch use a try..finally block
    procedure InternalBatchStop; virtual;
    /// TSQLRestServer.URI use it for Static.EngineList to by-pass virtual table
    // - this default implementation will return TRUE and replace SQL with
    // SQLSelectAll[true] if it SQL equals SQLSelectAll[false] (i.e. 'SELECT *')
    // - this method is called only if the WHERE clause of SQL refers to the
    // static table name only (not needed to check it twice)  
    function AdaptSQLForEngineList(var SQL: RawUTF8): boolean; virtual;
  public
    /// initialize the server data, reading it from a file if necessary
    // - data encoding on file is UTF-8 JSON format by default, or
    // should be some binary format if aBinaryFile is set to true (this virtual
    // method will just ignore this parameter, which will be used for overriden
    // constructor only)
    constructor Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false); virtual;
    
    /// overriden method for direct in-memory database engine call
    // - not implemented: always return false
    // - this method must be implemented to be thread-safe
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; override;
    /// overriden method for direct in-memory database engine call
    // - made public since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    // - do nothing method: will return FALSE (aka error)
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    /// search for a numerical field value
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    // - this default implementation will call the overloaded SearchField()
    // value after conversion of the FieldValue into RawUTF8
    function SearchField(const FieldName: ShortString; const FieldValue: Integer;
      var ResultID: TIntegerDynArray): boolean; overload; virtual;
    /// search for a field value, according to its SQL content representation
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    function SearchField(const FieldName: ShortString; const FieldValue: RawUTF8;
      var ResultID: TIntegerDynArray): boolean; overload; virtual; abstract;

    /// read only access to the file name specified by constructor
    // - you can call the TSQLRestServer.StaticDataCreate method to
    // update the file name of an already instancied static table
    property FileName: TFileName read fFileName write fFileName;
    /// read only access to a boolean value set to true if table data was modified
    property Modified: boolean read fModified write fModified;
    /// read only access to the class defining the record type stored in this REST server
    property StoredClass: TSQLRecordClass read fStoredClass;
    /// read only access to the class properties of the associated record type
    property StoredClassProps: TSQLRecordProperties read fStoredClassProps;
    /// read only access to the Server using this in-memory database
    property Owner: TSQLRestServer read fOwner;
  end;

  /// event prototype called by FindWhereEqual() method
  TFindWhereEqualEvent = procedure(aDest: pointer; aRec: TSQLRecord; aIndex: integer) of object;

  /// abstract REST server exposing some internal TSQLRecord-based methods
  TSQLRestServerStaticRecordBased = class(TSQLRestServerStatic)
  protected
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
  public
    /// manual Add of a TSQLRecord
    // - returns the ID created on success
    // - returns -1 on failure (not UNIQUE field value e.g.)
    // - on success, the Rec instance is added to the Values[] list: caller
    // doesn't need to Free it
    function AddOne(Rec: TSQLRecord): integer; virtual; abstract;
    /// manual Retrieval of a TSQLRecord field values
    // - an instance of the associated static class is created
    // - and all its properties are filled from the Items[] values
    // - caller can modify these properties, then use UpdateOne() if the changes
    // have to be stored inside the Items[] list
    // - calller must always free the returned instance
    // - returns NIL if any error occured, e.g. if the supplied aID was incorrect
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function GetOne(aID: integer): TSQLRecord; virtual; abstract;
    /// manual Update of a TSQLRecord field values
    // - Rec.ID specifies which record is to be updated
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(Rec: TSQLRecord): boolean; overload; virtual; abstract;
    /// manual Update of a TSQLRecord field values from TVarData array
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    // - this default implementation will create a temporary TSQLRecord instance
    // with the supplied Values[], and will call overloaded UpdateOne() method
    function UpdateOne(ID: integer; const Values: TVarDataDynArray): boolean; overload; virtual;
  end;

  /// class able to handle a O(1) hashed-based search of a property in a TList 
  // - used e.g. to hash TSQLRestServerStaticInMemory field values
  TListFieldHash = class(TObjectHash)
  protected
    fValues: TList;
    fField: integer;
    fProp: PPropInfo;
    fCaseInsensitive: boolean;
    /// overriden method to hash an item
    function Hash(Item: TObject): cardinal; override;
    /// overriden method to compare two items
    function Compare(Item1,Item2: TObject): boolean; override;
    /// overriden method to get an item
    // - shall return nil if Index is out of range (e.g. >= Count)
    // - will be called e.g. by Find() with Compare() to avoid collision
    function Get(Index: integer): TObject; override;
    /// overriden method to retrieve the number of items
    function Count: integer; override;
  public
    /// initialize a hash for a record array field
    // - aFieldIndex/aField parameters correspond to the indexed field (e.g.
    // stored false published property)
    // - if CaseInsensitive is TRUE, will apply NormToUpper[] 8 bits uppercase,
    // handling RawUTF8 properties just like the SYSTEMNOCASE collation
    constructor Create(aValues: TList; aFieldIndex: integer;
      aField: PPropInfo; aCaseInsensitive: boolean);
    /// the corresponding field index in the TSQLRecord
    property FieldIndex: integer read fField;
    /// the corresponding field RTTI
    property Field: PPropInfo read fProp;
    /// if the string comparison shall be case-insensitive
    property CaseInsensitive: boolean read fCaseInsensitive;
  end;

  /// REST server with direct access to a memory-stored database
  // - store the associated TSQLRecord values in memory
  // - handle only one TSQLRecord by server (it's NOT a true Rest Server)
  // - must be registered individualy in a TSQLRestServer to access data from a
  // common client, by using the TSQLRestServer.StaticDataCreate method:
  // it allows an unique access for both SQLite3 and Static databases
  // - handle basic REST commands, no SQL interpreter is implemented: only
  // valid SQL command is "SELECT Field1,Field2 FROM Table WHERE ID=120;", i.e
  // a one Table SELECT with one optional "WHERE fieldname = value" statement;
  // if used within a TSQLVirtualTableJSON, you'll be able to handle any kind of
  // SQL statement (even joined SELECT or such) with this memory-stored database
  // - our TSQLRestServerStatic database engine is very optimized and is a lot
  // faster than SQLite3 for such queries - but its values remain in RAM,
  // therefore it is not meant to deal with more than 100,000 rows
  // - data can be stored and retrieved from a file (JSON format is used by
  // default, if BinaryFile parameter is left to false; a proprietary compressed
  // binary format can be used instead) if a file name is supplied at creating
  // the TSQLRestServerStaticInMemory instance
  TSQLRestServerStaticInMemory = class(TSQLRestServerStaticRecordBased)
  protected
    fValue: TObjectList;
    /// true if IDs are sorted (which is the default behavior of this class),
    // for fastest ID2Index() by using a binary search algorithm
    fIDSorted: boolean;
    fCommitShouldNotUpdateFile: boolean;
    fBinaryFile: boolean;
    fExpandedJSON: boolean;
    fSearchRec: TSQLRecord;
    fBasicUpperSQLWhere: RawUTF8;
    fUniqueFields: TObjectList;
    function UniqueFieldsUpdateOK(aRec: TSQLRecord; aUpdateIndex: integer): boolean;
    function UniqueFieldHash(aFieldIndex: integer): TListFieldHash;
    function GetCount: integer;
    function GetItem(Index: integer): TSQLRecord;
    function GetID(Index: integer): integer;
    // optimized search of WhereValue in WhereField (0=RowID,1..=RTTI)
    function FindWhereEqual(WhereField: integer; const WhereValue: RawUTF8;
      OnFind: TFindWhereEqualEvent; Dest: pointer; FoundLimit: integer=0): PtrInt;
    procedure GetJSONValuesEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    procedure GetJSONValuesEventExpand(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    procedure AddIntegerDynArrayEvent(aDest: pointer; aRec: TSQLRecord; aIndex: integer);
    /// used to create the JSON content from a SELECT parsed command
    // - WhereField index follows FindWhereEqual / TSynTableStatement.WhereField
    // - returns the number of data row added (excluding field names)
    // - this method is very fast and optimized (for search and JSON serializing)
    function GetJSONValues(Stream: TStream; Expand, withID: boolean;
      const Fields: TSQLFieldBits; WhereField: integer; const WhereValue: RawUTF8): PtrInt;
    /// TSQLRestServer.URI use it for Static.EngineList to by-pass virtual table
    // - overriden method to handle basic queries as handled by EngineList()
    function AdaptSQLForEngineList(var SQL: RawUTF8): boolean; override;
    /// overriden methods for direct in-memory database engine thread-safe process
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
  public
    /// initialize the server data, reading it from a file if necessary
    // - data encoding on file is UTF-8 JSON format by default, or
    // should be some binary format if aBinaryFile is set to true
    constructor Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
      const aFileName: TFileName = ''; aBinaryFile: boolean=false); override;
    /// free used memory
    // - especially release all fValue[] instances
    destructor Destroy; override;

    /// load the values from JSON data
    procedure LoadFromJSON(const aJSON: RawUTF8); overload;
    /// load the values from JSON data
    procedure LoadFromJSON(JSONBuffer: PUTF8Char; JSONBufferLen: integer); overload;
    /// save the values into JSON data
    function SaveToJSON(Expand: Boolean): RawUTF8; overload;
    /// save the values into JSON data
    procedure SaveToJSON(Stream: TStream; Expand: Boolean); overload;
    /// load the values from binary data
    // - the binary format is a custom compressed format (using our SynLZ fast
    // compression algorithm), with variable-length record storage
    // - the binary content is first checked for consistency, before loading
    // - warning: the field layout should be the same at SaveToBinary call;
    // for instance, it won't be able to read a file content with a renamed
    // or modified field type 
    // - will return false if the binary content is invalid
    function LoadFromBinary(Stream: TStream): boolean;
    /// save the values into binary data
    // - the binary format is a custom compressed format (using our SynLZ fast
    // compression algorithm), with variable-length record storage: e.g. a 27 KB
    // Dali1.json content is stored into a 6 KB Dali2.data file
    // (this data has a text redundant field content in its FirstName field);
    // 502 KB People.json content is stored into a 92 KB People.data file
    // - returns the number of bytes written into Stream
    function SaveToBinary(Stream: TStream): integer;
    /// if file was modified, the file is updated on disk
    // - this method is called automaticaly when the TSQLRestServerStatic
    // instance is destroyed: should should want to call in in some cases,
    // in order to force the data to be saved regularly
    // - do nothing if the table content was not modified
    // - will write JSON content by default, or binary content if BinaryFile
    // property was set to true
    procedure UpdateFile;
    /// retrieve the index in Items[] of a particular ID
    // - return -1 if this ID was not found
    // - use fast binary search algorithm (since Items[].ID should be increasing)
    function IDToIndex(ID: integer): integer;
    /// manual Add of a TSQLRecord
    // - returns the ID created on success
    // - returns -1 on failure (not UNIQUE field value e.g.)
    // - on success, the Rec instance is added to the Values[] list: caller
    // doesn't need to Free it
    function AddOne(Rec: TSQLRecord): integer; override;
    /// manual Retrieval of a TSQLRecord field values
    // - an instance of the associated static class is created
    // - and all its properties are filled from the Items[] values
    // - caller can modify these properties, then use UpdateOne() if the changes
    // have to be stored inside the Items[] list
    // - calller must always free the returned instance
    // - returns NIL if any error occured, e.g. if the supplied aID was incorrect
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function GetOne(aID: integer): TSQLRecord; override;
    /// manual Update of a TSQLRecord field values
    // - Rec.ID specifies which record is to be updated
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(Rec: TSQLRecord): boolean; override;
    /// manual Update of a TSQLRecord field values from TVarData array
    // - will update all properties, including BLOB fields and such
    // - returns TRUE on success, FALSE on any error (e.g. invalid Rec.ID)
    // - method available since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function UpdateOne(ID: integer; const Values: TVarDataDynArray): boolean; override;
    /// overriden method for direct in-memory database engine call
    // - made public since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; override;
    /// overriden method for direct in-memory database engine call
    // - made public since a TSQLRestServerStatic instance may be created
    // stand-alone, i.e. without any associated Model/TSQLRestServer
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
    /// search for a field value, according to its SQL content representation
    // - return true on success (i.e. if some values have been added to ResultID)
    // - store the results into the ResultID dynamic array
    // - faster than OneFieldValues method, which creates a temporary JSON content
    function SearchField(const FieldName: ShortString; const FieldValue: RawUTF8;
      var ResultID: TIntegerDynArray): boolean; override;
    /// read-only access to the number of TSQLRecord values
    property Count: integer read GetCount;
    /// read-only access to the TSQLRecord values, storing the data
    // - this returns directly the item class instance stored in memory: if you
    // change the content, it will affect the internal data - so for instance
    // DO NOT change the ID values, unless you may have unexpected behavior
    property Items[Index: integer]: TSQLRecord read GetItem; default;
    /// read-only access to the ID of a TSQLRecord values
    property ID[Index: integer]: integer read GetID;
    /// if set to true, file content on disk will expect binary format
    // - default format on disk is JSON but can be overriden at constructor call
    // - binary format should be more efficient in term of speed and disk usage,
    // but can be proprietary
    property BinaryFile: boolean read fBinaryFile write fBinaryFile;
    // JSON writing, can set if the format should be expanded or not
    // - by default, the JSON will be in the custom non-expanded format,
    // to save disk space and time
    // - you can force the JSON to be emitted as an array of objects,
    // e.g. for better human friendliness (reading and modification)
    property ExpandedJSON: boolean read fExpandedJSON write fExpandedJSON;
    /// set this property to TRUE if you want the COMMIT statement not to
    // update the associated TSQLVirtualTableJSON
    property CommitShouldNotUpdateFile: boolean read fCommitShouldNotUpdateFile
      write fCommitShouldNotUpdateFile;
  end;

  /// REST server with direct access to a memory database, to be used as
  // external table
  // - this is the kind of in-memory table expected by TSQLVirtualTableJSON,
  // in order to be consistent with the internal DB cache
  TSQLRestServerStaticInMemoryExternal = class(TSQLRestServerStaticInMemory)
  public
    /// call this method when the internal DB content is known to be invalid
    // - by default, all REST/CRUD requests and direct SQL statements are
    // scanned and identified as potentially able to change the internal SQL/JSON
    // cache used at SQLite3 database level; but TSQLVirtualTableJSON virtual
    // tables could flush the database content without proper notification
    // - this overriden implementation will call Owner.FlushInternalDBCache
    procedure FlushInternalDBCache; override;
  end;

  /// a REST server using only in-memory tables
  // - this server will use TSQLRestServerStaticInMemory instances to handle
  // the data in memory, and optionally persist the data on disk as JSON or
  // binary files
  // - so it will not handle all SQL requests, just basic CRUD commands on
  // separated tables
  // - at least, it will compile as a TSQLRestServer without complaining for
  // pure abstract methods; it can be used to host some services if database
  // and ORM needs are basic (e.g. if only authentication and CRUD are needed)
  TSQLRestServerFullMemory = class(TSQLRestServer)
  protected
    fFileName: TFileName;
    fBinaryFile: Boolean;
    fStaticDataCount: cardinal;
    function GetStatic(Table: TSQLRecordClass): TSQLRestServerStaticInMemory;
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; override;
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
  public
    /// initialize a REST server with a database file
    // - all classes of the model will be created as TSQLRestServerStaticInMemory
    // - then data persistence will be created using aFileName
    // - if aFileName is left void (''), data will not be persistent
    constructor Create(aModel: TSQLModel; const aFileName: TFileName='';
      aBinaryFile: boolean=false; aHandleUserAuthentication: boolean=false); reintroduce; virtual;
    /// write any modification on file (if needed), and release all used memory
    destructor Destroy; override;
    /// load the content from the specified file name
    // - do nothing if file name was not assigned
    procedure LoadFromFile; virtual;
    /// write any modification into file
    // - do nothing if file name was not assigned
    procedure UpdateToFile; virtual;
    /// overriden method for direct in-memory database engine call
    // - not implemented: always return false
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; override;
    /// the file name used for data persistence
    property FileName: TFileName read fFileName write fFileName;
    /// set if the file content is to be compressed binary, or standard JSON
    // - it will use TSQLRestServerStaticInMemory LoadFromJSON/LoadFromBinary
    // SaveToJSON/SaveToBinary methods for optimized storage
    property BinaryFile: Boolean read fBinaryFile write fBinaryFile;
  end;

  /// a REST server using a TSQLRestClient for all its ORM process
  // - this server will use an internal TSQLRestClient instance to handle
  // all ORM operations (i.e. access to objects)
  // - it can be used e.g. to host some services on a stand-alone server, with
  // all ORM and data access retrieved from another server: it will allow to
  // easily implement a proxy architecture (for instance, as a DMZ for
  // publishing services, but letting ORM process stay out of scope)
  TSQLRestServerRemoteDB = class(TSQLRestServer)
  protected
    fClient: TSQLRestClient;
    function EngineRetrieve(TableModelIndex: integer; ID: integer): RawUTF8; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; override;
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
  public
    /// initialize a REST server associated to a given TSQLRestClient instance
    // - the specified TSQLRestClient will be used for all ORM and data process
    // - the supplied TSQLRestClient.Model will be used for TSQLRestServerRemoteDB
    // - note that the TSQLRestClient instance won't be freed - caller shall
    // manage its life time
    constructor Create(aRemoteClient: TSQLRestClient;
      aHandleUserAuthentication: boolean=false); reintroduce; virtual;
    /// implement Server-Side TSQLRest deletion
    /// overriden method for remote database engine call
    // - will return false - i.e. not implemented - since it is a server side
    // operation
    function EngineExecuteAll(const aSQL: RawUTF8): boolean; override;
    /// Execute directly a SQL statement, expecting a list of results
    // - return a result table on success, nil on failure
    // - will call EngineList() abstract method to retrieve its JSON content
    function ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    /// this method is called internally after any successfull deletion to
    // ensure relational database coherency
    // - this overriden method will just return TRUE: in this remote access,
    // true coherency will be performed on the ORM server side
    function AfterDeleteForceCoherency(Table: TSQLRecordClass; aID: integer): boolean; override;
    /// the remote ORM client used for data persistence
    property Client: TSQLRestClient read fClient;
  end;


  /// possible call parameters for TOnTableUpdate Event
  TOnTableUpdateState = (tusPrepare, tusChanged, tusNoChange);

  /// used by TSQLRestClientURI.UpdateFromServer() to let the client
  // perform the rows update (for Marked[] e.g.)
  TOnTableUpdate = procedure(aTable: TSQLTableJSON; State: TOnTableUpdateState) of object;

  /// used by TSQLRestClientURI.Update() to let the client
  // perform the record update (refresh associated report e.g.)
  TOnRecordUpdate = procedure(Value: TSQLRecord) of object;

  /// a generic REpresentational State Transfer (REST) client
  // - is RESTful (i.e. URI) remotely implemented (TSQLRestClientURI e.g.)
  // - is implemented for direct access to a database (TSQLRestClientDB e.g.)
  TSQLRestClient = class(TSQLRest)
  protected
    fForceBlobTransfert: boolean;
    fOnTableUpdate: TOnTableUpdate;
    fOnRecordUpdate: TOnRecordUpdate;
    /// get a member from its ID (implements REST GET member)
    // - returns the data of this object as JSON
    // - override this method for proper data retrieval from the database engine
    // - this method must be implemented in a thread-safe manner
    function EngineRetrieve(TableModelIndex: integer; ID: integer;
      ForUpdate: boolean; var InternalState: cardinal; var Resp: RawUTF8): boolean; virtual; abstract;
    /// this method is called before updating any record
    // - should return FALSE to force no update
    // - can be use to update some field values just before saving to the database
    // (e.g. for digital signing purpose)
    // - this default method just return TRUE (i.e. OK to update)
    function BeforeUpdateEvent(Value: TSQLRecord): Boolean; virtual;
  public
    /// create a new member (implements REST POST Collection)
    // - URI is 'ModelRoot/TableName' with POST method
    // - if SendData is true, content of Value is sent to the server as JSON
    // - if ForceID is true, client sends the Value.ID field to use this ID
    // - server must return Status 201/HTML_CREATED on success
    // - server must send on success an header entry with 'Location: ModelRoot/TableName/ID
    // - on success, returns the new ROWID value; on error, returns 0
    // - on success, Value.ID is updated with the new ROWID
    // - if aValue is TSQLRecordFTS3, Value.ID is stored to the virtual table
    function Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer; override;
    /// update a member (implements REST PUT Collection/Member)
    // - URI is 'ModelRoot/TableName/ID' with PUT method
    // - server must return Status 200/HTML_SUCCESS OK on success
    function Update(Value: TSQLRecord): boolean; override;
    /// delete a member (implements REST DELETE Collection/Member)
    // - URI is 'ModelRoot/TableName/ID' with DELETE method
    // - server must return Status 200/HTML_SUCCESS OK on success
    function Delete(Table: TSQLRecordClass; ID: integer): boolean; override;
    /// get a member from its ID (implements REST GET Collection/Member)
    // - URI is 'ModelRoot/TableName/ID' with GET method
    // - server must return Status 200/HTML_SUCCESS OK on success
    // - if ForUpdate is true, the REST method is LOCK and not GET: it tries to lock
    // the corresponding record, then retrieve its content; caller has to call
    // UnLock() method after Value usage, to release the record
    function Retrieve(aID: integer; Value: TSQLRecord; ForUpdate: boolean=false): boolean; override;
    /// get a blob field content from its record ID and supplied blob field name
    // - implements REST GET member with a supplied member ID and a blob field name
    // - URI is 'ModelRoot/TableName/ID/BlobFieldName' with GET method
    // - server must return Status 200/HTML_SUCCESS OK on success
    // - this method retrieve the blob data as a TSQLRawBlob string
    function RetrieveBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean; override;
    /// get all BLOB fields of the supplied value from the remote server
    // - call internaly by Retrieve method when ForceBlobTransfert is TRUE
    function RetrieveBlobFields(Value: TSQLRecord): boolean;
    /// update a blob field from its record ID and supplied blob field name
    // - implements REST PUT member with a supplied member ID and field name
    // - URI is 'ModelRoot/TableName/ID/BlobFieldName' with PUT method
    // - server must return Status 200/HTML_SUCCESS OK on success
    // - this method expect the blob data to be supplied as a TSQLRawBlob string
    function UpdateBlob(Table: TSQLRecordClass; aID: integer;
      const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean; override;
    /// update all BLOB fields of the supplied Value
    // - uses the UpdateBlob() method to send the BLOB properties content to the Server
    // - called internaly by Add and Update methods when ForceBlobTransfert is TRUE
    // - you can use this method by hand, to avoid several calls to UpdateBlob()
    function UpdateBlobFields(Value: TSQLRecord): boolean;
    /// get a member from its ID (implements REST GET Collection/Member)
    // - URI is 'ModelRoot/TableName/ID' with GET method
    // - returns true on server returned 200/HTML_SUCCESS OK success, false on error
    // - set Refreshed to true if the content changed
    function Refresh(aID: integer; Value: TSQLRecord; var Refreshed: boolean): boolean;

    /// retrieve a list of members as a TSQLTable (implements REST GET Collection)
    // - default SQL statement is 'SELECT ID FROM TableName;' (i.e. retrieve
    // the list of all ID of this collection members)
    // - optional SQLSelect parameter to change the returned fields
    // as in 'SELECT SQLSelect FROM TableName;'
    // - optional SQLWhere parameter to change the search range or ORDER
    // as in 'SELECT SQLSelect FROM TableName WHERE SQLWhere;'
    // - using inlined parameters via :(...): in SQLWhere is always a good idea
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    function List(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8 = 'RowID';
      const SQLWhere: RawUTF8 = ''): TSQLTableJSON; virtual; abstract;
    /// retrieve a list of members as a TSQLTable (implements REST GET Collection)
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[] values
    // - using inlined parameters via :(...): in SQLWhereFormat is always a good idea
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    // - will call the List virtual method internaly
    function ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
      SQLWhereFormat: PUTF8Char; const Args: array of const): TSQLTableJSON; overload;
    /// retrieve a list of members as a TSQLTable (implements REST GET Collection)
    // - in this version, the WHERE clause can be created with the same format
    // as FormatUTF8() function, replacing all '%' chars with Args[], and all '?'
    // chars with Bounds[] (inlining them with :(...): and auto-quoting strings)
    // - example of use:
    // ! Table := ListFmt([TSQLRecord],'Name','ID=?',[],[aID]);
    // - for one TClass, you should better use TSQLRest.MultiFieldValues()
    // - will call the List virtual method internaly
    function ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
      SQLWhereFormat: PUTF8Char; const Args, Bounds: array of const): TSQLTableJSON; overload;
    /// Execute directly a SQL statement
    // - return true on success
    function EngineExecute(const SQL: RawUTF8): boolean; overload; virtual; abstract;
    /// Execute directly a SQL statement with supplied parameters
    // - expect the same format as FormatUTF8() function, replacing all '%' chars
    // with Args[] values
    // - return true on success
    function EngineExecuteFmt(SQLFormat: PUTF8Char; const Args: array of const): boolean; overload;
    /// Execute directly a SQL statement with supplied parameters
    // - expect the same format as FormatUTF8() function, replacing all '%' chars
    // with Args[] values, and all '?' chars with Bounds[] (inlining them
    // with :(...): and auto-quoting strings)
    // - return true on success
    function EngineExecuteFmt(SQLFormat: PUTF8Char; const Args, Bounds: array of const): boolean; overload;
    /// dedicated method used to retrieve matching IDs using a fast R-Tree index
    // - a TSQLRecordRTree is associated to a TSQLRecord with a specified BLOB
    // field, and will call TSQLRecordRTree BlobToCoord and ContainedIn virtual
    // class methods to execute an optimized SQL query
    // - will return all matching DataTable IDs in DataID[]
    // - will generate e.g. the following statement
    // $ SELECT MapData.ID From MapData, MapBox WHERE MapData.ID=MapBox.ID
    // $  AND minX>=:(-81.0): AND maxX<=:(-79.6): AND minY>=:(35.0): AND :(maxY<=36.2):
    // $  AND MapBox_in(MapData.BlobField,:('\uFFF0base64encoded-81,-79.6,35,36.2'):);
    // when the following Delphi code is executed:
    // ! aClient.RTreeMatch(TSQLRecordMapData,'BlobField',TSQLRecordMapBox,
    // !   aMapData.BlobField,ResultID);
    function RTreeMatch(DataTable: TSQLRecordClass;
      const DataTableBlobFieldName: RawUTF8; RTreeTable: TSQLRecordRTreeClass;
      const DataTableBlobField: RawByteString; var DataID: TIntegerDynArray): boolean;
    /// begin a transaction (calls REST BEGIN Member)
    // - by default, Client transaction will use here a pseudo session
    function TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED): boolean; override;
    /// end a transaction (calls REST END Member)
    // - by default, Client transaction will use here a pseudo session
    procedure Commit(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;
    /// abort a transaction (calls REST ABORT Member)
    // - by default, Client transaction will use here a pseudo session
    procedure RollBack(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;

    /// is set to TRUE, all BLOB fields are transferred between the Client and
    // the remote Server
    // - i.e. Add() Update() will use Blob-related RESTful PUT/POST request
    // - i.e. Retrieve() will use Blob-related RESTful GET request
    // - note that the Refresh method won't handle BLOB fields, even if this
    // property setting is set to TRUE
    // - by default, this property is set to FALSE, which setting will spare
    // bandwidth and CPU
    property ForceBlobTransfert: boolean read fForceBlobTransfert write fForceBlobTransfert;
    /// this Event is called by UpdateFromServer() to let the Client adapt to
    // some rows update (for Marked[] e.g.)
    property OnTableUpdate: TOnTableUpdate read fOnTableUpdate write fOnTableUpdate;
    /// this Event is called by Update() to let the client
    // perform the record update (refresh associated report e.g.)
    property OnRecordUpdate: TOnRecordUpdate read fOnRecordUpdate write fOnRecordUpdate;
  end;

  /// used by TSQLRestClientURI.URI() to let the client ask for an User name
  // and password, in order to retry authentication to the server
  // - should return TRUE if aUserName and aPassword both contain some entered
  // values to be sent for remote secure authentication
  // - should return FALSE if the user pressed cancel or the number of Retry
  // reached a defined limit 
  TOnAuthentificationFailed = function(Retry: integer;
    var aUserName, aPassword: string): boolean of object;

  /// a generic REpresentational State Transfer (REST) client with URI
  // - URI are standard Collection/Member implemented as ModelRoot/TableName/ID
  // - handle RESTful commands GET POST PUT DELETE LOCK UNLOCK
  TSQLRestClientURI = class(TSQLRestClient)
  private
    fBatch: TJSONSerializer;
    fBatchTable: TSQLRecordClass;
    fBatchCount: integer;
    fOnAuthentificationFailed: TOnAuthentificationFailed;
    fOnSetUser: TNotifyEvent;
    fMaximumAuthentificationRetry: Integer;
  protected
    /// private values created by sucessfull SetUser() method
    fSessionUser: TSQLAuthUser;
    fSessionID: cardinal;
    fSessionIDHexa8: RawUTF8;
    fSessionPrivateKey: cardinal;
    fSessionLastTickCount: cardinal;
    fSessionTickCountOffset: cardinal;
    /// append the '&session_signature' to the url, if fSession<>0
    // - should be called in URI() overriden method
    // - will use the format as described for TSQLRestServer.Auth() method, i.e.
    // as expected by TAuthSession.IsValidURL(); in particular, time stamp
    // resolution is about 256 ms in the current implementation
    function SessionSign(const url: RawUTF8): RawUTF8;
    /// will call the /auth service on the server to notify client shutdown
    procedure SessionClose;
    /// abstract method to be implemented with a local, piped or HTTP/1.1 provider
    // - you can specify some POST/PUT data in SendData (leave as nil otherwize)
    // - return in result.Lo the HTTP STATUS integer error or success code
    // - return in result.Hi the server database internal status
    // - on success, store the resulting data into Resp^, headers in Head^ if not nil
    function InternalURI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; virtual; abstract;
    /// calls 'ModelRoot/TableName/ID' with appropriate REST method
    // - uses GET method if ForUpdate is false
    // - uses LOCK method if ForUpdate is true
    function URIGet(Table: TSQLRecordClass; ID: integer; var Resp: RawUTF8;
      ForUpdate: boolean=false): Int64Rec;
    /// retrieve a list of members as JSON encoded data - used by OneFieldValue()
    // and MultiFieldValue() public functions
    function InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON; override;
    // overriden methods
    function EngineRetrieve(TableModelIndex: integer; ID: integer;
      ForUpdate: boolean; var InternalState: cardinal; var Resp: RawUTF8): boolean; override;
    function EngineList(const SQL: RawUTF8; ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8; override;
    function EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer; override;
    function EngineUpdate(Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean; override;
    function EngineDelete(Table: TSQLRecordClass; ID: integer): boolean; override;
    function EngineDeleteWhere(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
      const IDs: TIntegerDynArray): boolean; override;
    function EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
      BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean; override;
    function EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean; override;
  public
    /// release memory, and unlock all still locked records by this client
    destructor Destroy; override;
    /// authenticate an User to the current connected Server
    // - will call the ModelRoot/Auth service, i.e. call TSQLRestServer.Auth()
    // published method to create a session for this user
    // - returns true on success
    // - calling this method is optional, depending on your user right policy:
    // your Server need to handle authentication
    // - on success, the SessionUser property map the logged user session on the
    // server side
    // - if aHashedPassword is TRUE, the aPassword parameter is expected to
    // contain the already-hashed value, just as stored in PasswordHashHexa
    // (i.e. SHA256('salt'+Value) as in TSQLAuthUser.SetPasswordPlain method)  
    function SetUser(const aUserName, aPassword: RawUTF8;
      aHashedPassword: Boolean=false): boolean;
    /// method calling the remote Server via a RESTful command
    // - calls the InternalURI abstract method, which should be overriden with a
    // local, piped or HTTP/1.1 provider
    // - this method will add sign the url with the appropriate digital signature
    // according to the current SessionUser property
    // - this method will retry the connection in case of authentication failure
    // (i.e. if the session was closed by the remote server, for any reason -
    // mostly a time out) if the OnAuthentificationFailed event handler is set  
    function URI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; 
    /// retrieve a list of members as a TSQLTable (implements REST GET Collection)
    // - URI is 'ModelRoot/TableName' with GET method
    // - SQLSelect and SQLWhere are encoded as 'select=' and 'where=' URL parameters
    // (using inlined parameters via :(...): in SQLWhere is always a good idea)
    // - server must return Status 200/HTML_SUCCESS OK on success
    function List(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8 = 'RowID';
      const SQLWhere: RawUTF8 = ''): TSQLTableJSON; override;
    /// unlock the corresponding record
    // - URI is 'ModelRoot/TableName/ID' with UNLOCK method
    // - returns true on success
    function UnLock(Table: TSQLRecordClass; aID: integer): boolean; override;
    /// Execute directly a SQL statement
    // - URI is 'ModelRoot' with POST method, and SQL statement sent as UTF-8
    // - server must return Status 200/HTML_SUCCESS OK on success
    function EngineExecute(const SQL: RawUTF8): boolean; override;
    /// Execute directly a SQL statement, expecting a list of resutls
    // - URI is 'ModelRoot' with GET method, and SQL statement sent as UTF-8
    // - return a result table on success, nil on failure
    function ExecuteList(const Tables: array of TSQLRecordClass;
      const SQL: RawUTF8): TSQLTableJSON; override;
    /// ask the server for its current internal state revision counter
    // - this counter is incremented every time the database is modified
    // - the returned value is 0 if the database doesn't support this feature
    // - TSQLTable does compare this value with its internal one to check if
    // its content must be updated
    function ServerInternalState: cardinal;
    /// check if the data may have changed of the server for this objects, and
    // update it if possible
    // - only working types are TSQLTableJSON and TSQLRecord descendants
    // - make use of the InternalState function to check the data content revision
    // - return true if Data is updated successfully, or false on any error
    // during data retrieval from server (e.g. if the TSQLRecord has been deleted)
    // - if Data contains only one TSQLTableJSON, PCurrentRow can point to the
    // current selected row of this table, in order to refresh its value
    // - use this method to refresh the client UI, e.g. via a timer
    function UpdateFromServer(const Data: array of TObject; out Refreshed: boolean;
      PCurrentRow: PInteger = nil): boolean;
    /// send a flush command to the remote Server cache
    // - this method will remotely call the Cache.Flush() methods of the server
    // instance, to force cohesion of the data
    // - ServerCacheFlush() with no parameter will flush all stored JSON content
    // - ServerCacheFlush(aTable) will flush the cache for a given table
    // - ServerCacheFlush(aTable,aID) will flush the cache for a given record
    function ServerCacheFlush(aTable: TSQLRecordClass=nil; aID: integer=0): boolean;

    {/ begin a transaction (implements REST BEGIN Member)
     - to be used to speed up some SQL statements like Add/Update/Delete methods above
     - must be ended with Commit on success
     - in the current implementation, the aTable parameter is not used yet
     - must be aborted with Rollback if any SQL statement failed
     - return true if no transaction is active, false otherwize
      !if Client.TransactionBegin(TSQLRecordPeopleObject) then
      !try
      !  //.... modify the database content, raise exceptions on error
      !  Client.Commit;
      !except
      !  Client.RollBack; // in case of error
      !end;
     - you can should better use the dedicated TransactionBeginRetry() method
      in case of Client concurent access }
    function TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal=1): boolean; override;
    {/ begin a transaction (implements REST BEGIN Member)
     - this version retries a TranslationBegin() to be successfull within
      a supplied number of times
     - will retry every 100 ms for "Retries" times (excluding the connection
      time in this 100 ms time period
     - default is to retry 10 times, i.e. within 2 second timeout
     - in the current implementation, the aTable parameter is not used yet
     - typical usage should be for instance:
      !if Client.TransactionBeginRetry(TSQLRecordPeopleObject,20) then
      !try
      !  //.... modify the database content, raise exceptions on error
      !  Client.Commit;
      !except
      !  Client.RollBack; // in case of error
      !end; }
    function TransactionBeginRetry(aTable: TSQLRecordClass; Retries: integer=10): boolean;
    {/ end a transaction (implements REST END Member)
     - write all pending SQL statements to the disk }
    procedure Commit(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;
    {/ abort a transaction (implements REST ABORT Member)
     - restore the previous state of the database, before the call to TransactionBegin }
    procedure RollBack(SessionID: cardinal=CONST_AUTHENTICATION_NOT_USED); override;

    {/ begin a BATCH sequence to speed up huge database change
     - each call to normal Add/Update/Delete methods will create a Server request,
       therefore can be slow (e.g. if the remote server has bad ping timing)
     - start a BATCH sequence using this method, then call BatchAdd() BatchUpdate()
       or BatchDelete() methods to make some changes to the database
     - when BatchSend will be called, all the sequence transactions will be sent
       as one to the remote server, i.e. in one URI request
     - if BatchAbort is called instead, all pending BatchAdd/Update/Delete
       transactions will be aborted, i.e. ignored
     - expect one TSQLRecordClass as parameter, which will be used for the whole
       sequence (in this case, you can't mix classes in the same BATCH sequence)
     - if no TSQLRecordClass is supplied, the BATCH sequence will allow any
       kind of individual record in BatchAdd/BatchUpdate/BatchDelete
     - return TRUE on sucess, FALSE if aTable is incorrect or a previous BATCH
       sequence was already initiated
     - should normally be used inside a Transaction block: there is no automated
       TransactionBegin..Commit/RollBack generated in the BATCH sequence }
    function BatchStart(aTable: TSQLRecordClass): boolean;
    /// create a new member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - if SendData is true, content of Value is sent to the server as JSON
    // - if ForceID is true, client sends the Value.ID field to use this ID for
    // adding the record (instead of a database-generated ID)
    // - if Value is TSQLRecordFTS3, Value.ID is stored to the virtual table
    // - Value class MUST match the TSQLRecordClass used at BatchTransactionBegin,
    // or may be of any kind if no class was specified
    // - BLOB fields are NEVER transmitted here, even if ForceBlobTransfert=TRUE
    function BatchAdd(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer;
    /// update a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - Value class MUST match the TSQLRecordClass used at BatchTransactionBegin,
    // or may be of any kind if no class was specified
    // - BLOB fields are NEVER transmitted here, even if ForceBlobTransfert=TRUE
    // - if Value has an opened FillPrepare() mapping, only the mapped fields
    // will be updated (and also ID and TModTime fields) - FillPrepareMany() is
    // not handled yet (all simple fields will be updated)
    function BatchUpdate(Value: TSQLRecord): integer;
    /// delete a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - deleted record class is the TSQLRecordClass used at BatchTransactionBegin()
    // call: it will fail if no class was specified for this BATCH sequence
    function BatchDelete(ID: integer): integer; overload;
    /// delete a member in current BATCH sequence
    // - work in BATCH mode: nothing is sent to the server until BatchSend call
    // - returns the corresponding index in the current BATCH sequence, -1 on error
    // - with this overloaded method, the deleted record class is specified:
    // no TSQLRecordClass shall have been set at BatchTransactionBegin() call
    function BatchDelete(Table: TSQLRecordClass; ID: integer): integer; overload;
    /// retrieve the current number of pending transactions in the BATCH sequence
    // - every call to BatchAdd/Update/Delete methods increases this count
    function BatchCount: integer;
    {/ execute a BATCH sequence started by BatchStart method
     - send all pending BatchAdd/Update/Delete statements to the remote server
     - URI is 'ModelRoot/TableName/0' with POST method
     - will return the URI Status value, i.e. 200/HTML_SUCCESS OK on success
     - a dynamic array of integers will be created in Results,
       containing all ROWDID created for each BatchAdd call, 200 (=HTML_SUCCESS)
       for all successfull BatchUpdate/BatchDelete, or 0 on error
     - any error during server-side process MUST be checked against Results[]
       (the main URI Status is 200 if about communication success, and won't
       imply that all statements in the BATCH sequence were successfull }
    function BatchSend(var Results: TIntegerDynArray): integer;
    {/ abort a BATCH sequence started by BatchStart method
     - in short, nothing is sent to the remote server, and current BATCH sequence
       is closed }
    procedure BatchAbort;

    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful GET request
      - returns the HTTP error code (e.g. 200/HTML_SUCCESS on success)
      - this version will use a GET with supplied parameters (which will be encoded
        with the URL) }
    function CallBackGet(const aMethodName: RawUTF8; const aParameters: array of const;
      out aResponse: RawUTF8; aTable: TSQLRecordClass=nil; aID: integer=0;
      aResponseHead: PRawUTF8=nil): integer;
    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful GET request
      - returns the UTF-8 decoded JSON result (server must reply with one
        "result":"value" JSON object)
      - this version will use a GET with supplied parameters (which will be encoded
        with the URL) }
    function CallBackGetResult(const aMethodName: RawUTF8; const aParameters: array of const;
      aTable: TSQLRecordClass=nil; aID: integer=0): RawUTF8;
    {/ wrapper to the protected URI method to call a method on the server, using
      a ModelRoot/[TableName/[ID/]]MethodName RESTful PUT request
      - returns the HTTP error code (e.g. 200/HTML_SUCCESS on success)
      - this version will use a PUT with the supplied raw UTF-8 data }
    function CallBackPut(const aMethodName, aSentData: RawUTF8;
      out aResponse: RawUTF8; aTable: TSQLRecordClass=nil; aID: integer=0;
      aResponseHead: PRawUTF8=nil): integer;
    /// register a Service on the client side via its interface
    // - this methods expects a list of interfaces to be registered to the client
    // (e.g. [TypeInfo(IMyInterface)])
    // - instance implementation pattern will be set by the appropriate parameter
    // - will return true on success, false if registration failed (e.g. if any of
    // the supplied interfaces is not correct or is not available on the server)
    // - that is, server side will be called to check for the availability of
    // each interface
    // - you can specify an optional custom contract for the first interface
    function ServiceRegister(const aInterfaces: array of PTypeInfo;
      aInstanceCreation: TServiceInstanceImplementation=sicSingle;
      const aContractExpected: RawUTF8=''): boolean; virtual;

    /// this Event is called in case of remote authentication failure
    // - client software can ask the user to enter a password and user name
    // - if no event is specified, the URI() method will return directly
    // an HTML_FORBIDDEN "403 Forbidden" error code
    property OnAuthentificationFailed: TOnAuthentificationFailed
      read fOnAuthentificationFailed write fOnAuthentificationFailed;
    /// this Event is called when a user is authenticated
    // - is called always, on each TSQLRestClientURI.SetUser call
    // - you can check the SessionUser property to retrieve the current
    // authenticated user, or nil if authentication failed
    // - could be used to refresh the User Interface layout according to
    // current authenticated user rights 
    property OnSetUser: TNotifyEvent read fOnSetUser write fOnSetUser;
    /// maximum additional retry occurence
    // - defaut is 0, i.e. will retry once
    // - set OnAuthentificationFailed to nil in order to avoid any retry 
    property MaximumAuthentificationRetry: Integer
      read fMaximumAuthentificationRetry write fMaximumAuthentificationRetry;
    /// the current user as set by SetUser() method
    // - returns nil if no User was currently authenticated
    // - only available fields by default are LogonName and PasswordHashHexa 
    property SessionUser: TSQLAuthUser read fSessionUser;
  end;

{$ifdef MSWINDOWS}
  /// Rest client with remote access to a server through a dll
  // - use only one TURIMapRequest function for the whole communication
  // - the data is stored in Global system memory, and freed by GlobalFree()
  TSQLRestClientURIDll = class(TSQLRestClientURI)
  private
    /// used by Create(from dll) constructor
    fLibraryHandle: cardinal;
  protected
    Func: TURIMapRequest;
    /// method calling the RESTful server through a DLL or executable, using
    // direct memory
    function InternalURI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; override;
  public
    /// connect to a server from a remote function
    constructor Create(aModel: TSQLModel; aRequest: TURIMapRequest); reintroduce; overload;
    /// connect to a server contained in a shared library
    // - this dll must contain at least a URIRequest entry
    // - raise an exception if the shared library is not found or invalid
    constructor Create(aModel: TSQLModel; const DllName: TFileName); reintroduce; overload;
    /// release memory and handles
    destructor Destroy; override;
  end;

  /// Rest client with remote access to a server through Windows messages
  // - use only one TURIMapRequest function for the whole communication
  // - the data is sent and received by using the standard and fast WM_COPYDATA message
  // - named pipes seems to be somewhat better for bigger messages under XP
  TSQLRestClientURIMessage = class(TSQLRestClientURI)
  protected
    /// the HWND of the server process, retrieved by Create() method
    fServerWindow: HWND;
    /// the HWND of the client process, as set by Create() method
    fClientWindow: HWND;
    /// the Window name used, if created internaly
    fClientWindowName: string;
    /// the time out to be used, in mili seconds
    fTimeOutMS: cardinal;
    /// the expected current response
    // - this value is set from the incoming WM_COPYDATA
    // - this value is set to #0 (i.e. string of one #0 char) while waiting
    // for a WM_COPYDATA message in URI() method
    fCurrentResponse: RawUTF8;
    /// method calling the RESTful server by using Windows WM_COPYDATA messages
    function InternalURI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; override;
  public
    /// connect to a server from its window name
    // - ServerWindowName is of UnicodeString type since Delphi 2009
    // (direct use of FindWindow()=FindWindowW() Win32 API)
    // - this version must supply a Client Window handle
    constructor Create(aModel: TSQLModel; const ServerWindowName: string;
      ClientWindow: HWND; TimeOutMS: cardinal); reintroduce; overload;
    /// connect to a server from its window name
    // - ServerWindowName is of UnicodeString type since Delphi 2009
    // (direct use of FindWindow()=FindWindowW() Win32 API)
    // - this version will instanciante and create a Client Window from
    // a Window Name, by using low level Win32 API: therefore, the Forms unit
    // is not needed with this constructor (save some KB)
    constructor Create(aModel: TSQLModel; const ServerWindowName,
      ClientWindowName: string; TimeOutMS: cardinal); reintroduce; overload;
    /// release the internal Window class created, if any
    destructor Destroy; override;
    /// event to be trigerred when a WM_COPYDATA message is received from the server
    // - to be called by the corresponding message WM_COPYDATA; method in the
    // client window 
    procedure WMCopyData(var Msg : TWMCopyData); message WM_COPYDATA;
  end;

  /// Rest client with remote access to a server through a Named Pipe
  // - named pipe is fast and optimized under Windows
  // - can be accessed localy or remotely
  TSQLRestClientURINamedPipe = class(TSQLRestClientURI)
  private
    /// handle for '\\.\pipe\Test_Local_Sqlite3' e.g.
    fServerPipe: cardinal;
    /// the pipe name
    fPipeName: TFileName;
{$ifndef ANONYMOUSNAMEDPIPE}
    fPipeSecurityAttributes: TSecurityAttributes;
    fPipeSecurityDescriptor: array[0..SECURITY_DESCRIPTOR_MIN_LENGTH] of byte;
{$endif}
  protected
    /// method calling the RESTful server through a DLL or executable, by using
    // a named pipe (faster than TCP/IP or HTTP connection)
    // - return status code in result.Lo
    // - return database internal state in result.Hi
    // - status code 501 HTML_NOTIMPLEMENTED if no server is available
    function InternalURI(const url, method: RawUTF8; Resp: PRawUTF8=nil;
      Head: PRawUTF8=nil; SendData: PRawUTF8=nil): Int64Rec; override;
  public
    /// connect to a server contained in a running application
    // - the server must have been declared by a previous
    // TSQLRestServer.ExportServer(ApplicationName) call
    // with ApplicationName as user-defined server identifier ('DBSERVER' e.g.)
    // - ApplicationName is of UnicodeString type since Delphi 2009
    // (direct use of Wide Win32 API version)
    // - this server identifier is appended to '\\.\pipe\Sqlite3_' to obtain
    // the full pipe name to connect to ('\\.\pipe\Sqlite3_DBSERVER' e.g.)
    // - this server identifier may also contain a remote computer name, and
    // must be fully qualified ('\\ServerName\pipe\ApplicationName' e.g.)
    // - raise an exception if the server is not running or invalid
    constructor Create(aModel: TSQLModel; const ApplicationName: TFileName);
    /// release memory and handles
    destructor Destroy; override;
  end;
{$endif Win32}

  /// will define a validation to be applied to a TSQLRecord field, using
  // if necessary an associated TSQLRest instance and a TSQLRecord class
  // - a typical usage is to validate a value to be unique in the table
  // (implemented in the TSynValidateUniqueField class)
  // - the optional associated parameters are to be supplied JSON-encoded
  // - ProcessRest and ProcessRec properties will be filled before Process
  // method call by TSQLRecord.Validate()
  TSynValidateRest = class(TSynValidate)
  protected
    fProcessRest: TSQLRest;
    fProcessRec: TSQLRecord;
  public
    /// the associated TSQLRest instance
    // - this value is updated by TSQLRecord.Validate with the current
    // TSQLRest used for the validation
    // - it can be used in the overriden Process method
    property ProcessRest: TSQLRest read fProcessRest;
    /// the associated TSQLRecord instance
    // - this value is updated by TSQLRecord.Validate with the current
    // TSQLRecord instance to be validated
    // - it can be used in the overriden Process method
    property ProcessRec: TSQLRecord read fProcessRec;
  end;

  /// will define a validation for a TSQLRecord Unique field
  // - it will check that the field value is not void
  // - it will check that the field value is not a duplicate
  TSynValidateUniqueField = class(TSynValidateRest)
  public
    /// perform the unique field validation action to the specified value
    // - duplication value check will use ProcessRest and ProcessRec properties,
    // as set by TSQLRecord.Validate
    function Process(aFieldIndex: integer; const Value: RawUTF8; var ErrorMsg: string): boolean; override;
  end;


  /// a WHERE constraint as set by the TSQLVirtualTable.Prepare() method
  TSQLVirtualTablePreparedConstraint = record
    /// Column on left-hand side of constraint
    // - The first column of the virtual table is column 0
    // - The ROWID of the virtual table is column -1
    // - Hidden columns are counted when determining the column index
    // - if this field contains VIRTUAL_TABLE_IGNORE_COLUMN (-2), TSQLVirtualTable.
    // Prepare() should ignore this entry
    Column: integer;
    /// Constraint operator
    // - MATCH keyword is parsed into soBeginWith, and should be handled as
    // soBeginWith, soContains or soSoundsLike* according to the effective
    // expression text value ('text*', '%text'...)
    Operator: TCompareOperator;
    /// If true, the constraint is assumed to be fully handled
    // by the virtual table and is not checked again by SQLite
    // - By default (OmitCheck=false), the SQLite core double checks all
    // constraints on each row of the virtual table that it receives
    // - TSQLVirtualTable.Prepare() can set this property to true
    OmitCheck: boolean;
    /// The associated expression
    // - TSQLVirtualTable.Prepare() must set this property VType to <> varEmpty
    // (=0) e.g. to varAny, if an expression is expected at
    // TSQLVirtualTableCursor.Search() call
    // - TSQLVirtualTableCursor.Search() will receive an expression value,
    // to be retrieved e.g. via sqlite3_value_*() functions
    Value: TVarData;
  end;

  /// an ORDER BY clause as set by the TSQLVirtualTable.Prepare() method
  TSQLVirtualTablePreparedOrderBy = record
    /// Column number
    // - The first column of the virtual table is column 0
    // - The ROWID of the virtual table is column -1
    // - Hidden columns are counted when determining the column index.
    Column: Integer;
    /// True for DESCending order, false for ASCending order.
    Desc: boolean;
  end;


  /// the WHERE and ORDER BY statements as set by TSQLVirtualTable.Prepare 
  // - Where[] and OrderBy[] are fixed sized arrays, for fast and easy code
  TSQLVirtualTablePrepared = {$ifndef ISDELPHI2010}object{$else}record{$endif}
  public
    /// number of WHERE statement parameters in Where[] array
    WhereCount: integer;
    /// numver of ORDER BY statement parameters in OrderBy[]
    OrderByCount: integer;
    /// if true, the ORDER BY statement is assumed to be fully handled
    // by the virtual table and is not checked again by SQLite
    // - By default (OmitOrderBy=false), the SQLite core sort all rows of the
    // virtual table that it receives according in order
    OmitOrderBy: boolean;
    ///  Estimated cost of using this prepared index
    // - SQLite uses this value to make a choice between several calls to
    // the TSQLVirtualTable.Prepare() method with several expressions
    EstimatedCost: Double;
    /// WHERE statement parameters, in TSQLVirtualTableCursor.Search() order
    Where: array[0..MAX_SQLFIELDS-1] of TSQLVirtualTablePreparedConstraint;
    /// ORDER BY statement parameters
    OrderBy: array[0..MAX_SQLFIELDS-1] of TSQLVirtualTablePreparedOrderBy;
    /// returns TRUE if there is only one ID=? statement in this search
    function IsWhereIDEquals(CalledFromPrepare: Boolean): boolean;
       {$ifdef HASINLINE}inline;{$endif}
    /// returns TRUE if there is only one FieldName=? statement in this search
    function IsWhereOneFieldEquals: boolean;
       {$ifdef HASINLINE}inline;{$endif}
  end;

  PSQLVirtualTablePrepared = ^TSQLVirtualTablePrepared;

  TSQLVirtualTableCursor = class;
  TSQLVirtualTableCursorClass = class of TSQLVirtualTableCursor;

  /// the possible features of a Virtual Table
  // - vtWrite is to be set if the table is not Read/Only
  // - vtTransaction if handles vttBegin, vttSync, vttCommit, vttRollBack
  // - vtSavePoint if handles vttSavePoint, vttRelease, vttRollBackTo
  // - vtWhereIDPrepared if the ID=? WHERE statement will be handled in
  // TSQLVirtualTableCursor.Search()
  TSQLVirtualTableFeature = (vtWrite, vtTransaction, vtSavePoint,
    vtWhereIDPrepared);

  /// a set of features of a Virtual Table
  TSQLVirtualTableFeatures = set of TSQLVirtualTableFeature;

  /// used to store and handle the main specifications of a TSQLVirtualTableModule
  TVirtualTableModuleProperties = record
    /// a set of features of a Virtual Table
    Features: TSQLVirtualTableFeatures;
    /// the associated cursor class
    CursorClass: TSQLVirtualTableCursorClass;
    /// the associated TSQLRecord class
    // - used to retrieve the field structure with all collations
    RecordClass: TSQLRecordClass;
    /// the associated TSQLRestServerStatic class used for storage
    // - is e.g. TSQLRestServerStaticInMemory for TSQLVirtualTableJSON,
    // TSQLRestServerStaticExternal for TSQLVirtualTableExternal, or nil for
    // TSQLVirtualTableLog
    StaticClass: TSQLRestServerStaticClass;
    /// can be used to customize the extension of the filename
    // - the '.' is not to be included
    FileExtension: TFileName;
  end;

  {/ parent class able to define a Virtual Table module
   - in order to implement a new Virtual Table type, you'll have to define a so
     called "Module" to handle the fields and data access and an associated
     TSQLVirtualTableCursorClass for handling the SELECT statements
   - for our framework, the SQLite3 unit will inherit from this class to define
     a TSQLVirtualTableModuleSQLite3 class, which will register the associated
     virtual table definition into a SQLite3 connection, on the server side
   - children should override abstract methods in order to implement the
     association with the database engine itself }
  TSQLVirtualTableModule = class
  protected
    fModuleName: RawUTF8;
    fTableClass: TSQLVirtualTableClass;
    fServer: TSQLRestServer;
    fFeatures: TVirtualTableModuleProperties;
    fFilePath: TFileName;
  public
    /// create the Virtual Table instance according to the supplied class
    // - inherited constructors may register the Virtual Table to the specified
    // database connection
    constructor Create(aTableClass: TSQLVirtualTableClass;
      aServer: TSQLRestServer); virtual;
    /// retrieve the file name to be used for a specific Virtual Table
    // - returns by default a file located in the executable folder, with the
    // table name as file name, and module name as extension
    function FileName(const aTableName: RawUTF8): TFileName; virtual;
    /// the Virtual Table module features
    property Features: TSQLVirtualTableFeatures read fFeatures.Features;
    /// the associated virtual table class
    property TableClass: TSQLVirtualTableClass read fTableClass;
    /// the associated virtual table cursor class
    property CursorClass: TSQLVirtualTableCursorClass read fFeatures.CursorClass;
    /// the associated TSQLRestServerStatic class used for storage
    // - e.g. returns TSQLRestServerStaticInMemory for TSQLVirtualTableJSON,
    // or TSQLRestServerStaticExternal for TSQLVirtualTableExternal, or
    // either nil for TSQLVirtualTableLog
    property StaticClass: TSQLRestServerStaticClass read fFeatures.StaticClass;
    /// the associated TSQLRecord class
    // - is mostly nil, e.g. for TSQLVirtualTableJSON
    // - used to retrieve the field structure for TSQLVirtualTableLog e.g.
    property RecordClass: TSQLRecordClass read fFeatures.RecordClass;
    /// the extension of the filename (without any left '.')
    property FileExtension: TFileName read fFeatures.FileExtension;
    /// the full path to be used for the filename
    // - is '' by default, i.e. will use the executable path
    // - you can specify here a custom path, which will be used by the FileName
    // method to retrieve the .json/.data full file 
    property FilePath: TFileName read fFilePath write fFilePath;
    /// the associated Server instance
    // - may be nil, in case of direct access to the virtual table
    property Server: TSQLRestServer read fServer;
    /// the corresponding module name
    property ModuleName: RawUTF8 read fModuleName;
  end;

  /// the available transaction levels
  TSQLVirtualTableTransaction = (
    vttBegin, vttSync, vttCommit, vttRollBack,
    vttSavePoint, vttRelease, vttRollBackTo);

  {/ abstract class able to access a Virtual Table content
   - override the Prepare/Structure abstract virtual methods for reading
     access to the virtual table content
   - you can optionaly override Drop/Delete/Insert/Update/Rename/Transaction
     virtual methods to allow content writing to the virtual table
   - the same virtual table mechanism can be used with several database module,
     with diverse database engines }
  TSQLVirtualTable = class
  protected
    fModule: TSQLVirtualTableModule;
    fTableName: RawUTF8;
    fStatic: TSQLRestServerStatic;
  public
    /// create the virtual table access instance
    // - the created instance will be released when the virtual table will be
    // disconnected from the DB connection (e.g. xDisconnect method for SQLite3)
    // - shall raise an exception in case of invalid parameters (e.g. if the
    // supplied module is not associated to a TSQLRestServer instance)
    // - aTableName will be checked against the current aModule.Server.Model
    // to retrieve the corresponding TSQLRecordVirtualTableAutoID class and
    // create any associated Static: TSQLRestServerStatic instance
    constructor Create(aModule: TSQLVirtualTableModule; const aTableName: RawUTF8;
      FieldCount: integer; Fields: PPUTF8CharArray); virtual;
    /// release the associated memory, especially the Static instance
    destructor Destroy; override;
    /// retrieve the corresponding module name
    // - will use the class name, triming any T/TSQL/TSQLVirtual/TSQLVirtualTable* 
    // - when the class is instanciated, it will be faster to retrieve the same
    // value via Module.ModuleName
    class function ModuleName: RawUTF8;
    /// a generic method to get a 'CREATE TABLE' structure from a supplied
    // TSQLRecord class
    // - is called e.g. by the Structure method
    class function StructureFromClass(aClass: TSQLRecordClass;
      const aTableName: RawUTF8): RawUTF8;
    /// the associated Virtual Table module
    property Module: TSQLVirtualTableModule read fModule;
    /// the name of the Virtual Table, as specified following the TABLE keyword
    // in the CREATE VIRTUAL TABLE statement
    property TableName: RawUTF8 read fTableName;
  public { virtual methods to be overriden }
    /// should return the main specifications of the associated TSQLVirtualTableModule
    class procedure GetTableModuleProperties(
      var aProperties: TVirtualTableModuleProperties); virtual; abstract;
    /// called to determine the best way to access the virtual table
    // - will prepare the request for TSQLVirtualTableCursor.Search()
    // - in Where[], Expr must be set to not 0 if needed for Search method,
    // and OmitCheck to true if double check is not necessary
    // - OmitOrderBy must be set to true if double sort is not necessary
    // - EstimatedCost should receive the estimated cost
    // - default implementation will let the DB engine perform the search,
    // and prepare for ID=? statement if vtWhereIDPrepared was set
    function Prepare(var Prepared: TSQLVirtualTablePrepared): boolean; virtual;
    /// should retrieve the format (the names and datatypes of the columns) of
    // the virtual table, as expected by sqlite3_declare_vtab()
    // - default implementation is to retrieve the structure for the associated
    // Module.RecordClass property (as set by GetTableModuleProperties) or
    // the Static.StoredClass: in both cases, column numbering will follow
    // the TSQLRecord published field order (TSQLRecord.RecordProps.Fields[])
    function Structure: RawUTF8; virtual;
    /// called when a DROP TABLE statement is executed against the virtual table
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Drop: boolean; virtual;
    /// called to delete a virtual table row
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Delete(aRowID: Int64): boolean; virtual;
    /// called to insert a virtual table row content
    // - the column values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - should return true on success, false otherwise
    // - should return the just created row ID in insertedRowID on success
    // - does nothing by default, and returns false, i.e. always fails
    function Insert(aRowID: Int64; var Values: TVarDataDynArray;
      out insertedRowID: Int64): boolean; virtual;
    /// called to update a virtual table row content
    // - the column values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - should return true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Update(oldRowID, newRowID: Int64; var Values: TVarDataDynArray): boolean; virtual;
    /// called to begin a transaction to the virtual table row
    // - do nothing by default, and returns false in case of RollBack/RollBackto
    // - aSavePoint is used for vttSavePoint, vttRelease and vttRollBackTo only
    // - note that if you don't nest your writing within a transaction, SQLite
    // will call vttCommit for each INSERT/UPDATE/DELETE, just like a regular
    // SQLite database - it could make bad written code slow even with Virtual
    // Tables
    function Transaction(aState: TSQLVirtualTableTransaction; aSavePoint: integer): boolean; virtual;
    /// called to rename the virtual table
    // - by default, returns false, i.e. always fails
    function Rename(const NewName: RawUTF8): boolean; virtual;
    /// the associated virtual table storage
    // - can be e.g. a TSQLRestServerStaticInMemory for TSQLVirtualTableJSON,
    // or a TSQLRestServerStaticExternal for TSQLVirtualTableExternal, or nil
    // for TSQLVirtualTableLog
    property Static: TSQLRestServerStatic read fStatic;
  end;

  {/ abstract class able to define a Virtual Table cursor
    - override the Search/HasData/Column/Next abstract virtual methods to
    implement the search process }
  TSQLVirtualTableCursor = class
  protected
    fTable: TSQLVirtualTable;
    /// used internaly between two Column() method calls for GetFieldVarData()
    fColumnTemp: RawByteString;
    /// easy set a TVarData content for the Column() method
    procedure SetColumn(var aResult: TVarData; aValue: Int64); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TVarData; const aValue: double); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TVarData; const aValue: RawUTF8); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumn(var aResult: TVarData; aValue: PUTF8Char; aValueLength: integer); overload;
      {$ifdef HASINLINE}inline;{$endif}
    procedure SetColumnBlob(var aResult: TVarData; aValue: pointer; aValueLength: integer);
      {$ifdef HASINLINE}inline;{$endif}
  public
    /// create the cursor instance
    // - it will be destroyed when by the DB engine (e.g. via xClose in SQLite3)
    constructor Create(aTable: TSQLVirtualTable); virtual;
    /// the associated Virtual Table class instance
    property Table: TSQLVirtualTable read fTable;
  public { abstract methods to be overriden }
    /// called to begin a search in the virtual table
    // - the TSQLVirtualTablePrepared parameters were set by
    // TSQLVirtualTable.Prepare and will contain both WHERE and ORDER BY statements
    // (retrieved e.g. by x_BestIndex() from a TSQLite3IndexInfo structure)
    // - Prepared will contain all prepared constraints and the corresponding
    // expressions in the Where[].Value field
    // - should move cursor to first row of matching data
    // - should return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; virtual; abstract;
    /// called after Search() to check if there is data to be retrieved
    // - should return false if reached the end of matching data
    function HasData: boolean; virtual; abstract;
    /// called to retrieve a column value of the current data row
    // - handled types in aResult are varNull, varInt64, varDouble, varString
    // (mapping a constant PUTF8Char) and varAny (BLOB with size = VLongs[0])
    // - if aColumn=-1, should return the row ID as varInt64 into aResult
    // - should return false in case of an error, true on success
    function Column(aColumn: integer; var aResult: TVarData): boolean;
      virtual; abstract;
    /// called to go to the next row of matching data
    // - should return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    function Next: boolean; virtual; abstract;
  end;

  {/ A generic Virtual Table cursor associated to Current/Max index properties }
  TSQLVirtualTableCursorIndex = class(TSQLVirtualTableCursor)
  protected
    fCurrent: integer;
    fMax: integer;
  public
    /// called after Search() to check if there is data to be retrieved
    // - will return false if reached the end of matching data, according to
    // the fCurrent/fMax protected properties values
    function HasData: boolean; override;
    /// called to go to the next row of matching data
    // - will return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    // - will check the fCurrent/fMax protected properties values
    function Next: boolean; override;
    /// called to begin a search in the virtual table
    // - this no-op version will mark EOF, i.e. fCurrent=0 and fMax=-1
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
  end;
  
  {/ A Virtual Table cursor for reading a TSQLRestServerStaticInMemory content
    - this is the cursor class associated to TSQLVirtualTableJSON }
  TSQLVirtualTableCursorJSON = class(TSQLVirtualTableCursorIndex)
  public
    /// called to begin a search in the virtual table
    // - the TSQLVirtualTablePrepared parameters were set by
    // TSQLVirtualTable.Prepare and will contain both WHERE and ORDER BY statements
    // (retrieved by x_BestIndex from a TSQLite3IndexInfo structure)
    // - Prepared will contain all prepared constraints and the corresponding
    // expressions in the Where[].Value field
    // - will move cursor to first row of matching data
    // - will return false on low-level database error (but true in case of a
    // valid call, even if HasData will return false, i.e. no data match)
    // - only handled WHERE clause is for "ID = value" - other request will
    // return all records in ID order, and let the database engine handle it
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called to retrieve a column value of the current data row
    // - handled types in aResult are varNull, varInt64, varDouble, varString
    // (mapping a constant PUTF8Char) and varAny (BLOB with size = VLongs[0])
    // - if aColumn=-1, will return the row ID as varInt64 into aResult
    // - will return false in case of an error, true on success
    function Column(aColumn: integer; var aResult: TVarData): boolean; override;
  end;

  {/ A TSQLRestServerStaticInMemory-based virtual table using JSON storage
   - for ORM access, you should use TSQLModel.VirtualTableRegister method to
     associated this virtual table module to a TSQLRecordVirtualTableAutoID class
   - transactions are not handled by this module
   - by default, no data is written on disk: you will need to call explicitly
     aServer.StaticVirtualTable[aClass].UpdateToFile for file creation or refresh
   - file extension is set to '.json' }
  TSQLVirtualTableJSON = class(TSQLVirtualTable)
  public { overriden methods }
    /// returns the main specifications of the associated TSQLVirtualTableModule
    // - this is a read/write table, without transaction, associated to the
    // TSQLVirtualTableCursorJSON cursor type, with 'JSON' as module name
    // - no particular class is supplied here, since it will depend on the
    // associated Static instance 
    class procedure GetTableModuleProperties(var aProperties: TVirtualTableModuleProperties);
      override;
    /// called to determine the best way to access the virtual table
    // - will prepare the request for TSQLVirtualTableCursor.Search()
    // - only prepared WHERE statement is for "ID = value"
    // - only prepared ORDER BY statement is for ascending IDs
    function Prepare(var Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called when a DROP TABLE statement is executed against the virtual table
    // - returns true on success, false otherwise
    function Drop: boolean; override;
    /// called to delete a virtual table row
    // - returns true on success, false otherwise
    function Delete(aRowID: Int64): boolean; override;
    /// called to insert a virtual table row content
    // - the column values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - column order follows the Structure method, i.e. StoredClassProps.Fields[] order
    // - returns true on success, false otherwise
    // - returns the just created row ID in insertedRowID on success
    // - does nothing by default, and returns false, i.e. always fails
    function Insert(aRowID: Int64; var Values: TVarDataDynArray;
      out insertedRowID: Int64): boolean; override;
    /// called to update a virtual table row content
    // - the column values are available via some TVarData of type
    // varNull, varInt64, varDouble, varString (mapping a constant PUTF8Char),
    // and varAny (BLOB with size = VLongs[0])
    // - column order follows the Structure method, i.e. StoredClassProps.Fields[] order
    // - returns true on success, false otherwise
    // - does nothing by default, and returns false, i.e. always fails
    function Update(oldRowID, newRowID: Int64; var Values: TVarDataDynArray): boolean; override;
  end;

  {/ A TSQLRestServerStaticInMemory-based virtual table using Binary storage
   - for ORM access, you should use TSQLModel.VirtualTableRegister method to
     associated this virtual table module to a TSQLRecordVirtualTableAutoID class
   - transactions are not handled by this module
   - by default, no data is written on disk: you will need to call explicitly
     aServer.StaticVirtualTable[aClass].UpdateToFile for file creation or refresh
   - binary format is more efficient in term of speed and disk usage than
     the JSON format implemented by TSQLVirtualTableJSON
   - binary format will be set by TSQLVirtualTableJSON.CreateTableInstance
   - file extension is set to '.data' }
  TSQLVirtualTableBinary = class(TSQLVirtualTableJSON);

  {/ Implements a read/only virtual table able to access a .log file, as created
     by TSynLog
   - to be used e.g. by a TSQLRecordLog_Log ('Log_' will identify this 'Log' module)
    - the .log file name will be specified by the Table Name, to which a '.log'
      file extension will be appended before loading it from the current
      directory }
  TSQLVirtualTableLog = class(TSQLVirtualTable)
  protected
    fLogFile: TSynLogFile;
  public
    /// returns the main specifications of the associated TSQLVirtualTableModule
    // - this is a read only table, with transaction, associated to the
    // TSQLVirtualTableCursorLog cursor type, with 'Log' as module name,
    // and associated to TSQLRecordLog_Log table field layout
    class procedure GetTableModuleProperties(
      var aProperties: TVirtualTableModuleProperties); override;
    /// creates the TSQLVirtualTable according to the supplied parameters
    // - aTableName will be checked against the current aModule.Server.Model
    // to retrieve the corresponding TSQLRecordVirtualTableAutoID class
    constructor Create(aModule: TSQLVirtualTableModule; const aTableName: RawUTF8;
      FieldCount: integer; Fields: PPUTF8CharArray); override;
    /// release the associated .log file mapping and all internal structures
    destructor Destroy; override;
  end;

  {/ A Virtual Table cursor for reading a TSynLogFile content
    - this is the cursor class associated to TSQLVirtualTableLog }
  TSQLVirtualTableCursorLog = class(TSQLVirtualTableCursorIndex)
  public
    /// called to begin a search in the virtual table
    function Search(const Prepared: TSQLVirtualTablePrepared): boolean; override;
    /// called to retrieve a column value of the current data row
    function Column(aColumn: integer; var aResult: TVarData): boolean; override;
  end;

  {/ Record associated to a Virtual Table implemented in Delphi, with ID
    forced at INSERT
  - will use TSQLVirtualTableModule / TSQLVirtualTable / TSQLVirtualTableCursor
    classes for a generic Virtual table mechanism on the Server side
  - call Model.VirtualTableRegister() before TSQLRestServer.Create on the
    Server side (not needed for Client) to associate such a record with a
    particular Virtual Table module, otherwise an exception will be raised:
    ! Model.VirtualTableRegister(TSQLRecordDali1,TSQLVirtualTableJSON); }
  TSQLRecordVirtualTableForcedID = class(TSQLRecordVirtual);

  {/ Record associated to Virtual Table implemented in Delphi, with ID
    generated automatically at INSERT
  - will use TSQLVirtualTableModule / TSQLVirtualTable / TSQLVirtualTableCursor
    classes for a generic Virtual table mechanism
  - call Model.VirtualTableRegister() before TSQLRestServer.Create on the
    Server side (not needed for Client) to associate such a record with a
    particular Virtual Table module, otherwise an exception will be raised:
    ! Model.VirtualTableRegister(TSQLRecordDali1,TSQLVirtualTableJSON); }
  TSQLRecordVirtualTableAutoID = class(TSQLRecordVirtual);

/// special comparaison function for sorting ftRecord (TRecordReference/RecordRef)
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareRecord(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftBoolean
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareBoolean(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftEnumerate, sftSet or sftID
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareUInt32(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftInteger or
// sftTimeLog / sftModTime / sftCreateTime UTF-8 encoded values in the SQLite3
// database or JSON content
function UTF8CompareInt64(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftCurrency
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareCurr64(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftFloat
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareDouble(P1,P2: PUTF8Char): PtrInt;

/// special comparaison function for sorting sftDateTime
// UTF-8 encoded values in the SQLite3 database or JSON content
function UTF8CompareISO8601(P1,P2: PUTF8Char): PtrInt;

const
  /// if a TSQLVirtualTablePreparedConstraint.Column is to be ignored
  VIRTUAL_TABLE_IGNORE_COLUMN = -2;
  /// if a TSQLVirtualTablePreparedConstraint.Column points to the RowID
  VIRTUAL_TABLE_ROWID_COLUMN = -1;

  /// if the TSQLRecordVirtual table kind is a FTS3/FTS4 virtual table
  IS_FTS = [rFTS3, rFTS4];                  

  /// if the TSQLRecordVirtual table kind is not an embedded type
  // - can be set for a TSQLRecord after a VirtualTableExternalRegister call
  IS_CUSTOM_VIRTUAL = [rCustomForcedID, rCustomAutoID];

  /// if the TSQLRecordVirtual table kind expects the ID to be set on INSERT
  INSERT_WITH_ID = [rFTS3, rFTS4, rRTree, rCustomForcedID];

  /// Supervisor Table access right, i.e. alllmighty over all fields
  ALL_ACCESS_RIGHTS = [0..MAX_SQLTABLES-1];

  /// Supervisor Database access right, i.e. allmighty over all Tables
  SUPERVISOR_ACCESS_RIGHTS: TSQLAccessRights =
    (AllowRemoteExecute: [reService,reUrlEncodedDelete];
     GET: ALL_ACCESS_RIGHTS; POST: ALL_ACCESS_RIGHTS;
     PUT: ALL_ACCESS_RIGHTS; DELETE: ALL_ACCESS_RIGHTS);

  /// Supervisor Database access right, i.e. allmighty over all Tables
  // - this constant will set AllowRemoteExecute field to true
  // - is used by default only TSQLRestClientDB.URI() method, for direct
  // local access right
  FULL_ACCESS_RIGHTS: TSQLAccessRights =
    (AllowRemoteExecute: [reSQL,reService,reUrlEncodedDelete];
     GET: ALL_ACCESS_RIGHTS; POST: ALL_ACCESS_RIGHTS;
     PUT: ALL_ACCESS_RIGHTS; DELETE: ALL_ACCESS_RIGHTS);

  /// special TSQLFieldBits value containing all field bits set to 1
  ALL_FIELDS: TSQLFieldBits = [0..MAX_SQLFIELDS-1];

  /// timer identifier which indicates we must refresh the current Page
  // - used for User Interface generation
  // - is associated with the TSQLRibbonTabParameters.AutoRefresh property,
  // and is handled in TSQLRibbon.RefreshClickHandled
  WM_TIMER_REFRESH_SCREEN = 1;
  /// timer identifier which indicates we must refresh the Report content
  // - used for User Interface generation
  // - is handled in TSQLRibbon.RefreshClickHandled
  WM_TIMER_REFRESH_REPORT = 2;

  /// HTML Status Code for "Success"
  HTML_SUCCESS = 200;
  /// HTML Status Code for "Created"
  HTML_CREATED = 201;
  /// HTML Status Code for "Bad Request"
  HTML_BADREQUEST = 400;
  /// HTML Status Code for "Forbidden"
  HTML_FORBIDDEN = 403;
  /// HTML Status Code for "Not Found"
  HTML_NOTFOUND = 404;
  /// HTML Status Code for "Request Time-out"
  HTML_TIMEOUT = 408;
  /// HTML Status Code for "Not Implemented"
  HTML_NOTIMPLEMENTED = 501;
  /// HTML Status Code for "Service Unavailable"
  HTML_UNAVAILABLE = 503;


/// create a TRecordReference with the corresponding parameters
function RecordReference(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer): TRecordReference;

/// convert a dynamic array of TRecordRef into its corresponding IDs
procedure RecordRefToID(var aArray: TIntegerDynArray);

/// wrapper to convert an array of TSQLRecordClass to a generic array of TClass
// - used e.g. by TSQLRestClientURI.List before calling TSQLTableJSON.Create
function RecordClassesToClasses(const Tables: array of TSQLRecordClass): TClasses;

/// compute the SQL statement to be executed for a specific SELECT on Tables
// - you can set multiple Table class in Tables: the statement will contain the
// table name ('SELECT T1.F1,T1.F2,T1.F3,T2.F1,T2.F2 FROM T1,T2 WHERE ..' e.g.)
function SQLFromSelectWhere(const Tables: array of TSQLRecordClass;
  const SQLSelect, SQLWhere: RawUTF8): RawUTF8;

/// get the order table name from a SQL statement
// - return the word following any 'ORDER BY' statement
// - return 'RowID' if none found
function SQLGetOrder(const SQL: RawUTF8): RawUTF8;

/// this function will extract inlined :(1234): parameters into Types[]/Values[]
// - will return the generic SQL statement with ? instead of :(1234):
// - call internaly SQLParamContent() function for inline parameters decoding
// - will set maxParam=0 in case of no inlined parameters
// - recognized types are only sftInteger, sftFloat, sftDateTime ('\uFFF1...'),
// sftUTF8Text and sftBlob ('\uFFF0...')
// - sftUnknown is returned on invalid content
function ExtractInlineParameters(const SQL: RawUTF8;
  var Types: TSQLFieldTypeArray; var Values: TRawUTF8DynArray; var maxParam: integer): RawUTF8;

{$ifdef PUREPASCAL}{$ifdef HASINLINE}
/// this function is published only for class function TSQLRecord.RecordProps()
// internal call after inlining
function PropsCreate(aTable: TSQLRecordClass): TSQLRecordProperties;
{$endif}{$endif}

/// low-level function to retrieve the class instance implementing a given
// interface
// - this will work with interfaces stubs generated by the compiler, but also
// with our TInterfacedObjectFake kind of interface implementation classes
function ObjectFromInterface(const aValue: IInterface): TObject;

/// assign a Weak interface reference, to be used for circular references
// - by default setting aInterface.Field := aValue will increment the internal
// reference count of the implementation object: when underlying objects reference
// each other via interfaces (e.g. as parent and children), what causes the
// reference count to never reach zero, therefore resulting in memory links
// - to avoid this issue, use this procedure instead
procedure SetWeak(aInterfaceField: PIInterface; const aValue: IInterface);
 // {$ifdef HASINLINE}inline;{$endif} raise compilation Internal Error C2170

/// assign a Weak interface reference, which will be ZEROed (set to nil) when
// the corresponding object will be released
// - this function is bit slower than SetWeak, but will avoid any GPF, by
// maintaining a list of per-instance weak interface field reference, and
// hook the FreeInstance virtual method in order to reset any reference to nil:
// FreeInstance will be overriden for this given class VMT only (to avoid
// unnecessary slowdown of other classes), calling the previous method afterward
// (so will work even with custom FreeInstance implementations)
// - for faster possible retrieval, it will assign the unused vmtAutoTable VMT
// entry trick (just like TSQLRecord.RecordProps) - note that it will be
// compatible also with interfaces implemented via TSQLRecord children
// - implementation should be thread-safe
procedure SetWeakZero(aObject: TObject; aObjectInterfaceField: PIInterface;
  const aValue: IInterface);

{$ifdef ISDELPHIXE} // class helper requires Delphi 2006 or newer but are buggy before XE :(
type
  /// TWeakZeroInterfaceHelper is a class helper that allows you to use
  // SetWeakZero() in any class without specifying the Self parameter
  TWeakZeroInterfaceHelper = class helper for TObject
  protected
    /// Use SetWeak0 to assign an interface to a weak interface field
    // - this is just a wrapper around the global SetWeakZero() function
    procedure SetWeak0(aObjectInterfaceField: PIInterface; const aValue: IInterface);
  end;
{$endif}

{$ifdef MSWINDOWS}
var
  /// if this variable is TRUE, the URIRequest() function won't use
  // Win32 API GlobalAlloc() function, but fastest native Getmem()
  // - can be also usefull for debugg
  USEFASTMM4ALLOC: boolean = false;

/// this function can be exported from a DLL to remotely access to a TSQLRestServer
// - use TSQLRestServer.ExportServer to assign a server to this function
// - return 501 HTML_NOTIMPLEMENTED if no TSQLRestServer.ExportServer has been assigned
// - memory for Resp and Head are allocated with GlobalAlloc(): client must release
// this pointers with GlobalFree() after having retrieved their content
// - simply use TSQLRestClientURIDll to access to an exported URIRequest() function
function URIRequest(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;
{$endif}


type
  PServiceRunningContext = ^TServiceRunningContext;
  /// will identify the currently running service on the server side
  // - is the type of the global ServiceContext threadvar
  TServiceRunningContext = record
    /// the currently running service factory
    // - it can be used within server-side implementation to retrieve the
    // associated TSQLRestServer instance
    Factory: TServiceFactoryServer;
    /// the currently runnning session identifier which launched the method
    // - make available the current session or authentication parameters
    // (including e.g. user details via Factory.RestServer.SessionGetUser)
    Session: ^TSQLRestServerSessionContext;
    /// the thread which launched the request
    // - is set by TSQLRestServer.BeginCurrentThread from multi-thread server
    // handlers - e.g. TSQLite3HttpServer or TSQLRestServerNamedPipeResponse
    RunningThread: TThread;
  end;

threadvar
  /// this thread-specific variable will be set with the currently running
  // service context (on the server side)
  // - is set by TServiceFactoryServer.ExecuteMethod() just before calling the
  // implementation method of a service, allowing to retrieve the current
  // execution context
  // - its content is reset to zero out of the scope of a method execution
  // - when used, a local copy or a PServiceRunningContext pointer should better
  // be created, since accessing a threadvar has a non negligible performance cost
  ServiceContext: TServiceRunningContext;


{ ************ Unit-Testing classes and functions }

type
  /// this test case will test most low-level functions, classes and types
  // defined and implemented in the SQLite3Commons unit
  TTestLowLevelTypes = class(TSynTestCase)
  published
    /// some low-level RTTI access
    // - especially the field type retrieval from published properties
    procedure RTTI;
    /// some low-level Url encoding from parameters
    procedure UrlEncoding;
    /// some low-level JSON encoding/decoding
    procedure EncodeDecodeJSON;
  end;

  /// this test case will test some generic classes
  // defined and implemented in the SQLite3Commons unit
  TTestBasicClasses = class(TSynTestCase)
  published
    /// test the TSQLRecord class
    // - especially SQL auto generation, or JSON export/import
    procedure _TSQLRecord;
    /// test the digital signature of records
    procedure _TSQLRecordSigned;
    /// test the TSQLModel class
    procedure _TSQLModel;
  end;


type
  // a record mapping used in the test classes of the framework
  // - this class can be used for debugging purposes, with the database
  // created by TTestFileBased in SQLite3.pas
  // - this class will use 'People' as a table name
  TSQLRecordPeople = class(TSQLRecord)
  private
    fData: TSQLRawBlob;
    fFirstName: RawUTF8;
    fLastName: RawUTF8;
    fYearOfBirth: integer;
    fYearOfDeath: word;
  published
    property FirstName: RawUTF8 read fFirstName write fFirstName;
    property LastName: RawUTF8 read fLastName write fLastName;
    property Data: TSQLRawBlob read fData write fData;
    property YearOfBirth: integer read fYearOfBirth write fYearOfBirth;
    property YearOfDeath: word read fYearOfDeath write fYearOfDeath;
  public
    {/ method used to test the Client-Side
       ModelRoot/TableName/ID/MethodName RESTful request, i.e.
       ModelRoot/People/ID/DataAsHex in this case
     - this method calls the supplied TSQLRestClient to retrieve its results,
       with the ID taken from the current TSQLRecordPeole instance ID field
     - parameters and result types depends on the purpose of the function
     - TSQLRestServerTest.DataAsHex published method implements the result
       calculation on the Server-Side }
    function DataAsHex(aClient: TSQLRestClientURI): RawUTF8;
    {/ method used to test the Client-Side
       ModelRoot/MethodName RESTful request, i.e. ModelRoot/Sum in this case
     - this method calls the supplied TSQLRestClient to retrieve its results
     - parameters and result types depends on the purpose of the function
     - TSQLRestServerTest.Sum published method implements the result calculation
       on the Server-Side
     - this method doesn't expect any ID to be supplied, therefore will be
       called as class function - normally, it should be implement in a
       TSQLRestClient descendant, and not as a TSQLRecord, since it does't depend
       on TSQLRecordPeople at all
     - you could also call the same servce from the ModelRoot/People/ID/Sum URL,
       but it won't make any difference) }
    class function Sum(aClient: TSQLRestClientURI; a, b: double): double;
  end;


{ ************ Logging classes and functions }

type
  /// logging class with enhanced RTTI
  // - will write TObject/TSQLRecord, enumerations and sets content as JSON
  // - is the default logging family used by SQLite3Commons/SQLite3
  TSQLLog = class(TSynLog)
  protected
    procedure CreateLogWriter; override;
    procedure AddTyped(aTypeInfo: pointer; var aValue); override;
  end;

{$ifdef WITHLOG}
var
  /// TSQLLog class is used for logging for all our ORM related functions
  // - this global variable can be used to customize it
  SQLite3Log: TSynLogClass = TSQLLog;
{$endif}


implementation

uses
  SynCrypto; // for TSQLRecordSigned


// ************ some RTTI and SQL mapping routines

{$ifdef FPC}
function aligntoptr(p : pointer) : pointer;inline;
begin
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
  result := align(p,sizeof(p));
{$else FPC_REQUIRES_PROPER_ALIGNMENT}
  result := p;
{$endif FPC_REQUIRES_PROPER_ALIGNMENT}
end;
{$endif}

{$ifdef USETYPEINFO}
  // this pure pascal version must handle the 64-bits ordinal values and
  // the special layout of the underlying compiler (mostly FPC)
  // -> use the typinfo unit
{$else}
function GetOrdProp(Instance: TObject; PropInfo: PPropInfo): Longint;
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        { <-    EAX Longint result              }
        PUSH    EBX
        PUSH    EDI
        MOV     EDI,[EDX].TPropInfo.PropType
        MOV     EDI,[EDI]
        MOV     BL,otSLong
        CMP     [EDI].TTypeInfo.Kind,tkClass
        JE      @@isClass
        MOVZX   ECX,[EDI].TTypeInfo.Name.Byte[0]
        MOV     BL,byte ptr [EDI].TTypeInfo.Name[ECX+1] // get the ord type
@@isClass:
        MOV     ECX,[EDX].TPropInfo.GetProc
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FE
        MOV     EDX,[EDX].TPropInfo.Index
        JB      @@isStaticMethod
        JA      @@isField
        {       the GetProc is a virtual method }
        MOVSX   ECX,CX                  { sign extend slot offs }
        ADD     ECX,[EAX]               { vmt   + slotoffs      }
        CALL    dword ptr [ECX]         { call vmt[slot]        }
        JMP     @@final
@@isStaticMethod:
        CALL    ECX
        JMP     @@final
@@isField:
        AND     ECX,$00FFFFFF
        ADD     ECX,EAX
        MOV     AL,[ECX]
        CMP     BL,otSWord
        JB      @@final
        MOV     AX,[ECX]
        CMP     BL,otSLong
        JB      @@final
        MOV     EAX,[ECX]
@@final:CMP     BL,otSLong
        JAE     @@exit
        CMP     BL,otSWord
        JAE     @@word
        CMP     BL,otSByte
        MOVSX   EAX,AL
        JE      @@exit
        AND     EAX,$FF
        JMP     @@exit
@@word: MOVSX   EAX,AX
        JE      @@exit
        AND     EAX,$FFFF
@@exit: POP     EDI
        POP     EBX
end;
{$endif}

{$ifdef USETYPEINFO}
  // this pure pascal version must handle the 64-bits ordinal values and
  // the special layout of the underlying compiler (mostly FPC)
  // -> use the typinfo unit
{$else}
// AB: use the getter field address if no setter (no write attribute) exists
procedure SetOrdProp(Instance: TObject; PropInfo: PPropInfo; Value: Longint);
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Value                       }
        PUSH    EBX
        PUSH    ESI
        PUSH    EDI
        MOV     EDI,EDX
        MOV     ESI,[EDI].TPropInfo.PropType
        MOV     ESI,[ESI]
        MOV     BL,otSLong
        CMP     [ESI].TTypeInfo.Kind,tkClass
        JE      @@isClass
        XOR     EBX,EBX
        MOV     BL,[ESI].TTypeInfo.Name.Byte[0]
        MOV     BL,byte ptr [ESI].TTypeInfo.Name[EBX+1] // get field size
@@isClass:
        MOV     EDX,[EDI].TPropInfo.Index       { pass Index in DX      }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX     }
@@hasIndex:
        MOV     ESI,[EDI].TPropInfo.SetProc
        or esi,esi // no setter ?
        jz @NoSet
        CMP     [EDI].TPropInfo.SetProc.Byte[3],$FE
@set:   JA      @@isField
        JB      @@isStaticMethod
        {       SetProc turned out to be a virtual method. call it      }
        MOVSX   ESI,SI                          { sign extend slot offset }
        ADD     ESI,[EAX]                       { vmt   + slot offset   }
        CALL    dword ptr [ESI]
        JMP     @@exit
@@isStaticMethod:
        CALL    ESI
        JMP     @@exit
@NoSet: MOV     ESI,[EDI].TPropInfo.GetProc // use the field address
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     ESI,$00FFFFFF
        ADD     EAX,ESI
        MOV     [EAX],CL
        CMP     BL,otSWord
        JB      @@exit
        MOV     [EAX],CX
        CMP     BL,otSLong
        JB      @@exit
        MOV     [EAX],ECX
@@exit: POP     EDI
        POP     ESI
        POP     EBX
end;
{$endif}

{$ifdef USETYPEINFO}
  // this pure pascal version must handle the 64-bits ordinal values and
  // the special layout of the underlying compiler (mostly FPC)
  // -> use the typinfo unit
{$else}
function GetInt64Prop(Instance: TObject; PropInfo: PPropInfo): Int64;
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        { <-    EDX:EAX result                  }
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FE
        MOV     ECX,[EDX].TPropInfo.GetProc
        MOV     EDX,[EDX].TPropInfo.Index       { pass Index in EDX     }
        JA      @@isField
        JB      @@isStaticMethod
        {       GetProc is a virtual method     }
        MOVSX   ECX,CX                          { sign extend slot number }
        ADD     ECX,[EAX]
        CALL    dword ptr [ECX]
        JMP     @@exit
@@isStaticMethod:
        CALL    ECX
        JMP     @@exit
@@isField:
        AND     ECX,$00FFFFFF
        ADD     EAX,ECX
        MOV     EDX,[EAX].Integer[4]
        MOV     EAX,[EAX].Integer[0]
@@exit:
end;
{$endif}

{$ifdef USETYPEINFO}
  // this pure pascal version must handle the 64-bits ordinal values and
  // the special layout of the underlying compiler (mostly FPC)
  // -> use the typinfo unit
{$else}
procedure SetInt64Prop(Instance: TObject; PropInfo: PPropInfo; const Value: Int64);
// AB: use the getter field address if no setter (no write attribute) exists
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       [ESP+4] Value                   }
        MOV     ECX,[EDX].TPropInfo.SetProc
        or ecx,ecx
        jz @noset
        CMP     [EDX].TPropInfo.SetProc.Byte[3],$FE
        JA      @@isField
        MOV     EDX,[EDX].TPropInfo.Index
        PUSH    Value.Integer[4]
        PUSH    Value.Integer[0]
        JB      @@isStaticMethod
        {       SetProc is a virtual method     }
        MOVSX   ECX,CX
        ADD     ECX,[EAX]
        call    dword ptr [ECX]
        jmp     @@exit
@@isStaticMethod:
        call    ecx
        jmp     @@exit
@NoSet: MOV     ECX,[EDX].TPropInfo.GetProc // use the field address
        CMP     [EDX].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     ECX,$00FFFFFF
        ADD     EAX,ECX
        MOV     EDX,Value.Integer[0]
        MOV     ECX,Value.Integer[4]
        MOV     [EAX].Integer[0],EDX
        MOV     [EAX].Integer[4],ECX
@@exit:
end;
{$endif}

{$ifdef USETYPEINFO}
procedure GetLongStrProp(Instance: TObject; PropInfo: PPropInfo; var Value: RawByteString);
{$ifdef HASINLINE}inline;{$endif}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
begin  // pointer(PropInfo) below to call typinfo unit 
{$ifdef UNICODE} // GetStrProp() use UnicodeString and will make a bad conversion
  Value := RawByteString(GetAnsiStrProp(Instance,pointer(PropInfo))); 
{$else}
  Value := RawByteString(GetStrProp(Instance,pointer(PropInfo)));
{$endif}
end;
{$else}
procedure GetLongStrProp(Instance: TObject; PropInfo: PPropInfo; var Value: RawByteString);
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to result string    }
        PUSH    ESI
        PUSH    EDI
        MOV     EDI,EDX
        MOV     EDX,[EDI].TPropInfo.Index       { pass index in EDX }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX }
@@hasIndex:
        MOV     ESI,[EDI].TPropInfo.GetProc
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
@@isVirtualMethod:
        MOVSX   ESI,SI                          { sign extend slot offset }
        ADD     ESI,[EAX]                       { vmt + slot offset }
        CALL    DWORD PTR [ESI]
        JMP     @@exit
@@isStaticMethod:
        CALL    ESI
        JMP     @@exit
@@isField:
        AND     ESI,$00FFFFFF
        MOV     EDX,[EAX+ESI]
        MOV     EAX,ECX
        CALL    System.@LStrLAsg // copy local string(EDX) into string(EAX)
@@exit: POP     EDI
        POP     ESI
end;
{$endif}

procedure SetLongStrProp(Instance: TObject; PropInfo: PPropInfo; const Value: RawByteString);
// AB: use the getter field address if no setter (no write attribute) exists
{$ifdef USETYPEINFO}
{$ifdef HASINLINE}inline;{$endif}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit and pointer(PropInfo)
begin
{$ifdef UNICODE}
  SetAnsiStrProp(Instance,pointer(PropInfo),Value);
{$else}
  SetStrProp(Instance,pointer(PropInfo),string(Value));
{$endif}
end;
{$else}
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to string value     }
        PUSH    ESI
        PUSH    EDI
        MOV     ESI,EDX
        MOV     EDX,[ESI].TPropInfo.Index       { pass index in EDX }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX }
@@hasIndex:
        MOV     EDI,[ESI].TPropInfo.SetProc
        or edi,edi // no setter ?
        jz @NoSet
        CMP     [ESI].TPropInfo.SetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
@@isVirtualMethod:
        MOVSX   EDI,DI
        ADD     EDI,[EAX]
        CALL    DWORD PTR [EDI]
        JMP     @@exit
@@isStaticMethod:
        CALL    EDI
        JMP     @@exit
@NoSet: MOV     EDI,[ESI].TPropInfo.GetProc // use the field address
        CMP     [ESI].TPropInfo.GetProc.Byte[3],$FF
        JNE     @@exit // we only allow setting if we know the field address
@@isField:
        AND     EDI,$00FFFFFF
        ADD     EAX,EDI
        MOV     EDX,ECX
        CALL    System.@LStrLAsg // copy local string(EDX) into string(EAX)
@@exit: POP     EDI
        POP     ESI
end;
{$endif}

{$ifdef UNICODE}
function GetUnicodeStrProp(Instance: TObject; PropInfo: PPropInfo): UnicodeString;
type
  TUStringGetProc = function: UnicodeString of object;
  TUStringIndexedGetProc = function (Index: Integer): UnicodeString of object;
var P: PUnicodeString;
    M: TMethod;
    Getter: PtrUInt;
begin // caller must check that PropInfo^.PropType^.Kind = tkUString
  Getter := PtrUInt(PropInfo^.GetProc);
  if (Getter and $FF000000) = $FF000000 then begin
    // field - Getter is the field's offset in the instance data
    P := Pointer(PtrUInt(Instance) + PtrUInt(Getter and $00FFFFFF));
    Result := P^;  // auto ref count
  end else begin
    if (Getter and $FF000000) = $FE000000 then
      // virtual method  - Getter is a signed 2 byte integer VMT offset
      M.Code := Pointer(PPtrUInt(PPtrInt(Instance)^ + SmallInt(Getter))^) else
      // static method - Getter is the actual address
      M.Code := Pointer(Getter);
    M.Data := Instance;
    if PropInfo^.Index = Integer($80000000) then  // no index
      Result := TUStringGetProc(M)() else
      Result := TUStringIndexedGetProc(M)(PropInfo^.Index);
  end;
end;

procedure SetUnicodeStrProp(Instance: TObject; PropInfo: PPropInfo; const Value: UnicodeString);
type
  TUStringSetProc = procedure (const Value: UnicodeString) of object;
  TUStringIndexedSetProc = procedure (Index: Integer; const Value: UnicodeString) of object;
var P: PUnicodeString;
    M: TMethod;
    Setter: PtrUInt;
begin // caller must check that PropInfo^.PropType^.Kind = tkUString
  if PropInfo^.SetProc=0 then  // no setter ?
    if LongRec(PropInfo^.GetProc).Bytes[3]<>$FF then
      exit else begin  // we only allow setting if we know the field address
      P := Pointer(PtrUInt(Instance) + PtrUInt(PropInfo^.GetProc and $00FFFFFF));
      P^ := Value;   // auto ref count
      exit;
    end;
  Setter := Longint(PropInfo^.SetProc);
  if (Setter and $FF000000) = $FF000000 then begin
    // field - Setter is the field's offset in the instance data
    P := Pointer(PtrUInt(Instance) + (Setter and $00FFFFFF));
    P^ := Value;   // auto ref count
  end else begin
    if (Setter and $FF000000) = $FE000000 then
      // virtual method  - Setter is a signed 2 byte integer VMT offset
      M.Code := Pointer(PPtrUInt(PPtrInt(Instance)^ + SmallInt(Setter))^) else
      // static method - Setter is the actual address
      M.Code := Pointer(Setter);
    M.Data := Instance;
    if PropInfo^.Index = Integer($80000000) then  // no index
      TUStringSetProc(M)(Value) else
      TUStringIndexedSetProc(M)(PropInfo^.Index, Value);
  end;
end;
{$endif}

{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
{$else}
type
  LongRec = packed record
    case Integer of
      0: (Lo, Hi: Word);
      1: (Words: array [0..1] of Word);
      2: (Bytes: array [0..3] of Byte);
  end;

procedure SetFloatProp(Instance: TObject; PropInfo: PPropInfo; Value: Extended);
// AB: use the getter field address if no setter (no write attribute) exists
type
  TSingleSetProc = procedure (const Value: Single) of object;
  TDoubleSetProc = procedure (const Value: Double) of object;
  TExtendedSetProc = procedure (const Value: Extended) of object;
  TCompSetProc = procedure (const Value: Comp) of object;
  TCurrencySetProc = procedure (const Value: Currency) of object;
var P: Pointer;
    M: TMethod;
label St;
begin
  if PropInfo^.SetProc=0 then  // no setter ?
    if LongRec(PropInfo^.GetProc).Bytes[3]<>$FF then
      exit else begin  // we only allow setting if we know the field address
      P := Pointer(PtrUInt(Instance) + PtrUInt(PropInfo^.GetProc and $00FFFFFF));
      goto St;  // use the field address to set its value
    end;
  if LongRec(PropInfo^.SetProc).Bytes[3] = $FF then begin
    // field - SetProc is the field's offset in the instance data
    P := Pointer(PtrUInt(Instance) + PtrUInt(PropInfo^.SetProc and $00FFFFFF));
St: case PropInfo^.PropType^^.FloatType of
      ftSingle:    PSingle(P)^ := Value;
      ftDouble:    PDouble(P)^ := Value;
      ftExtended:  PExtended(P)^ := Value;
      ftComp:      PComp(P)^ := Value;
      ftCurr:      PCurrency(P)^ := Value; // use SetInt64Prop() to avoid rounding
    end;
  end
  else begin
    if LongRec(PropInfo^.SetProc).Bytes[3] = $FE then
      // virtual method  - SetProc is a signed 2 byte integer VMT offset
      M.Code := Pointer(PPtrUInt(PPtrInt(Instance)^ + SmallInt(PropInfo^.SetProc))^) else
      // static method - SetProc is the actual address
      M.Code := Pointer(PropInfo^.SetProc);
    M.Data := Instance;
    if PropInfo^.Index = Integer($80000000) then begin // no index
      case PropInfo^.PropType^^.FloatType of
        ftSingle  :  TSingleSetProc(M)(Value);
        ftDouble  :  TDoubleSetProc(M)(Value);
        ftExtended:  TExtendedSetProc(M)(Value);
        ftComp    :  TCompSetProc(M)(Value);
        ftCurr    :  TCurrencySetProc(M)(Value); // use SetInt64Prop() to avoid rounding
      end;
    end;  // indexed methods not handled here, since not used in TSQLRecord
  end;
end;
{$endif}

{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
{$else}
function GetFloatProp(Instance: TObject; PropInfo: PPropInfo): Extended;
type
  TFloatGetProc = function : Extended of object;
  TFloatIndexedGetProc = function (Index: Integer): Extended of object;
var P: Pointer;
    M: TMethod;
begin // faster code by AB
  if LongRec(PropInfo^.GetProc).Bytes[3] = $FF then begin
    // field - GetProc is the field's offset in the instance data
    P := Pointer(PtrUInt(Instance) + PtrUInt(PropInfo^.GetProc and $00FFFFFF));
    case PropInfo^.PropType^.FloatType of
      ftSingle:    Result := PSingle(P)^;
      ftDouble:    Result := PDouble(P)^;
      ftExtended:  Result := PExtended(P)^;
      ftComp:      Result := PComp(P)^;
      ftCurr:      Result := PCurrency(P)^; // use GetInt64Prop() to avoid rounding
    else Result := 0;
    end;
  end
  else begin
    if LongRec(PropInfo^.GetProc).Bytes[3] = $FE then
      // virtual method  - GetProc is a signed 2 byte integer VMT offset
      M.Code := Pointer(PPtrUInt(PPtrInt(Instance)^ + SmallInt(PropInfo^.GetProc))^) else
      // static method - GetProc is the actual address
      M.Code := Pointer(PropInfo^.GetProc);
    M.Data := Instance;
    if PropInfo^.Index = Integer($80000000) then  // no index
      Result := TFloatGetProc(M) else
      Result := TFloatIndexedGetProc(M)(PropInfo^.Index);
    if PropInfo^.PropType^.FloatType = ftCurr then
      Result := Result / 10000;
  end;
end;
{$endif}


{$ifdef USETYPEINFO}
// this pure pascal version must handle the 64-bits ordinal values and
// the special layout of the underlying compiler (mostly FPC)
// -> use the typinfo unit
{$else}
function GetMethodProp(Instance: TObject; PropInfo: PPropInfo): TMethod;
asm     { ->    EAX Pointer to instance         }
        {       EDX Pointer to property info    }
        {       ECX Pointer to result           }
        PUSH    EBX
        PUSH    EDI
        MOV     EDI,EDX
        MOV     EDX,[EDI].TPropInfo.Index       { pass Index in DX      }
        CMP     EDX,$80000000
        JNE     @@hasIndex
        MOV     EDX,ECX                         { pass value in EDX     }
@@hasIndex:
        MOV     EBX,[EDI].TPropInfo.GetProc
        CMP     [EDI].TPropInfo.GetProc.Byte[3],$FE
        JA      @@isField
        JB      @@isStaticMethod
        {       GetProc is a virtual method     }
        MOVSX   EBX,BX                          { sign extend slot number }
        ADD     EBX,[EAX]
        CALL    dword ptr [EBX]
        JMP     @@exit
@@isStaticMethod:
        CALL    EBX
        JMP     @@exit
@@isField:
        AND     EBX,$00FFFFFF
        ADD     EAX,EBX
        MOV     EDX,[EAX]
        MOV     EBX,[EAX+4]
        MOV     [ECX],EDX
        MOV     [ECX+4],EBX
@@exit: POP     EDI
        POP     EBX
end;
{$endif}

function InternalMethodInfo(aClassType: TClass; const aMethodName: ShortString): PMethodInfo;
var Count, i: integer;
begin
  while aClassType<>nil do begin
    result := PPointer(PtrInt(aClassType)+vmtMethodTable)^;
    if result<>nil then begin
      {$ifdef FPC}
      Count := PCardinal(result)^;
      inc(PCardinal(result));
      {$else}
      Count := PWord(result)^;
      inc(PWord(result));
      {$endif}
      for i := 0 to Count-1 do
      if IdemPropName(result^.Name{$ifdef FPC}^{$endif},aMethodName) then
        Exit else
        {$ifdef FPC}
        inc(result);
        {$else}
        inc(PtrUInt(result),result^.Len);
        {$endif}
    end;
    if PPointer(PtrInt(aClassType)+vmtParent)^<>nil then
      aClassType := PPointer(PPointer(PtrInt(aClassType)+vmtParent)^)^ else
      break;
  end;
  result := nil;
end;

function TMethodInfo.MethodAddr: Pointer;
begin
  if @self<>nil then
    result := Addr else
    result := @self;
end;

function TMethodInfo.ReturnInfo: PReturnInfo;
begin
  if @self<>nil then begin
    result := {$ifdef FPC}aligntoptr{$endif}(@Name[ord(Name[0])+1]);
    if PtrUInt(result)-PtrUInt(@self)=Len then
      result := nil;
  end else
      result := @self;
end;

(*
function TMethodInfo.RetrieveValidTSQLRestServerCallBack: pointer;
{$ifndef DELPHI6OROLDER}
var RI: PReturnInfo;
{$endif}
begin
  {$ifdef DELPHI6OROLDER} // not enough RTTI (e.g. Delphi 6) -> assume OK :(
  if @Self<>nil then
    result := Addr else
  {$else}
  RI := ReturnInfo;
   if (RI=nil) and (@Self<>nil) then begin
    result := Addr; // returns method address (OK) if not enough RTTI
    exit;
  end;
  if (RI^.ParamCount=6) and (RI^.CallingConvention=ccRegister) and
     (RI^.ReturnType<>nil) and (RI^.ReturnType^.Kind=tkInteger) then
  with RI^.Param^ do // expects "aSession: cardinal"
    if ParamType^.Kind=tkInteger then
    with Next^ do
    if (ParamType^.Kind=tkClass) and ParamType^.InheritsFrom(TSQLRecord) then
      with Next^ {ignore PUTF8Char} .Next^ do // expects "const aSentData: RawUTF8"
      if (ParamType^.Kind=tkLString) and (pfConst in Flags) then
        with Next^ do // expects "out aResp: RawUTF8"
        if (ParamType^.Kind=tkLString) and (pfOut in Flags) then
          with Next^ do // expects "out aHead: RawUTF8"
          if (ParamType^.Kind=tkLString) and (pfOut in Flags) then begin
            result := Addr; // returns method address on matching signature
            exit;
          end;
  {$endif}
  result := nil; // method unknown or with wrong signature
end;
*)

function TReturnInfo.Param: PParamInfo;
begin
  result := Pointer(PtrUInt(@self)+sizeof(TReturnInfo));
end;

function TParamInfo.Next: PParamInfo;
begin
  result := {$ifdef FPC}aligntoptr{$endif}(@Name[ord(Name[0])+1]);
end;

{$ifdef FPC}
function InternalClassProp(ClassType: TClass): PClassProp;
begin // FPC use memory alignment + vmtTypeInfo =-60 -> use PtrInt
  result := PTypeInfo(PPointer(PtrInt(ClassType)+vmtTypeInfo)^)^.ClassType^.ClassProp;
end;
{$else}
{$ifdef PUREPASCAL}
function InternalClassProp(ClassType: TClass): PClassProp;
var PTI: PTypeInfo;
begin // code is a bit abstract, but compiles very well
  PTI := PPointer(PtrInt(ClassType)+vmtTypeInfo)^;
  if PTI<>nil then // avoid GPF if no RTTI available for this class
    with PTI^, PClassType(@Name[ord(Name[0])+1])^ do
      result := PClassProp(@UnitName[ord(UnitName[0])+1]) else
    result := nil;
end;
{$else}
function InternalClassProp(ClassType: TClass): PClassProp;
asm // this code is the fastest possible
  mov eax,[eax+vmtTypeInfo]
  or eax,eax; jz @z // avoid GPF if no RTTI available for this class
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
  movzx edx,byte ptr [eax].TClassType.UnitName
  lea eax,[eax+edx].TClassType.UnitName[1].TClassProp
@z:
end;
{$endif}
{$endif}

function ClassFieldIndex(ClassType: TClass; const PropName: shortstring): integer;
var P: PPropInfo;
    CP: PClassProp;
begin
  if ClassType<>nil then begin
    CP := InternalClassProp(ClassType);
    if CP<>nil then begin
      P := @CP^.PropList;
      for result := 0 to CP^.PropCount-1 do
        if IdemPropName(P^.Name,PropName) then
          exit else
          P := P^.Next;
    end;
  end;
  result := -1;
end;

function ClassFieldProp(ClassType: TClass; const PropName: shortstring): PPropInfo;
begin
  if ClassType<>nil then
    result := InternalClassProp(ClassType)^.FieldProp(PropName) else
    result := nil;
end;

function ClassFieldPropWithParents(aClassType: TClass; const PropName: shortstring): PPropInfo;
var i: integer;
    CP: PClassProp;
begin
  while aClassType<>nil do begin
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    result := @CP^.PropList;
    for i := 1 to CP^.PropCount do
      if IdemPropName(result^.Name,PropName) then
        exit else
        result := result^.Next;
    aClassType := aClassType.ClassParent;
  end;
  result := nil;
end;

function ClassFieldPropWithParentsFromUTF8(aClassType: TClass; PropName: PUTF8Char): PPropInfo;
var i, L: integer;
    CP: PClassProp;
begin
  L := StrLen(PropName);
  while aClassType<>nil do begin
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    result := @CP^.PropList;
    for i := 1 to CP^.PropCount do
      if IdemPropName(result^.Name,PropName,L) then
        exit else
        {$ifdef FPC}
        result := result^.Next;
        {$else}
        result := @result^.Name[ord(result^.Name[0])+1]; // inlined result^.Next
        {$endif}
    aClassType := aClassType.ClassParent;
  end;
  result := nil;
end;

function GetObjectComponent(Obj: TPersistent; const ComponentName: shortstring;
  ComponentClass: TClass): pointer;
var P: PPropInfo;
begin
  result := nil;
  if Obj=nil then
    exit;
  P := ClassFieldPropWithParents(PPointer(Obj)^,ComponentName);
  if (P<>nil) and (P^.PropType^^.Kind=tkClass) then
    if P^.PropType^^.ClassType^.ClassType.InheritsFrom(ComponentClass) then
{$ifdef CPU64} // pointer(P) to call typinfo
      result := pointer(GetOrdProp(Obj, pointer(P)); {$else}
      result := pointer(P^.GetOrdValue(Obj));
{$endif}
end;
  
function ClassFieldPropFromIndex(ClassType: TClass; PropIndex: integer): PPropInfo;
var i: integer;
begin
  result := nil;
  if ClassType<>nil then
  with InternalClassProp(ClassType)^ do
  if PropIndex<PropCount then begin
    result := @PropList;
    for i := 1 to PropIndex do
      result := result^.Next;
  end;
end;

function GetEnumCaption(aTypeInfo: PTypeInfo; const aIndex): string;
begin
  if (aTypeInfo=nil) or (aTypeInfo^.Kind<>tkEnumeration) then
    result := '' else
    result := aTypeInfo^.EnumBaseType^.GetCaption(PByte(@aIndex)^);
end;

function GetEnumNameTrimed(aTypeInfo: PTypeInfo; const aIndex): RawUTF8;
begin
  if (aTypeInfo=nil) or (aTypeInfo^.Kind<>tkEnumeration) then
    result := '' else
    result := aTypeInfo^.EnumBaseType^.GetEnumNameTrimed(aIndex);
end;


{ TSQLTable }

function TSQLTable.FieldIndex(FieldName: PUTF8Char): integer;
begin
  if (self<>nil) and (fResults<>nil) and (FieldName<>nil) then
    if IsRowID(FieldName) then begin
      result := FieldIndexID;
      exit;
    end else
    for result := 0 to FieldCount-1 do
      if AnsiIComp(pointer(fResults[result]),pointer(FieldName))=0 then
        exit;
  result := -1;
end;

function TSQLTable.FieldIndexID: integer;
begin
  if (self<>nil) and (fResults<>nil) then
    for result := 0 to FieldCount-1 do
      if IsRowID(fResults[result]) then
        exit;
  result := -1;
end;

function TSQLTable.FieldIndex(const FieldName: shortstring): integer;
var FieldNameZ: array[byte] of AnsiChar;
begin
  if (self<>nil) and (fResults<>nil) then
    if IsRowID(FieldName) then begin
      result := FieldIndexID;
      exit;
    end else begin
      move(FieldName[1],FieldNameZ,ord(FieldName[0]));
      FieldNameZ[ord(FieldName[0])] := #0; // make prop name asciiz
      for result := 0 to FieldCount-1 do // first Row=FieldName
        if AnsiIComp(pointer(fResults[result]),FieldNameZ)=0 then
          exit;
    end;
  result := -1;
end;

function TSQLTable.FieldValue(const FieldName: shortstring; Row: integer): PUTF8Char;
var Index: integer;
begin
  Index := FieldIndex(FieldName);
  if (Index<0) or (cardinal(Row-1)>=cardinal(RowCount)) then
    result := nil else                     
    result := fResults[Index+Row*FieldCount];
end;

procedure TSQLTable.SortBitsFirst(var Bits);
var oldIDColumn, oldResults: array of PUTF8Char;
    i, j, nSet, n: integer;
    R: PPUTF8Char;
begin
  if fIDColumn<>nil then begin
    n := length(fIDColumn);
    SetLength(oldIDColumn,n);
    move(fIDColumn[0],oldIDColumn[0],n*4);
  end;
  i := (RowCount+1)*FieldCount;
  SetLength(oldResults,i);
  move(fResults[0],oldResults[0],i*4);
  // put marked IDs first
  n := 1; // copy row data (first row=0 i.e. idents is left as it is)
  R := @fResults[FieldCount];
  j := FieldCount;
  for i := 1 to RowCount do begin
    if GetBit(Bits,i-1) then begin
      if fIDColumn<>nil then
        fIDColumn[n] := oldIDColumn[i];
      move(oldResults[j],R^,FieldCount*4);
      inc(n);
      inc(R,FieldCount);
    end;
    inc(j,FieldCount);
  end;
  nSet := n-1;
  // put unmarked IDs
  j := FieldCount;
  for i := 1 to RowCount do begin
    if not GetBit(Bits,i-1) then begin
      if fIDColumn<>nil then
        fIDColumn[n] := oldIDColumn[i];
      move(oldResults[j],R^,FieldCount*4);
      inc(n);
      inc(R,FieldCount);
    end;
    inc(j,FieldCount);
  end;
  assert(n-1=RowCount);
  // recalcultate Bits[]
  fillchar(Bits,(RowCount shr 3)+1,0);
  for i := 0 to nSet-1 do
    SetBit(Bits,i); // slow but accurate
end;

function TSQLTable.IDColumnHide: boolean;
var FID,R,F: integer;
    S,D1,D2: PPUTF8Char;
begin
  // 1. check if possible
  result := false;
  if (self=nil) or Assigned(fIDColumn) or (FieldCount<=1) then
    exit; // already hidden or not possible
  FID := FieldIndexID;
  if FID<0 then
    exit; // no 'ID' field
  // 2. alloc new arrays of PUTF8Char
  dec(fFieldCount);
  R := RowCount+1;
  SetLength(fIDColumn,R);               // will contain the ID column data
  SetLength(fNotIDColumn,R*FieldCount); // will be the new fResults[]
  // 3. copy fResults[] into new arrays
  S := @fResults[0];
  D1 := @fNotIDColumn[0];
  D2 := @fIDColumn[0];
  for R := 0 to RowCount do
    for F := 0 to FieldCount do begin // we have FieldCount := FieldCount-1
      if F<>FID then begin
        D1^ := S^; // copy not ID column into fNotIDColumn[]
        inc(D1);
      end else begin
        D2^ := S^; // copy ID column into fIDColumn[]
        inc(D2);
      end;
      inc(S);
    end;
  // 4. TSQLTable data now points to new values without ID field
  result := true;
  fResults := @fNotIDColumn[0];
end;

function TSQLTable.IDColumnHiddenValue(Row: integer): integer;
begin
  if (self=nil) or (fResults=nil) or (Row<=0) or (Row>RowCount) then
    result := 0 else
    if Assigned(fIDColumn) then // get hidden ID column UTF-8 content
      result := GetInteger(fIDColumn[Row]) else begin
      result := FieldIndexID;  // get ID column field index
      if result>=0 then
        result := GetInteger(fResults[Row*FieldCount+result]) else
        result := 0;
    end;
end;

procedure TSQLTable.IDArrayFromBits(const Bits; var IDs: TIntegerDynArray);
var n, i, FID: integer;
begin
  if not Assigned(fIDColumn) then begin
    FID := FieldIndexID; // get ID column field index
    if FID<0 then
      exit;
  end else
    FID := 0; // make compiler happy
  n := GetBitsCount(Bits,RowCount);
  if n=RowCount then begin
    IDColumnHiddenValues(IDs); // all selected -> direct get all IDs
    exit;
  end;
  SetLength(IDs,n);
  if n=0 then
    exit;
  n := 0;
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
    if GetBit(Bits,i-1) then begin
      IDs[n] := GetInteger(fIDColumn[i]); // get hidden ID column UTF-8 content
      inc(n);
    end;
  end else begin
    inc(FID,FieldCount); // [i*FieldCount+FID] = [(i+1)*FieldCount+FID] below
    for i := 0 to RowCount-1 do
    if GetBit(Bits,i) then begin
      IDs[n] := GetInteger(fResults[i*FieldCount+FID]); // get ID column UTF-8 content
      inc(n);
    end;
  end;
end;

procedure TSQLTable.IDColumnHiddenValues(var IDs: TIntegerDynArray);
var n, i, FID: integer;
    U: PPUTF8Char;
begin
  n := RowCount;
  if not Assigned(fIDColumn) then begin
    FID := FieldIndexID; // get ID column field index
    if FID<0 then
      n := 0;
  end else
    FID := 0;
  SetLength(IDs,n);
  if n=0 then
    exit;
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
      IDs[i-1] := GetInteger(fIDColumn[i]); // get hidden ID column UTF-8 content
  end else begin
    U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
    for i := 0 to RowCount-1 do begin
      IDs[i] := GetInteger(U^);
      inc(U,FieldCount);
    end;
  end;
end;

procedure TSQLTable.IDArrayToBits(var Bits; var IDs: TIntegerDynArray);
var i,FID: integer;
    U: PPUTF8Char;
    ID: Pointer;
    IDn: integer;
//    AllID: TIntegerDynArray;
begin
  if length(IDs)=RowCount then begin
    fillchar(Bits,(RowCount shr 3)+1,255); // all selected -> all bits set to 1
    exit;
  end;
  fillchar(Bits,(RowCount shr 3)+1,0);
  if IDs=nil then
    exit; // no selected -> all bits left to 0
  // we sort IDs to use FastFindIntegerSorted() and its fast binary search
  ID := @IDs[0];
  IDn := high(IDs);
  QuickSortInteger(ID,0,IDn);
  if not Assigned(fIDColumn) then begin
    FID := FieldIndexID; // get ID column field index
    if FID<0 then
      exit; // no ID column -> unable to get bit index
  end else
    FID := 0; // make compiler happy
  if Assigned(fIDColumn) then begin
    for i := 1 to RowCount do
      if FastFindIntegerSorted(ID,IDn,GetInteger(fIDColumn[i]))>=0 then
        SetBit(Bits,i-1);
  end else begin
    U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
    for i := 0 to RowCount-1 do begin
      if FastFindIntegerSorted(ID,IDn,GetInteger(U^))>=0 then
        SetBit(Bits,i);
      inc(U,FieldCount);
    end;
  end;
{  // debugg:
  IDArrayFromBits(Bits,AllID);
  assert(length(AllID)=length(IDs));
  QuickSortInteger(@AllID[0],0,high(AllID));
  QuickSortInteger(@IDs[0],0,high(IDs));
  assert(comparemem(@AllID[0],@IDs[0],length(AllID)*4)); }
end;

function TSQLTable.RowFromID(aID: integer): integer;
var ID: RawUTF8;
    FID: integer;
    U: PPUTF8Char;
begin
  if self=nil then begin
    result := -1;
    exit;
  end;
  if (fResults<>nil) and (aID>0) then begin
    // search aID as UTF-8 in fIDColumn[] or fResults[]
    ID := {$ifndef ENHANCEDRTL}UInt32ToUtf8{$else}IntToStr{$endif}(aID);
    if Assigned(fIDColumn) then begin // get hidden ID column UTF-8 content
      for result := 1 to RowCount do
        if StrComp(fIDColumn[result],pointer(ID))=0 then
          exit;
    end else begin
      FID := FieldIndexID;  // get ID column field index
      if FID>=0 then begin
        U := @fResults[FID+FieldCount];  // U^ = ID column UTF-8 content
        for result := 1 to RowCount do
          if StrComp(U^,pointer(ID))=0 then
            exit else
            inc(U,FieldCount);
      end;
    end;
  end;
  result := RowCount; // not found -> return last row index
end;

procedure TSQLTable.DeleteRow(Row: integer);
begin
  if (Row<1) or (Row>RowCount) then
    exit; // out of range
  if Assigned(fIDColumn) then
    if Row<RowCount then
      move(fIDColumn[Row+1],fIDColumn[Row],(RowCount-Row)*4);
  if Row<RowCount then begin
    Row := Row*FieldCount; // convert row index into position in fResults[]
    move(fResults[Row+FieldCount],fResults[Row],(RowCount*FieldCount-Row)*sizeof(pointer));
  end;
  dec(fRowCount);
end;

procedure TSQLTable.DeleteColumnValues(Field: integer);
var i: integer;
    U: PPUTF8Char;
begin
  if cardinal(Field)>=cardinal(FieldCount) then
    exit; // out of range
  U := @fResults[Field+FieldCount];  // U^ = column UTF-8 content for this field
  for i := 1 to RowCount do begin
    U^[0] := #0; // just void UTF-8 content text
    inc(U,FieldCount);
  end;
end;

function SQLFromSelectWhere(const Tables: array of TSQLRecordClass;
   const SQLSelect, SQLWhere: RawUTF8): RawUTF8;
var i: integer;
    Props: array[0..31] of TSQLRecordProperties;
begin
  if high(Tables)=0 then begin
    // fastest common call with one TSQLRecordClass
    result := TSQLRecordClass(Tables[0]).RecordProps.
      SQLFromSelectWhere(SQLSelect,SQLWhere);
    exit;
  end;
  // 'SELECT T1.F1,T1.F2,T1.F3,T2.F1,T2.F2 FROM T1,T2 WHERE ..' e.g.
  if PtrUInt(high(Tables))>high(Props) then
    raise EModelException.Create('SQLFromSelectWhere');
  for i := 0 to high(Tables) do begin
    Props[i] := TSQLRecordClass(Tables[i]).RecordProps;
    if Props[i]=nil then
      raise EModelException.CreateFmt('SQLFromSelectWhere: not in Model: %s',
        [Tables[i].ClassName]);
  end;
  if SQLSelect='*' then
     // don't send BLOB values to query: retrieve all other fields
    if high(Tables)=0 then
      result := 'SELECT '+Props[0].SQLTableSimpleFields[true,false] else begin
      result := 'SELECT '+Props[0].SQLTableSimpleFields[true,true];
      for i := 1 to high(Tables) do
        result := result+','+Props[i].SQLTableSimpleFields[true,true];
    end else
    result := 'SELECT '+SQLSelect;
  result := result+' FROM '+Props[0].SQLTableName;
  for i := 1 to high(Tables) do
    result := result+','+Props[i].SQLTableName;
  if SQLWhere<>'' then
    if IdemPChar(pointer(SQLWhere),'ORDER BY ') or
       IdemPChar(pointer(SQLWhere),'GROUP BY ') or
       IdemPChar(pointer(SQLWhere),'LIMIT ') then
      result := result+' '+SQLWhere else
      result := result+' WHERE '+SQLWhere;
  result := result+';';
end;

function FieldPropFromTable(const aTable: TSQLRecordClass; const PropName: ShortString;
  EnumTypeInfo: PPointer): TSQLFieldType;
var f: integer;
begin
  if IsRowID(PropName) then
    result := sftInteger else
    with aTable.RecordProps do begin
      f := FieldIndex(PropName);
      if f<0 then
        result := sftUnknown else begin
        result := FieldType[f];
        if EnumTypeInfo<>nil then
          case result of
            sftEnumerate:
              EnumTypeInfo^ := Fields[f]^.PropType^^.EnumBaseType;
            sftSet:
              EnumTypeInfo^ := Fields[f]^.PropType^^.SetEnumType;
            else
              EnumTypeInfo^ := nil;
          end;
      end;
    end;
end;

function FieldPropFromTables(const Tables: TClasses; const PropName: ShortString;
  EnumTypeInfo: PPointer; out TableIndex: integer): TSQLFieldType;
var SubClass,
    SubProp: shortstring;
    i,t: integer;
begin
  TableIndex := -1;
  if length(Tables)=1 then begin
    result := FieldPropFromTable(TSQLRecordClass(Tables[0]),PropName,EnumTypeInfo);
    if result<>sftUnknown then
      TableIndex := 0;
  end else begin
    i := ord(PropName[0]); // fast i := Pos('.',PropName) which Delphi 2009+ don't like
    while i>0 do 
      if PropName[i]='.' then
        break else
        dec(i);
    if i=0 then begin
      // no 'ClassName.PropertyName' format: find first exact property name
      for t := 0 to high(Tables) do begin
        result := FieldPropFromTable(TSQLRecordClass(Tables[t]),PropName,EnumTypeInfo);
        if result<>sftUnknown then begin
          TableIndex := t;
          exit;
        end;
      end;
    end else begin
      // we expect property names as 'ClassName.PropertyName'
      dec(i);
      SubClass[0] := AnsiChar(i);
      move(PropName[1],SubClass[1],i); // get class name into SubClass
      SubProp := copy(PropName,i+1,255); // extract property name
      for t := 0 to high(Tables) do
        if Tables[t]<>nil then // avoid GPF
        if IdemPropName( // found class?
          // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
          // vmtClassName = UTF-8 encoded text stored in a shortstring = -44
          PShortString(PPointer(PtrInt(Tables[t])+vmtClassName)^)^, SubClass) then begin
        //if Tables[t].ClassNameIs(SubClass) then begin // not Delphi 2009 OK
          TableIndex := t;
          result := FieldPropFromTable(TSQLRecordClass(Tables[t]),SubProp,EnumTypeInfo); // get property type
          exit;
        end;
    end;
    result := sftUnknown;
  end;
end;

procedure TSQLTable.InitFieldTypes;
var f,i: integer;
    T: TSQLFieldType;
    P: pointer;
    TableInd: integer;
begin
  SetLength(fFieldType,FieldCount);
  for f := 0 to FieldCount-1 do begin
    P := nil;
    // init fFieldType[] from fQueryTables[] and the field names in fResults[]
    if Assigned(QueryTables) then
      T := FieldPropFromTables(QueryTables,fResults[f],@P,TableInd) else begin
      TableInd := -1;
      T := sftUnknown;
    end;
    if T=sftUnknown then
      // not found from fQueryTables[]: get from content
      if IsRowID(fResults[f]) then
        T := sftInteger else
      for i := 1 to RowCount do begin
        T := UTF8ContentType(fResults[i*FieldCount+f]);
        if T<>sftUnknown then begin
          if (T in [sftInteger,sftFloat]) and (f in fFieldParsedAsString) then
            T := sftUTF8Text else // force string value not to be a number
          if T=sftInteger then
            T := sftCurrency; // we only checked the first field... best guess...
          break; // get first non null field content
        end;
      end;
    with fFieldType[f] do begin
      TableIndex := TableInd;
      ContentType := T;
      EnumTypeInfo := P;
    end;
  end;
end;

function TSQLTable.FieldType(Field: integer; EnumTypeInfo: PPointer): TSQLFieldType;
begin
  if (self<>nil) and (cardinal(Field)<cardinal(FieldCount)) then begin
    if not Assigned(fFieldType) then
      InitFieldTypes;
    result := fFieldType[Field].ContentType;
    if EnumTypeInfo<>nil then
      EnumTypeInfo^ := fFieldType[Field].EnumTypeInfo;
  end else
    result := sftUnknown;
end;

function TSQLTable.Get(Row, Field: integer): PUTF8Char;
const PCharNil: integer = 0;
begin
  if (self=nil) or (fResults=nil) or (cardinal(Row)>cardinal(RowCount)) or
     (cardinal(Field)>=cardinal(FieldCount)) then // cardinal() -> test <0
    result := @PCharNil else
    result := fResults[Row*FieldCount+Field];
end;

function TSQLTable.GetU(Row,Field: integer): RawUTF8;
var P: PUTF8Char;
begin
  if (self=nil) or (fResults=nil) or (cardinal(Row)>cardinal(RowCount)) or
     (cardinal(Field)>=cardinal(FieldCount)) then // cardinal() -> test <0
    result := '' else begin
    P := fResults[Row*FieldCount+Field];
    SetString(Result,PAnsiChar(P),StrLen(P));
  end;
end;

function TSQLTable.GetA(Row, Field: integer): WinAnsiString;
begin
  result := Utf8ToWinAnsi(Get(Row,Field));
end;

function TSQLTable.GetAsInteger(Row, Field: integer): integer;
begin
  result := GetInteger(Get(Row,Field));
end;

function TSQLTable.GetS(Row, Field: integer): shortstring;
begin
  UTF8ToShortString(result,Get(Row,Field));
end;

function TSQLTable.GetString(Row, Field: integer): string;
var U: PUTF8Char;
begin
  U := Get(Row,Field);
  {$ifdef UNICODE}
  result := UTF8DecodeToUnicodeString(U,0); // L=0 -> use StrLen
  {$else}
  result := CurrentAnsiConvert.UTF8BufferToAnsi(U,StrLen(U));
  {$endif}
end;

function TSQLTable.GetCaption(Row, Field: integer): string;
begin
  GetCaptionFromPCharLen(Get(Row,Field),result);
end;

function BlobToTSQLRawBlob(P: PUTF8Char): TSQLRawBlob;
var Len, LenHex: integer;
begin
  result := '';
  Len := StrLen(P);
  if Len=0 then
    exit;
  if (P[0] in ['x','X']) and (P[1]='''') and (P[Len-1]='''') then begin
    // BLOB literals are string literals containing hexadecimal data and
    // preceded by a single "x" or "X" character. For example: X'53514C697465'
    LenHex := (Len-3) shr 1;
    SetLength(result,LenHex);
    if HexToBin(@P[2],pointer(result),LenHex) then
      exit; // valid hexa data
  end else
  if (PInteger(P)^ and $00ffffff=JSON_BASE64_MAGIC) and IsBase64(@P[3],Len-3) then begin
    // Base-64 encoded content ('\uFFF0base64encodedbinary')
    result := Base64ToBin(@P[3],Len-3);
    exit;
  end;
  // TEXT format
  SetString(result,PAnsiChar(P),Len);
end;

function BlobToStream(P: PUTF8Char): TStream;
begin
  Result := TRawByteStringStream.Create(BlobToTSQLRawBlob(P));
end;

function BlobToBytes(P: PUTF8Char): TBytes;
var Len, LenResult: integer;
begin
  result := nil;
  Len := StrLen(P);
  if Len=0 then
    exit;
  if (P[0] in ['x','X']) and (P[1]='''') and (P[Len-1]='''') then begin
    // BLOB literals format
    LenResult := (Len-3)shr 1;
    SetLength(Result,LenResult);
    if HexToBin(@P[2],pointer(Result),LenResult) then
      exit; // valid hexa data
  end else
  if (PInteger(P)^ and $00ffffff=JSON_BASE64_MAGIC) and IsBase64(@P[3],Len-3) then begin
    // Base-64 encoded content ('\uFFF0base64encodedbinary')
    inc(P,3);
    dec(Len,3);
    LenResult := Base64ToBinLength(pointer(P),len);
    SetLength(Result,LenResult);
    if LenResult>0 then
      Base64Decode(pointer(P),pointer(Result),Len shr 2);
    exit;
  end;
  // TEXT format
  SetLength(Result,Len);
  Move(P^,pointer(Result)^,Len);
end;

function TSQLRawBlobToBlob(const RawBlob: TSQLRawBlob): RawUTF8;
// BLOB literals are string literals containing hexadecimal data and
//  preceded by a single "x" or "X" character. For example: X'53514C697465'
begin
  result := TSQLRawBlobToBlob(pointer(RawBlob),length(RawBlob));
end;

function TSQLRawBlobToBlob(RawBlob: pointer; RawBlobLength: integer): RawUTF8; overload;
// BLOB literals are string literals containing hexadecimal data and
//  preceded by a single "x" or "X" character. For example: X'53514C697465'
var P: PAnsiChar;
begin
  result := '';
  if RawBlobLength<>0 then begin
    SetLength(result,RawBlobLength*2+3);
{$ifdef UNICODE2} // not needed: SetLength() did already set the codepage
    PWord(PtrUInt(result)-12)^ := CP_UTF8; // use only SetLength() -> force set code page
{$endif}
    P := pointer(result);
    P[0] := 'X';
    P[1] := '''';
    BinToHex(RawBlob,P+2,RawBlobLength);
    P[RawBlobLength*2+2] := '''';
  end;
end;

function isBlobHex(P: PUTF8Char): boolean;
// BLOB literals are string literals containing hexadecimal data and
// preceded by a single "x" or "X" character. For example: X'53514C697465'
var Len: integer;
begin
  if P=nil then begin
    result := false;
    exit;
  end;
  while P=' ' do inc(P);
  if (P[0] in ['x','X']) and (P[1]='''') then begin
    Len := (StrLen(P)-3) shr 1;
    result := (P[Len-1]='''') and HexToBin(@P[2],nil,Len);
    exit;
  end else begin
    result := false;
    exit;
  end;
end;

function TSQLTable.GetBlob(Row, Field: integer): TSQLRawBlob;
begin
  result := BlobToTSQLRawBlob(Get(Row,Field));
end;

function TSQLTable.GetBytes(Row,Field: integer): TBytes;
begin
  result := BlobToBytes(Get(Row,Field));
end;

function TSQLTable.GetStream(Row,Field: integer): TStream;
begin
  result := BlobToStream(Get(Row,Field));
end;

{$ifdef PUREPASCAL} 
function TSQLTable.GetDateTime(Row, Field: integer): TDateTime;
begin
  result := Iso8601ToDateTimePUTF8Char(Get(Row,Field),0)
end;
{$else}
function TSQLTable.GetDateTime(Row, Field: integer): TDateTime;
asm
  call TSQLTable.Get
  xor edx,edx // L=0 -> will call strlen()
  jmp Iso8601ToDateTimePUTF8Char
end;
{$endif}

procedure TSQLTable.GetRowValues(Field: integer; out Values: TRawUTF8DynArray);
var i: integer;
    U: PPUTF8Char;
begin
  Finalize(Values);
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) then
    exit;
  SetLength(Values,RowCount);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 0 to RowCount-1 do begin
    SetString(Values[i],PAnsiChar(U^),StrLen(U^));
    inc(U,FieldCount); // go to next row
  end;
end;

procedure TSQLTable.GetRowValues(Field: integer; out Values: TIntegerDynArray);
var i: integer;
    U: PPUTF8Char;
begin
  Finalize(Values);
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) then
    exit;
  SetLength(Values,RowCount);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 0 to RowCount-1 do begin
    Values[i] := GetInteger(U^);
    inc(U,FieldCount); // go to next row
  end;
end;

function TSQLTable.GetRowValues(Field: integer; Sep: AnsiChar): RawUTF8;
var i, L: integer;
    U: PPUTF8Char;
    P: PUTF8Char;
begin
  result := '';
  if (self=nil) or (cardinal(Field)>cardinal(FieldCount)) or (RowCount=0) then
    exit;
  L := 0;
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 1 to RowCount do begin
    inc(L,StrLen(U^)+1);
    inc(U,FieldCount); // go to next row
  end;
  if L=0 then
    exit;
  SetLength(result,L-1); // L-1 = don't add a last ','
  P := pointer(result);
  U := @fResults[FieldCount+Field]; // start reading after first Row (= Field Names)
  for i := 1 to RowCount do begin
    L := StrLen(U^);
    move(U^^,P^,L);
    if i=RowCount then // don't add a last ','
      break;
    P[L] := Sep;
    inc(P,L+1);
    inc(U,FieldCount); // go to next row
  end;
end;

procedure TSQLTable.GetJSONValues(JSON: TStream; Expand: boolean;
  RowFirst: integer=0; RowLast: integer=0);
var W: TJSONWriter;
    F,R: integer;
    U: PPUTF8Char;
begin
  W := TJSONWriter.Create(JSON,Expand,false);
  try
    if (self=nil) or (FieldCount<=0) or (RowCount<=0) then begin
      W.CancelAllVoid;
      exit;
    end;
    // check range
    if RowLast=0 then
      RowLast := RowCount else
    if RowLast>RowCount then
      RowLast := RowCount;
    if RowFirst<=0 then 
      RowFirst := 1; // start reading after first Row (Row 0 = Field Names)
    // get col names and types
    SetLength(W.ColNames,FieldCount);
    for F := 0 to FieldCount-1 do
      W.ColNames[F] := fResults[F]; // first Row is field Names
    W.AddColumns(RowLast-RowFirst+1); // write or init field names (see JSON Expand)
    if Expand then
      W.Add('[');
    // write rows data
    U := @fResults[FieldCount*RowFirst];
    for R := RowFirst to RowLast do begin
      if Expand then
        W.Add('{');
      for F := 0 to FieldCount-1 do begin
        if Expand then
          W.AddString(W.ColNames[F]); // '"'+ColNames[]+'":'
        if U^=nil then
          W.AddShort('null') else
        if IsStringJSON(U^) then begin
          // IsStringJSON() is fast and safe: no need to guess exact value type
          W.Add('"');
          W.AddJSONEscape(U^,0);
          W.Add('"');
        end else
          W.AddNoJSONEscape(U^,0);
        W.Add(',');
        inc(U); // points to next value
      end;
      W.CancelLastComma; // cancel last ','
      if Expand then begin
        W.Add('}',',');
        if R<>RowLast then
          W.AddCR; // make expanded json more human readable
      end else
        W.Add(',');
    end;
    W.CancelLastComma; // cancel last ','
    W.Add(']');
    if not Expand then
      W.Add('}');
    W.Add(#10);
    W.Flush;
  finally
    W.Free;
  end;
end;

procedure TSQLTable.GetCSVValues(Dest: TStream; Tab: boolean; CommaSep: AnsiChar=',';
  AddBOM: boolean=false);
var U: PPUTF8Char;
    F,R,FMax: integer;
    W: TTextWriter;
begin
  if (self=nil) or (FieldCount<=0) or (RowCount<=0) then
    exit;
  W := TTextWriter.Create(Dest,8196);
  try
    if AddBOM then
      W.AddShort(#$ef#$bb#$bf); // add UTF-8 Byte Order Mark
    if Tab then
      CommaSep := #9;
    FMax := FieldCount-1;
    U := pointer(fResults);
    for R := 0 to RowCount do
      for F := 0 to FMax do begin
        if Tab or (not IsStringJSON(U^)) then
          W.AddNoJSONEscape(U^) else begin
          W.Add('"');
          W.AddNoJSONEscape(U^);
          W.Add('"');
        end;
        if F=FMax then
          W.AddCR else
          W.Add(CommaSep);
        inc(U); // points to next value
      end;
    W.Flush;
  finally
    W.Free;
  end;
end;

function TSQLTable.GetJSONValues(Expand: boolean): RawUTF8;
var MS: TRawByteStringStream;
begin
  MS := TRawByteStringStream.Create;
  try
    GetJSONValues(MS,Expand); // create JSON data in MS
    result := MS.DataString;
  finally
    MS.Free;
  end;
end;

function TSQLTable.GetW(Row, Field: integer): RawUnicode;
begin
  result := UTF8DecodeToRawUnicode(Get(Row,Field),0);
end;

function TSQLTable.GetWP(Row, Field: integer; Dest: PWideChar; MaxDestChars: cardinal): integer;
var P: PUTF8Char;
begin
  P := Get(Row,Field);
  result := UTF8ToWideChar(Dest,P,MaxDestChars,StrLen(P)) shr 1; // bytes div 2
end;

function TSQLTable.LengthW(Row, Field: integer): integer;
begin // nil -> fast calculate unicode length, without any memory allocation
  result := Utf8ToUnicodeLength(Get(Row,Field));
end;

function UTF8CompareCurr64(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64;
begin // faster than UTF8CompareDouble() for pure decimal (no exponent) values
  V1 := StrToCurr64(P1);
  V2 := StrToCurr64(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareBoolean(P1,P2: PUTF8Char): PtrInt;
label Z,P,N;
begin // assume 0 is FALSE, anything else is true
  if P1=P2  then goto Z else
  if P1=nil then goto P else
  if P2=nil then goto N else
  if (P1^=#0) or (PWord(P1)^=ord('0')) then
    if (P2^=#0) or (PWord(P2)^=ord('0')) then begin
Z:    result := 0;  // P1=false P2=false
      exit;
    end else begin
N:    result := -1; // P1=false P2=true
      exit;
    end else
    if (P2^<>#0) and (PWord(P2)^<>ord('0')) then
      goto Z        // P1=true P2=true
    else begin
P:    result := 1;  // P1=true P2=false
      exit;
    end;
end;

function UTF8CompareInt32(P1,P2: PUTF8Char): PtrInt;
var V1,V2: PtrInt;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetInteger(P1);
  V2 := GetInteger(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareUInt32(P1,P2: PUTF8Char): PtrInt;
var V1,V2: PtrUInt;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetCardinal(P1);
  V2 := GetCardinal(P2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareRecord(P1,P2: PUTF8Char): PtrInt;
var V1,V2,T1,T2: PtrUInt;
label er;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := GetCardinal(P1);
  V2 := GetCardinal(P2);
  if V1=V2 then
    result := 0 else begin
    // special RecordRef / TRecordReference INTEGER sort
    T1 := V1 and 63;  // first sort by Table order
    T2 := V2 and 63;
    if T1<T2 then
      result := -1 else
      if T1>T2 then
        result := +1 else
        // we have T1=T2 -> same Table -> sort by ID
        if V1<V2 then
          result := -1 else
          if V1=V2 then
            result := 0 else
            result := +1;
  end;
end;

function UTF8CompareInt64(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  SetInt64(P1,V1);
  SetInt64(P2,V2);
  if V1<V2 then
    result := -1 else
    if V1=V2 then
      result := 0 else
      result := +1;
end;

function UTF8CompareDouble(P1,P2: PUTF8Char): PtrInt;
var V1,V2: extended;
    Err: integer;
label er;
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  v1 := GetExtended(P1,Err);
  if Err<>0 then begin
er: result := UTF8IComp(P1,P2);
    exit;
  end;
  V2 := GetExtended(P2,Err);
  if Err<>0 then goto er;
  if V1<V2 then // we don't care about exact = for a sort: Epsilon check is slow
    result := -1 else
    result := +1;
end;

function UTF8CompareISO8601(P1,P2: PUTF8Char): PtrInt;
var V1,V2: Int64; // faster than Iso8601ToDateTimePUTF8Char: uses integer math
begin
  if P1=P2 then begin
    result := 0;
    exit;
  end;
  V1 := Iso8601ToSecondsPUTF8Char(P1,0);
  V2 := Iso8601ToSecondsPUTF8Char(P2,0);
  if (V1=0) or (V2=0) then // any invalid date -> compare as strings
    result := UTF8IComp(P1,P2) else
    if V1<V2 then
      result := -1 else
      if V1=V2 then
        result := 0 else
        result := +1;
end;

var
  /// simple wrapper to UTF-8 compare function for the SQLite3 field datatypes
  // - used internaly for field sorting (see TSQLTable.SortFields() method)
  // and for default User Interface Query (see TSQLRest.QueryIsTrue() method)
  SQLFieldTypeComp: array[TSQLFieldType] of TUTF8Compare  =
   (nil,                  // unknown
    nil,    // AnsiText will be set to AnsiIComp in initialization block below
{$ifdef USENORMTOUPPER}
    UTF8IComp,           // UTF8Text, 8 bits case insensitive compared
{$else}
    nil,    // UTF8Text will be set to AnsiIComp in initialization block below
{$endif}
    UTF8CompareUInt32,   // Enumerate
    UTF8CompareUInt32,   // Set
    UTF8CompareInt64,    // Integer
    UTF8CompareUInt32,   // ID
    UTF8CompareRecord,   // Record
    UTF8CompareBoolean,  // Boolean
    UTF8CompareDouble,   // Float
    UTF8CompareISO8601,  // DateTime
    UTF8CompareInt64,    // TimeLog
    UTF8CompareCurr64,   // Currency
    UTF8IComp,           // Object (TEXT serialization)
    nil,                 // Blob
    nil,                 // BlobDynArray
{$ifdef PUBLISHRECORD}
    nil,                 // BlobRecord
{$endif PUBLISHRECORD}
    nil,
    UTF8CompareInt64,    // ModTime
    UTF8CompareInt64);   // CreateTime

type
  /// a static object is used for smaller recursive stack size and faster code
  // - these special sort implementation do the comparaison first by the
  // designed field, and, if the field value is identical, the ID value is
  // used (it will therefore sort by time all identical values)
  // - code generated is very optimized: stack and memory usage, CPU registers
  // prefered, multiplication avoided to calculate memory position from index,
  // hand tuned assembler...
  TUTF8QuickSort = {$ifndef UNICODE}object{$else}record{$endif}
  public
    // sort parameters
    fComp: TUTF8Compare;
    Results: PPUtf8CharArray;
    IDColumn: PPUtf8CharArray;
    Params: TSQLTableSortParams;
    CurrentRow: integer;
    // used to avoid multiplications to calculate data memory position from index
    // - CPU64 ready
    FieldCountNextPtr, FieldIndexNextPtr: PtrInt;
    // temp vars (avoid stack usage):
    PID: Integer;
    PP, CI, CJ: PPUTF8Char;
    I, J: PtrInt;
{$ifdef PUREPASCAL}
    Tmp: PUTF8Char;
{$endif}
    /// recursively perform the sort
    procedure QuickSort(L, R: Integer);
    /// compare value at index I with pivot value
    // - sort by ID if values are identical
    function CompI: integer;
    /// compare value at index J with pivot value
    // - sort by ID if values are identical
    function CompJ: integer;
    /// set the pivot value
    procedure SetPP(aPP: PPUTF8Char; aP: PtrInt);
  end;

procedure TUTF8QuickSort.SetPP(aPP: PPUTF8Char; aP: PtrInt);
begin
  PP := aPP;
  // PID must be updated every time PP is modified
  if Assigned(IDColumn) then
    PID := GetInteger(IDColumn[aP]) else
    PID := GetInteger(PPUTF8Char(PtrInt(aPP)-FieldIndexNextPtr)^);
end;

function TUTF8QuickSort.CompI: integer;
begin
  result := fComp(CI^,PP^);
  if result=0 then
    // same value -> sort by ID
    if Assigned(IDColumn) then
      result := GetInteger(IDColumn[I])-PID else
      result := GetInteger(PPUTF8Char(PtrInt(CI)-FieldIndexNextPtr)^)-PID;
end;

function TUTF8QuickSort.CompJ: integer;
begin
  result := fComp(CJ^,PP^);
  if result=0 then
    // same value -> sort by ID
    if Assigned(IDColumn) then
      result := GetInteger(IDColumn[J])-PID else
      result := GetInteger(PPUTF8Char(PtrInt(CJ)-FieldIndexNextPtr)^)-PID;
end;

procedure TUTF8QuickSort.QuickSort(L, R: Integer);
// code below is very fast and optimized
procedure Exchg(P1,P2: PtrUInt; FieldCount: integer); // full row exchange
{$ifdef PUREPASCAL}  // CPU64 will call this version e.g.
var B: PtrUInt;
    i: PtrUInt;
begin
  for i := 1 to FieldCount do begin
    B := PPtrUInt(P1)^;
    PPtrUInt(P1)^ := PPtrUInt(P2)^;
    PPtrUInt(P2)^ := B;
    inc(PPtrUInt(P1));
    inc(PPtrUInt(P2));
  end;
end;
{$else}
asm // eax=P1 edx=P2 ecx=FieldCount
    push esi
    push edi
@1: dec ecx
    mov esi,[eax]
    mov edi,[edx]
    mov [edx],esi
    mov [eax],edi
    lea eax,[eax+4]
    lea edx,[edx+4]
    jnz @1
    pop edi
    pop esi
end;
procedure Exchg32(P: pointer; I,J: integer);
asm // eax=P edx=I ecx=J
  push ebx
  lea edx,[eax+edx*4]
  lea ecx,[eax+ecx*4]
  mov eax,[edx]
  mov ebx,[ecx]
  mov [ecx],eax
  mov [edx],ebx
  pop ebx
end;
{$endif}
var P: PtrInt;
begin
  if @fComp<>nil then
  repeat
    I := L;
    CI := @Results[I*Params.FieldCount+Params.FieldIndex];
    J := R;
    CJ := @Results[J*Params.FieldCount+Params.FieldIndex];
    P := ((I+J) shr 1);
    SetPP(@Results[P*Params.FieldCount+Params.FieldIndex],P);
    repeat
      // this loop has no multiplication -> most of the time is spent in comp()
      if Params.Asc then begin // ascending order comparaison
        while compI<0 do begin
          inc(I);
          inc(PtrInt(CI),FieldCountNextPtr); // next row
        end;
        while compJ>0 do begin
          dec(J);
          dec(PtrInt(CJ),FieldCountNextPtr); // previous row
        end;
      end else begin // descending order comparaison
        while compI>0 do begin
          inc(I);
          inc(PtrInt(CI),FieldCountNextPtr); // next row
        end;
        while compJ<0 do begin
          dec(J);
          dec(PtrInt(CJ),FieldCountNextPtr); // previous row
        end;
      end;
      if I<=J then begin
        if I<>J then begin // swap elements
          if CurrentRow=J then // update current row number
            CurrentRow := I else
          if CurrentRow=I then
            CurrentRow := J;
          Exchg(PtrInt(CI)-FieldIndexNextPtr,PtrInt(CJ)-FieldIndexNextPtr,
            Params.FieldCount); // exchange PUTF8Char for whole I,J rows
          if Assigned(IDColumn) then begin // update hidden ID column also
          {$ifdef PUREPASCAL}
            Tmp := IDColumn[I];
            IDColumn[I] := IDColumn[J];
            IDColumn[J] := Tmp;
          {$else}
            Exchg32(IDColumn,I,J);
          {$endif}
          end;
        end;
        if PP=CI then
          SetPP(CJ,J) else
        if PP=CJ then
          SetPP(CI,I);
        inc(I);
        dec(J);
        inc(PtrInt(CI),FieldCountNextPtr);
        dec(PtrInt(CJ),FieldCountNextPtr);
      end else
        break;
    until I>J;
    P := I; // save I which will be overwritten by QuickSort() below
    if L<J then
      QuickSort(L, J);
    I := P;
    L := P;
  until I>=R;
end;

procedure TSQLTable.SortFields(Field: integer; Asc: boolean=true;
      PCurrentRow: PInteger=nil; FieldType: TSQLFieldType=sftUnknown);
var Sort: TUTF8QuickSort; // fast static object for sorting
begin
  if FieldType=sftUnknown then // guess the field type from first row
    FieldType := self.FieldType(Field,nil);
  Sort.fComp := SQLFieldTypeComp[FieldType];
  if (@Sort.fComp=nil) or (FieldCount=0) then exit;
  // store sorting parameters for resort in TSQLTableJSON.FillFrom()
  fSortParams.FieldType := FieldType;
  fSortParams.FieldCount := FieldCount;
  fSortParams.FieldIndex := Field;
  fSortParams.Asc := Asc;
  // this sort routine is very fast, thanks to the dedicated static object
  Sort.Params := fSortParams;
  Sort.Results := fResults;
  Sort.IDColumn := @fIDColumn[0];
  Sort.FieldCountNextPtr := FieldCount*sizeof(PtrInt);
  Sort.FieldIndexNextPtr := Field*sizeof(PtrInt);
  if PCurrentRow=nil then
    Sort.CurrentRow := -1 else
    Sort.CurrentRow := PCurrentRow^;
  if RowCount>1 then
    Sort.QuickSort(1,RowCount); // ignore first row = field names -> (1,RowCount)
  if PCurrentRow<>nil then
    PCurrentRow^ := Sort.CurrentRow;
end;

function TSQLTable.SortCompare(Field: integer): TUTF8Compare;
begin
  result := SQLFieldTypeComp[FieldType(Field,nil)];
end;

procedure TSQLTable.Assign(source: TSQLTable);
begin
  fResults := source.fResults;
  fRowCount := source.fRowCount;
  fFieldCount := source.fFieldCount;
end;

constructor TSQLTable.Create(const Tables: array of TClass; const aSQL: RawUTF8);
var n: integer;
begin
  inherited Create;
  n := length(Tables);
  if n>0 then begin
    SetLength(fQueryTables,n);
    move(Tables[0],fQueryTables[0],n*sizeof(TClass));
  end;
  fQuerySQL := aSQL;
end;

destructor TSQLTable.Destroy;
begin
  fOwnedRecords.Free;
  inherited;
end;

function TSQLTable.QueryRecordType: TClass;
begin
  if (self<>nil) and (pointer(fQueryTables)<>nil) then
      result := fQueryTables[0] else
      result := nil;
end;

function TSQLTable.NewRecord(RecordType: TClass=nil): TObject;
begin
  result := nil;
  if self=nil then exit;
  if RecordType=nil then begin
    RecordType := QueryRecordType;
    if RecordType=nil then exit;
  end;
  result := RecordType.Create;
  if fOwnedRecords=nil then
    fOwnedRecords := TObjectList.Create;
  fOwnedRecords.Add(result);
end;

function TSQLTable.CalculateFieldLengthMean(var aResult: TIntegerDynArray;
  FromDisplay: boolean=false): integer;
procedure CalculateEnumerates(F: integer; P: PEnumType);
var R, i, n: integer;
    EnumCounts: array of integer; // slow GetCaption() will be called once
    U: PPUTF8Char;
begin
  if P=nil then
    exit; // no a true enumerate field
  // 1. count of every possible enumerated value into EnumCounts[]
  SetLength(EnumCounts,P^.MaxValue+1); // EnumCounts[] := 0
  U := @fResults[FieldCount+F]; // start reading after first Row (= Field Names)
  for R := 1 to RowCount do begin
    n := GetInteger(U^);
    if n<=P^.MaxValue then // update count of every enumerated value
      inc(EnumCounts[n]) else
      inc(EnumCounts[0]); // GetCaption(invalid index) displays first one
    inc(U,FieldCount); // points to next row
  end;
  // 2. update aResult[F] with displayed caption text length
  n := 0;
  for i := 0 to P^.MaxValue do
    if EnumCounts[i]<>0 then
      inc(n,length(P^.GetCaption(i))*EnumCounts[i]);
  aResult[F] := n; // store displayed total length
end;
var R,F,n: integer;
    U: PPUTF8Char;
    Tot: cardinal;
begin
  SetLength(aResult,FieldCount);
  if FromDisplay and (length(fFieldLengthMean)=FieldCount) then begin
    move(fFieldLengthMean[0],aResult[0],FieldCount*4);
    result := fFieldLengthMeanSum;
    exit;
  end;
  if RowCount=0 then begin
    // no data: calculate field length from first row (i.e. Field Names)
    U := @fResults[0];
    for F := 0 to FieldCount-1 do begin
      inc(aResult[F],Utf8FirstLineToUnicodeLength(U^));  // count
      inc(U); // points to next value
    end;
    Tot := 1;
  end else begin
    if not Assigned(fFieldType) then
      InitFieldTypes;
    U := @fResults[FieldCount]; // start reading after first Row
    for R := 1 to RowCount do // sum all lengths by field
      for F := 0 to FieldCount-1 do begin
        case fFieldType[F].ContentType of
        sftInteger, sftBlob,  sftRecord, sftID, sftSet, sftCurrency:
          inc(aResult[F],8);
        else inc(aResult[F],Utf8FirstLineToUnicodeLength(U^));
        end;
        inc(U); // points to next value
      end;
    if Assigned(fQueryTables) then begin
      // aResult[] must be recalculated from captions, if exists
      for F := 0 to FieldCount-1 do
      with fFieldType[F] do
        case ContentType of
        sftEnumerate:
          CalculateEnumerates(F,EnumTypeInfo);
        end;
    end;
    Tot := RowCount;
  end;
  result := 0;
  for F := 0 to FieldCount-1 do begin
    n := cardinal(aResult[F]) div Tot; // Mean = total/count
    if n=0 then n := 1;  // none should be 0
    aResult[F] := n;
    inc(result,n); // fast calculate mean sum
  end;
end;

function TSQLTable.FieldLengthMean(Field: integer): cardinal;
begin
  if (self=nil) or (cardinal(Field)>=cardinal(FieldCount)) or (fResults=nil) then
    result := 0 else begin
    if fFieldLengthMean=nil then
      // if not already calculated, do it now
      fFieldLengthMeanSum := CalculateFieldLengthMean(fFieldLengthMean);
    result := fFieldLengthMean[Field];
  end;
end;

function TSQLTable.FieldLengthMeanSum: cardinal;
begin
  if self=nil then
    result := 0 else begin
    if fFieldLengthMean=nil then
      FieldLengthMean(0); // initialize fFieldLengthMean[] and fFieldLengthMeanSum
    result := fFieldLengthMeanSum;
  end;
end;

function TSQLTable.FieldLengthMax(Field: integer; NeverReturnsZero: boolean): cardinal;
var i: integer;
    len: cardinal;
    U: PPUTF8Char;
begin
  result := 0;
  if (self<>nil) and (cardinal(Field)<cardinal(FieldCount)) then begin
    U := @fResults[FieldCount+Field]; // start reading after first Row
    for i := 1 to RowCount do begin
      len := StrLen(U^);
      if len>result then
        result := len;
      inc(U,FieldCount);
    end;
  end;
  if (result=0) and NeverReturnsZero then
    result := 1; // minimal not null length
end;

function TSQLTable.FieldTable(Field: integer): TClass;
begin
  if (self=nil) or (cardinal(Field)>=cardinal(FieldCount)) or (fQueryTables=nil) then
    result := nil else begin
    if not Assigned(fFieldType) then
       InitFieldTypes;
    Field := fFieldType[Field].TableIndex;
    if Field<0 then
      result := nil else
      result := fQueryTables[Field];
  end;
end;

procedure TSQLTable.SetFieldLengthMean(const Lengths: array of cardinal);
var F: integer;
    n: cardinal;
begin
  if (self=nil) or (length(Lengths)<>FieldCount) then
    exit;
  if fFieldLengthMean=nil then // if not already calculated, allocate array
    SetLength(fFieldLengthMean,FieldCount);
  fFieldLengthMeanSum := 0;
  for F := 0 to FieldCount-1 do begin
    n := Lengths[F];
    if n=0 then n := 1;  // none should be 0
    fFieldLengthMean[F] := n;
    inc(fFieldLengthMeanSum,n); // fast calculate mean sum
  end;
end;

procedure TSQLTable.FieldLengthMeanIncrease(aField, aIncrease: integer);
begin
  if (self=nil) or (cardinal(aField)>=cardinal(FieldCount)) then
    exit; // avoid GPF
  if fFieldLengthMean=nil then
    FieldLengthMean(0); // initialize fFieldLengthMean[] and fFieldLengthMeanSum
  inc(fFieldLengthMean[aField],aIncrease);
  inc(fFieldLengthMeanSum,aIncrease);
end;

function TSQLTable.SearchValue(const aUpperValue: RawUTF8;
  StartRow, FieldIndex: integer; Client: TObject; Lang: TSynSoundExPronunciation;
  UnicodeComparison: boolean): integer;
var U: PPUTF8Char;
    Kind: TSQLFieldType;
    Search: PAnsiChar;
    UpperUnicode: RawUnicode;
    UpperUnicodeLen: integer;
    EnumType: PEnumType;
    Value, err: integer;
    TimeLog: Int64;
    EnumValue: RawUTF8;
    s: string;
    P: PShortString;
    EnumValues: set of 0..63;
    Soundex: TSynSoundEx;
    CL: TSQLRest absolute Client;
    tmp: array[0..23] of AnsiChar;
begin
  result := 0;
  if (StartRow<=0) or (StartRow>RowCount) or (aUpperValue='') or
     (cardinal(FieldIndex)>=cardinal(FieldCount)) then
    exit;
  Search := pointer(aUpperValue);
  if Search^='%' then begin
    inc(Search);
    if Search^='%' then begin
      inc(Search);
      if Search^='%' then begin
        inc(Search);
        Lang := sndxSpanish;
      end else
        Lang := sndxFrench;
    end else
      Lang := sndxEnglish;
  end;
  if ((Lang<>sndxNone) and not Soundex.Prepare(Search,Lang)) then
    exit;
  result := StartRow;
  Kind := FieldType(FieldIndex,@EnumType);
  U := @fResults[FieldCount*StartRow+FieldIndex];
  // search in one specified field value
  if (Kind=sftEnumerate) and (EnumType<>nil) then begin
    // for enumerates: first search in all available values
    Int64(EnumValues) := 0;
    P := @EnumType^.NameList;
    for Value := 0 to EnumType^.MaxValue do begin
      EnumValue := TrimLeftLowerCase(P);
      GetCaptionFromPCharLen(pointer(EnumValue),s);
      EnumValue := StringToUTF8(s);
      if ((Lang<>sndxNone) and SoundEx.UTF8(pointer(EnumValue))) or
         ((Lang=sndxNone) and FindUTF8(pointer(EnumValue),Search)) then 
        include(EnumValues,Value);
      inc(PtrUInt(P),ord(P^[0])+1);
    end;
    // then search directly from the INTEGER value
    if Int64(EnumValues)<>0 then
    while cardinal(result)<=cardinal(RowCount) do begin
      Value := GetInteger(U^,err);
      if (err=0) and (Value in EnumValues) then
        exit; // we found a matching field
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
    result := 0; // not found
    exit;
  end;
  // special cases: conversion from INTEGER to text before search
  if Kind in [sftTimeLog,sftModTime,sftCreateTime] then
    while cardinal(result)<=cardinal(RowCount) do begin
      SetInt64(U^,TimeLog);
      if TimeLog<>0 then begin
        tmp[Iso8601(TimeLog).Text(tmp,true,' ')] := #0;
        if FindAnsi(tmp,Search) then
          exit;
      end;
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  else
  if ((Kind in [sftRecord,sftID]) and
     (Client<>nil) and Client.InheritsFrom(TSQLRest) and (CL.Model<>nil)) then
    while cardinal(result)<=cardinal(RowCount) do begin
      Value := GetInteger(U^);
      if Value<>0 then begin
        if Kind=sftRecord then
          EnumValue := RecordRef(Value).Text(CL.Model) else
          EnumValue := U^; // sftID -> display ID number -> no sounded
        if Lang=sndxNone then begin
          if FindUTF8(pointer(EnumValue),Search) then exit;
        end else
          if SoundEx.UTF8(pointer(EnumValue)) then exit;
      end;
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  else
  // by default, search as UTF-8 encoded text
  if Lang<>sndxNone then begin
    while cardinal(result)<=cardinal(RowCount) do
    if SoundEx.UTF8(U^) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
  end else
  if UnicodeComparison then begin
    // slowest but always accurate Unicode comparison
    UpperUnicode := UTF8DecodeToRawUnicodeUI(RawUTF8(Search),@UpperUnicodeLen);
    while cardinal(result)<=cardinal(RowCount) do
    if FindUnicode(pointer(Utf8DecodeToRawUnicode(U^,0)),
       pointer(UpperUnicode),UpperUnicodeLen) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end
  end else
    // default fast Win1252 search
    while cardinal(result)<=cardinal(RowCount) do
    if FindUTF8(U^,Search) then
      exit else begin
      inc(U,FieldCount); // ignore all other fields -> jump to next row data
      inc(Result);
    end;
  result := 0; // not found
end;

function TSQLTable.SearchValue(const aUpperValue: RawUTF8;
  StartRow: integer; FieldIndex: PInteger; Client: TObject; Lang: TSynSoundExPronunciation;
  UnicodeComparison: boolean): integer;
var F, Row: integer;
begin
  result := 0;
  if (self=nil) or (StartRow<=0) or (StartRow>RowCount) or (aUpperValue='') then
    exit;
  // search in all fields values
  for F := 0 to FieldCount-1 do begin
    Row := SearchValue(aUpperValue,StartRow,F,Client,Lang,UnicodeComparison);
    if (Row<>0) and ((result=0) or (Row<result)) then begin
      if FieldIndex<>nil then
        FieldIndex^ := F;
      result := Row;
    end;
  end;
end;

function TSQLTable.SearchFieldEquals(const aValue: RawUTF8; FieldIndex: integer): integer;
begin
  result := 0;
  if (self=nil) or (aValue='') or (cardinal(FieldIndex)>cardinal(fFieldCount)) then
    exit;
  for result := 1 to RowCount do
    if UTF8IComp(Get(result,FieldIndex),pointer(aValue))=0 then
      exit;
  result := 0;
end;

{$ifdef USEVARIANTS}
function TSQLTable.GetVariant(Row, Field: integer; Client: TObject): Variant;
var FT: TSQLFieldType;
    EnumType: PEnumType;
    err: integer;
    Value64: Int64;
    ValueRef: RecordRef absolute Value64;
    Value8601: Iso8601 absolute Value64;
    ValueCurrency: Currency absolute Value64;
    DateTime: TDateTime absolute Value64;
begin
  if Row=0 then begin // Field Name
    result := sftUnknown;
    result := GetCaption(0,Field);
    exit;
  end;
  FT := FieldType(Field,@EnumType);
  case FT of
  sftCurrency: begin
    Value64 := StrToCurr64(Get(Row,Field));
    result := ValueCurrency;
  end;
  sftFloat: begin
    result := GetExtended(Get(Row,Field),err);
    if err=0 then
      exit;
  end;
  sftDateTime: begin
    DateTime := Iso8601ToDateTimePUTF8Char(Get(Row,Field),0);
    if DateTime<>0 then begin
      result := DateTime;
      exit;
    end;
  end;
  sftEnumerate, sftID, sftSet, sftInteger, sftTimeLog, sftModTime, sftCreateTime,
  sftRecord, sftBoolean: begin
    Value64 := GetInt64(Get(Row,Field),err);
    if err=0 then begin
      case FT of
      sftEnumerate:
        result := EnumType^.GetCaption(Value64);
      sftID, sftSet, sftInteger:
        result := Value64;
      sftTimeLog, sftModTime, sftCreateTime:
        result := Value8601.ToDateTime;
      sftRecord:
        if (Value64<>0) and
           (Client<>nil) and Client.InheritsFrom(TSQLRest) then // 'TableName ID'
          result := {$ifdef UNICODE}Ansi7ToString{$endif}(ValueRef.Text(TSQLRest(Client).Model)) else
          result := Value64; // display ID number if no table model
      sftBoolean:
        result := boolean(Value64);
      end;
      exit;
    end;
    // err<>0 -> not an integer -> will be displayed with GetString()
  end;
  end;
  // sftBlob and sftMany are not handled
  // sftBlobRecord, sftBlobDynArray as binary string
  // sftObject as JSON serialization
  result := GetString(Row,Field);
end;
{$endif}

function TSQLTable.ExpandAsString(Row, Field: integer; Client: TObject;
  out Text: string): TSQLFieldType;
var EnumType: PEnumType;
    err: integer;
    Value: Int64;
    Ref: RecordRef absolute Value;
begin // Text was already forced to '' because was defined as "out" parameter
  if Row=0 then begin // Field Name
    result := sftUnknown;
    Text := GetCaption(0,Field);
    exit;
  end;
  result := FieldType(Field,@EnumType);
  case result of
  sftDateTime: begin
    Value := Iso8601ToSecondsPUTF8Char(Get(Row,Field),0);
    if Value<>0 then begin
      if Assigned(i18nDateText) then
        Text := i18nDateText(Value) else
        Text := {$ifdef UNICODE}Ansi7ToString{$endif}(Iso8601(Value).Text(true,' '));
      exit;
    end;
  end;
  sftBlob:
    Text := '???';
  sftEnumerate, sftSet, sftRecord, sftID, sftTimeLog, sftModTime, sftCreateTime: begin
    Value := GetInt64(Get(Row,Field),err);
    if err<>0 then
      // not an integer -> to be displayed as sftUTF8Text
      result := sftUTF8Text else
    case result of
      sftEnumerate: begin
        Text := EnumType^.GetCaption(Value);
        exit;
      end;
      sftTimeLog, sftModTime, sftCreateTime: begin
        if Value=0 then
          Text := '' else
        if Assigned(i18nDateText) then
          Text := i18nDateText(Value) else
          Text := {$ifdef UNICODE}Ansi7ToString{$endif}(Iso8601(Value).Text(true,' '));
        exit;
      end;
{      sftID, sftSet:
        result := sftUTF8Text; // will display INTEGER field as number }
      sftRecord:
        if (Value<>0) and 
           (Client<>nil) and Client.InheritsFrom(TSQLRest) then // 'TableName ID'
          Text := {$ifdef UNICODE}Ansi7ToString{$endif}(Ref.Text(TSQLRest(Client).Model)) else
          result := sftUTF8Text; // display ID number if no table model
    end;
  end;
  end;
  if Text='' then
    // returns the value as text by default
    Text := GetString(Row,Field);
end;

function TSQLTable.ExpandAsSynUnicode(Row,Field: integer; Client: TObject; out Text: SynUnicode): TSQLFieldType;
var s: string;
begin
  result := ExpandAsString(Row,Field,Client,s);
  Text := StringToSynUnicode(s);
end;

function TSQLTable.GetTimeLog(Row, Field: integer; Expanded: boolean;
  FirstTimeChar: AnsiChar): RawUTF8;
var Value: Iso8601;
begin
  SetInt64(Get(Row,Field),Value.Value);
  result := Value.Text(Expanded,FirstTimeChar);
end;


{ TSQLTableJSON }

procedure Base64MagicToBlob(PS: PUTF8Char; var result: RawUTF8);
begin
  // do not escape the result: returns e.g. X'53514C697465'
  result := TSQLRawBlobToBlob(Base64ToBin(PAnsiChar(PS),StrLen(PS)));
end;

const
  NULL_DF = ord('N')+ord('U')shl 8+ord('L')shl 16+ord('L')shl 24;
  EndOfJSONField: TSetOfAnsiChar = [',',']','}',':'];

function GetJSONArrayOrObjectAsQuotedStr(P: PUTF8Char; out PDest: PUTF8Char;
  EndOfObject: PUTF8Char): RawUTF8;
var Beg: PUTF8Char;
begin
  assert(EndOfObject<>nil);
  result := '';
  PDest := nil;
  Beg := P;
  P := GotoNextJSONObjectOrArray(P); // quick go to end of array of object
  if P=nil then
    exit;
  EndOfObject^ := P^;
  P^ := #0; // so Beg will be a valid ASCIIZ string
  PDest := P+1;
  result := QuotedStr(Beg,'''');
end;

procedure TJSONObjectDecoder.Decode(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Params: TJSONObjectDecoderParams; RowID: integer; ReplaceRowIDWithID: boolean);
var EndOfObject: AnsiChar;

  procedure GetSQLValue(ndx: integer);
  var wasString: boolean;
      res: PUTF8Char;
      c: integer;
  begin
    res := P;
    if res=nil then begin
      FieldValues[ndx] := ''; // avoid GPF, but will return invalid SQL
      exit;
    end;
    while res^ in [#1..' '] do inc(res);
    if (PInteger(res)^ and $DFDFDFDF=NULL_DF) and
       (res[4] in [#0,#9,#10,#13,' ',',','}',']'])  then begin
      /// GetJSONField('null') returns '' -> check here to make a diff with '""'
      include(FieldNull,ndx);
      FieldValues[ndx] := 'null';
      inc(res,4);
      while res^ in [#1..' '] do inc(res);
      if res^=#0 then
        P := nil else begin
        EndOfObject := res^;
        res^ := #0;
        P := res+1;
      end;
    end else begin
      // first check if nested object or array
      case res^ of // handle JSON {object} or [array] in P
      '{','[':
        FieldValues[ndx] := GetJSONArrayOrObjectAsQuotedStr(res,P,@EndOfObject);
      else begin
        // handle JSON string, number or false/true in P
        res := GetJSONField(res,P,@wasString,@EndOfObject);
        if wasString then begin
          c := PInteger(res)^ and $00ffffff;
          if c=JSON_BASE64_MAGIC then
            case Params of
            pInlined: //untouched -> recognized as BLOB in SQLParamContent()
              FieldValues[ndx] := QuotedStr(res,'''');
            pQuoted: // \uFFF0base64encodedbinary -> 'X''hexaencodedbinary'''
              // if not inlined, it can be used directly in INSERT/UPDATE statements
              Base64MagicToBlob(res+3,FieldValues[ndx]);
            pNonQuoted: // returned directly as RawByteString
              FieldValues[ndx] := Base64ToBin(res+3);
            end else begin
            if c=JSON_SQLDATE_MAGIC then
              inc(res,3); // ignore \uFFF1 magic marker
            // regular string content
            if Params=pNonQuoted then
              // returned directly as RawUTF8
              FieldValues[ndx] := res else
              { escape SQL strings, cf. the official SQLite3 documentation:
                "A string is formed by enclosing the string in single quotes (').
                 A single quote within the string can be encoded by putting two
                 single quotes in a row - as in Pascal." }
              FieldValues[ndx] := QuotedStr(res,'''');
          end;
        end else
          // non string params (numeric or null/false/true) are passed untouched
          FieldValues[ndx] := res;
      end;
      end;
    end;
    Inc(FieldLen,length(FieldValues[ndx]));
  end;

var FieldName: RawUTF8;
    F: integer;
begin
  FieldCount := 0;
  FieldLen := 0;
  if P=nil then
    exit;
  FillChar(FieldNull,sizeof(FieldNull),0);
  InlinedParams := Params=pInlined;
  if pointer(Fields)=nil then begin
    // get "COL1"="VAL1" pairs, stopping at '}' or ']'
    DecodedFieldNames := @FieldNames;
    if RowID>0 then begin // insert explicit RowID
      if ReplaceRowIDWithID then
        FieldNames[0] := 'ID' else
        FieldNames[0] := 'RowID';
      FieldValues[0] := Int32ToUtf8(RowID);
      FieldCount := 1;
      inc(FieldLen,Length(FieldNames[0])+Length(FieldValues[0]));
    end;
    repeat
      FieldName := GetJSONField(P,P);
      if P=nil then break; // syntax error
      if IsRowId(pointer(FieldName)) then
        if RowID>0 then begin
          GetSQLValue(FieldCount); // ignore this parameter if inserted explicit RowID
          if EndOfObject in [#0,'}',']'] then
            break else continue;
        end else
        if ReplaceRowIDWithID then
          FieldName := 'ID';
      inc(FieldLen,length(FieldName));
      FieldNames[FieldCount] := FieldName;
      GetSQLValue(FieldCount); // update EndOfObject
      inc(FieldCount);
      if FieldCount=MAX_SQLFIELDS then
        raise EParsingException.Create('Too many inlines in GetJSONObjectAsSQL');
    until EndOfObject in [#0,'}',']'];
  end else begin
    // get "VAL1","VAL2"...
    if RowID>0 then
      raise EParsingException.Create('GetJSONObjectAsSQL(expanded) won''t handle RowID');
    if length(Fields)>MAX_SQLFIELDS then
      raise EParsingException.Create('Too many inlines in GetJSONObjectAsSQL');
    DecodedFieldNames := pointer(Fields);
    FieldCount := length(Fields);
    for F := 0 to FieldCount-1 do begin
      inc(FieldLen,length(Fields[F]));
      GetSQLValue(F); // update EndOfObject
    end;
  end;
end;

procedure TJSONObjectDecoder.Decode(JSON: RawUTF8; const Fields: TRawUTF8DynArray;
  Params: TJSONObjectDecoderParams; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false);
var P: PUTF8Char;
begin
  if JSON='' then begin
    FieldCount := 0;
    FieldLen := 0;
  end else begin
    P := @JSON[1]; // call UniqueString(JSON)
    while P^ in [#1..' ','{','['] do inc(P);
    Decode(P,Fields,Params,RowID,ReplaceRowIDWithID);
  end;
end;

function TJSONObjectDecoder.SameFieldNames(const Fields: TRawUTF8DynArray): boolean;
var i: integer;
begin
  result := false;
  if length(Fields)<>FieldCount then
    exit;
  for i := 0 to FieldCount-1 do
    if not IdemPropNameU(Fields[i],FieldNames[i]) then
      exit;
  result := true;
end;

procedure TJSONObjectDecoder.AssignFieldNamesTo(var Fields: TRawUTF8DynArray);
var i: integer;
begin
  SetLength(Fields,FieldCount);
  for i := 0 to FieldCount-1 do
    Fields[i] := FieldNames[i];
end;

function TJSONObjectDecoder.EncodeAsSQLPrepared(const TableName: RawUTF8;
  Update: boolean): RawUTF8;
const SQL: array[boolean] of PUTF8Char = (
   'insert into %%', 'update % set % where ID=?');
var F: integer;
    P: PUTF8Char;
    tmp: RawUTF8;
begin
  result := '';
  if FieldCount=0 then
    exit;
  SetLength(tmp,FieldLen+2*FieldCount+12); // max length
  P := pointer(tmp);
  if Update then begin
    // returns 'COL1=?,COL2=?' (UPDATE SET format)
    for F := 0 to FieldCount-1 do begin
      P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
      PInteger(P)^ := Ord('=')+Ord('?')shl 8+Ord(',')shl 16;
      inc(P,3);
    end;
    dec(P);
  end else begin
    // returns ' (COL1,COL2) VALUES (?,?)' (INSERT format)
    PWord(P)^ := Ord(' ')+ord('(')shl 8;
    inc(P,2);
    for F := 0 to FieldCount-1 do begin
      P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
      P^ := ',';
      inc(P);
    end;
    P := AppendRawUTF8ToBuffer(P-1,') VALUES (');
    for F := 1 to FieldCount do begin
      PWord(P)^ := Ord('?')+Ord(',')shl 8;
      inc(P,2);
    end;
    P[-1] := ')';
  end;
  assert(P-pointer(tmp)<length(tmp));
  SetLength(tmp,P-pointer(tmp));
  result := FormatUTF8(SQL[Update],[TableName,tmp]);
end;

function TJSONObjectDecoder.EncodeAsSQL(Update: boolean): RawUTF8;
var F, Len: integer;
    P: PUTF8Char;
begin
  result := '';
  if FieldCount=0 then
    exit;
  if InlinedParams then
    Len := FieldLen+6*FieldCount else
    Len := FieldLen+2*FieldCount;
  if Update then begin
    // returns 'COL1='VAL1',COL2=VAL2' (UPDATE SET format)
    SetLength(result,Len-1); // -1 for last ','
    P := pointer(result);
    for F := 0 to FieldCount-1 do begin
      P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
      if InlinedParams then begin
        PInteger(P)^ := Ord('=')+Ord(':')shl 8+Ord('(')shl 16;
        inc(P,3);
      end else begin
        P^ := '=';
        inc(P);
      end;
      P := AppendRawUTF8ToBuffer(P,FieldValues[F]);
      if InlinedParams then begin
        PWord(P)^ := Ord(')')+Ord(':')shl 8;
        P[2] := ',';
        // PInteger(P)^ := Ord(')')+Ord(':')shl 8+Ord(',')shl 16; may corrupt mem
        inc(P,3);
      end else begin
        P^ := ',';
        inc(P);
      end;
    end;
    dec(P);
    P^ := #0; // trim last ','
  end else begin
    // returns ' (COL1,COL2) VALUES ('VAL1',VAL2)' (INSERT format)
    SetLength(result,Len+11);
    P := pointer(result);
    PWord(P)^ := Ord(' ')+ord('(')shl 8;
    inc(P,2);
    for F := 0 to FieldCount-1 do begin
      P := AppendRawUTF8ToBuffer(P,DecodedFieldNames[F]);
      P^ := ',';
      inc(P);
    end;
    P := AppendRawUTF8ToBuffer(P-1,') VALUES (');
    for F := 0 to FieldCount-1 do begin
      if InlinedParams then begin
        PWord(P)^ := Ord(':')+Ord('(')shl 8;
        inc(P,2);
      end;
      P := AppendRawUTF8ToBuffer(P,FieldValues[F]);
      if InlinedParams then begin
        PWord(P)^ := Ord(')')+Ord(':')shl 8;
        P[2] := ',';
        inc(P,3);
      end else begin
        P^ := ',';
        inc(P);
      end;
    end;
    P[-1] := ')';
  end;
  Assert(P-pointer(result)=length(result));
end;


const
  FROMINLINED: array[boolean] of TJSONObjectDecoderParams = (
    pQuoted, pInlined);

function GetJSONObjectAsSQL(var P: PUTF8Char; const Fields: TRawUTF8DynArray;
  Update, InlinedParams: boolean; RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8;
var Decoder: TJSONObjectDecoder;
begin
  Decoder.Decode(P,Fields,FROMINLINED[InlinedParams],RowID,ReplaceRowIDWithID);
  result := Decoder.EncodeAsSQL(Update);
end;

function GetJSONObjectAsSQL(JSON: RawUTF8; Update, InlinedParams: boolean;
 RowID: Integer=0; ReplaceRowIDWithID: Boolean=false): RawUTF8; overload;
var Decoder: TJSONObjectDecoder;
begin
  Decoder.Decode(JSON,nil,FROMINLINED[InlinedParams],RowID,ReplaceRowIDWithID);
  result := Decoder.EncodeAsSQL(Update);
end;

function Expect(var P: PUTF8Char; const Value: RawUTF8): boolean;
var L: integer;
begin
  if P=nil then
    result := false else begin
    while P^ in [#1..' '] do inc(P);
    if Value='' then
      result := false else begin
      L := length(Value);
      result := CompareMem(P,pointer(Value),L);
      if result then
        inc(P,L);
    end;
  end;
end;

function GetJSONIntegerVar(var P: PUTF8Char): PtrInt;
var c: PtrUInt;
begin
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  c := byte(P^)-48;
  if c>9 then
    result := 0 else begin
    result := c;
    inc(P);
    repeat
      c := byte(P^)-48;
      if c>9 then
        break;
      result := result*10+PtrInt(c);
      inc(P);
    until false;
  end;
end;

function UnJSONFirstField(var P: PUTF8Char): RawUTF8;
// expand=true: [ {"col1":val11} ] -> val11
// expand=false: { "fieldCount":1,"values":["col1",val11] } -> vall11
begin
  result := '';
  if P=nil then exit;
  if Expect(P,'{"fieldCount":') then begin
    // not expanded format
    if GetJSONIntegerVar(P)<>1 then
      exit; // wrong field count
    while P^<>'[' do if P^=#0 then exit else inc(P); // go to ["col1"
    inc(P); // go to "col1"
  end else begin
    // expanded format
    while P^<>'[' do if P^=#0 then exit else inc(P); // need an array of objects
    repeat inc(P); if P^=#0 then exit; until P^='{'; // go to object begining
  end;
  GetJSONField(P,P); // ignore field name
  result := GetJSONField(P,P); // get field value
end;

function IsNotAjaxJSON(P: PUTF8Char): Boolean;
begin
  result := Expect(P,'{"fieldCount":');
end;

function IsNotExpanded(var P: PUTF8Char; var FieldCount,RowCount: integer): boolean;
begin
  if not Expect(P,'{"fieldCount":') then begin
    result := false;
    exit;
  end;
  FieldCount := GetJSONIntegerVar(P);
  if Expect(P,',"rowCount":') then
    RowCount := GetJSONIntegerVar(P) else
    RowCount := 0;
  result := (FieldCount<>0) and Expect(P,',"values":[');
end;

function GetRowCountNotExpanded(P: PUTF8Char; FieldCount: integer; var RowCount: integer): PUTF8Char;
begin
  RowCount := 0;
  result := P; // no data at all of unexpected end
  repeat
    // get a row
    P := GotoNextJSONField(P,FieldCount);
    if P=nil then exit; // unexpected end
    inc(RowCount);
  until P[-1]=']'; // end of array
  if P^='}' then begin // our expected formated JSON stream is ended with }
    if RowCount>0 then
      dec(RowCount); // first Row = field names -> data in rows 1..RowCount
    result := P;
  end else
    RowCount := 0; // bad format -> no data
end;

function JSONIgnoreFieldName(P: PUTF8Char): PUTF8Char;
begin
  result := nil;
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  if P^='"' then begin // "string \"field"
    repeat
      inc(P);
      if P^=#0 then exit; // unexpected end
    until (P^='"') and (P[-1]<>'\');
    inc(P);
  end;
  repeat
    if P^=#0 then exit else // unexpected end
    if P^=':' then break else // field name expected format is "FieldName":Value
    inc(P);
  until false;
  result := P+1;
end;

function JSONIgnoreFieldValue(P: PUTF8Char): PUTF8Char;
begin
  result := nil;
  if P=nil then exit;
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  if P^='"' then begin // "string \"field"
    repeat
      inc(P);
      if P^=#0 then exit else // unexpected end
      if P^='"' then
        if P[-1]<>'\' then  // 'sdklds\"' is invalid ending
          break else
          if P[-2]='\' then break; //   '\\"' is valid ending
    until false;
    inc(P);
  end;
  repeat
    if P^=#0 then exit else // unexpected end
    if P^ in [',','}'] then break else // expect 'Value,' or 'Value}'
    inc(P);
  until false;
  result := P;
end;

function JSONIgnoreObject(P: PUTF8Char): PUTF8Char;
begin
  if P<>nil then begin
    while P^<>'{' do inc(P);
    if P^<>'{' then
      // expect '{"Name":Value,....}' object
      P := nil else
      if P[1]='}' then
        // it is a void object {}
        inc(P,2) else begin
        // ignore all "FieldName":Value pairs
        repeat
          P := JSONIgnoreFieldValue(JSONIgnoreFieldName(P+1));
          if P=nil then
            break;
          if P^=',' then inc(P);
          if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
        until P^='}';
        if P<>nil then
          if P^<>'}' then
            P := nil else // unexpected end
            inc(P); // returns position after the expected ending '}' delimiter
      end;
  end;
  result := P;
end;

function JSONGetObject(var P: PUTF8Char; ExtractID: PInteger;
  var EndOfObject: AnsiChar): RawUTF8;
var Beg, PC: PUTF8Char;
begin
  result := '';
  if P=nil then
    exit;
  while P^<>'{' do inc(P);
  Beg := P;
  P := JSONIgnoreObject(Beg);
  if (P<>nil) and not (P^ in EndOfJSONField) then
    P := nil;
  if P<>nil then begin
    EndOfObject := P^;
    inc(P); // ignore end of object, i.e. ',' or ']'
    if ExtractID<>nil then begin
      PC := Beg;
      while PC^<>'"' do
        if PC^=#0 then exit else inc(PC);
      if IdemPChar(PC,'"ID":') or IdemPChar(PC,'"ROWID":') then begin
        ExtractID^ := GetInteger(PosChar(PC,':')+1);
        PC := PosChar(PC,',');
        PC^ := '{';
        SetString(result,PAnsiChar(PC),P-PC-1); // extract the '"ID":203,' pair
        exit;
      end else
        ExtractID^ := 0;
    end;
    SetString(result,PAnsiChar(Beg),P-Beg-1);
  end;
end;

function TSQLTableJSON.PrivateCopyChanged(aJSON: PUTF8Char; aLen: integer): boolean;
var Hash: cardinal;
begin
  Hash := crc32(0,pointer(aJSON),aLen);
  result := (fPrivateCopyHash=0) or (Hash=0) or (Hash<>fPrivateCopyHash);
  if not result then
    exit;
  SetString(fPrivateCopy,PAnsiChar(aJSON),aLen);
  fPrivateCopyHash := Hash;
end;

function TSQLTableJSON.ParseAndConvert(Buffer: PUTF8Char; BufferLen: integer): boolean;
function GetFieldCountExpanded(P: PUTF8Char): integer;
{$ifdef PUREPASCAL}
begin
  result := 0;
  repeat
    P := JSONIgnoreFieldValue(JSONIgnoreFieldName(P));
    if P=nil then begin // unexpected end
      result := 0;
      exit;
    end;
    inc(result);
    if P^='}' then break; // end of object
    inc(P);
  until false;
end;
{$else}
asm
    push ebx
    xor ebx,ebx
@1: call JSONIgnoreFieldName
    call JSONIgnoreFieldValue
    or eax,eax
    jz @z  // P=nil -> unexpected end
    inc ebx
    cmp byte ptr [eax],'}'
    lea eax,[eax+1]
    jnz @1 // end of object
@z: mov eax,ebx
    pop ebx
end;
{$endif}
var i, max, nfield, nrow, resmax, f: integer;
    EndOfObject: AnsiChar;
    P: PUTF8Char;
    wasString: Boolean;
begin
  result := false; // error on parsing
  if (self=nil) or (Buffer=nil) then
    exit;
  // go to start of object
  P := GotoNextNotSpace(Buffer);
  if IsNotExpanded(P,fFieldCount,fRowCount) then begin
    // A. Not Expanded format
(* {"fieldCount":9,"values":["ID","Int","Test","Unicode","Ansi","ValFloat","ValWord",
    "ValDate","Next",0,0,"abcde+ef++","abcde+ef++","abcde+ef++",
    3.14159265300000E+0000,1203,"2009-03-10T21:19:36",0,..]} *)
    // 1. get RowCount and DataLen
    if fRowCount=0 then // if IsNotExpanded() did not retrieve it
      if (GetRowCountNotExpanded(P,FieldCount,fRowCount)-P)=0 then begin
        fRowCount := 0; // may occur if P^ content was not valid
        exit;
      end;
    // 2. initialize and fill fResults[] PPUTF8CharArray memory
    max := (RowCount+1)*FieldCount;
    SetLength(fJSONResults,max);
    fResults := @fJSONResults[0];
    // unescape+zeroify JSONData + fill fResults[] to proper place
    dec(max);
    f := 0;
    for i := 0 to max do begin
      // get a field
      fJSONResults[i] := GetJSONField(P,P,@wasString);
      if (P=nil) and (i<>max) then
        exit; // failure (GetRowCountNotExpanded should have detect it)
      if (f>=0) and (i>=FieldCount) then begin
        if wasString then
          Include(fFieldParsedAsString,f); // mark column was "string"
        inc(f);
        if f=FieldCount then
          f := -1; // only check first row (should be consistent)
      end;
    end;
  end else begin
    // B. Expanded format
(* [{"ID":0,"Int":0,"Test":"abcde+ef++","Unicode":"abcde+ef++","Ansi":
    "abcde+ef++","ValFloat": 3.14159265300000E+0000,"ValWord":1203,
    "ValDate":"2009-03-10T21:19:36","Next":0},{..}] *)
    // 1. get fields count from first row
    while P^<>'[' do if P^=#0 then exit else inc(P); // need an array of objects
    repeat inc(P); if P^=#0 then exit; until P^='{'; // go to object beginning
    inc(P);
    nfield := GetFieldCountExpanded(P);
    if nField=0 then
      exit; // invalid data for first row
    // 2. get values (assume fields are always the same as in the first object)
    max := nfield; // index to start storing values in fResults[]
    resmax := nfield*2;
    SetLength(fJSONResults,resmax); // space for field names + 1 data row
    nrow := 0;
    repeat // unescape+zeroify JSONData + fill U[] with pointer to values
      for i := 0 to nfield-1 do begin
        if nrow=0 then // get field name from 1st Row
          fJSONResults[i] := GetJSONField(P,P) else
          P := JSONIgnoreFieldName(P);  // ignore field name for later rows
        if max>=resmax then begin // check space inside loop for GPF security
          inc(resmax,resmax shr 3+nfield shl 8);
          SetLength(fJSONResults,resmax); // enough space for 256 more rows
        end;
        if P=nil then break; // normal end: no more field name
        fJSONResults[max] := GetJSONField(P,P,@wasString,@EndOfObject); // get value
        if P=nil then begin
          nfield := 0;
          break; // unexpected end
        end;
        if (nrow=1) and wasString then // mark column was "string"
          Include(fFieldParsedAsString,max-nfield);
        inc(max);
      end;
      if P=nil then
        break; // unexpected end
      if EndOfObject<>'}' then
        break; // data field layout is not consistent: should never happen
      inc(nrow);
      while (P^<>'{') and (P^<>']') do // go to next object beginning
        if P^=#0 then
          exit else
          inc(P);
      if P^=']' then
        break else
        inc(P); // jmp '{'
    until false;
    if max<>(nrow+1)*nfield then begin // field count must be the same for all objects
      fFieldCount := 0;
      fRowCount := 0;
      exit; // data field layout is not consistent: should never happen
    end;
    // 3. save field pointers to fResults[]
    SetLength(fJSONResults,max); // resize to exact size
    fResults := @fJSONResults[0];
    fFieldCount := nfield;
    fRowCount := nrow;
  end;
  result := true; // if we reached here, means successfull conversion from P^
end;

function TSQLTableJSON.UpdateFrom(const aJSON: RawUTF8; var Refreshed: boolean;
  PCurrentRow: PInteger): boolean;
var len: Integer;
begin
  len := length(aJSON);
  if PrivateCopyChanged(pointer(aJSON),len) then
    if ParseAndConvert(pointer(fPrivateCopy),len) then begin
     // parse success from new aJSON data -> need some other update?
     if Assigned(fIDColumn) then begin
       // ID column was hidden -> do it again
       Finalize(fIDColumn);
       IDColumnHide;
     end;
     with fSortParams do
       if FieldCount<>0 then
         // TSQLTable.SortFields() was called -> do it again
         SortFields(FieldIndex,Asc,PCurrentRow,FieldType);
     Refreshed := true;
     result := true;
    end else
      // parse error
      result := false else
    // data didn't change (fPrivateCopyHash checked)
    result := true;
end;

constructor TSQLTableJSON.Create(const Tables: array of TClass;
  const aSQL: RawUTF8; JSONBuffer: PUTF8Char; JSONBufferLen: integer);
begin // don't raise exception on error parsing
  inherited Create(Tables,aSQL);
  ParseAndConvert(JSONBuffer,JSONBufferLen);
end;

constructor TSQLTableJSON.Create(const Tables: array of TClass; const aSQL,
  aJSON: RawUTF8);
var len: integer;
begin
  len := length(aJSON);
  PrivateCopyChanged(pointer(aJSON),len);
  Create(Tables,aSQL,pointer(fPrivateCopy),len);
end;


{ TINIWriter }

const
  sWriteObject1: PWinAnsiChar = #13'[%]'#13;
  sWriteObject2: PWinAnsiChar = '%%=%'#13;
  
procedure TINIWriter.WriteObject(Value: TObject; const SubCompName: RawUTF8='';
  WithSection: boolean=true);
var P: PPropInfo;
    i, V: integer;
    VT: shortstring; // for str()
    Obj: TObject;
    CP: PClassProp;
begin
  if Value<>nil then begin
    if WithSection then
      // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
      // vmtClassName = UTF-8 encoded text stored in a shortstring = -44
      Add(sWriteObject1,[PShortString(PPointer(PPtrInt(Value)^+vmtClassName)^)^]);
    CP := InternalClassProp(PPointer(Value)^);
    if CP=nil then
      exit;
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      case P^.PropType^^.Kind of
        tkInt64{$ifdef FPC}, tkQWord{$endif}:
          Add(sWriteObject2,[SubCompName,P^.Name,GetInt64Prop(Value,pointer(P))]);
        {$ifdef FPC}tkBool,{$endif}
        tkEnumeration, tkInteger, tkSet: begin
          V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
          if V<>P^.Default then
            Add(sWriteObject2,[SubCompName,P^.Name,V]);
        end;
        {$ifdef FPC}tkAString,{$endif} tkLString:
          Add(sWriteObject2,[SubCompName,P^.Name,P^.GetLongStrValue(Value)]);
        tkFloat: begin
          VT[0] := AnsiChar(ExtendedToString(VT,GetFloatProp(Value,pointer(P)),DOUBLE_PRECISION));
          Add(sWriteObject2,[SubCompName,P^.Name,VT]);
        end;
        {$ifdef UNICODE}
        tkUString: // write converted to UTF-8
          Add(sWriteObject2,[SubCompName,P^.Name,GetUnicodeStrProp(Value,pointer(P))]);
        {$endif}
        tkDynArray: begin
          Add(sWriteObject2,[SubCompName,P^.Name]);
          AddDynArrayJSON(P^.GetDynArray(Value));
          Add(#13);
        end;
{$ifdef PUBLISHRECORD}
        tkRecord:
          Add(sWriteObject2,[SubCompName,P^.Name,BinToBase64WithMagic(
            RecordSave(P^.GetFieldAddr(Value)^,P^.PropType^))]);
{$endif PUBLISHRECORD}
        tkClass: begin
          Obj := pointer(GetOrdProp(Value,pointer(P)));  // works also for CPU64
          if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
             WriteObject(Obj,SubCompName+RawUTF8(P^.Name)+'.',false);
        end;
        // tkString (shortstring) and tkWString are not handled
      end;
      P := P^.Next;
    end;
  end;
end;

function UTF8ContentType(P: PUTF8Char): TSQLFieldType;
var V: PUTF8Char;
    c: integer;
begin
  if P=nil then begin
    result := sftUnknown;
    exit;
  end;
  P := GotoNextNotSpace(P);
  V := P;
  if (PInteger(P)^ and $dfdfdfdf=NULL_DF) and (P[4]=#0) then
     result := sftUnknown else
  // don't check for 'false' or 'true' here, since their UTF-8 value is '0' or '1'
  if (P[0] in ['1'..'9']) or // is first char numeric?
     ((P[0]='0') and not (P[1] in ['0'..'9'])) or // '012' excluded by JSON
     ((P[0]='-') and (P[1] in ['0'..'9'])) then begin
    // check if P^ is a true numerical value
    result := sftInteger;
    repeat inc(P) until not (P^ in ['0'..'9']); // check digits
    if P^='.' then begin
      inc(P);
      if P^ in ['0'..'9'] then begin
        result := sftFloat;
        repeat inc(P) until not (P^ in ['0'..'9']); // check fractional digits
      end else begin
        result := sftUTF8Text; // invalid '23023.' value
        exit;
      end;
    end else
      if P-V>18 then begin
        Result := sftUTF8Text; // outside Int64 digits range
        exit; // even sftFloat precision won't be able to handle it
      end;
    if byte(P^) and $DF=ord('E') then begin
      result := sftFloat;
      inc(P);
      if P^='+' then inc(P) else
      if P^='-' then inc(P);
      while P^ in ['0'..'9'] do inc(P);
    end;
    P := GotoNextNotSpace(P);
    if P^<>#0 then // invalid numerical value -> test if not TDateTime
      if Iso8601ToSecondsPUTF8Char(V,0)<>0 then
        result := sftDateTime else
        result := sftUTF8Text;
    exit;
  end else begin
    c := PInteger(V)^ and $00ffffff;
    if (c=JSON_BASE64_MAGIC) or ((V[1]='''') and isBlobHex(V)) then
      result := sftBlob else
    if c=JSON_SQLDATE_MAGIC then
      result := sftDateTime else
      result := sftUTF8Text;
  end;
end;

procedure Base64MagicDecode(var ParamValue: RawUTF8);
begin // '\uFFF0base64encodedbinary' decode into binary
  ParamValue := Base64ToBin(PAnsiChar(pointer(ParamValue))+3,length(ParamValue)-3);
end;

function SQLParamContent(P: PUTF8Char; out ParamType: TSQLFieldType; out ParamValue: RawUTF8): PUTF8Char;
var PDeb: PAnsiChar;
    L: integer;
    c: cardinal;
begin
  ParamType := sftUnknown;
  result := nil;
  if P=nil then
    exit;
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  case P^ of
  '''','"': begin
    P := UnQuoteSQLString(P,ParamValue);
    if P=nil then
      exit; // not a valid quoted string (e.g. unexpected end in middle of it)
    ParamType := sftUTF8Text;
    L := length(ParamValue)-3;
    if L>0 then begin
      c := PInteger(ParamValue)^ and $00ffffff;
      if c=JSON_BASE64_MAGIC then begin
        // ':("\uFFF0base64encodedbinary"):' format -> decode
        Base64MagicDecode(ParamValue); // wrapper function to avoid temp. string
        ParamType := sftBlob;
      end else
      if (c=JSON_SQLDATE_MAGIC) and // handle ':("\uFFF112012-05-04"):' format
         IsIso8601(PUTF8Char(pointer(ParamValue))+3,L) then begin
        ParamValue := copy(ParamValue,4,L); // return ISO-8601 text
        ParamType := sftDateTime;           // identified as Date/Time
      end;
    end;
  end;
  '-','+','0'..'9': begin // allow 0 or + in SQL
    // check if P^ is a true numerical value
    PDeb := pointer(P);
    ParamType := sftInteger;
    repeat inc(P) until not (P^ in ['0'..'9']); // check digits
    if P^='.' then begin
      inc(P);
      if P^ in ['0'..'9'] then begin
        ParamType := sftFloat;
        repeat inc(P) until not (P^ in ['0'..'9']); // check fractional digits
      end else begin
        ParamType := sftUnknown; // invalid '23023.' value
        exit;
      end;
    end;
    if byte(P^) and $DF=ord('E') then begin
      ParamType := sftFloat;
      inc(P);
      if P^='+' then inc(P) else
      if P^='-' then inc(P);
      while P^ in ['0'..'9'] do inc(P);
    end;
    SetString(ParamValue,PDeb,P-PDeb);
  end;
  'N','n':
  if PInteger(P)^ and $DFDFDFDF=NULL_DF then begin
    inc(P,4);
    ParamType := sftBlob; // null in JSON should occur only for BLOBs
  end else
    exit; // invalid content (only :(null): expected)
  else
    exit; // invalid content
  end;
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  if PWord(P)^<>Ord(')')+Ord(':')shl 8 then
    // we expect finishing with P^ pointing at '):'
    ParamType := sftUnknown else
    // result<>nil only if value content in P^
    result := P+2;
end;


{ TPropInfo }

function TPropInfo.GetSQLFromFieldValue(const FieldValue: RawUTF8): RawUTF8;
begin
  case PropType^^.Kind of
    tkLString,{$ifdef FPC}tkAString,{$endif}{$ifdef UNICODE}tkUString,{$endif}
    tkChar, tkWChar:
      { escape SQL strings, cf. the official SQLite3 documentation:
       "A string constant is formed by enclosing the string in single quotes (').
       A single quote within the string can be encoded by putting two single
       quotes in a row - as in Pascal."
       Warning: in SQLite, double quotes are NOT identifying TEXT but a keyword }
      result := QuotedStr(FieldValue,'''');
{    tkInteger, tkClass, tkEnumeration, tkInt64, tkFloat, tkSet:
       these kind of values are stored as a numerical (floating-point) value }
    else
      result := FieldValue;
  end;
end;

function TPropInfo.SameValue(Item1,Item2: TObject; CaseInsensitive: boolean): boolean;
var tmp1,tmp2: RawByteString;
{$ifdef UNICODE}
    tmpU1,tmpU2: UnicodeString;
{$endif}
label Int;
begin
  if Item1=Item2 then begin
    result := true;
    exit;
  end else
  if (Item1=nil) or (Item2=nil) then begin
    result := false;
    exit;
  end else
  case PropType^^.Kind of
  tkEnumeration, tkInteger, tkSet, tkChar, tkWChar: begin
    result := GetOrdProp(Item1,pointer(@self))=GetOrdProp(Item2,pointer(@self));
    exit;
  end;
  tkFloat:
    if PropType^.FloatType in [ftDouble,ftCurr] then
      goto Int; // compare 8 bytes content at binary level
  tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
Int:result := GetInt64Prop(Item1,pointer(@self))=GetInt64Prop(Item2,pointer(@self));
    exit;
  end;
  tkLString{$ifdef FPC},tkAString{$endif}: begin
    GetLongStrProp(Item1,pointer(@self),tmp1);
    GetLongStrProp(Item2,pointer(@self),tmp2);
    if CaseInsensitive then
      if PropType^=TypeInfo(RawUTF8) then
        result := UTF8IComp(pointer(tmp1),pointer(tmp2))=0 else
      if PropType^=TypeInfo(TSQLRawBlob) then
        result := tmp1=tmp2 else // BLOB is binary so always case sensitive
      if PropType^=TypeInfo(WinAnsiString) then
        result := AnsiIComp(pointer(tmp1),pointer(tmp2))=0 else
        result := StrIComp(pointer(tmp1),pointer(tmp2))=0 else
      result := tmp1=tmp2;
    exit;
  end;
  {$ifdef UNICODE}
  tkUString: begin
    tmpU1 := GetUnicodeStrProp(Item1,pointer(@self));
    tmpU2 := GetUnicodeStrProp(Item2,pointer(@self));
    if CaseInsensitive then
      result := AnsiICompW(pointer(tmpU1),pointer(tmpU2))=0 else
      result := tmpU1=tmpU2;
    exit;
  end;
  {$endif}
  tkDynArray: begin
    result := GetDynArray(Item1).Equals(GetDynArray(Item2));
    exit;
  end;
  end;
  GetValueVar(Item1,false,RawUTF8(tmp1),nil);
  GetValueVar(Item2,false,RawUTF8(tmp2),nil);
  result := tmp1=tmp2; // slow, always working implementation
end;

function TPropInfo.GetHash(Instance: TObject; CaseInsensitive: boolean): cardinal;
var I64: Int64;
    tmp: RawByteString;
{$ifdef UNICODE}
    tmpU: UnicodeString;
{$endif}
    Up: array[byte] of AnsiChar; // avoid slow heap allocation
label Int;
begin
  if Instance<>nil then
  case PropType^^.Kind of
  tkEnumeration, tkInteger, tkSet, tkClass,
  tkChar, tkWChar: begin
    result := GetOrdProp(Instance,pointer(@self));
    exit;
  end;
  tkFloat:
    if PropType^.FloatType in [ftDouble,ftCurr] then
      goto Int; // hash from 8 bytes binary content
  tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
Int:I64 := GetInt64Prop(Instance,pointer(@self));
    result := Int64Rec(I64).Lo xor Int64Rec(I64).Hi;
    exit;
  end;
  tkLString{$ifdef FPC},tkAString{$endif}: begin
    GetLongStrProp(Instance,pointer(@self),tmp);
    if CaseInsensitive then
      if PropType^=TypeInfo(RawUTF8) then
        result := crc32(0,Up,UTF8UpperCopy255(Up,tmp)-Up) else
        if PropType^=TypeInfo(TSQLRawBlob) then // binary is case sensitive
          result := crc32(0,pointer(tmp),length(tmp)) else
          result := crc32(0,Up,UpperCopy255(Up,tmp)-Up) else
      result := crc32(0,pointer(tmp),length(tmp));
    exit;
  end;
  {$ifdef UNICODE}
  tkUString: begin
    tmpU := GetUnicodeStrProp(Instance,pointer(@self));
    if CaseInsensitive then
      result := crc32(0,Up,UpperCopy255W(Up,tmpU)-Up) else
      result := crc32(0,pointer(tmpU),length(tmpU)*sizeof(char));
    exit;
  end;
  {$endif}
  tkDynArray: begin
    tmp := GetDynArray(Instance).SaveTo;
    result := crc32(0,pointer(tmp),length(tmp));
    exit;
  end;
  end else begin
    result := 1;
    exit; // return a default Hash for Instance=nil
  end;
  GetValueVar(Instance,false,RawUTF8(tmp),nil);
  result := crc32(0,pointer(tmp),length(tmp));
end;

procedure TPropInfo.NormalizeValue(var Value: RawUTF8);
var err, VInt: integer;
    VInt64: Int64;
    VFloat: double; // we force Double precision value, as SQLite3 does
label Int;
begin
  case PropType^^.Kind of
    tkInteger, tkSet: begin
Int:  VInt := GetInteger(pointer(Value),err);
      if err<>0 then
        Value := '' else
        Value := {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(VInt);
    end;
    tkClass: // TSQLRecord field value is pointer(RecordID), not any Instance
      case PropType^^.ClassSQLFieldType of
        sftID: goto Int;
        sftObject: ; // already UTF-8 encoded -> already normalized
        else Value := '';
      end;
    {$ifdef FPC}tkBool,{$endif} tkEnumeration:
    // boolean use ToSQL=true format ('0' or '1')
    with PropType^^.EnumBaseType^ do begin
      VInt := GetInteger(pointer(Value),err);
      if err<>0 then // we allow a value stated as text -> convert into integer
        if {$ifdef FPC}PropType^^.Kind=tkBool{$else}PropType^=TypeInfo(boolean){$endif} then
          VInt := GetEnumNameValue(pointer(Value)) else
          VInt := GetEnumNameTrimedValue(pointer(Value));
      if cardinal(VInt)<=cardinal(MaxValue) then
        Value := {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(VInt) else
        Value := '';
    end;
    {$ifdef FPC}tkAString,{$endif} {$ifdef UNICODE}tkUString,{$endif}
    tkLString, tkChar, tkWChar:
      ; // already UTF-8 encoded -> already normalized
    tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
      VInt64 := GetInt64(pointer(Value),err); // works also with TTimeLog
      if err<>0 then
        Value := '' else
        Value := {$ifndef ENHANCEDRTL}Int64ToUtf8{$else}IntToStr{$endif}(VInt64);
    end;
    tkFloat:
    if PropType^=TypeInfo(Currency) then
      Value := Curr64ToStr(StrToCurr64(pointer(Value))) else
      if PropType^=TypeInfo(TDateTime) then
        Value := DateTimeToIso8601Text(Iso8601ToDateTime(Value)) else begin
{$ifdef ENHANCEDRTL}
        val(Value,VFloat,err);
{$else} VFloat := GetExtended(pointer(Value),err);
{$endif}if err<>0 then
          Value := '' else
          Value := ExtendedToStr(VFloat,DOUBLE_PRECISION);
      end;
    else Value := '';  // e.g. tkString (shortstring), tkWString or tkDynArray
  end;
end;

function TPropInfo.GetOrdValue(Instance: TObject): Integer;
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [
       tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass]) then
    result := GetOrdProp(Instance,pointer(@self)) else
    result := -1;
end;

function TPropInfo.GetInt64Value(Instance: TObject): Int64;
begin
  if (Instance<>nil) and (@self<>nil) then
  case PropType^^.Kind of
    tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass:
      result := GetOrdProp(Instance,pointer(@self));
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      result := GetInt64Prop(Instance,pointer(@self));
    else result := 0;
  end else
    result := 0;
end;

function TPropInfo.GetCurrencyValue(Instance: TObject): Currency;
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) and
     (PropType^.FloatType=ftCurr) then
    PInt64(@result)^ := GetInt64Prop(Instance,pointer(@self)) else
    result := 0;
end;

function TPropInfo.GetExtendedValue(Instance: TObject): Extended;
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) then
     result := GetFloatProp(Instance,pointer(@self)) else
     result := 0;
end;

procedure TPropInfo.SetExtendedValue(Instance: TObject; const Value: Extended);
begin
  if (Instance<>nil) and (@self<>nil) and (PropType^^.Kind=tkFloat) then
    SetFloatProp(Instance,pointer(@self),Value);
end;

function TPropInfo.GetDynArray(Instance: TObject): TDynArray;
begin
  result.Init(PropType^,GetFieldAddr(Instance)^);
end;

function TPropInfo.GetLongStrValue(Instance: TObject): RawUTF8;
var tmp: RawByteString;
begin
  result := '';
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) then
    if PropType^=TypeInfo(RawUTF8) then
      GetLongStrProp(Instance,pointer(@self),RawByteString(result)) else begin
      GetLongStrProp(Instance,pointer(@self),tmp);
      if tmp<>'' then
        if PropType^=TypeInfo(WinAnsiString) then
          result := WinAnsiToUTF8(WinAnsiString(tmp)) else
        if PropType^=TypeInfo(RawUnicode) then
          result := RawUnicodeToUTF8(RawUnicode(tmp)) else
        if PropType^=TypeInfo(TSQLRawBlob) then
          result := TSQLRawBlobToBlob(TSQLRawBlob(tmp)) else
          // not a known LongStr type -> use generic AnsiString
          result := StringToUTF8(string(AnsiString(tmp)));
    end;
end;

procedure TPropInfo.SetLongStrValue(Instance: TObject; const Value: RawUTF8);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) then
  if (Value='') or (PropType^=TypeInfo(RawUTF8)) then
    SetLongStrProp(Instance,pointer(@self),Value) else 
  if PropType^=TypeInfo(WinAnsiString) then
    SetLongStrProp(Instance,pointer(@self),UTF8ToWinAnsi(Value)) else
  if PropType^=TypeInfo(RawUnicode) then
    SetLongStrProp(Instance,pointer(@self),Utf8DecodeToRawUnicode(Value)) else
  if PropType^=TypeInfo(TSQLRawBlob) then
    SetLongStrProp(Instance,pointer(@self),BlobToTSQLRawBlob(pointer(Value))) else
    // not a known LongStr type -> use generic AnsiString
    SetLongStrProp(Instance,pointer(@self),AnsiString(UTF8ToString(Value)));
end;

function TPropInfo.GetGenericStringValue(Instance: TObject): string;
begin
  if (Instance=nil) or (@self=nil) then
    result := '' else
    case PropType^^.Kind of
      {$ifdef FPC}tkAString,{$endif} tkLString:
        result := UTF8ToString(GetLongStrValue(Instance));
{$ifdef UNICODE}
      tkUString:
        result := GetUnicodeStrProp(Instance,pointer(@self));
{$endif}
     else result := '';
     end;
end;

procedure TPropInfo.SetGenericStringValue(Instance: TObject; const Value: string);
begin
  if (Instance<>nil) and (@self<>nil) then
    case PropType^^.Kind of
      {$ifdef FPC}tkAString,{$endif}tkLString:
         SetLongStrValue(Instance,StringToUtf8(Value));
{$ifdef UNICODE}
       tkUString:
         SetUnicodeStrProp(Instance,pointer(@self),Value);
{$endif}
    end;
end;

{$ifdef UNICODE}

function TPropInfo.GetUnicodeStrValue(Instance: TObject): UnicodeString;
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind=tkUString) then
    result := GetUnicodeStrProp(Instance,pointer(@self));
end;

procedure TPropInfo.SetUnicodeStrValue(Instance: TObject; const Value: UnicodeString);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind=tkUString) then
    SetUnicodeStrProp(Instance,pointer(@self),Value);
end;
{$endif}

procedure TPropInfo.SetOrdValue(Instance: TObject; Value: Integer);
begin
  if (Instance<>nil) and (@self<>nil) and
     (PropType^^.Kind in [
       tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass]) then
    SetOrdProp(Instance,pointer(@self),Value);
end;

procedure TPropInfo.SetInt64Value(Instance: TObject; Value: Int64);
begin
  if (Instance<>nil) and (@self<>nil) then
  case PropType^^.Kind of
    tkInteger,tkEnumeration,tkSet,{$ifdef FPC}tkBool,{$endif}tkClass:
      SetOrdProp(Instance,pointer(@self),Value);
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      SetInt64Prop(Instance,pointer(@self),Value);
  end;
end;

type
  PObject = ^TObject;

function TPropInfo.SetBinary(Instance: TObject; P: PAnsiChar): PAnsiChar;
var PB: PByte absolute P;
    valid: boolean;
label I64, Int;
begin
  result := nil;
  if (P=nil) or (Instance=nil) then
    exit;
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}
    tkEnumeration, tkInteger, tkSet, tkChar, tkWChar: // SetOrdProp() properties
Int:  SetOrdProp(Instance,Pointer(@self),integer(FromVarUInt32(PB)));
    tkClass:
    case PropType^^.ClassSQLFieldType of
      sftID: goto int;
      sftObject: begin // unserialize object from JSON UTF-8 TEXT - not fast, but works
        JSONToObject(PObject(GetFieldAddr(Instance))^,pointer(FromVarString(PB)),valid);
        if not valid then exit;
      end;
      else exit;
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
I64:begin
      SetInt64Prop(Instance,Pointer(@self),PInt64(P)^);
      inc(P,sizeof(Int64));
    end;
    tkFloat:
      if PropType^.FloatType in [ftCurr,ftDouble] then
        goto I64 else begin
        SetFloatProp(Instance,Pointer(@self),PExtended(P)^);
        inc(P,sizeof(Extended));
      end;
    {$ifdef FPC}tkAString,{$endif} tkLString:
      SetLongStrProp(Instance,pointer(@self),FromVarString(PB));
    {$ifdef UNICODE}
    tkUString:
      SetUnicodeStrProp(Instance,pointer(@self),Utf8ToUnicodeString(FromVarString(PB)));
    {$endif}
    tkDynArray:
      P := GetDynArray(Instance).LoadFrom(P);
{$ifdef PUBLISHRECORD}
    tkRecord:
      P := RecordLoad(GetFieldAddr(Instance)^,P,PropType^);
{$endif}
  end;
  result := P;
end;

procedure TPropInfo.GetBinary(Instance: TObject; W: TFileBufferWriter);
var VExt: Extended;
    V64:  Int64 absolute VExt;
    VStr: RawByteString;
label I64, Int;
begin
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}
    tkEnumeration, tkInteger, tkSet, tkChar, tkWChar: // GetOrdProp() properties
Int:  W.WriteVarUInt32(cardinal(GetOrdProp(Instance,Pointer(@self))));
    tkClass:
    case PropType^^.ClassSQLFieldType of
      sftID: goto int;
      sftObject: // serialize object as JSON UTF-8 TEXT - not fast, but works
        W.Write(ObjectToJSON(TObject(GetOrdProp(Instance,@self)),false,true));
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
I64:   V64 := GetInt64Prop(Instance,Pointer(@self));
       W.Write(@V64,SizeOf(Int64));
     end;
    tkFloat:
      if PropType^.FloatType in [ftCurr,ftDouble] then
        goto I64 else begin
        VExt := GetFloatProp(Instance,Pointer(@self));
        W.Write(@VExt,sizeof(VExt));
      end;
    {$ifdef FPC}tkAString,{$endif} tkLString: begin
      GetLongStrProp(Instance,pointer(@self),VStr);
      W.Write(VStr);
    end;
    {$ifdef UNICODE}
    tkUString:
      W.Write(UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(@self))));
    {$endif}
    tkDynArray: begin
      VStr := GetDynArray(Instance).SaveTo;
      W.Write(pointer(VStr),length(VStr));
    end;
{$ifdef PUBLISHRECORD}
    tkRecord:
      RecordSave(GetFieldAddr(Instance)^,PropType^);
{$endif}
  end;
end;

{$ifndef LVCL}
procedure CopyCollection(Source, Dest: TCollection);
var i: integer;
begin
  if (Source=nil) or (Dest=nil) or (Source.ClassType<>Dest.ClassType) then
    exit;
  Dest.BeginUpdate;
  try
    Dest.Clear;
    for i := 0 to Source.Count-1 do
      CopyObject(Source.Items[i],Dest.Add); // Assign() fails
  finally
    Dest.EndUpdate;
  end;
end;
{$endif}

procedure TPropInfo.CopyValue(Source, Dest: TObject);
var Value: RawByteString;
    S,D: TObject;
label I64, Int;
begin
  if (@self<>nil) and (Source<>nil) and (Dest<>Source) and (Dest<>nil) then
//    (PPointer(Source)^=PPointer(Dest)^) then // allow parent into child e.g.
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}
    tkEnumeration, tkInteger, tkSet, tkChar, tkWChar:
Int:  SetOrdProp(Dest,pointer(@self),GetOrdProp(Source,pointer(@self)));
    tkClass:
    case PropType^^.ClassSQLFieldType of
      sftID:
        // special case for TSQLRecord published properties (sftID, sftRecord)
        // -> these are not class instances, but INTEGER reference to records
        goto int;
      sftObject: begin
        // generic case: copy also class content (create instances)
        S := pointer(GetOrdProp(Source,pointer(@self)));
        D := pointer(GetOrdProp(Dest,pointer(@self)));
        // note: Get/SetOrdProp() works also for CPU64 (returns an PtrInt)
{$ifndef LVCL}
        if S.InheritsFrom(TCollection) then
          CopyCollection(TCollection(S),TCollection(D)) else {$endif} begin
          D.Free; // release previous child
          if S=nil then
            D := nil else begin
            D := S.ClassType.Create; // create new child instance
            CopyObject(S,D); // copy child content
          end;
          SetOrdProp(Dest,pointer(@self),PtrInt(D));
        end;
      end;
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}:
      // works also with TTimeLog, Double and Currency
I64:  SetInt64Prop(Dest,pointer(@self),GetInt64Prop(Source,pointer(@self)));
    tkFloat:
    if PropType^.FloatType in [ftDouble,ftCurr] then
      goto I64 else
      SetFloatProp(Dest,pointer(@self),GetFloatProp(Source,pointer(@self)));
    {$ifdef FPC}tkAString,{$endif} tkLString: begin
      GetLongStrProp(Source,pointer(@self),Value);
      SetLongStrProp(Dest,pointer(@self),Value);
    end;
    {$ifdef UNICODE}
    tkUString:
      SetUnicodeStrProp(Dest,pointer(@self),GetUnicodeStrProp(Source,pointer(@self)));
    {$endif}
    tkDynArray:
      GetDynArray(Dest).Copy(GetDynArray(Source));
{$ifdef PUBLISHRECORD}
    tkRecord:
      RecordCopy(GetFieldAddr(Dest)^,GetFieldAddr(Source)^,PropType^);
{$endif}
    // note: tkString (shortstring) and tkWString (WideString) not handled
  end;
end;

{$ifdef USEVARIANTS}
procedure TPropInfo.GetVariant(Instance: TObject; var Dest: Variant);
var V64: Int64;
begin
  if @self=nil then
    VarClear(Dest) else
  case PropType^^.Kind of
    {$ifdef FPC}
    tkBool:
      Dest := boolean(GetOrdProp(Instance,@self));
    tkEnumeration,
    {$else}
    tkEnumeration:
      if PropType^=TypeInfo(boolean) then
        Dest := boolean(GetOrdProp(Instance,@self)) else
        Dest := GetOrdProp(Instance,@self);
    {$endif}
    tkInteger, tkSet:
      Dest := GetOrdProp(Instance,@self);
    tkChar:
      Dest := AnsiChar(GetOrdProp(Instance,@self));
    tkWChar:
      Dest := WideChar(GetOrdProp(Instance,@self));
    tkInt64{$ifdef FPC}, tkQWord{$endif}: // works also with TTimeLog
      Dest := GetInt64Prop(Instance,pointer(@self));
    tkFloat:
    if PropType^=TypeInfo(Currency) then begin
      V64 := GetInt64Prop(Instance,pointer(@self));
      Dest := PCurrency(@V64)^;
    end else
      Dest := GetFloatProp(Instance,pointer(@self));
{$ifdef FPC}tkAString,{$endif} tkLString:
      Dest := UTF8ToString(GetLongStrValue(Instance));
    {$ifdef UNICODE}
    tkUString:
      Dest := GetUnicodeStrProp(Instance,pointer(@self));
    {$endif}
    tkDynArray:
      DynArrayToVariant(Dest,GetFieldAddr(Instance),PropType^);
    // note: tkString (shortstring), tkWString and tkRecord not handled
    tkClass: // TSQLRecord field value is pointer(RecordID), not any Instance
      if PropType^^.ClassSQLFieldType=sftID then
        Dest := GetOrdProp(Instance,pointer(@self)) else // get RowID
        VarClear(Dest);
    else
      VarClear(Dest);
  end;
end;

procedure TPropInfo.SetVariant(Instance: TObject; const Source: Variant);
begin
  if @self<>nil then
  case PropType^^.Kind of
  tkDynArray:
    DynArrayFromVariant(PPointer(GetFieldAddr(Instance))^,Source,PropType);
  else
    SetValue(Instance,pointer(StringToUTF8(Source)));
  end;
end;
{$endif}

function TPropInfo.GetValue(Instance: TObject; ToSQL: boolean; wasSQLString: PBoolean=nil): RawUTF8;
begin
  GetValueVar(Instance,ToSQL,result,wasSQLString);
end;

procedure TPropInfo.GetValueVar(Instance: TObject; ToSQL: boolean; var result: RawUTF8; wasSQLString: PBoolean);
var w: WideChar;
    V: double; // we force Double precision value, as SQLite3 does
label Int, Blob;
begin
  if wasSQLString<>nil then
    wasSQLString^ := false;
  if @self=nil then
    result := '' else
  case PropType^^.Kind of
    {$ifdef FPC}tkBool,{$endif}tkEnumeration:
      if not ToSQL and
         ({$ifdef FPC}PropType^^.Kind=tkBool{$else}PropType^=TypeInfo(boolean){$endif}) then
        result := JSON_BOOLEAN[boolean(GetOrdProp(Instance,@self))] else
        goto Int; // custom enumerations are stored as integer
    tkClass: // TSQLRecord field value is pointer(RecordID), not any Instance
      case PropType^^.ClassSQLFieldType of
        sftID:     goto Int;  // get pointer(RowID)
        sftObject: begin // serialize object as JSON UTF-8 TEXT
          result := ObjectToJSON(TObject(GetOrdProp(Instance,@self)),false,true);
          if wasSQLString<>nil then
            wasSQLString^ := true;
        end;
        else result := 'null';
      end;
    tkInteger, tkSet:
Int:  result := {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(GetOrdProp(Instance,@self));
    tkChar, tkWChar: begin
      w := WideChar(GetOrdProp(Instance,@self));
      if ToSQL and (w=#0) then
        // 'null' and not #0 to avoid end of SQL text - JSON will escape #0
        result := 'null' else begin
        result := RawUnicodeToUtf8(@w,1);
        if wasSQLString<>nil then
          wasSQLString^ := true;
      end;
    end;
    tkInt64{$ifdef FPC}, tkQWord{$endif}: // works also with TTimeLog
      result := {$ifndef ENHANCEDRTL}Int64ToUtf8{$else}IntToStr{$endif}(
        GetInt64Prop(Instance,pointer(@self)));
    tkFloat:
    if PropType^=TypeInfo(Currency) then
      result := Curr64ToStr(GetInt64Prop(Instance,pointer(@self))) else begin
      V := GetFloatProp(Instance,pointer(@self));
      if PropType^=TypeInfo(TDateTime) then begin
        result := DateTimeToIso8601Text(V);
        if wasSQLString<>nil then
          wasSQLString^ := true;
      end else
        result := ExtendedToStr(V,DOUBLE_PRECISION);
    end;
{$ifdef FPC}tkAString,{$endif} tkLString: begin
      if PropType^=TypeInfo(TSQLRawBlob) then begin
        GetLongStrProp(Instance,pointer(@self),RawByteString(result));
Blob:   if result='' then
          result := 'null' else begin
          if ToSQL then
            // encode as BLOB literals (e.g. "X'53514C697465'")
            result := TSQLRawBlobToBlob(TSQLRawBlob(result)) else
            // JSON content is e.g. '\uFFF0base64encodedbinary'
            result := BinToBase64WithMagic(result);
          if wasSQLString<>nil then
            wasSQLString^ := true;
        end;
      end else
        // generic conversion into UTF-8 text
        result := GetLongStrValue(Instance);
      if wasSQLString<>nil then
        wasSQLString^ := true;
    end;
    {$ifdef UNICODE}
    tkUString: begin
      result := UnicodeStringToUtf8(GetUnicodeStrProp(Instance,pointer(@self)));
      if wasSQLString<>nil then
        wasSQLString^ := true;
    end;
    {$endif}
    tkDynArray: begin
      result := GetDynArray(Instance).SaveTo;
      goto Blob;
    end;
{$ifdef PUBLISHRECORD}
    tkRecord: begin
      result := RecordSave(GetFieldAddr(Instance)^,PropType^);
      goto Blob;
    end;
{$endif PUBLISHRECORD}
    // note: tkString (shortstring) and tkWString (WideString) not handled
    else
      result := 'null';
  end;
end;

{$ifndef USETYPEINFO}
function TPropInfo.GetFieldAddr(Instance: TObject): pointer;
asm
  cmp [eax].TPropInfo.GetProc.Byte[3],$FF // is it a field property?
  mov eax,[eax].TPropInfo.GetProc
  jnz @0
  // field - Getter is the field's offset in the instance data
  and eax,$00FFFFFF
  add eax,edx
  ret
@0:xor eax,eax // method -> return nil
end;
{$endif}

function TPropInfo.IsBlob: boolean;
begin
  if @self=nil then
    result := false else
  with PropType^^ do
    result := (Kind in [{$ifdef FPC}tkAString,{$endif}tkLString]) and
      (PropType^=TypeInfo(TSQLRawBlob));
end;

function TPropInfo.IsSimpleField: boolean;
begin
  result := (@self<>nil) and not(PropType^^.SQLFieldType in NOT_SIMPLE_FIELDS);
end;

function TPropInfo.IsStored: boolean;
begin
{$ifdef FPC} // extracted from IsStoredProp() function in typinfo.pp
  result := ((PropProcs shr 4) and 3=ptconst) and LongBool(StoredProc);
{$else}      // Delphi version
  result := boolean(StoredProc);
{$endif}
end;

{$ifdef FPC}

// extracted from typeinfo.pp
function aligntoptr(p : pointer): pointer; inline;
begin
{$ifdef FPC_REQUIRES_PROPER_ALIGNMENT}
   result := align(p,sizeof(p));
{$else FPC_REQUIRES_PROPER_ALIGNMENT}
   result := p;
{$endif FPC_REQUIRES_PROPER_ALIGNMENT}
end;

function TPropInfo.Next: PPropInfo;
begin
  result := aligntoptr(@Name[ord(Name[0])+1]);
end;
{$else}
{$ifdef HASINLINE}
function TPropInfo.Next: PPropInfo;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
{$ifdef PUREPASCAL}
function TPropInfo.Next: PPropInfo;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TPropInfo.Next: PPropInfo;
asm // very fast code
  movzx edx,byte ptr [eax].TPropInfo.Name
  lea eax,[eax+edx].TPropInfo.Name[1]
end;
{$endif}
{$endif}
{$endif}

procedure TPropInfo.SetValue(Instance: TObject; Value: PUTF8Char);
var V: Extended;
    Error: integer;
    ObjValid: boolean;
    I: integer;
begin
  if @self<>nil then
  case PropType^^.Kind of
    tkInteger, tkSet:
      SetOrdProp(Instance,pointer(@self),GetInteger(Value));
    {$ifdef FPC}tkBool,{$endif}tkEnumeration:
    if Value=nil then 
      SetOrdProp(Instance,pointer(@self),0) else begin
      I := GetInteger(pointer(Value),Error);
      with PropType^^.EnumBaseType^ do begin
        if Error<>0 then // we allow a value stated as text
          if {$ifdef FPC}PropType^^.Kind=tkBool{$else}PropType^=TypeInfo(boolean){$endif} then
            I := GetEnumNameValue(Value) else   // 'true' or 'false'
            I := GetEnumNameTrimedValue(Value); // -> convert into integer
        if cardinal(I)>cardinal(MaxValue) then
          I := 0;  // only set a valid value
        SetOrdProp(Instance,pointer(@self),I);
      end;
    end;
    tkChar, tkWChar:
      if (Value<>nil) and (PInteger(Value)^ and $DFDFDFDF=NULL_DF) then
        SetOrdProp(Instance,pointer(@self),0) else // ToSQL -> 'null' and not #0
        SetOrdProp(Instance,pointer(@self),GetUTF8Char(Value));
    tkInt64{$ifdef FPC}, tkQWord{$endif}: // works also with TTimeLog
      SetInt64Prop(Instance,pointer(@self),GetInt64(Value));
    tkFloat: begin
      if Value=nil then
        V := 0 else
        if PropType^=TypeInfo(Currency) then begin
          SetInt64Prop(Instance,pointer(@self),StrToCurr64(Value)); // fast conversion
          exit;
        end else
        if PropType^=TypeInfo(TDateTime) then
          V := Iso8601ToDateTimePUTF8Char(Value,0) else begin
{$ifdef ENHANCEDRTL}
          val(Value,V,Error);
{$else}   V := GetExtended(pointer(Value),Error);
{$endif}  if Error<>0 then
            V := 0;
        end;
      SetFloatProp(Instance,pointer(@self),V);
    end;
    {$ifdef FPC}tkAString,{$endif}
    tkLString:
      SetLongStrValue(Instance,RawUTF8(Value));
    {$ifdef UNICODE}
    tkUString: // fast UTF-8 decoding
      SetUnicodeStrProp(Instance,pointer(@self),UTF8DecodeToUnicodeString(Value,0));
    {$endif}
    tkDynArray:
      GetDynArray(Instance).LoadFrom(pointer(BlobToTSQLRawBlob(Value)));
{$ifdef PUBLISHRECORD}
    tkRecord:
      RecordLoad(GetFieldAddr(Instance)^,pointer(BlobToTSQLRawBlob(Value)),PropType^);
{$endif PUBLISHRECORD}
    // note: tkString (shortstring) and tkWString (WideString) not handled
    tkClass: // TSQLRecord field value is pointer(RecordID), not any Instance
      case PropType^^.ClassSQLFieldType of
      sftID: // set pointer(RowID)
        SetOrdProp(Instance,pointer(@self),GetInteger(Value));
      sftObject:
        JSONToObject(PObject(GetFieldAddr(Instance))^,pointer(Value),ObjValid);
      end;
  end;
end;

procedure TPropInfo.AppendName(var Text: RawUTF8; const Optional: RawUTF8='');
var L, L2, LOptional: PtrUInt;
begin
  L := PtrUInt(Text);
  if L<>0 then
    L := pInteger(L-4)^; // L := length(Text)
  L2 := L+ord(Name[0]);
  LOptional := length(Optional);
  SetLength(Text,L2+LOptional);
  move(Name[1],pointer(PtrUInt(Text)+L)^,ord(Name[0]));
  if LOptional<>0 then
    Move(pointer(Optional)^,PAnsiChar(PtrUInt(Text)+L2)^,LOptional);
end;

function TPropInfo.GetCaption: string;
var Tmp: array[byte] of AnsiChar;
    L: integer;
begin // GetCaptionFromPCharLen() expects ASCIIz -> use tmp[] buffer
  L := ord(Name[0]);
  Tmp[L] := #0;
  move(Name[1],Tmp[0],L);
  GetCaptionFromPCharLen(Tmp,result);
end;


{ TTypeInfo }

{$ifdef FPC}
function TTypeInfo.ClassType: PClassType;
begin // FPC can use memory alignment -> use GetTypeData() function
  if pointer(@self)<>nil then
    result := pointer(GetTypeData(pointer(@self))) else // use typinfo.pp function
    result := nil; // avoid GPF
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.ClassType: PClassType;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.ClassType: PClassType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

{$ifdef FPC}
function TTypeInfo.RecordType: PRecordType; 
begin // FPC can use memory alignment -> use GetTypeData() function
  if pointer(@self)<>nil then
    result := pointer(GetTypeData(pointer(@self))) else // use typinfo.pp function
    result := nil; // avoid GPF
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.RecordType: PRecordType;
begin
  result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.RecordType: PRecordType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

function TTypeInfo.ClassSQLFieldType: TSQLFieldType;
var CT: PClassType;
begin
  {$ifdef FPC}
  CT := pointer(GetTypeData(pointer(@self))); // use typinfo.pp function
  {$else}
  CT := PClassType(@Name[ord(Name[0])+1]);
  {$endif}
  while true do // unrolled three InheritsFrom() calls
    if CT^.ClassType<>TSQLRecordMany then
    if CT^.ClassType<>TSQLRecord then
    if (CT^.ClassType<>TPersistent) and (CT^.ClassType<>TRawUTF8List) then
      if CT^.ParentInfo<>nil then
        {$ifdef FPC}
        CT := CT^.ParentInfo^^.ClassTypes // use typinfo.pp function
        {$else}
        with CT^.ParentInfo^^ do
          CT := @Name[ord(Name[0])+1] // get parent ClassType
        {$endif}
      else break
    else begin
      result := sftObject; // published properties, TStrings TRawUTF8List TCollection
      exit;
    end else begin
      result := sftID; // TSQLRecord field value is pointer(RecordID), not any Instance
      exit;
    end else begin
      result := sftMany; // no data is stored here, but in a pivot table
      exit;
    end;
  result := sftUnknown;
end;

{$ifdef FPC}
function TTypeInfo.EnumBaseType: PEnumType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := pointer(GetTypeData(PEnumType(GetTypeData(pointer(@self)))^.BaseType^);
end;
{$else}
{$ifdef PUREPASCAL}
function TTypeInfo.EnumBaseType: PEnumType;
begin
  with PEnumType(@Name[ord(Name[0])+1])^.BaseType^^ do
    result := @Name[ord(Name[0])+1];
end;
{$else}
function TTypeInfo.EnumBaseType: PEnumType;
asm // very fast code
  movzx edx,byte ptr [eax].TTypeInfo.Name
  mov eax,[eax+edx].TTypeInfo.Name[1].TEnumType.BaseType
  mov eax,[eax]
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
end;
{$endif}
{$endif}

{$ifdef PUREPASCAL}
function TTypeInfo.InheritsFrom(AClass: TClass): boolean;
var CT: PClassType;
begin
  CT := ClassType;
  while CT<>nil do begin
    if CT^.ClassType=pointer(AClass) then begin
      result := true;
      exit;
    end;
    if CT^.ParentInfo=nil then
      break else
      CT := CT^.ParentInfo^.ClassType;
  end;
  result := false;
end;
{$else}
function TTypeInfo.InheritsFrom(AClass: TClass): boolean;
asm // eax=PClassType edx=AClass
@1:movzx ecx,byte ptr [eax].TTypeInfo.Name
   lea eax,[eax+ecx].TTypeInfo.Name[1]
   cmp edx,[eax].TClassType.ClassType
   jz @2
   mov eax,[eax].TClassType.ParentInfo
   or eax,eax
   jz @3 // no parent
   mov eax,[eax] // get parent type info
   jmp @1
@2:mov al,1
@3:
end;
{$endif}

function TTypeInfo.SQLFieldType: TSQLFieldType;
begin // very fast, thanks to the TypeInfo() compiler-generated function
  case Kind of
    tkInteger:
      if @self=TypeInfo(TRecordReference) then begin
        result := sftRecord;
        exit; // direct exit is faster in generated asm code (Delphi 7 at least)
      end else begin
        result := sftInteger;
        exit;
      end;
    tkInt64:
      if @self=TypeInfo(TCreateTime) then begin
        result := sftCreateTime;
        exit;
      end else
      if @self=TypeInfo(TModTime) then begin
        result := sftModTime;
        exit;
      end else
      if @self=TypeInfo(TTimeLog) then begin
        result := sftTimeLog;
        exit;
      end else begin
        result := sftInteger;
        exit;
      end;
{$ifdef FPC}
    tkBool: begin
      result := sftBoolean;
      exit;
    end;
{$endif}
    tkSet: begin
      result := sftSet;
      exit;
    end;
    tkEnumeration:
{$ifndef FPC}
      if @self=TypeInfo(Boolean) then begin
        result := sftBoolean;
        exit;
      end else
{$endif}begin
        result := sftEnumerate;
        exit;
      end;
    tkFloat:
      if @self=TypeInfo(Currency) then begin
        result := sftCurrency;
        exit;
      end else
      if @self=TypeInfo(TDateTime) then begin
        result := sftDateTime;
        exit;
      end else begin
        result := sftFloat;
        exit;
      end;
    {$ifdef FPC}tkAString,{$endif} tkLString:
      if (@self=TypeInfo(RawUTF8)) or (@self=TypeInfo(RawUnicode)) then begin
        result := sftUTF8Text;
        exit;
      end else
      if @self=TypeInfo(TSQLRawBlob) then begin
        result := sftBlob;
        exit;
      end else begin
        result := sftAnsiText;
        exit;                     
      end;
    {$ifdef UNICODE}tkUString,{$endif} tkChar, tkWChar: begin
      result := sftUTF8Text;
      exit;
    end;
    tkDynArray: begin
      result := sftBlobDynArray;
      exit;
    end;
{$ifdef PUBLISHRECORD}
    tkRecord: begin
      result := sftBlobRecord;
      exit;
    end;
{$endif}
    tkClass: begin
      result := ClassSQLFieldType;
      exit;
    end;
    // note: tkString (shortstring) and tkWString (WideString) not handled
    else begin
      result := sftUnknown;
      exit;
    end;
  end;
end;

{$ifdef FPC}
function TTypeInfo.FloatType: TFloatType;
type PFloatType = ^TFloatType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := PFloatType(GetTypeData(pointer(@self)))^; // use typinfo.pp function
end;
{$else}
function TTypeInfo.FloatType: TFloatType;
begin
  result := TFloatType(Name[ord(Name[0])+1]);
end;
{$endif}

{$ifdef FPC}
function TTypeInfo.OrdType: TOrdType;
type POrdType = ^TOrdType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := POrdType(GetTypeData(pointer(@self)))^; // use typinfo.pp function
end;
{$else}
function TTypeInfo.OrdType: TOrdType;
begin
  result := TOrdType(Name[ord(Name[0])+1]);
end;
{$endif}

{$ifdef FPC}
function TTypeInfo.SetEnumType: PEnumType;
begin // FPC can use memory alignment -> use GetTypeData() function
  result := PTypeInfo(GetTypeData(pointer(@self))^.CompType^).EnumBaseType;
end;
{$else}
function TTypeInfo.SetEnumType: PEnumType;
begin
  result := PPTypeInfo(PPointer(@Name[ord(Name[0])+(1+sizeof(TOrdType))])^)^.EnumBaseType;
end;
{$endif}


{ TClassProp }

function TClassProp.FieldCountWithParents: integer;
var aClassType: TClass;
    CP: PClassProp;
begin
  result := 0;
  if @self=nil then
    exit;
  aClassType := TClass(@self);
  repeat
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no RTTI information (e.g. reached TObject level)
    inc(result,CP^.PropCount);
    aClassType := aClassType.ClassParent;
  until aClassType=nil;
end;

function TClassProp.FieldProp(const PropName: shortstring): PPropInfo;
var i: integer;
begin
  if @self<>nil then begin
    result := @PropList;
    for i := 1 to PropCount do
      if IdemPropName(result^.Name,PropName) then
        exit else
        result := result^.Next;
  end;
  result := nil;
end;

{ TClassType }

{$ifdef FPC}
function TClassType.ClassProp: PClassProp;
begin
  if pointer(@self)<>nil then
    result := aligntoptr(@UnitName[ord(UnitName[0])+1]) else
    result := nil; // avoid GPF
end;
{$else}
function TClassType.ClassProp: PClassProp;
begin
  if pointer(@self)<>nil then
    result := pointer(@UnitName[ord(UnitName[0])+1]) else
    result := nil; // avoid GPF
end;
{$endif}

function TClassType.RTTISize: integer;
var C: PClassProp;
    P: PPropInfo;
    i: Integer;
begin
  result := 0;
  C := ClassProp;
  if C=nil then
    exit;
  P := @C^.PropList;
  for i := 1 to C^.PropCount do
    P := P^.Next;
  result := PtrUInt(P)-PtrUInt(@self);
end;

{$ifdef PUREPASCAL}
function TClassType.InheritsFrom(AClass: TClass): boolean;
var P: PPTypeInfo;
begin
  result := true;
  if ClassType=AClass then
    exit;
  P := ParentInfo;
  while P<>nil do
    with P^.ClassType^ do
    if ClassType=AClass then
      exit else
      P := ParentInfo;
  result := false;
end;
{$else}
function TClassType.InheritsFrom(AClass: TClass): boolean;
asm // eax=PClassType edx=AClass
    cmp [eax].TClassType.ClassType,edx
    jz @3
@2: mov eax,[eax].TClassType.ParentInfo
    or eax,eax
    jz @0
@1: mov eax,[eax]
    movzx ecx,byte ptr [eax].TTypeInfo.Name
    lea eax,[eax+ecx].TTypeInfo.Name[1]
    cmp edx,[eax].TClassType.ClassType
    jnz @2
@3: mov al,1
@0:
end;
{$endif}


{ TEnumType }


function TEnumType.GetEnumName(const Value): PShortString;
var Ordinal: integer;
begin
  if MaxValue<=255 then
    Ordinal := byte(Value) else
    Ordinal := word(Value);
  result := GetEnumNameOrd(Ordinal);
end;

function TEnumType.GetEnumNameOrd(Value: Integer): PShortString;
// note: FPC doesn't align NameList (cf. GetEnumName() function in typinfo.pp)
{$ifdef PUREPASCAL}
begin
  result := @NameList;
  if cardinal(Value)<=cardinal(MaxValue) then
    while Value>0 do begin
      dec(Value);
      inc(PtrUInt(result),ord(result^[0])+1);
    end;
end;
{$else}
asm // eax=PEnumType edx=Value
    cmp edx,[eax].TEnumType.MaxValue
    lea eax,[eax].TEnumType.NameList
    ja @z
    or edx,edx
    jz @z
    xor ecx,ecx
@1: mov cl,[eax]
    dec edx
    lea eax,[eax+ecx+1]
    jnz @1
@z: db $f3 // rep ret AMD trick here
end;
{$endif}

function TEnumType.GetEnumNameValue(const EnumName: ShortString): Integer;
var P: PShortString;
begin
  P := @NameList;
  for result := 0 to MaxValue do
    if IdemPropName(EnumName,P^) then
      exit else
      inc(PtrUInt(P),ord(P^[0])+1); // next enumeration item
  result := -1;
end;

function TEnumType.GetEnumNameValue(Value: PUTF8Char): Integer;
var P: PShortString;
    L: integer;
begin
  P := @NameList;
  L := StrLen(Value);
  if L<>0 then
    for result := 0 to MaxValue do
      if IdemPropName(P^,Value,L) then
        exit else
        inc(PtrUInt(P),ord(P^[0])+1); // next enumeration item
  result := -1;
end;

{$ifdef HASINLINE}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
begin
  result := TrimLeftLowerCase(GetEnumName(Value));
end;
{$else}
{$ifdef PUREPASCAL}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
begin
  result := TrimLeftLowerCase(GetEnumName(Value));
end;
{$else}
function TEnumType.GetEnumNameTrimed(const Value): RawUTF8;
asm
  push ecx
  call TEnumType.GetEnumName
  pop edx
  jmp TrimLeftLowerCase
end;
{$endif}
{$endif}

function TEnumType.GetCaption(const Value): string;
// GetCaptionFromPCharLen() expect ASCIIz -> use temp RawUTF8
begin
  GetCaptionFromPCharLen(pointer(GetEnumNameTrimed(Value)),result);
end;

procedure TEnumType.AddCaptionStrings(Strings: TStrings; UsedValuesBits: Pointer=nil);
var i, L: integer;
    Line: array[byte] of AnsiChar;
    P: PAnsiChar;
    V: PShortString;
    s: string;
begin
  V := @NameList;
  for i := MinValue to MaxValue do begin
    if (UsedValuesBits=nil) or
       GetBit(UsedValuesBits^,i) then begin
      L := ord(V^[0]);
      P := @V^[1];
      while (L>0) and (P^ in ['a'..'z']) do begin // ignore left lowercase chars
        inc(P);
        dec(L);
      end;
      if L=0 then begin
        L := ord(V^[0]);
        P := @V^[1];
      end;
      Line[L] := #0; // GetCaptionFromPCharLen() expect it as ASCIIZ
      move(P^,Line,L);
      GetCaptionFromPCharLen(Line,s);
      Strings.AddObject(s,pointer(i));
    end;
    inc(PtrUInt(V),length(V^)+1);
  end;
end;

function TEnumType.GetCaptionStrings(UsedValuesBits: Pointer=nil): string;
var i, L: integer;
    Line: array[byte] of AnsiChar;
    P: PAnsiChar;
    V: PShortString;
    s: string;
begin
  result := '';
  V := @NameList;
  for i := MinValue to MaxValue do begin
    if (UsedValuesBits=nil) or GetBit(UsedValuesBits^,i) then begin
      L := ord(V^[0]);
      P := @V^[1];
      while (L>0) and (P^ in ['a'..'z']) do begin // ignore left lowercase chars
        inc(P);
        dec(L);
      end;
      if L=0 then begin
        L := ord(V^[0]);
        P := @V^[1];
      end;
      Line[L] := #0; // GetCaptionFromPCharLen() expect it as ASCIIZ
      move(P^,Line,L);
      GetCaptionFromPCharLen(Line,s);
      result := result+s+#13#10;
    end;
    inc(PtrUInt(V),length(V^)+1);
  end;
end;

function TEnumType.GetEnumNameTrimedValue(const EnumName: ShortString): Integer;
var P: PUTF8Char;
    L: integer;
    V: PShortString;
begin
  V := @NameList;
  for result := 0 to MaxValue do begin
    L := ord(V^[0]);
    P := @V^[1];
    while (L>0) and (P^ in ['a'..'z']) do begin
      inc(P);
      dec(L);
    end;
    if L=0 then begin // no uppercase in this enum value caption -> try whole
      if IdemPropName(EnumName,V^) then
        exit;
    end else // P^ points to the first uppercase char in this enum value caption
      if IdemPropName(EnumName,P,L) then
        exit;
    inc(PtrUInt(V),length(V^)+1);
  end;
  result := -1;
end;

function TEnumType.GetEnumNameTrimedValue(Value: PUTF8Char): Integer;
var EnumName: shortstring; // temporary string
begin
  if Value=nil then
    result := -1 else begin
    EnumName := Value;
    result := GetEnumNameTrimedValue(EnumName);
  end;
end;


{ TSQLRecordFill }

procedure TSQLRecordFill.AddMap(aRecord: TSQLRecord; aField: PPropInfo;
  aIndex: integer);
begin
  if (self<>nil) and (aRecord<>nil) then
    if fTableMapCount<length(fTableMap) then
      with fTableMap[fTableMapCount] do begin
        Dest := aRecord;
        DestField := aField;
        TableIndex := aIndex;
        inc(fTableMapCount);
      end else
{$ifdef WITHLOG}
     SQLite3Log.Add.Log(sllError,'Exceeds fTableMap[] size',aRecord);
{$endif}
end;

procedure TSQLRecordFill.AddMap(aRecord: TSQLRecord; const aFieldName: ShortString;
  aIndex: integer);
var aFieldIndex: integer;
begin
  if (self<>nil) and (aRecord<>nil) then
    if IsRowID(aFieldName) then
      AddMap(aRecord,nil,aIndex) else
      with aRecord.RecordProps do begin
        aFieldIndex := FieldIndex(aFieldName);
        if aFieldIndex>=0 then begin // only map if column is a valid field
          include(fTableMapFields,aFieldIndex);
          AddMap(aRecord,Fields[aFieldIndex],aIndex);
        end;
      end;
end;

destructor TSQLRecordFill.Destroy;
begin
  try
    UnMap; // release fTable instance if necessary
  finally
    inherited;
  end;
end;

function TSQLRecordFill.Fill(aRow: integer): Boolean;
begin
  if (self=nil) or (Table=nil) or (cardinal(aRow)>cardinal(Table.RowCount)) then
    Result := False else begin
    Fill(@Table.fResults[aRow*Table.FieldCount]);
    Result := True;
  end;
end;

function TSQLRecordFill.Fill(aRow: integer; aDest: TSQLRecord): Boolean;
begin
  if (self=nil) or (aDest=nil) or
     (Table=nil) or (cardinal(aRow)>cardinal(Table.RowCount)) then
    Result := False else begin
    Fill(@Table.fResults[aRow*Table.FieldCount],aDest);
    Result := True;
  end;
end;

procedure TSQLRecordFill.Fill(aTableRow: PPUtf8CharArray);
var f: integer;
begin
  if (self<>nil) and (aTableRow<>nil) then
    for f := 0 to fTableMapCount-1 do
      with fTableMap[f] do
        if DestField=nil then
          Dest.ID := GetInteger(aTableRow[TableIndex]) else
          DestField^.SetValue(Dest,aTableRow[TableIndex]);
end;

procedure TSQLRecordFill.Fill(aTableRow: PPUtf8CharArray; aDest: TSQLRecord);
var f: integer;
begin
  if (self<>nil) and (aTableRow<>nil) then
  for f := 0 to fTableMapCount-1 do
    with fTableMap[f] do
      if DestField=nil then
        aDest.ID := GetInteger(aTableRow[TableIndex]) else
        DestField^.SetValue(aDest,aTableRow[TableIndex]);
end;

procedure TSQLRecordFill.Map(aRecord: TSQLRecord; aTable: TSQLTable;
  aCheckTableName: TSQLCheckTableName);
var f: integer;
    ColumnName: PUTF8Char;
    FieldName: shortstring;
    Props: TSQLRecordProperties;
begin
  if (aTable=nil) or (aTable.fResults=nil) then // avoid any GPF
    exit;
  fTable := aTable;
  Props := aRecord.RecordProps;
  for f := 0 to aTable.FieldCount-1 do begin
    ColumnName := aTable.fResults[f];
    if aCheckTableName=ctnNoCheck then
      FieldName := ColumnName else
      if IdemPChar(ColumnName,pointer(Props.SQLTableNameUpperWithDot)) then
        FieldName := ColumnName+length(Props.SQLTableNameUpperWithDot) else
        if aCheckTableName=ctnMustExist then
          continue else
          FieldName := ColumnName;
    AddMap(aRecord,FieldName,f);
  end;
  fFillCurrentRow := 1; // point to first data row (0 is field names)
end;

procedure TSQLRecordFill.UnMap;
var i: integer;
begin
  if self=nil then
    exit;
  fTableMapCount := 0;
  fFillCurrentRow :=  0;
  // release TSQLRecordMany.fDestID^ instances set by TSQLRecord.FillPrepareMany()
  for i := 0 to high(fTableMapRecordManyInstances) do
  with fTableMapRecordManyInstances[i] do begin
    TObject(fDestID^).Free;
    fDestID^ := 0;
    fSourceID^ := 0;
  end;
  SetLength(fTableMapRecordManyInstances,0);
  FillChar(fTableMapFields,sizeof(fTableMapFields),0);
  SetLength(fTableMapFieldsColNames,0);
  // free any previous fTable if necessary
  if Table<>nil then
  try
    if Table.OwnerMustFree then
      Table.Free;
  finally
    fTable := nil;
  end;
end;

procedure TSQLRecordFill.SetMappedFieldsExpandedJSONWriter(aClass: TSQLRecordClass;
  W: TJSONWriter);
var i,n: integer;
begin // update ID, TModTime and FillPrepare mapped fields
  if (self=nil) or (W=nil) or (aClass=nil) then
    exit;
  if fTableMapRecordManyInstances<>nil then
    raise EBusinessLayerException.Create('SetMappedFieldsExpandedJSONWriter after FillPrepareMany');
  if fTableMapFieldsColNames=nil then
  with aClass.RecordProps do begin // init fTableMapFields[Max,ColNames] from mapping
    n := 1;
    for i := 0 to high(Fields) do
      if FieldType[i]=sftModTime then begin
        Include(fTableMapFields,i);
        inc(n);
      end else
      if i in fTableMapFields then
        inc(n);
    SetLength(fTableMapFieldsColNames,n);
    fTableMapFieldsColNames[0] := '"RowID":';
    n := 1;
    for i := 0 to high(Fields) do
      if i in fTableMapFields then begin // as in TJSONWriter.AddColumns
        fTableMapFieldsColNames[n] := '"'+FieldsName[i]+'":';
        fTableMapFieldsMax := i;
        inc(n);
      end;
    assert(length(fTableMapFieldsColNames)=n);
  end;
  W.Expand := true;
  W.WithID := true;
  W.FieldMax := fTableMapFieldsMax;
  W.Fields := fTableMapFields;
  W.ColNames := fTableMapFieldsColNames;
end;


{ TSQLRecord }

constructor TSQLRecord.Create;
var i: integer;
    O: TSQLRecordMany;
begin
  // auto-instanciate any TSQLRecordMany instance
  with RecordProps do
    if pointer(ManyFields)<>nil then
    for i := 0 to high(ManyFields) do begin
      O := TSQLRecordManyClass(ManyFields[i]^.PropType^^.ClassType^.ClassType).Create;
      {$ifdef USETYPEINFO} wrong code below because of esi=setter=nil {$endif}
      SetOrdProp(self,pointer(ManyFields[i]),PtrInt(O));
    end;
end;

function TSQLRecord.CreateCopy: TSQLRecord;
var i: integer;
begin
  // create new instance
  if self=nil then begin
    result := nil;
    exit;
  end;
  result := RecordClass.Create;
  // copy properties content
  result.fID := fID;
  with RecordProps do
    for i := 0 to high(Fields) do
    if FieldType[i] in COPIABLE_FIELDS then
      Fields[i]^.CopyValue(self,Result);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; aID: integer; ForUpdate: boolean=false);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aID,self,ForUpdate);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; aPublishedRecord: TSQLRecord; ForUpdate: boolean);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aPublishedRecord.ID,self,ForUpdate);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; const aSQLWhere: RawUTF8);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(aSQLWhere,self);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),self);
end;

constructor TSQLRecord.Create(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const ParamsSQLWhere, BoundsSQLWhere: array of const);
begin
  Create;
  if aClient<>nil then
    aClient.Retrieve(FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),self);
end;

class procedure TSQLRecord.InitializeTable(Server: TSQLRestServer; const FieldName: RawUTF8);
var f: integer;
begin // is not part of TSQLRecordProperties because has been declared as virtual
  if (self<>nil) and (Server<>nil) then
  with RecordProps do
  for f := 0 to high(Fields) do
    if FieldType[f] in [sftRecord, sftID] then
      if (FieldName='') or IdemPropNameU(FieldName,FieldsName[f]) then
          Server.CreateSQLIndex(self,FieldsName[f],false);
end;

procedure TSQLRecord.FillFrom(aRecord: TSQLRecord);
var i, f: integer;
    S, D: TSQLRecordProperties;
begin
  if (self=nil) or (aRecord=nil) or not InheritsFrom(aRecord.ClassType) then
    exit;
  if PPointer(aRecord)^=PPointer(Self)^ then
    fID := aRecord.fID;
  S := aRecord.RecordProps;
  D := RecordProps;
  for i := 0 to high(S.Fields) do
  if S.FieldType[i] in COPIABLE_FIELDS then
    for f := 0 to high(D.Fields) do
      if D.Fields[f]=S.Fields[i] then begin
        S.Fields[i].CopyValue(aRecord,Self);
        break;
      end;
end;

procedure TSQLRecord.FillFrom(Table: TSQLTable; Row: integer);
begin
  try
    FillPrepare(Table);
    if Table.InternalState<>fInternalState then
      fInternalState := Table.InternalState;
    FillRow(Row);
  finally
    FillClose; // avoid GPF in TSQLRecord.Destroy
  end;
end;

procedure TSQLRecord.FillFrom(const JSONTable: RawUTF8; Row: integer);
var Table: TSQLTableJSON;
    PrivateCopy: RawUTF8;
begin
  PrivateCopy := JSONTable;
  Table := TSQLTableJSON.Create([],'',@PrivateCopy[1],length(PrivateCopy));
  try
    FillFrom(Table,Row);
  finally
    Table.Free;
  end;
end;

procedure TSQLRecord.FillFrom(const JSONRecord: RawUTF8);
var tmp: pointer; // FillFrom() modifies the buffer memory: work on a copy
    P: PUTF8Char;
    L: integer;
begin
  P := pointer(JSONRecord);
  if P<>nil then begin
    L := PInteger(P-4)^+1; // +1 for last #0
    getmem(tmp,L);
    try
      move(P^,tmp^,L); // make a working copy of the JSON text (including #1)
      FillFrom(tmp); // now we can safely call FillFrom()
    finally
      Freemem(tmp);
    end;
  end;
end;

procedure TSQLRecord.FillFrom(P: PUTF8Char);
(* two possible formats = first not expanded, 2nd is expanded (most usefull)
 {"fieldCount":9,"values":["ID","Int","Test","Unicode","Ansi","ValFloat","ValWord",
  "ValDate","Next",0,0,"abcde+ef++","abcde+ef++","abcde+ef++",
  3.14159265300000E+0000,1203,"2009-03-10T21:19:36",0]}
 {"ID":0,"Int":0,"Test":"abcde+ef++","Unicode":"abcde+ef++","Ansi":
 "abcde+ef++","ValFloat": 3.14159265300000E+0000,"ValWord":1203,
 "ValDate":"2009-03-10T21:19:36","Next":0} *)
var F: array[0..MAX_SQLFIELDS-1] of PUTF8Char; // store field/property names
    i, n: integer;
    Prop: shortstring;   // temp shortstring used for property names
    Value: PUTF8Char;
begin
  // go to start of object
  if P=nil then
    exit;
  while P^<>'{' do
    if P^=#0 then exit else inc(P);
  if Expect(P,'{"fieldCount":') then begin
    // not expanded format
    n := GetJSONIntegerVar(P)-1;
    if (cardinal(n)>high(F)) or not Expect(P,',"values":[') then
      exit;
    for i := 0 to n do
      F[i] := GetJSONField(P,P); // get field names
    for i := 0 to n do begin
      Prop := F[i]; // share shortstring on stack with code below
      FillValue(Prop,GetJSONField(P,P)); // set properties from values
    end;
  end else
  if P^='{' then begin
    // expanded format
    inc(P);
    repeat
      Value := GetJSONField(P,P);  // get field name
      if P=nil then break;
      Prop := Value; // since Value may be nil, avoid GPF
      Value := GetJSONField(P,P); // get value
      FillValue(Prop,Value); // set property from value
    until P=nil;
  end;
end;

procedure TSQLRecord.FillPrepare(Table: TSQLTable; aCheckTableName: TSQLCheckTableName);
begin
  if self=nil then
    exit;
  if fFill=nil then
    fFill := TSQLRecordFill.Create else
    fFill.UnMap;
  fFill.Map(self,Table,aCheckTableName);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; const aSQLWhere: RawUTF8;
  const aCustomFieldsCSV: RawUTF8; aCheckTableName: TSQLCheckTableName): boolean;
var T: TSQLTable;
begin
  result := false;
  FillClose; // so that no further FillOne will work
  if (self=nil) or (aClient=nil) then
    exit;
  if aCustomFieldsCSV='' then
    T := aClient.InternalListRecordsJSON(RecordClass,aSQLWhere) else
    T := aClient.InternalListJSON(RecordClass,aCustomFieldsCSV,aSQLWhere);
  if T=nil then
    exit;
  T.OwnerMustFree := true;
  FillPrepare(T,aCheckTableName);
  result := true;
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8=''): boolean;
begin
  if (FormatSQLWhere=nil) or (high(BoundsSQLWhere)<0) then
    result := false else
    result := FillPrepare(aClient,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),
      aCustomFieldsCSV);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const ParamsSQLWhere, BoundsSQLWhere: array of const;
  const aCustomFieldsCSV: RawUTF8): boolean;
begin
  if (FormatSQLWhere=nil) or ((high(ParamsSQLWhere)<0)and(high(BoundsSQLWhere)<0)) then
    result := false else
    result := FillPrepare(aClient,
      FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),aCustomFieldsCSV);
end;

function TSQLRecord.FillPrepare(aClient: TSQLRest; const aIDs: TIntegerDynArray;
  const aCustomFieldsCSV: RawUTF8=''): boolean;
begin
  if aIDs=nil then
    result := false else
    result := FillPrepare(aClient,
      IntegerDynArrayToCSV(aIDs,length(aIDs),'ID in (',')'),aCustomFieldsCSV);
end;

procedure TSQLRecord.FillRow(aRow: integer; aDest: TSQLRecord=nil);
begin
  if self<>nil then
    if aDest=nil then
      fFill.Fill(aRow) else
      if fFill.fTableMapRecordManyInstances=nil then
        fFill.Fill(aRow,aDest) else
        raise EBusinessLayerException.Create('FillRow() forbidden after FillPrepareMany');
end;

function TSQLRecord.FillOne: boolean;
begin
  if (self=nil) or (fFill=nil) or (fFill.Table=nil) or
     (fFill.Table.RowCount=0) or // also check if FillTable is emtpy
     (cardinal(fFill.FillCurrentRow)>cardinal(fFill.Table.RowCount)) then
    result := false else begin
    FillRow(fFill.FillCurrentRow);
    inc(fFill.fFillCurrentRow);
    result := true;
  end;
end;

function TSQLRecord.FillRewind: boolean;
begin
  if (self=nil) or (fFill=nil) or (fFill.Table=nil) or (fFill.Table.RowCount=0) then
    result := false else begin
    fFill.fFillCurrentRow := 1;
    result := true;
  end;
end;

procedure TSQLRecord.FillClose;
begin
  if self<>nil then
    fFill.UnMap;
end;

procedure TSQLRecord.FillValue(const PropName: ShortString; Value: PUTF8Char);
begin
  if self<>nil then
    if IsRowID(PropName) then
      fID := GetInteger(Value) else
      RecordProps.FieldProp(PropName)^.SetValue(self,Value);
end;


const
  SQLFieldTypeToVType: array[TSQLFieldType] of word =
    (varEmpty,       // sftUnknown
     varString,      // sftAnsiText
     varString,      // sftUTF8Text
     varInt64,       // sftEnumerate
     varInt64,       // sftSet
     varInt64,       // sftInteger
     varInt64,       // sftID
     varInt64,       // sftRecord
     varInt64,       // sftBoolean
     varDouble,      // sftFloat
     varString,      // sftDateTime
     varInt64,       // sftTimeLog
     varDouble,      // sftCurrency
     varString,      // sftObject
     varAny,         // sftBlob
     varAny,         // sftBlobDynArray
{$ifdef PUBLISHRECORD}
     varAny,         // sftBlobRecord
{$endif}
     varEmpty,       // sftMany
     varInt64,       // sftModTime
     varInt64);      // sftCreateTime

procedure TSQLRecord.GetFieldVarData(aFieldIndex: integer;
  var aValue: TVarData; var temp: RawByteString);
var aType: TSQLFieldType;
    aField: PPropInfo;
begin
  if aFieldIndex<0 then begin
    aValue.VType := varInt64;
    aValue.VInt64 := fID;
  end else
  with RecordProps do
    if aFieldIndex>=length(FieldType) then
      aValue.VType := varNull else begin
      aType := FieldType[aFieldIndex];
      aField := Fields[aFieldIndex];
      aValue.VType := SQLFieldTypeToVType[aType];
      case aValue.VType of
        varInt64:
          aValue.VInt64 := aField.GetInt64Value(self);
        varDouble:
          aValue.VDouble := GetFloatProp(self,aField);
        varString: begin
          aField.GetValueVar(self,false,RawUTF8(temp),nil); // handle also sftObject
          aValue.VString := pointer(temp);
        end;
        varAny: begin
          case aType of
            sftBlob:
              GetLongStrProp(self,aField,temp);
            sftBlobDynArray:
              temp := aField^.GetDynArray(self).SaveTo;
{$ifdef PUBLISHRECORD}
            sftBlobRecord:
              with aField^ do
                temp := RecordSave(GetFieldAddr(self)^,PropType^);
{$endif}  end;
          aValue.VPointer := pointer(temp);
          aValue.VLongs[0] := length(temp);
        end;
      end;
    end;
end;

function TSQLRecord.SetFieldVarData(aFieldIndex: integer;
  const aValue: TVarData): boolean;
var aType: TSQLFieldType;
    aField: PPropInfo;
    tmp: RawByteString;
begin
  result := false;
  if aFieldIndex<0 then
    if aValue.VType=varInt64 then
      fID := aValue.VInt64 else
      exit else
  with RecordProps do
    if aFieldIndex<length(FieldType) then begin
      aField := Fields[aFieldIndex];
      aType := FieldType[aFieldIndex];
      if SQLFieldTypeToVType[aType]=aValue.VType then // exact type match
      case aValue.VType of
        varInt64:  aField^.SetInt64Value(self,aValue.VInt64);
        varDouble: SetFloatProp(self,aField,aValue.VDouble);
        varString: aField^.SetValue(self,aValue.VString); // sftObject ready 
        varAny:
          case aType of
          sftBlob: begin
            SetString(tmp,PAnsiChar(aValue.VPointer),aValue.VLongs[0]);
            SetLongStrProp(self,aField,tmp);
          end;
          sftBlobDynArray:
            aField^.GetDynArray(self).LoadFrom(aValue.VPointer);
{$ifdef PUBLISHRECORD}
          sftBlobRecord:
            RecordLoad(aField^.GetFieldAddr(self)^,aValue.VPointer,aField^.PropType^);
{$endif}  end;
        else exit;
      end else
      case aValue.VType of // no type match -> best guess
        varString:
          aField^.SetValue(self,aValue.VString);
        varInt64:
          aField^.SetValue(self,pointer(Int64ToUtf8(aValue.VInt64)));
        varDouble:
          aField^.SetValue(self,pointer(ExtendedToStr(aValue.VDouble,DOUBLE_PRECISION)));
        else exit;
      end;
    end else
    exit;
  result := true;
end;

function TSQLRecord.SetFieldVarDatas(const Values: TVarDataDynArray): boolean;
var max, field: integer;
begin
  result := false;
  max := high(Values);
  with RecordProps do
    // expect exact Values[] type match with FieldType[]
    if max<>high(FieldType) then // must match field count
      exit else
    for field := 0 to max do
      if SQLFieldTypeToVType[FieldType[field]]<>Values[field].VType then
        exit;
  // now we can safely update field values
  for field := 0 to max do
    SetFieldVarData(field,Values[field]);
  result := true;
end;

procedure TSQLRecord.GetBinaryValues(W: TFileBufferWriter);
var f: integer;
begin
  with RecordProps do
    for f := 0 to high(Fields) do
      Fields[f]^.GetBinary(self,W);
end;

function TSQLRecord.SetBinaryValues(var P: PAnsiChar): boolean;
var f: integer;
begin
  result := false;
  with RecordProps do
    for f := 0 to high(Fields) do begin
      P := Fields[f]^.SetBinary(self,P);
      if P=nil then
        exit;
    end;
  result := true;
end;

procedure TSQLRecord.GetJSONValues(W: TJSONSerializer);
var i,n: integer;
    v: RawUTF8;
    isString: boolean;
label txt,txt1;
begin
  if self=nil then
    exit;
  // write the row data
  if W.Expand then begin
    W.Add('{');
    if W.WithID then
      W.AddString(W.ColNames[0]);
  end;
  if W.WithID then begin
    W.Add(fID);
    W.Add(',');
    n := 1;
  end else
    n := 0;
  with RecordProps do
  for i := 0 to High(Fields) do
    if i in W.Fields then begin
      if W.Expand then begin
        W.AddString(W.ColNames[n]); // '"'+ColNames[]+'":'
        inc(n);
      end;
      case FieldType[i] of
        sftSet, sftID, sftRecord, sftEnumerate:
          W.AddU(GetOrdProp(self,Fields[i]));
        sftTimeLog, sftModTime, sftCreateTime:
          W.Add(GetInt64Prop(self,Fields[i]));
        sftInteger:
          W.Add(Fields[i].GetInt64Value(self));
        sftBoolean:
          W.AddString(JSON_BOOLEAN[boolean(GetOrdProp(self,Fields[i]))]);
        sftFloat:
          W.Add(GetFloatProp(self,Fields[i]));
        sftCurrency:
          W.AddCurr64(GetInt64Prop(self,Fields[i]));
        sftDateTime: begin
          W.Add('"');
          W.AddDateTime(GetFloatProp(self,Fields[i]));
          W.Add('"');
        end;
        sftBlobDynArray: begin
{         // '[1,2,3,4]' or '["\uFFF0base64encodedbinary"]'
          if W.Expand then
            // write as'[1,2,3,4]' or '["\uFFF0base64encodedbinary"]'
            W.AddDynArrayJSON(Fields[i]^.GetDynArray(self)) else         }
          // write as '"\uFFF0base64encodedbinary"'
          v := Fields[i]^.GetDynArray(self).SaveTo;
          W.WrBase64(pointer(v),length(v),true); // withMagic=true
        end;
{$ifdef PUBLISHRECORD}
        sftBlobRecord:
          with Fields[i]^ do W.WrRecord(GetFieldAddr(self)^,PropType^);
{$endif}sftObject: // faster than Fields[i]^.GetValue (avoid most memory alloc)
          W.WriteObject(TObject(GetOrdProp(self,Fields[i])),false,true,false);
        sftBlob:
          if Fields[i]^.PropType^=TypeInfo(TSQLRawBlob) then begin
            GetLongStrProp(self,Fields[i],RawByteString(v));
            W.WrBase64(pointer(v),length(v),true); // withMagic=true -> add ""
          end else
            goto txt;
        sftUTF8Text: // speed improvement for RawUTF8 fields
          if Fields[i]^.PropType^=TypeInfo(RawUTF8) then begin
            GetLongStrProp(self,Fields[i],RawByteString(v));
            goto txt1;
          end else
            goto txt;
      else begin
        // this will work with all other kind of fields
txt:    Fields[i]^.GetValueVar(self,false,v,@isString);
        if isString then begin
txt1:     W.Add('"');
          if PtrUInt(v)<>0 then
            W.AddJSONEscape(pointer(v),PInteger(PtrUInt(v)-4)^);
          W.Add('"');
        end else
          if PtrUInt(v)<>0 then
            W.AddNoJSONEscape(pointer(v),PInteger(PtrUInt(v)-4)^);
      end;
      end;
      W.Add(',');
    end;
  W.CancelLastComma; // cancel last ','
  if W.Expand then
    W.Add('}');
end;

procedure TSQLRecord.GetJSONValues(JSON: TStream; Expand: boolean; withID: boolean;
  Occasion: TSQLOccasion);
var W: TJSONSerializer;
begin
  if self=nil then
    exit;
  // get col names and types
  with RecordProps do
    W := CreateJSONWriter(JSON,Expand,withID,SimpleFieldsBits[Occasion],0);
  if W<>nil then
  try
    // write the row data
    GetJSONValues(W);
    // end the JSON object
    if not Expand then
      W.AddNoJSONEscape(PAnsiChar(']}'),2);
    W.Flush;
  finally
    W.Free;
  end;
end;

function TSQLRecord.GetJSONValues(Expand: boolean; withID: boolean;
  Occasion: TSQLOccasion; UsingStream: TCustomMemoryStream=nil): RawUTF8;
var J: TRawByteStringStream;
begin
  if UsingStream<>nil then begin
    UsingStream.Seek(0,soFromBeginning);
    GetJSONValues(UsingStream,Expand,withID,Occasion);
    SetString(result,PAnsiChar(UsingStream.Memory),UsingStream.Seek(0,soFromCurrent));
  end else begin
    J := TRawByteStringStream.Create;
    try
      GetJSONValues(J,Expand,withID,Occasion);
      result := J.DataString;
    finally
      J.Free;
    end;
  end;
end;

const
  /// simple wrapper from each SQL used type into SQLite3 field datatype
  // - set to '' for fields with no column created in the database
  SQLFieldTypeToSQL: array[TSQLFieldType] of RawUTF8 =
   ('',                              // sftUnknown
    ' TEXT COLLATE NOCASE, ',        // sftAnsiText
    ' TEXT COLLATE SYSTEMNOCASE, ',  // sftUTF8Text
    ' INTEGER, ',                    // sftEnumerate
    ' INTEGER, ',                    // sftSet
    ' INTEGER, ',                    // sftInteger
    ' INTEGER, ',                    // sftID
    ' INTEGER, ',                    // sftRecord
    ' INTEGER, ',                    // sftBoolean
    ' FLOAT, ',                      // sftFloat
    ' TEXT COLLATE ISO8601, ',       // sftDateTime
    ' INTEGER, ',                    // sftTimeLog
    ' FLOAT, ',                      // sftCurrency
    ' TEXT COLLATE NOCASE, ',        // sftObject
    ' BLOB, ',                       // sftBlob
    ' BLOB, ',                       // sftBlobDynArray
{$ifdef PUBLISHRECORD}
    ' BLOB, ',                       // sftBlobRecord
{$endif}
    '',                              // sftMany
    ' INTEGER, ',                    // sftModTime
    ' INTEGER, ');                   // sftCreateTime

function GetVirtualTableSQLCreate(Props: TSQLRecordProperties): RawUTF8;
var i: integer;
    SQL: RawUTF8;
begin
  result := ''; // RowID is added by sqlite3_declare_vtab() for a Virtual Table 
  for i := 0 to high(Props.FieldType) do begin
    SQL := SQLFieldTypeToSQL[Props.FieldType[i]];
    if SQL<>'' then
      Props.Fields[i]^.AppendName(result,SQL);
  end;
  pWord(@result[length(result)-1])^ := ord(')')+ord(';')shl 8;
end;

class function TSQLRecord.GetSQLCreate(aModel: TSQLModel): RawUTF8;
// not implemented in TSQLRecordProperties since has been made virtual
var i, n: integer;
    SQL: RawUTF8;
    M: TSQLVirtualTableClass;
begin
  if self<>nil then
  with RecordProps do begin
    n := length(FieldType);
    if Kind<>rSQLite3 then begin
      // create a FTS3/FTS4/RTREE virtual table
      result := 'CREATE VIRTUAL TABLE '+SQLTableName+' USING ';
      case Kind of
      rFTS3:  result := result+'fts3(';
      rFTS4:  result := result+'fts4(';
      rRTree: result := result+'rtree(ID,';
      rCustomForcedID, rCustomAutoID: begin
        M := aModel.VirtualTableModule(self);
        if M=nil then
          raise EModelException.CreateFmt('No registered module for %s',[ClassName]);
        result := result+M.ModuleName+'('+GetVirtualTableSQLCreate(RecordProps);
      end;
      end;
      case Kind of
      rFTS3, rFTS4: begin
        for i := 0 to n-1 do
          if FieldType[i]<>sftUTF8Text then
            raise EModelException.CreateFmt('%s.%s: FTS3/FTS4 field must be RawUTF8',
              [SQLTableName,FieldsName[i]]) else
            Fields[i]^.AppendName(result,',');
        if InheritsFrom(TSQLRecordFTS3Porter) or
           InheritsFrom(TSQLRecordFTS4Porter) then
          result := result+' tokenize=porter)' else
          result := result+' tokenize=simple)';
      end;
      rRTree: begin
        if (n<3) or (n>RTREE_MAX_DIMENSION*2+1) or (n and 2<>1) then
          raise EModelException.CreateFmt('%d: %s RTREE expects an odd 3..%d column number',
            [n,SQLTableName,RTREE_MAX_DIMENSION*2+1]);
        for i := 0 to n-1 do
          if FieldType[i]<>sftFloat then
            raise EModelException.CreateFmt('%s.%s: RTREE field must be double',
              [SQLTableName,FieldsName[i]]) else
            Fields[i]^.AppendName(result,',');
        result[length(result)] := ')';
      end;
      end;
    end else begin
      // inherits from TSQLRecord: create a "normal" SQLite3 table
      result := 'CREATE TABLE '+SQLTableName+
        '(ID INTEGER PRIMARY KEY AUTOINCREMENT, ';
      // we always add an ID field which is an INTEGER PRIMARY KEY
      // column, as it is always created (as hidden ROWID) by the SQLite3 engine
      for i := 0 to n-1 do begin
        SQL := SQLFieldTypeToSQL[FieldType[i]];
        if SQL<>'' then begin
          Fields[i]^.AppendName(result,SQL);
          if i in IsUniqueFieldsBits then
            insert(' UNIQUE',result,length(result)-1);
        end;
      end;
      pWord(@result[length(result)-1])^ := ord(')')+ord(';')shl 8;
    end;
  end else
    result := '';
end;

function TSQLRecord.GetSQLSet: RawUTF8;
var i: integer;
    V: RawUTF8;
    wasString: boolean;
begin
  result := '';
  if self=nil then
    exit;
  with RecordProps do
    for i := 0 to High(SimpleFields) do begin
      // format is 'COL1='VAL1', COL2='VAL2'' }
      SimpleFields[i]^.AppendName(result,'=');
      SimpleFields[i]^.GetValueVar(self,true,V,@wasString);
      if wasString then
        result := result+''''+V+''', ' else
        result := result+V+', ';
    end;
  if result<>'' then
    SetLength(result,length(result)-2);
end;

function TSQLRecord.GetSQLValues: RawUTF8;
var i: integer;
    V: RawUTF8;
    wasString: boolean;
begin
  result := '';
  if self<>nil then
  with RecordProps do
    if SimpleFields=nil then
      exit else begin
    if HasNotSimpleFields then // get 'COL1,COL2': no 'ID,' for INSERT (false below)
      result := SQLTableSimpleFields[false,false]; // always <> '*'
    result := result+' VALUES (';
    for i := 0 to high(SimpleFields) do begin
      SimpleFields[i]^.GetValueVar(self,true,V,@wasString);
      if wasString then
        result := result+''''+V+''',' else
        result := result+V+',';
    end;
    result[length(result)] := ')';
  end;
end;

class function TSQLRecord.CaptionName(Action: PShortString=nil; ForHint: boolean=false): string;
var tmp: RawUTF8;
begin
  if self=nil then
    result := '' else begin
    if Action=nil then
      tmp := RecordProps.SQLTableName else
      tmp := TrimLeftLowerCase(Action);
    GetCaptionFromPCharLen(pointer(tmp),result);
  end;
end;

function TSQLRecord.SameValues(Reference: TSQLRecord): boolean;
var O: PPropInfo;
    i: integer;
begin
  result := false;
  if (self=nil) or (Reference=nil) then
    exit;
  if Reference.fID<>fID then // ID field must be tested by hand
    exit;
  with Reference.RecordProps do
    for i := 0 to high(SimpleFields) do begin
      // compare not TSQLRawBlob/TSQLRecordMany fields
      O := RecordProps.FieldProp(SimpleFields[i]^.Name);
      if O=nil then
        exit; // this Reference property doesn't exist in current object
      if SimpleFields[i]^.GetValue(Reference,false,nil)<>O^.GetValue(self,false,nil) then
        exit; // properties don't have the same value
    end;
  result := true;
end;

function TSQLRecord.SameRecord(Reference: TSQLRecord): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (Reference=nil) or
     (PPointer(Reference)^<>PPointer(Self)^) or (Reference.fID<>fID) then
    exit;
  with RecordProps do
    for i := 0 to high(SimpleFields) do
      // compare not TSQLRawBlob/TSQLRecordMany fields
      with SimpleFields[i]^ do
        if GetValue(Reference,true,nil)<>GetValue(self,true,nil) then
          exit; // properties don't have the same value
  result := true;
end;

procedure TSQLRecord.ClearProperties;
var i: integer;
begin
  if self=nil then
    exit;
  fInternalState := 0;
  fID := 0;
  with RecordProps do
    for i := 0 to high(Fields) do
    if FieldType[i] in COPIABLE_FIELDS then
      Fields[i]^.SetValue(self,nil);
end;

{$IFDEF PUREPASCAL}
function TSQLRecord.RecordClass: TSQLRecordClass; 
begin
  if self=nil then
    Result := nil else
    Pointer(Result) := PPointer(Self)^;
end;
{$else}
function TSQLRecord.RecordClass: TSQLRecordClass;
asm
  or eax,eax; jz @z
  mov eax,[eax]
@z:
end;
{$endif}

{$IFDEF PUREPASCAL}
function TSQLRecord.ClassProp: PClassProp; 
begin
  if self<>nil then
    result := InternalClassProp(PPointer(Self)^) else
    result := nil; // avoid GPF
end;
{$else}
function TSQLRecord.ClassProp: PClassProp;
asm
  or eax,eax; jz @z // avoid GPF
  mov eax,[eax] // get ClassType of this TSQLRecord instance
  or eax,eax; jz @z // avoid GPF
  mov eax,[eax+vmtTypeInfo]
  or eax,eax; jz @z // avoid GPF
  movzx edx,byte ptr [eax].TTypeInfo.Name
  lea eax,[eax+edx].TTypeInfo.Name[1]
  movzx edx,byte ptr [eax].TClassType.UnitName
  lea eax,[eax+edx].TClassType.UnitName[1].TClassProp
@z:
end;
{$endif}

function TSQLRecord.RecordReference(Model: TSQLModel): TRecordReference;
begin
  if (self=nil) or (fID<=0) then
    result := 0 else begin
    result := Model.GetTableIndex(TSQLRecordClass(PPointer(Self)^));
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,fID shl 6);
  end;
end;

destructor TSQLRecord.Destroy;
var i: integer;
begin
  if fFill<>nil then
    fFill.Free; // call UnMap -> release fTable instance if necessary
  with RecordProps do
    // free all TSQLRecordMany instances created by TSQLRecord.Create
    if pointer(ManyFields)<>nil then
    for i := 0 to high(ManyFields) do
      TSQLRecordMany(GetOrdProp(self,pointer(ManyFields[i]))).Free;
  inherited;
end;

function TSQLRecord.SimplePropertiesFill(const aSimpleFields: array of const): boolean;
var i: integer;
    tmp: RawUTF8;
begin
  if self=nil then
    result := false else // means error
    with RecordProps do
    if length(SimpleFields)<>length(aSimpleFields) then
      result := false else begin
      for i := 0 to high(aSimpleFields) do begin
        VarRecToUTF8(aSimpleFields[i],tmp); // will work for every handled type
        SimpleFields[i]^.SetValue(self,Pointer(tmp));
      end;
      result := True;
    end;
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  const aSQLWhere: RawUTF8; const aCustomFieldsCSV: RawUTF8='');
var aTable: TSQLTable;
begin
  Create;
  if aCustomFieldsCSV='' then
    aTable := aClient.InternalListRecordsJSON(RecordClass,aSQLWhere) else
    aTable := aClient.InternalListJSON(RecordClass,aCustomFieldsCSV,aSQLWhere);
  if aTable=nil then
    exit;
  aTable.OwnerMustFree := true;
  FillPrepare(aTable);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const;
  const aCustomFieldsCSV: RawUTF8='');
begin
  CreateAndFillPrepare(aClient,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere),
    aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  FormatSQLWhere: PUTF8Char; const ParamsSQLWhere,
  BoundsSQLWhere: array of const; const aCustomFieldsCSV: RawUTF8);
begin
  CreateAndFillPrepare(aClient,
    FormatUTF8(FormatSQLWhere,ParamsSQLWhere,BoundsSQLWhere),aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepare(aClient: TSQLRest;
  const aIDs: TIntegerDynArray; const aCustomFieldsCSV: RawUTF8='');
begin
  Create;
  FillPrepare(aClient,aIDs,aCustomFieldsCSV);
end;

constructor TSQLRecord.CreateAndFillPrepareMany(aClient: TSQLRest;
  aFormatSQLJoin: PUTF8Char; const aParamsSQLJoin, aBoundsSQLJoin: array of const);
begin
  Create;
  FillPrepareMany(aClient,aFormatSQLJoin,aParamsSQLJoin,aBoundsSQLJoin);
end;

function TSQLRecord.FillPrepareMany(aClient: TSQLRest;
  aFormatSQLJoin: PUTF8Char; const aParamsSQLJoin, aBoundsSQLJoin: array of const): boolean;
var aSQLFields, aSQLFrom, aSQLWhere, aSQL: RawUTF8;
    aField: string[3];
    aMany: RawUTF8;
    f, n, i, SQLFieldsCount: Integer;
    Props: TSQLRecordProperties;
    T: TSQLTable;
    SQLFields: array of record
      SQL: string[3];
      Prop: PPropInfo;
      Instance: TSQLRecord;
    end;
    FN: PShortString;
    M: TSQLRecordMany;
    D: TSQLRecord;
    P: PUTF8Char;
    Objects: array of TSQLRecord;
    ObjectsClass: array of TSQLRecordClass;

  function AddField(aProp: PPropInfo): Boolean;
  begin
    if SQLFieldsCount>=MAX_SQLFIELDS then
      result := false else
      with SQLFields[SQLFieldsCount] do begin
        SQL := aField;
        Prop := aProp;
        Instance := Objects[f];
        inc(SQLFieldsCount);
        result := true;
      end;
  end;
  function ProcessField(var P: PUTF8Char): RawUTF8;
  var B: PUTF8Char;
      i: integer;
      M: TSQLRecordMany;
      aManyField: string[63];
    function GetManyField(F: PUTF8Char): boolean;
    var B: PUTF8Char;
    begin
      result := true;
      B := F;
      while ord(F^) in IsIdentifier do inc(F); // go to end of sub-field name
      if B=F then begin
        result := false;
        exit;
      end;
      dec(B,2); // space for 'C.'
      SetString(aManyField,B,F-B);
      aManyField[2] := '.';
      P := F;
    end;
  begin
    B := P;
    while ord(P^) in IsIdentifier do inc(P); // go to end of field name
    SetString(result,B,P-B);
    if (result='') or IdemPropNameU(result,'AND') or IdemPropNameU(result,'OR') or
       IdemPropNameU(result,'LIKE') or IdemPropNameU(result,'NOT') or
       IdemPropNameU(result,'NULL') then
      exit;
    if not IsRowID(pointer(result)) then begin
      i := Props.FieldIndexFromRawUTF8(result);
      if i<0 then
        exit;
      if Props.FieldType[i]=sftMany then begin
        M := TSQLRecordMany(GetOrdProp(self,pointer(Props.Fields[i])));
        assert(M<>nil);
        for i := 0 to n-1 do
        if Objects[i*2+1]=M then begin
          if IdemPChar(P,'.DEST.') then begin // special case of Many.Dest.*
            if GetManyField(P+6) then begin
              aManyField[1] := AnsiChar(i*2+67);
              result := RawUTF8(aManyField);
              exit; // Categories.Dest.Name=? -> C.Name=?
            end;
          end else
          if (P^='.') and GetManyField(P+1) then begin
            aManyField[1] := AnsiChar(i*2+66);
            result := RawUTF8(aManyField);
            exit;  // Categories.Kind=? -> CC.Kind=?
          end;
        end;
        exit;
      end;
    end;
    result := 'A.'+result; // Owner=? -> A.Owner=?
  end;

begin
  result := false;
  FillClose; // so that no further FillOne will work
  if (self=nil) or (aClient=nil) then
    exit;
  // reset TSQLRecordFill object
  if fFill=nil then
    fFill := TSQLRecordFill.Create else
    fFill.UnMap;
  // compute generic joined SQL statement and initialize Objects*[]+SQLFields[]
  SetLength(SQLFields,MAX_SQLFIELDS);
  Props := RecordProps;
  n := Length(Props.ManyFields);
  SetLength(Objects,n*2+1);
  SetLength(ObjectsClass,n*2+1);
  Objects[0] := self;
  ObjectsClass[0] := PPointer(self)^;
  SetLength(fFill.fTableMapRecordManyInstances,n);  // fFill.UnMap will release memory
  for f := 0 to n-1 do begin
    M := TSQLRecordMany(GetOrdProp(self,pointer(Props.ManyFields[f])));
    assert(M<>nil,'TSQLRecord.Create should have created TSQLRecordMany instances');
    fFill.fTableMapRecordManyInstances[f] := M;
    Objects[f*2+1] := M;
    ObjectsClass[f*2+1] := PPointer(M)^;
    with M.RecordProps do begin
      Assert((fRecordManySourceClass=PPointer(self)^) and (fRecordManyDestClass<>nil));
      ObjectsClass[f*2+2] := fRecordManyDestClass;
      D := fRecordManyDestClass.Create;
      // let TSQLRecordMany.Source and Dest point to real instances
      M.fSourceID^ := PtrInt(self);
      M.fDestID^ := PtrInt(D);
    end;
    Objects[f*2+2] := TSQLRecord(M.fDestID^);
    if Props.fSQLFillPrepareMany='' then begin
      aMany := AnsiChar(f*2+66); // Many=B,D,F...
      if aSQLWhere<>'' then
        aSQLWhere := aSQLWhere+' and ';
      aSQLWhere := FormatUTF8('%%.Source=A.RowID and %.Dest=%.RowID',
        [aSQLWhere,aMany,aMany,AnsiChar(f*2+67){Dest=C,E,G..}]);
    end;
  end;
  SQLFieldsCount := 0;
  aField := 'A00';
  for f := 0 to high(ObjectsClass) do
    with ObjectsClass[f].RecordProps do begin
      PWord(@aField[2])^ := ord('I')+ord('D')shl 8;
      if not AddField(nil) then
        Exit; // try to add the ID field
      if Props.fSQLFillPrepareMany='' then begin
        if aSQLFields<>'' then
          aSQLFields := aSQLFields+',';
          aSQLFields := FormatUTF8('%%.RowID %',[aSQLFields,aField[1],aField]);
      end;
      for i := 0 to high(SimpleFields) do begin
        FN := @SimpleFields[i]^.Name;
        if (f and 1=0) {self/dest} or
           not(IdemPropName(FN^,'SOURCE') or IdemPropName(FN^,'DEST')) {many} then begin
          PWord(@aField[2])^ := TwoDigitLookupW[i];
          if not AddField(SimpleFields[i]) then
            Exit; // try to add this simple field
          if Props.fSQLFillPrepareMany='' then
            aSQLFields := FormatUTF8('%,%.% %',[aSQLFields,aField[1],FN^,aField]);
        end;
      end;
      if Props.fSQLFillPrepareMany='' then begin
        if aSQLFrom<>'' then
          aSQLFrom := aSQLFrom+',';
        aSQLFrom := aSQLFrom+SQLTableName+' '+RawUTF8(aField[1]);
      end;
      inc(aField[1]);
    end;
  if Props.fSQLFillPrepareMany<>'' then
    aSQL := Props.fSQLFillPrepareMany else begin
    aSQL := FormatUTF8('select % from % where %',[aSQLFields,aSQLFrom,aSQLWhere]);
    Props.fSQLFillPrepareMany := aSQL;
  end;
  // process aFormatSQLJoin,aParamsSQLJoin and aBoundsSQLJoin parameters
  if aFormatSQLJoin<>nil then begin
    aSQLWhere := '';
    repeat
      P := aFormatSQLJoin;
      while not (ord(P^) in IsIdentifier) do begin
        case P^ of
        '"':  repeat inc(P) until P^ in [#0,'"'];
        '''': repeat inc(P) until P^ in [#0,''''];
        end;
        if P^=#0 then break;
        inc(P);
      end;
      if P<>aFormatSQLJoin then begin // append ' ',')'..
        SetString(aSQLFrom,aFormatSQLJoin,P-aFormatSQLJoin);
        aSQLWhere := aSQLWhere+aSQLFrom;
        aFormatSQLJoin := P;
      end;
      if P^=#0 then break;
      aSQLWhere := aSQLWhere+ProcessField(aFormatSQLJoin);
    until aFormatSQLJoin^=#0;
    aSQL := aSQL+' and ('+FormatUTF8(pointer(aSQLWhere),aParamsSQLJoin,aBoundsSQLJoin)+')';
  end;
  // execute SQL statement and retrieve data
  T := aClient.ExecuteList(ObjectsClass,aSQL);
  if (T=nil) or (T.fResults=nil) then
    exit;
  fFill.fTable := T;
  T.OwnerMustFree := true;
  // map fields
  assert(T.FieldCount=SQLFieldsCount);
  for i := 0 to SQLFieldsCount-1 do
    assert(IdemPropName(SQLFields[i].SQL,T.fResults[i],StrLen(T.fResults[i])));
  for i := 0 to SQLFieldsCount-1 do
    with SQLFields[i] do
      fFill.AddMap(Instance,Prop,i);
  fFill.fFillCurrentRow := 1; // point to first data row (0 is field names)
  result := true;
end;

function TSQLRecord.GetID: integer;
begin
  if PtrUInt(self)<PtrUInt(SystemInfo.lpMinimumApplicationAddress) then
    // was called from a TSQLRecord property (sftID type)
    // (will return 0 if current instance is nil)
    result := PtrUInt(self) else
    // was called from a read TSQLRecord instance
    result := fID;
end;

function TSQLRecord.GetHasBlob: boolean;
begin
  if Self=nil then
    result := false else
    result := RecordProps.BlobFields<>nil;
end;

function TSQLRecord.GetSimpleFieldCount: integer;
begin
  if Self=nil then
    result := 0 else
    result := length(RecordProps.SimpleFields);
end;

function TSQLRecord.GetFillCurrentRow: integer;
begin
  if (self=nil) or (fFill=nil) then
    result := 0 else
    result := fFill.FillCurrentRow;
end;

function TSQLRecord.GetTable: TSQLTable;
begin
  if (self=nil) or (fFill=nil) then
    result := nil else
    result := fFill.Table;
end;

function TSQLRecord.GetFieldValue(const PropName: RawUTF8): RawUTF8;
var P: PPropInfo;
begin
  result := '';
  if self=nil then
    exit;
  P := RecordProps.FieldPropFromRawUTF8(PropName);
  if P<>nil then
    P^.GetValueVar(self,False,result,nil);
end;

procedure TSQLRecord.SetFieldValue(const PropName: RawUTF8;
  Value: PUTF8Char);
var P: PPropInfo;
begin
  if self=nil then
    exit;
  P := RecordProps.FieldPropFromRawUTF8(PropName);
  if P<>nil then
    P^.SetValue(self,pointer(Value));
end;

{$ifdef USEVARIANTS}
function TSQLRecord.GetFieldVariant(const PropName: string): Variant;
var P: PPropInfo;
begin
  if self=nil then
    P := nil else
    P := RecordProps.FieldPropFromRawUTF8({$ifdef UNICODE}StringToUTF8{$endif}(PropName));
  if P=nil then
    VarClear(result) else
    P^.GetVariant(self,result);
end;

procedure TSQLRecord.SetFieldVariant(const PropName: string;
  const Source: Variant);
var P: PPropInfo;
begin
  if self=nil then
    P := nil else
    P := RecordProps.FieldPropFromRawUTF8({$ifdef UNICODE}StringToUTF8{$endif}(PropName));
  if P<>nil then
    P^.SetVariant(self,Source);
end;
{$endif}

function PropsCreate(aTable: TSQLRecordClass): TSQLRecordProperties;
begin // private sub function makes the code faster in most case
  if not aTable.InheritsFrom(TSQLRecord) then
    // invalid call
    result := nil else begin
    // create the properties information from RTTI
    result := TSQLRecordProperties.Create(aTable);
    // store the TSQLRecordProperties instance into AutoTable unused VMT entry
    PatchCodePtrUInt(pointer(PtrInt(aTable)+vmtAutoTable),PtrUInt(result));
    // register to the internal garbage collection (avoid memory leak)
    GarbageCollector.Add(result);
  end;
end;

// since "var class" are not available in Delphi 6-7, and is inherited by
// the children classes under latest Delphi versions (i.e. the "var class" is
// shared by all inherited classes, whereas we want one var per class), we reused
// one of the unused magic VMT slots (i.e. the one for automated methods,
// AutoTable, a relic from Delphi 2 that is generally not used anymore) - see
// http://hallvards.blogspot.com/2007/05/hack17-virtual-class-variables-part-ii.html

{$ifdef PUREPASCAL}
class function TSQLRecord.RecordProps: TSQLRecordProperties;
begin
  if Self<>nil then begin
    result := PPointer(PtrInt(Self)+vmtAutoTable)^;
    if result=nil then
      result := PropsCreate(self);
  end else
    result := nil;
end;
{$else}
class function TSQLRecord.RecordProps: TSQLRecordProperties;
asm
  or eax,eax
  jz @null
  mov edx,[eax+vmtAutoTable]
  or edx,edx
  jz PropsCreate
  mov eax,edx
@null:
end;
{$endif}

function TSQLRecord.Filter(const aFields: TSQLFieldBits): boolean;
var f, i: integer;
    Value, Old: RawUTF8;
begin
  result := IsZero(aFields);
  if (self=nil) or result then
    // avoid GPF and handle case if no field was selected
    exit;
  with RecordProps do
  if Filters=nil then
    // no filter set yet -> process OK
    result := true else begin
    for f := 0 to high(Fields) do
      if not(FieldType[f] in [sftUnknown,sftMany]) and (Filters[f]<>nil) then
        with Filters[f] do
        for i := 0 to Count-1 do
        if TSynFilterOrValidate(List[i]).InheritsFrom(TSynFilter) then begin
          Fields[f].GetValueVar(self,false,Value,nil);
          Old := Value;
          TSynFilter(List[i]).Process(f,Value);
          if Old<>Value then
            // value was changed -> store modified
            Fields[f].SetValue(self,pointer(Value));
        end;
  end;
end;

function TSQLRecord.Filter(const aFields: array of RawUTF8): boolean;
var F: TSQLFieldBits;
begin
  if RecordProps.FieldIndexsFromRawUTF8(aFields,F) then
    // must always call the virtual Filter() method
    result := Filter(F) else
    result := false;
end;

class function TSQLRecord.SQLTableName: RawUTF8;
begin
  if self=nil then
    result := '' else
    result := RecordProps.SQLTableName;
end;

class function TSQLRecord.AddFilterOrValidate(const aFieldName: RawUTF8;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  result := RecordProps.AddFilterOrValidate(aFieldName,aFilter);
end;

function TSQLRecord.Validate(aRest: TSQLRest; const aFields: TSQLFieldBits;
  aInvalidFieldIndex: PInteger): string;
var f, i: integer;
    Value: RawUTF8;
    Validate: TSynValidate;
    ValidateRest: TSynValidateRest absolute Validate;
begin
  result := '';
  if (self=nil) or IsZero(aFields) then
    // avoid GPF and handle case if no field was selected
    exit;
  with RecordProps do
  for f := 0 to high(Fields) do
  if not(FieldType[f] in [sftUnknown,sftMany]) then begin
    if (Filters<>nil) and (Filters[f]<>nil) then
      for i := 0 to Filters[f].Count-1 do begin
        Validate := TSynValidate(Filters[f].List[i]);
        if Validate.InheritsFrom(TSynValidate) then begin
          if Value='' then
            Fields[f].GetValueVar(self,false,Value,nil);
          if Validate.InheritsFrom(TSynValidateRest) then begin
            // set additional parameters
            ValidateRest.fProcessRec := self;
            ValidateRest.fProcessRest := aRest;
          end;
          if not Validate.Process(f,Value,result) then begin
            // TSynValidate process failed -> notify caller
            if aInvalidFieldIndex<>nil then
              aInvalidFieldIndex^ := f;
            if result='' then
              // no custom message -> show a default message
              result := format(sValidationFailed,[
                GetCaptionFromClass(Validate.ClassType)]);
            exit;
          end;
        end;
      end;
    Value := '';
  end;
end;

function TSQLRecord.Validate(aRest: TSQLRest; const aFields: array of RawUTF8;
  aInvalidFieldIndex: PInteger=nil): string;
var F: TSQLFieldBits;
begin
  if RecordProps.FieldIndexsFromRawUTF8(aFields,F) then
    // must always call the virtual Validate() method
    result := Validate(aRest,F,aInvalidFieldIndex) else
    result := '';
end;

function TSQLRecord.DynArray(const DynArrayFieldName: shortstring): TDynArray;
var F: integer;
begin
  with RecordProps do
    for F := 0 to high(DynArrayFields) do
      with DynArrayFields[F]^ do
      if IdemPropName(Name,DynArrayFieldName) then begin
        result.Init(PropType^,GetFieldAddr(self)^);
        exit;
      end;
  result.Void;
end;

function TSQLRecord.DynArray(DynArrayFieldIndex: integer): TDynArray;
var F: integer;
begin
  if DynArrayFieldIndex>0 then
    with RecordProps do
      for F := 0 to high(DynArrayFields) do
        with DynArrayFields[F]^ do
        if Index=DynArrayFieldIndex then begin
          result.Init(PropType^,GetFieldAddr(self)^);
          exit;
        end;
  result.Void;
end;

procedure TSQLRecord.ComputeFieldsBeforeWrite(aRest: TSQLRest; aOccasion: TSQLEvent);
var F: integer;
begin
  if (self<>nil) and (aRest<>nil) then
    with RecordProps do begin
      if sftModTime in HasTypeFields then
        for F := 0 to high(FieldType) do
        if FieldType[f]=sftModTime then
          SetInt64Prop(Self,Fields[F],aRest.ServerTimeStamp);
      if (sftCreateTime in HasTypeFields) and (aOccasion=seAdd) then
        for F := 0 to high(FieldType) do
        if FieldType[f]=sftCreateTime then
          SetInt64Prop(Self,Fields[F],aRest.ServerTimeStamp);
    end;
end;


{ TSQLModel }

procedure TSQLModel.SetTableProps(aTable: TSQLRecordClass; aIndex: integer;
  Last, VirtualsRemain: boolean);
var f, R: integer;
    Props: TSQLRecordProperties;
    PT: PTypeInfo;
begin
  Props := aTable.RecordProps;
  if (not VirtualsRemain) and (Props.Kind in IS_CUSTOM_VIRTUAL) then
    Props.Kind := rSQLite3; // reset to internal table at model creation
  if Props.Model=nil then begin
    Props.Model := self;
    Props.ModelTableIndex := aIndex;
  end;
  TableProps[aIndex] := Props;
  fTablesName[aIndex] := Props.SQLTableName;
  fTablesNameIndex[aIndex] := aIndex;
  for f := 0 to high(Props.Fields) do begin
    PT := Props.Fields[f]^.PropType^;
    case Props.FieldType[f] of
    sftRecord, sftID: begin
      R := length(RecordReferences);
      SetLength(RecordReferences,R+1);
      with RecordReferences[R] do begin
        TableIndex := aIndex;
        FieldType := Props.FieldType[f];
        FieldName := @Props.Fields[f]^.Name;
        FieldRecordClass := TSQLRecordClass(PT^.ClassType^.ClassType);
      end;
    end;
    sftMany:
      if GetTableIndex(TSQLRecordClass(PT^.ClassType^.ClassType))<0 then
        raise EModelException.CreateFmt('%s must include %s for %s.%s',
          [ClassName,TSQLRecordClass(PT^.ClassType^.ClassType).ClassName,
           Tables[aIndex].ClassName,Props.FieldsName[f]]);
    end;
  end;
  if Last then
    QuickSortRawUTF8(fTablesName,length(fTablesName),@fTablesNameIndex,StrIComp);
end;

function TSQLModel.AddTable(aTable: TSQLRecordClass; aTableIndexCreated: PInteger=nil): boolean;
var n: integer;
begin
  if GetTableIndex(aTable)>=0 then begin
    result := false;
    exit;
  end;
  n := length(Tables)+1;
  SetLength(fTables,n);
  SetLength(fTablesName,n);
  SetLength(fTablesNameIndex,n);
  SetLength(TableProps,n);
  dec(n);
  fTables[n] := aTable;
  SetTableProps(aTable,n,true,false);
  if aTableIndexCreated<>nil then
    aTableIndexCreated^ := n;
  result := true;
end;

constructor TSQLModel.Create(CloneFrom: TSQLModel);
begin
  if CloneFrom=nil then
    raise EModelException.Create('TSQLModel.Create(CloneFrom=nil)');
  Create(CloneFrom.fTables,CloneFrom.fRoot,true);
  fVirtualTableModule := CloneFrom.fVirtualTableModule;
end;

constructor TSQLModel.Create(TabParameters: PSQLRibbonTabParameters;
  TabParametersCount, TabParametersSize: integer;
  const NonVisibleTables: array of TSQLRecordClass; const aRoot: RawUTF8);
var i: integer;
    Tables: array of TSQLRecordClass;
begin
  if (TabParameters=nil) or (TabParametersCount<=0) or
     (cardinal(TabParametersSize)<sizeof(TSQLRibbonTabParameters)) then
    raise EModelException.Create('TSQLModel.Create(TabParameters?)');
  SetLength(Tables,TabParametersCount+length(NonVisibleTables));
  for i := 0 to TabParametersCount-1 do begin
    Tables[i] := TabParameters^.Table;
    inc(PtrUInt(TabParameters),TabParametersSize);
  end;
  for i := 0 to high(NonVisibleTables) do
    Tables[i+TabParametersCount] := NonVisibleTables[i];
  Create(Tables,aRoot);
end;

constructor TSQLModel.Create(const Tables: array of TSQLRecordClass; const aRoot: RawUTF8;
  aVirtualsRemain: boolean);
var N, i: integer;
begin
  N := length(Tables);
  if N>sizeof(SUPERVISOR_ACCESS_RIGHTS.Get)*8 then // TSQLAccessRights bits size
    raise EModelException.CreateFmt('%s has too many Tables: %d>%d',
      [ClassName,N,sizeof(SUPERVISOR_ACCESS_RIGHTS.Get)*8]); // e.g. N>64
  // set the Tables to be associated with this Model, as TSQLRecord classes
  SetLength(fTables,N);
  move(Tables[0],fTables[0],N*Sizeof(Tables[0]));
  SetLength(fTablesName,N);
  SetLength(fTablesNameIndex,N);
  SetLength(TableProps,N);
  // initialize internal properties
  dec(N);
  for i := 0 to N do
    SetTableProps(Tables[i],i,(i=N),aVirtualsRemain);
  // set the optional Root URI path of this Model
  fRoot := aRoot;
end;

function TSQLModel.GetMainFieldName(Table: TSQLRecordClass;
  ReturnFirstIfNoUnique: boolean=false): RawUTF8;
begin
  if Table<>nil then
    with Table.RecordProps do
      if MainField[ReturnFirstIfNoUnique]<0 then
        result := '' else
        result := FieldsName[MainField[ReturnFirstIfNoUnique]] else
    result := '';
end;

function TSQLModel.GetIsUnique(aTable: TSQLRecordClass; aFieldIndex: integer): boolean;
var i: integer;
begin
  i := GetTableIndex(aTable);
  if (i<0) or (Cardinal(aFieldIndex)>=MAX_SQLFIELDS) then
    Result := false else
    Result := aFieldIndex in TableProps[i].IsUniqueFieldsBits;
end;

function TSQLModel.GetTableIndexFromSQLSelect(const SQL: RawUTF8;
  EnsureUniqueTableInFrom: boolean): integer;
var i,j,k: integer;
    TableName: RawUTF8;
begin
  i := PosI(' FROM ',SQL);
  if i>0 then begin
    inc(i,6);
    while SQL[i] in [#1..' '] do inc(i);
    j := 0;
    while ord(SQL[i+j]) in IsIdentifier do inc(j);
    if j>0 then begin
      k := i+j;
      while SQL[k] in [#1..' '] do inc(k);
      if (not EnsureUniqueTableInFrom) or (SQL[k]<>',') then begin 
        SetString(TableName,PAnsiChar(PtrInt(SQL)+i-1),j);
        result := GetTableIndex(TableName);
        exit;
      end;
    end;
  end;
  result := -1;
end;

function TSQLModel.GetTable(const SQLTableName: RawUTF8): TSQLRecordClass;
var i: integer;
begin
  i := GetTableIndex(SQLTableName);
  if i>=0 then
    result := Tables[i] else
    result := nil;
end;

function TSQLModel.GetTableExactClass(const TableName: RawUTF8): TSQLRecordClass;
var i: integer;
begin
  i := GetTableExactIndex(TableName);
  if i>=0 then
    result := Tables[i] else
    result := nil;
end;

function TSQLModel.GetTableIndex(aTable: TSQLRecordClass): integer;
begin
  if (self<>nil) and (aTable<>nil) then
    with aTable.RecordProps do
      // fastest O(1) search
      if Model=self then begin
        result := ModelTableIndex;
        exit;
      end else
      // slowest O(n) but generic search
      for result := 0 to high(Tables) do
        if Tables[result]=aTable then
          exit;
  result := -1;
end;

function TSQLModel.GetTableExactIndex(const TableName: RawUTF8): integer;
var L: integer;
begin
  if self<>nil then begin
  L := length(TableName);
  for result := 0 to high(Tables) do
    if Tables[result]<>nil then // avoid GPF
    if IdemPropName(
       // new TObject.ClassName is UnicodeString (Delphi 20009) -> inline code with
       // vmtClassName = UTF-8 encoded text stored in a shortstring
       PShortString(PPointer(PtrInt(Tables[result])+vmtClassName)^)^,
       pointer(TableName),L) then
      exit;  // case insensitive search
  end;
  result := -1;
end;

function TSQLModel.GetTableIndex(const SQLTableName: RawUTF8): integer;
begin
  if (self<>nil) and (SQLTableName<>'') then begin
    // fast binary search
    result := FastFindPUTF8CharSorted(pointer(fTablesName),high(fTablesName),pointer(SQLTableName),StrIComp);
    if result>=0 then
      result := fTablesNameIndex[result];
  end else
    result := -1;
end;

function TSQLModel.GetTableIndex(SQLTableName: PUTF8Char): integer;
begin
  if (self<>nil) and (SQLTableName<>nil) then begin
    // fast binary search
    result := FastFindPUTF8CharSorted(pointer(fTablesName),high(fTablesName),SQLTableName,StrIComp);
    if result>=0 then
      result := fTablesNameIndex[result];
  end else
    result := -1;
end;

function TSQLModel.getURI(aTable: TSQLRecordClass): RawUTF8;
begin
  if (self<>nil) and (Root<>'') then
    result := Root+'/'+aTable.RecordProps.SQLTableName else
    result := aTable.RecordProps.SQLTableName;
end;

function TSQLModel.NewRecord(const SQLTableName: RawUTF8): TSQLRecord;
var aClass: TSQLRecordClass;
begin
  aClass := Table[SQLTableName];
  if aClass=nil then
    result := nil else
    result := aClass.Create;
end;

procedure TSQLModel.SetActions(aActions: PTypeInfo);
begin
  if (aActions=nil) or not (aActions^.Kind=tkEnumeration) then
    fActions := nil else
    fActions := aActions^.EnumBaseType;
end;

procedure TSQLModel.SetEvents(aEvents: PTypeInfo);
begin
  if (aEvents=nil) or not (aEvents^.Kind=tkEnumeration) then
    fEvents := nil else
    fEvents := aEvents^.EnumBaseType;
end;

function TSQLModel.GetSQLCreate(aTableIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(aTableIndex)>=cardinal(length(fTables))) then
    result := '' else
    result := Tables[aTableIndex].GetSQLCreate(self);
end;

function TSQLModel.GetSQLAddField(aTableIndex, aFieldIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(aTableIndex)>=cardinal(length(TableProps))) then
    result := '' else
    with TableProps[aTableIndex] do
    result := SQLAddField(aFieldIndex);
end;

function TSQLModel.isLocked(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  result := GetLocks(aTable)^.isLocked(aID);
end;

function TSQLModel.isLocked(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := isLocked(PSQLRecordClass(aRec)^,aRec.fID);
end;

function TSQLModel.Lock(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  if self=nil then
    result := false else begin
    if fLocks=nil then
      SetLength(fLocks,length(fTables)); // initialize fLocks[] if necessary
    result :=  GetLocks(aTable)^.Lock(aID);
  end;
end;

function TSQLModel.Lock(aTableIndex, aID: integer): boolean;
begin
  if (self=nil) or (aTableIndex>=length(fTables)) then
    result := false else begin
    if fLocks=nil then
      SetLength(fLocks,length(fTables)); // initialize fLocks[] if necessary
    result := fLocks[aTableIndex].Lock(aID);
  end;
end;

function TSQLModel.Lock(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := Lock(PSQLRecordClass(aRec)^,aRec.fID);
end;

procedure TSQLModel.PurgeOlderThan(MinutesFromNow: cardinal);
var i: integer;
begin
  if fLocks<>nil then
    for i := 0 to high(fLocks) do
     fLocks[i].PurgeOlderThan(MinutesFromNow);
end;

function TSQLModel.UnLock(aTable: TSQLRecordClass; aID: integer): boolean;
begin
  if (self=nil) or (fLocks=nil) then
    result := false else
    result := GetLocks(aTable)^.UnLock(aID);
end;

function TSQLModel.UnLock(aRec: TSQLRecord): boolean;
begin
  if aRec=nil then
    result := false else
    result := UnLock(PSQLRecordClass(aRec)^,aRec.fID);
end;

function TSQLModel.GetLocks(aTable: TSQLRecordClass): PSQLLocks;
var i: integer;
begin
  if (self=nil) or (fLocks=nil) then
    result := nil else begin
    i := GetTableIndex(aTable);
    if i<0 then
      result := nil else
      result := @fLocks[i];
  end;
end;

procedure TSQLModel.UnLockAll;
var i: integer;
begin
  for i := 0 to high(fLocks) do
    fLocks[i].Count := 0;
end;

function TSQLModel.getURIID(aTable: TSQLRecordClass; aID: integer): RawUTF8;
begin
  if self<>nil then
    if aTable=nil then
      result := Root else
      result := getURI(aTable) else
      result := '';
  if aID>0 then
    result := result+'/'+{$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(aID);
end;

function TSQLModel.getURICallBack(const aMethodName: RawUTF8; aTable: TSQLRecordClass; aID: integer): RawUTF8;
begin
  result := getURIID(aTable,aID)+'/'+aMethodName;
end;

function TSQLModel.ActionName(const Action): string;
begin
  if (Self=nil) or (fActions=nil) then
    result := '' else
    result := TSQLRecord.CaptionName(fActions^.GetEnumName(byte(Action)));
end;

function TSQLModel.EventName(const Event): string;
begin
  if (Self=nil) or (fEvents=nil) then
    result := '' else
    result := TSQLRecord.CaptionName(fEvents^.GetEnumName(byte(Event)));
end;

function TSQLModel.RecordReference(Table: TSQLRecordClass; ID: integer): TRecordReference;
begin
  if (self=nil) or (ID<=0) then
    result := 0 else begin
    result := GetTableIndex(Table);
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,ID shl 6);
  end;
end;

function TSQLModel.VirtualTableRegister(aClass: TSQLRecordClass;
  aModule: TSQLVirtualTableClass): boolean;
var i: integer;
begin
  result := false;
  if aClass=nil then exit;
  i := GetTableIndex(aClass);
  if i<0 then
    raise EORMException.CreateFmt('Invalid VirtualTableRegister(%s) call: '+
      'class is not in the current database Model',[aClass.ClassName]);
  with TableProps[i] do
  if not (Kind in IS_CUSTOM_VIRTUAL) then
    if Kind<>rSQLite3 then
      raise EORMException.CreateFmt('Invalid VirtualTableRegister(%s) call: '+
        'impossible to set class as virtual',[aClass.ClassName]) else
      Kind := rCustomAutoID;
  if length(fVirtualTableModule)<>length(Tables) then
    SetLength(fVirtualTableModule,length(Tables));
  fVirtualTableModule[i] := aModule;
  result := true;
end;

function TSQLModel.VirtualTableModule(aClass: TSQLRecordClass): TSQLVirtualTableClass;
var i: integer;
begin
  result := nil;
  if (self=nil) or (fVirtualTableModule=nil) then
    exit;
  i := GetTableIndex(aClass);
  if (i>=0) and (TableProps[i].Kind in IS_CUSTOM_VIRTUAL) then
    result := fVirtualTableModule[i];
end;

destructor TSQLModel.Destroy;
var i: integer;
begin
  for i := 0 to high(TableProps) do
    with TableProps[i] do
      if Model=self then
        Model := nil;  // unassociate this TSQLRecord with this model
  inherited;
end;


{ TSQLRest }

constructor TSQLRest.Create(aModel: TSQLModel);
begin
  fModel := aModel;
  fAcquireWriteTimeOut := 2000; // default AcquireWrite time out is 2 seconds 
  InitializeCriticalSection(fTransactionCriticalSession);
end;

destructor TSQLRest.Destroy;
begin
  if (fModel<>nil) and (fModel.Owner=self) then
    // make sure we are the Owner (TSQLRestServerStatic has fModel<>nil e.g.)
    fModel.Free;
  fServices.Free;
  fCache.Free;
  DeleteCriticalSection(fTransactionCriticalSession);
  inherited;
end;

function TSQLRest.MultiFieldValue(Table: TSQLRecordClass;
  const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
  WhereID: integer): boolean;
begin
  result := MultiFieldValue(Table,FieldName,FieldValue,'RowID=:('+
    {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(WhereID)+'):');
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8): RawUTF8;
var Res: array[0..0] of RawUTF8;
begin
  if MultiFieldValue(Table,[FieldName],Res,WhereClause) then
    result := Res[0] else
    result := '';
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass; const FieldName: RawUTF8;
  FormatSQLWhere: PUTF8Char; const BoundsSQLWhere: array of const): RawUTF8;
begin
  result := OneFieldValue(Table,FieldName,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere));
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass;
  const FieldName: RawUTF8; WhereClauseFmt: PUTF8Char;
  const Args, Bounds: array of const): RawUTF8;
begin
  result := OneFieldValue(Table,FieldName,FormatUTF8(WhereClauseFmt,Args,Bounds));
end;

function TSQLRest.OneFieldValue(Table: TSQLRecordClass;
  const FieldName: RawUTF8; WhereID: integer): RawUTF8;
var Res: array[0..0] of RawUTF8;
begin
  if (WhereID>0) and MultiFieldValue(Table,[FieldName],Res,'RowID=:('+
    {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(WhereID)+'):') then
    result := Res[0] else
    result := '';
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; var Data: TRawUTF8DynArray): boolean;
var i: integer;
    T: TSQLTableJSON;
begin
  SetLength(Data,0);
  result := false;
  T := InternalListJSON(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    // get row values
    SetLength(Data,T.RowCount);
    for i := 1 to T.RowCount do // ignore fResults[0] i.e. field name
      Data[i-1] := T.fResults[i];
    result := true;
  finally
    T.Free;
  end;
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; Strings: TStrings; IDToIndex: PInteger=nil): Boolean;
var Row, aID: integer;
    T: TSQLTableJSON;
begin
  result := false;
  if (Strings<>nil) and (self<>nil) and (Table<>nil) then
  try
    {$ifndef LVCL}
    Strings.BeginUpdate;
    {$endif}
    Strings.Clear;
    T := InternalListJSON(Table,Table.RecordProps.
      SQLFromSelectWhere('ID,'+FieldName,WhereClause));
    if T<>nil then
    try
      if (T.FieldCount=2) and (T.RowCount>0) then begin
        for Row := 1 to T.RowCount do begin // ignore Row 0 i.e. field names
          aID := GetInteger(T.Get(Row,0));
          Strings.AddObject(UTF8ToString(T.GetU(Row,1)),pointer(aID));
          if (IDToIndex<>nil) and (aID=IDToIndex^) then begin
            IDToIndex^ := Row-1;
            IDToIndex := nil; // set once
          end;
        end;
        result := true;
      end;
    finally
      T.Free;
    end;
  finally
    {$ifndef LVCL}
    Strings.EndUpdate;
    {$endif}
  end;
  if IDToIndex<>nil then
    IDToIndex^ := -1; // ID not found
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause, Separator: RawUTF8): RawUTF8;
var i, Len, SepLen, L: integer;
    T: TSQLTableJSON;
    P: PUTF8Char;
begin
  result := '';
  T := InternalListJSON(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    // calculate row values CSV needed memory
    SepLen := length(Separator);
    Len := 0;
    for i := 1 to T.RowCount do // ignore fResults[0] i.e. field name
      inc(Len,StrLen(T.fResults[i])+SepLen);
    dec(Len,SepLen);
    SetLength(result,Len);
    // add row values as CSV
    P := pointer(result);
    for i := 1 to T.RowCount do begin // ignore fResults[0] i.e. field name
      L := StrLen(T.fResults[i]);
      if L<>0 then begin
        move(T.fResults[i]^,P^,L);
        inc(P,L);
      end;
      if i=T.RowCount then
        break;
      move(pointer(Separator)^,P^,SepLen);
      inc(P,SepLen);
    end;
    assert(P-pointer(result)=Len);
  finally
    T.Free;
  end;
end;

function TSQLRest.OneFieldValues(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8; var Data: TIntegerDynArray): boolean;
var T: TSQLTableJSON;
begin
  SetLength(Data,0);
  result := false;
  T := InternalListJSON(Table,FieldName,WhereClause);
  if T<>nil then
  try
    if (T.FieldCount<>1) or (T.RowCount<=0) then
      exit;
    T.GetRowValues(0,Data);
    result := true;
  finally
    T.Free;
  end;
end;

function TSQLRest.InternalListJSON(Table: TSQLRecordClass; const FieldName,
  WhereClause: RawUTF8): TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    result := nil else
    with Table.RecordProps do
    if (PosEx(RawUTF8(','),FieldName,1)=0) and not IsFieldName(FieldName) then
      result := nil else // prevent SQL error
      result := InternalListJSON(Table,SQLFromSelectWhere(FieldName,WhereClause));
end;

function TSQLRest.InternalListRecordsJSON(Table: TSQLRecordClass;
  const WhereClause: RawUTF8): TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    result := nil else
    result := InternalListJSON(Table,
      Table.RecordProps.SQLFromSelectWhere('*',WhereClause));
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass; FieldNames: RawUTF8;
  const WhereClause: RawUTF8): TSQLTableJSON;
var P: PUTF8Char;
    aFieldName: RawUTF8;
begin
  Result := nil;
  if (self<>nil) and (Table<>nil) then
  with Table.RecordProps do begin
    if FieldNames='' then
      // true,false -> include 'ID,'
      FieldNames := SQLTableSimpleFields[true,false] else begin
      P := pointer(FieldNames);
      repeat
        aFieldName := Trim(GetNextItem(P));
        if not IsFieldName(aFieldName) then
          exit; // invalid field name
      until P=nil;
    end;
    result := InternalListJSON(Table,SQLFromSelectWhere(FieldNames,WhereClause));
  end;
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass; const FieldNames: RawUTF8;
  WhereClauseFormat: PUTF8Char; const BoundsSQLWhere: array of const): TSQLTableJSON;
begin
  result := MultiFieldValues(Table,FieldNames,FormatUTF8(WhereClauseFormat,[],BoundsSQLWhere));
end;

function TSQLRest.MultiFieldValues(Table: TSQLRecordClass;
  const FieldNames: RawUTF8; WhereClauseFormat: PUTF8Char;
  const Args, Bounds: array of const): TSQLTableJSON;
begin
  result := MultiFieldValues(Table,FieldNames,FormatUTF8(WhereClauseFormat,Args,Bounds));
end;

function TSQLRest.MultiFieldValue(Table: TSQLRecordClass;
  const FieldName: array of RawUTF8; var FieldValue: array of RawUTF8;
  const WhereClause: RawUTF8): boolean;
var SQL: RawUTF8;
    i: integer;
    T: TSQLTableJSON;
begin
  result := false;
  if (self<>nil) and (Table<>nil) and (length(FieldName)=length(FieldValue)) then
  with Table.RecordProps do begin
    for i := 0 to high(FieldName) do
      if not IsFieldName(FieldName[i]) then
        exit else // prevent SQL error
        if SQL='' then
          SQL := 'SELECT '+FieldName[i] else
          SQL := SQL+','+FieldName[i];
    SQL := SQL+' FROM '+SQLTableName+' WHERE '+WhereClause+' LIMIT 1;';
    T := InternalListJSON(Table,SQL);
    if T<>nil then
    try
      if (T.FieldCount<>length(FieldName)) or (T.RowCount<=0) then
        exit;
      // get field values from the first (and unique) row
      for i := 0 to T.FieldCount-1 do
        FieldValue[i] := T.fResults[T.FieldCount+i];
      result := true;
    finally
      T.Free;
    end;
  end;
end;

function TSQLRest.Retrieve(const SQLWhere: RawUTF8; Value: TSQLRecord): boolean;
var T: TSQLTable;
begin
  if (self=nil) or (Value=nil) then
    T := nil else
    T := InternalListJSON(PSQLRecordClass(Value)^,Value.RecordProps.
      SQLFromSelectWhere('*',SQLWhere+' LIMIT 1'));
  if T=nil then
    result := false else
    try
      if T.RowCount>=1 then begin
        Value.FillFrom(T,1); // fetch data from first result row
        result := true;
      end else
        result := false;
    finally
      T.Free;
    end;
end;

function TSQLRest.Retrieve(WhereClauseFmt: PUTF8Char; const Args,Bounds: array of const;
  Value: TSQLRecord): boolean; 
begin
  result := Retrieve(FormatUTF8(WhereClauseFmt,Args,Bounds),Value);
end;

function TSQLRest.Retrieve(Reference: TRecordReference; ForUpdate: boolean=false): TSQLRecord;
var aClass: TSQLRecordClass;
begin
  result := nil;
  if (self=nil) or (RecordRef(Reference).ID=0) then
    exit;
  aClass := RecordRef(Reference).Table(Model);
  if aClass=nil then
    exit;
  result := aClass.Create(self,RecordRef(Reference).ID,ForUpdate);
  if result.fID=0 then
    FreeAndNil(result); // error during value retrieval
end;

function TSQLRest.Retrieve(aPublishedRecord, aValue: TSQLRecord): boolean;
begin
  result := Retrieve(aPublishedRecord.ID,aValue);
end;

function TSQLRest.UnLock(Rec: TSQLRecord): boolean;
begin
  if (self=nil) or (Rec=nil) or (Rec.fID<=0) then
    result := false else
    result := UnLock(PSQLRecordClass(Rec)^,Rec.fID);
end;

procedure TSQLRest.Commit(SessionID: cardinal);
begin
  if self<>nil then begin
    EnterCriticalSection(fTransactionCriticalSession);
    try
      if (fTransactionActive<>0) and (fTransactionActive=SessionID) then begin
        fTransactionActive := 0; // by default, just release flag
        fTransactionTable := nil;
      end;
    finally
      LeaveCriticalSection(fTransactionCriticalSession);
    end;
  end;
end;

procedure TSQLRest.RollBack(SessionID: cardinal);
begin
  if self<>nil then begin
    EnterCriticalSection(fTransactionCriticalSession);
    try
      if (fTransactionActive<>0) and (fTransactionActive=SessionID) then begin
        fTransactionActive := 0; // by default, just release flag
        fTransactionTable := nil;
      end;
    finally
      LeaveCriticalSection(fTransactionCriticalSession);
    end;
  end;
end;

function TSQLRest.TransactionBegin(aTable: TSQLRecordClass; SessionID: cardinal): boolean;
begin
  result := false;
  if self<>nil then begin
    EnterCriticalSection(fTransactionCriticalSession);
    try
      if fTransactionActive=0 then begin // nested transactions are not allowed
        fTransactionActive := SessionID;
        fTransactionTable := aTable;
        result := true;
      end;
    finally
      LeaveCriticalSection(fTransactionCriticalSession);
    end;
  end;
end;

function TSQLRest.RecordCanBeUpdated(Table: TSQLRecordClass; ID: integer; Action: TSQLEvent;
  ErrorMsg: PRawUTF8 = nil): boolean;
begin
  result := true; // accept by default -> override this method to customize this
end;

function TSQLRest.Delete(Table: TSQLRecordClass; ID: integer): boolean;
begin
  result := RecordCanBeUpdated(Table,ID,seDelete);
end;

function TSQLRest.InternalDelete(Table: TSQLRecordClass; const SQLWhere: RawUTF8;
  var IDs: TIntegerDynArray): boolean;
var i: integer;
begin
  result := false;
  if (not OneFieldValues(Table,'RowID',SQLWhere,IDs)) or
     (IDs=nil) then
    exit;
  for i := 0 to high(IDs) do
    if not RecordCanBeUpdated(Table,IDs[i],seDelete) then
      exit;
  for i := 0 to high(IDs) do
    fCache.NotifyDeletion(Table,IDs[i]);
  result := true;
end;

function TSQLRest.Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean;
var IDs: TIntegerDynArray;
begin
  if InternalDelete(Table,SQLWhere,IDs) then
    result := EngineDeleteWhere(Table,SQLWhere,IDs) else
    result := false;
end;

function TSQLRest.Delete(Table: TSQLRecordClass; FormatSQLWhere: PUTF8Char;
  const BoundsSQLWhere: array of const): boolean;
begin
  result := Delete(Table,FormatUTF8(FormatSQLWhere,[],BoundsSQLWhere));
end;

function TSQLRest.Update(Value: TSQLRecord): boolean;
begin
  result := (Value<>nil) and (Value.fID<>0) and
    RecordCanBeUpdated(PSQLRecordClass(Value)^,Value.fID,seUpdate);
end;

function TSQLRest.Update(aTable: TSQLRecordClass; aID: integer;
  const aSimpleFields: array of const): boolean;
var Value: TSQLRecord;
begin
  result := false; // means error
  if (self=nil) or (aTable=nil) or (aID=0) then
    exit;
  Value := aTable.Create;
  try
    if not Value.SimplePropertiesFill(aSimpleFields) then
      exit;
    Value.fID := aID;
    result := Update(Value);
  finally
    Value.Free;
  end;
end;

function TSQLRest.Add(aTable: TSQLRecordClass; const aSimpleFields: array of const;
  ForcedID: integer=0): integer;
var Value: TSQLRecord;
begin
  result := 0; // means error
  if (self=nil) or (aTable=nil) then
    exit;
  Value := aTable.Create;
  try
    if Value.SimplePropertiesFill(aSimpleFields) then begin
      if ForcedID<>0 then
        Value.fID := ForcedID;
      result := Add(Value,true);
    end;
  finally
    Value.Free;
  end;
end;

procedure TSQLRest.QueryAddCustom(aTypeInfo: pointer; aEvent: TSQLQueryEvent;
  const aOperators: TSQLQueryOperators);
var Enum: PEnumType;
    i,n: integer;
begin
  if (self=nil) or not Assigned(aEvent)  or
     (aTypeInfo=nil) or (PTypeInfo(aTypeInfo)^.Kind<>tkEnumeration) then
    exit;
  Enum := PTypeInfo(aTypeInfo)^.EnumBaseType;
  n := length(QueryCustom);
  SetLength(QueryCustom,n+Enum^.MaxValue+1);
  for i := 0 to Enum^.MaxValue do
    with QueryCustom[i+n] do begin
      EnumType := Enum;
      EnumIndex := i;
      Event := aEvent;
      Operators := aOperators;
    end;
end;

class function TSQLRest.QueryIsTrue(aTable: TSQLRecordClass; aID: integer;
  FieldType: TSQLFieldType; Value: PUTF8Char; Operator: integer;
  Reference: PUTF8Char): boolean;
begin // use mostly the same fast comparison functions as for sorting  
  result := false;
  if aID=0 then
    exit; // invalid input field
  if Reference=nil then
    exit; // avoid most GPF
  if FieldType=sftMany then
    exit; // nothing is stored directly, but in a separate pivot table
  if FieldType in [sftUnknown,sftBlob,sftBlobDynArray,sftObject
    {$ifdef PUBLISHRECORD},sftBlobRecord{$endif}] then
    FieldType := sftUTF8Text; // unknown or blob fields are compared as UTF-8
  { TODO: handle sftBlobDynArray/sftBlobRecord comparison }
  case TSQLQueryOperator(Operator) of
    qoNone:
      result := true;
    qoEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)=0;
    qoNotEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<>0;
    qoLessThan:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<0;
    qoLessThanOrEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)<=0;
    qoGreaterThan:
      result := SQLFieldTypeComp[FieldType](Value,Reference)>0;
    qoGreaterThanOrEqualTo:
      result := SQLFieldTypeComp[FieldType](Value,Reference)>=0;
    qoEqualToWithCase:
      result := StrComp(Value,Reference)=0;
    qoNotEqualToWithCase:
      result := StrComp(Value,Reference)<>0;
    qoContains:
      result := PosIU(Reference,Value)<>0;
    qoBeginWith:
      result := IdemPCharU(Value,Reference);
    qoSoundsLikeEnglish,
    qoSoundsLikeFrench,
    qoSoundsLikeSpanish:
      result := PSynSoundEx(Reference)^.UTF8(Value);
  end;
end;

function TSQLRest.RetrieveBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8;
  out BlobStream: THeapMemoryStream): boolean;
var BlobData: TSQLRawBlob;
begin
  BlobStream := THeapMemoryStream.Create;
  result := RetrieveBlob(Table,aID,BlobFieldName,BlobData);
  if not result or (BlobData='') then
    exit;
  BlobStream.Write(pointer(BlobData)^,length(BlobData));
  BlobStream.Seek(0,soFromBeginning); // rewind
end;

function TSQLRest.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; BlobData: TStream): boolean;
var Blob: TSQLRawBlob;
    L: integer;
begin
  result := false;
  if (self=nil) or (BlobData=nil) then
    exit;
  L := BlobData.Seek(0,soFromEnd);
  SetLength(Blob,L);
  BlobData.Seek(0,soFromBeginning);
  if BlobData.Read(pointer(Blob)^,L)<>L then
    exit;
  result := UpdateBlob(Table,aID,BlobFieldName,Blob);
end;

function TSQLRest.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; BlobData: pointer; BlobSize: integer): boolean;
var Blob: TSQLRawBlob;
begin
  if (self=nil) or (BlobData=nil) or (BlobSize<0) then
    result := false else begin
    SetString(Blob,PAnsiChar(BlobData),BlobSize);
    result := UpdateBlob(Table,aID,BlobFieldName,Blob);
  end;
end;

function TSQLRest.TableRowCount(Table: TSQLRecordClass): integer;
var T: TSQLTableJSON;
begin
  if (self=nil) or (Table=nil) then
    T := nil else
    T := InternalListJSON(Table,'SELECT Count(*) FROM '+Table.RecordProps.SQLTableName);
  if T<>nil then
  try
    Result := T.GetAsInteger(1,0);
  finally
    T.Free;
  end else
    Result := -1;
end;


function TSQLRest.MainFieldValue(Table: TSQLRecordClass; ID: Integer;
   ReturnFirstIfNoUnique: boolean=false): RawUTF8;
begin
  if (self=nil) or (Table=nil) or (ID<=0) then
    result := '' else
    with Table.RecordProps do
    if MainField[ReturnFirstIfNoUnique]<0 then
      result := '' else
      result := OneFieldValue(Table,FieldsName[MainField[ReturnFirstIfNoUnique]],ID);
end;

function TSQLRest.MainFieldID(Table: TSQLRecordClass; const Value: RawUTF8): integer;
var aMainField: integer;
begin
  result := 0;
  if (self<>nil) and (Value<>'') and (Table<>nil) then
  with Table.RecordProps do begin
    aMainField := MainField[false];
    if aMainField>=0 then
      result := GetInteger(pointer(OneFieldValue(Table,'RowID',
        FieldsName[aMainField]+'=:('+QuotedStr(Value,'''')+'):')));
  end;
end;

function TSQLRest.MainFieldIDs(Table: TSQLRecordClass; const Values: array of RawUTF8;
  var IDs: TIntegerDynArray): boolean;
var aMainField, id: integer;
begin
  SetLength(IDs,0);
  if (self<>nil) and (high(Values)>=0) and (Table<>nil) then
    if high(Values)=0 then begin // handle special case of one Values[] item
      id := MainFieldID(Table,Values[0]);
      if id>0 then begin
        SetLength(IDs,1);
        IDs[0] := id;
      end;
    end else
    with Table.RecordProps do begin // request all Values[] IDs at once
      aMainField := MainField[false];
      if aMainField>=0 then
        OneFieldValues(Table,'RowID',FieldsName[aMainField]+' in ('+
          RawUTF8ArrayToQuotedCSV(Values)+')',IDs);
    end;
  result := IDs<>nil;
end;

function TSQLRest.FTSMatch(Table: TSQLRecordFTS3Class;
  const WhereClause: RawUTF8; var DocID: TIntegerDynArray): boolean;
begin // FTS3 tables don't have any ID, but RowID or DocID
  result := OneFieldValues(Table,'RowID',WhereClause,DocID);
end;

function TSQLRest.FTSMatch(Table: TSQLRecordFTS3Class;
  const MatchClause: RawUTF8; var DocID: TIntegerDynArray;
  const PerFieldWeight: array of double): boolean;
var WhereClause: RawUTF8;
    i: integer;
begin
  result := false;
  with Table.RecordProps do
    if length(PerFieldWeight)<>length(SimpleFields) then
      exit else
    WhereClause := FormatUTF8('% MATCH :(''%''): ORDER BY rank(matchinfo(%)',
      [SQLTableName,MatchClause,SQLTableName]);
  for i := 0 to high(PerFieldWeight) do
    WhereClause := FormatUTF8('%,:(%):',[WhereClause,PerFieldWeight[i]]);
  result := FTSMatch(Table,WhereClause+') DESC',DocID);
end;

function TSQLRest.AcquireWrite(const aContext: TSQLRestServerSessionContext): Boolean;
var Start, Now: Cardinal;
begin
  if self<>nil then begin
    Start := GetTickCount;
    repeat
      if TryEnterCriticalSection(fTransactionCriticalSession) then begin
        if (fTransactionActive=0) or (fTransactionActive=aContext.Session) then begin
          // no transaction or inside a transaction for this session -> OK
          result := true;
          exit; // continue inside Critical Section until ReleaseWrite
        end;
        LeaveCriticalSection(fTransactionCriticalSession);
      end;
      Now := GetTickCount;
      if (Now<Start) or (Now>Start+AcquireWriteTimeOut) then
        break; // wait up to 2 second by default
      Sleep(1); // retry every 1 ms
    until false;
  end;
  result := false;
end;

procedure TSQLRest.ReleaseWrite;
begin
  LeaveCriticalSection(fTransactionCriticalSession);
end;

function TSQLRest.GetServerTimeStamp: TTimeLog;
var Tix: cardinal;
begin
  Tix := GetTickCount shr 9; // resolution change 1 ms -> 512 ms 
  if fServerTimeStampCacheTix=Tix then
    result := fServerTimeStampCacheValue.Value else begin
    fServerTimeStampCacheTix := Tix;
    fServerTimeStampCacheValue.From(Now+fServerTimeStampOffset);
    result := fServerTimeStampCacheValue.Value;
  end;
end;

procedure TSQLRest.SetServerTimeStamp(const Value: TTimeLog);
begin
  fServerTimeStampOffset := PIso8601(@Value)^.ToDateTime-Now;
  if fServerTimeStampOffset=0 then
    fServerTimeStampOffset := 0.0001; // retrieve server date/time only once
end;

function TSQLRest.GetCache: TSQLRestCache;
begin
  if self=nil then
    result := nil else begin
    if fCache=nil then
      fCache := TSQLRestCache.Create(self);
    result := fCache;
  end;
end;

function TSQLRest.CacheWorthItForTable(aTableIndex: cardinal): boolean;
begin
  result := true; // always worth caching by default
end;


{ TSQLRestCacheEntry }

procedure TSQLRestCacheEntry.FlushCacheEntry(Index: Integer);
begin
  if cardinal(Index)<cardinal(Count) then
    if CacheAll then
      Value.Delete(Index) else
      with Values[Index] do begin
        TimeStamp := 0;
        JSON := '';
      end;
end;

procedure TSQLRestCacheEntry.FlushCacheAllEntries;
var i: integer;
begin
  if not CacheEnable then
    exit;
  EnterCriticalSection(Mutex);
  try
    if CacheAll then
      Value.Clear else
      for i := 0 to Count-1 do
      with Values[i] do begin
        TimeStamp := 0;
        JSON := '';
      end;
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

procedure TSQLRestCacheEntry.SetJSON(aID: integer; const aJSON: RawUTF8);
var Rec: TSQLRestCacheEntryValue;
    i: integer;
begin
  EnterCriticalSection(Mutex);
  try
    Rec.ID := aID;
    Rec.TimeStamp := GetTickCount;
    Rec.JSON := aJSON;
    i := Value.Find(Rec);
    if i>=0 then
      Values[i] := Rec else
      if CacheAll then begin
        Value.Add(Rec);
        Value.Sort; // will sort by ID for faster retrieval
      end;
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

procedure TSQLRestCacheEntry.SetJSON(aRecord: TSQLRecord);
begin  // soInsert = include all fields
  SetJSON(aRecord.fID,aRecord.GetJSONValues(true,false,soInsert));
end;

function TSQLRestCacheEntry.RetrieveJSON(aID: integer; var aJSON: RawUTF8): boolean;
var i: integer;
    Now: cardinal;
begin
  EnterCriticalSection(Mutex);
  try
    result := false;
    i := Value.Find(aID);
    if i>=0 then
      with Values[i] do
      if TimeStamp<>0 then begin // 0 when there is no JSON value cached
        Now := GetTickCount;
        if (TimeOut=0) or
           ((Now>=TimeStamp) and (Now<TimeStamp+TimeOut)) then begin
          aJSON := JSON;
          result := true; // found a non outdated serialized value in cache
        end else
          FlushCacheEntry(i);
      end;
  finally
    LeaveCriticalSection(Mutex);
  end;
end;

function TSQLRestCacheEntry.RetrieveJSON(aID: integer; aValue: TSQLRecord): boolean;
var JSON: RawUTF8;
begin
  if RetrieveJSON(aID,JSON) then begin
    aValue.FillFrom(JSON);
    aValue.fID := aID; // override RowID field if not present
    result := true;
  end else
    result := false;
end;


{ TSQLRestCache }

function TSQLRestCache.CachedEntries: cardinal;
var i,j: integer;
begin
  result := 0;
  if self<>nil then
    for i := 0 to high(fCache) do
      with fCache[i] do
      if CacheEnable then
      for j := 0 to Count-1 do
        if Values[j].TimeStamp<>0 then
          inc(result);
end;

function TSQLRestCache.CachedMemory: cardinal;
var i,j: integer;
begin
  result := 0;
  if self<>nil then
    for i := 0 to high(fCache) do
      with fCache[i] do
      if CacheEnable then
      for j := 0 to Count-1 do
        if Values[j].TimeStamp<>0 then
          inc(result,length(Values[j].JSON)+(sizeof(Values[j])+16));
end;

function TSQLRestCache.SetTimeOut(aTable: TSQLRecordClass; aTimeout: Integer): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (aTable=nil) then
    exit;
  i := Rest.Model.GetTableIndex(aTable);
  if Rest.CacheWorthItForTable(i) then
    if Cardinal(i)<Cardinal(Length(fCache)) then
      with fCache[i] do begin
        EnterCriticalSection(Mutex);
        TimeOut := aTimeOut;
        LeaveCriticalSection(Mutex);
        result := true;
      end;
end;

function TSQLRestCache.SetCache(aTable: TSQLRecordClass): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (aTable=nil) then
    exit;
  i := Rest.Model.GetTableIndex(aTable);
  if Rest.CacheWorthItForTable(i) then
    if Cardinal(i)<Cardinal(Length(fCache)) then
      with fCache[i] do begin
        // global cache of all records of this table
        EnterCriticalSection(Mutex);
        try
          CacheEnable := true;
          CacheAll := True;
          Value.Clear;
          result := true;
        finally
          LeaveCriticalSection(Mutex);
        end;
      end;
end;

function TSQLRestCache.SetCache(aTable: TSQLRecordClass; aID: Integer): boolean;
var i: integer;
    Rec: TSQLRestCacheEntryValue;
begin
  result := false;
  if (self=nil) or (aTable=nil) or (aID<=0) then
    exit;
  i := Rest.Model.GetTableIndex(aTable);
  if Cardinal(i)>=Cardinal(Length(fCache)) then
    exit;
  if Rest.CacheWorthItForTable(i) then
    with fCache[i] do begin
      EnterCriticalSection(Mutex);
      try
        CacheEnable := true;
        if not CacheAll then begin
          i := Value.Find(aID);
          if i<0 then begin
            Rec.ID := aID;
            Rec.TimeStamp := 0;
            Value.Add(Rec);
            Value.Sort; // will sort by ID for faster retrieval
          end;
        end;
      finally
        LeaveCriticalSection(Mutex);
      end;
    end;
  result := True;
end;

function TSQLRestCache.SetCache(aRecord: TSQLRecord): boolean;
begin
  if (self=nil) or (aRecord=nil) or (aRecord.fID<=0) then
    result := false else
    result := SetCache(PSQLRecordClass(aRecord)^,aRecord.fID);
end;

constructor TSQLRestCache.Create(aRest: TSQLRest);
var i: integer;
begin
  if aRest=nil then
    EBusinessLayerException.CreateFmt('%s.Create',[ClassName]);
  fRest := aRest;
  SetLength(fCache,length(fRest.Model.Tables));
  for i := 0 to high(fCache) do
    with fCache[i] do begin
      Value.Init(TypeInfo(TSQLRestCacheEntryValueDynArray),Values,@Count);
      Value.Compare := SortDynArrayInteger; // will search/sort by ID
      InitializeCriticalSection(Mutex);
    end;
end;

destructor TSQLRestCache.Destroy;
var i: integer;
begin
  for i := 0 to high(fCache) do
    DeleteCriticalSection(fCache[i].Mutex);
  inherited;
end;

procedure TSQLRestCache.Clear;
var i: integer;
begin
  if self<>nil then
  for i := 0 to high(fCache) do
  with fCache[i] do begin
    EnterCriticalSection(Mutex);
    try
      Value.Clear;
      CacheAll := false;
      CacheEnable := false;
      TimeOut := 0;
    finally
      LeaveCriticalSection(Mutex);
    end;
  end;
end;

procedure TSQLRestCache.Flush;
var i: integer;
begin
  if self<>nil then
  for i := 0 to high(fCache) do
    fCache[i].FlushCacheAllEntries; // include *CriticalSection(Mutex)
end;

procedure TSQLRestCache.Flush(aTable: TSQLRecordClass);
var i: integer;
begin
  if self<>nil then begin
    i := fRest.Model.GetTableIndex(aTable);
    if i>=0 then
      fCache[i].FlushCacheAllEntries; // include *CriticalSection(Mutex)
  end;
end;

procedure TSQLRestCache.Flush(aTable: TSQLRecordClass; aID: integer);
var i: integer;
begin
  if self<>nil then begin
    i := fRest.Model.GetTableIndex(aTable);
    if i>0 then
      with fCache[i] do
      if CacheEnable then begin
        EnterCriticalSection(Mutex);
        try
          FlushCacheEntry(Value.Find(aID));
        finally
          LeaveCriticalSection(Mutex);
        end;
      end;
  end;
end;

procedure TSQLRestCache.Notify(aTable: TSQLRecordClass; aID: integer;
  const aJSON: RawUTF8; aAction: TSQLOccasion);
begin
  if (self<>nil) and (aTable<>nil) and (aID>0) then
    Notify(fRest.Model.GetTableIndex(aTable),aID,aJSON,aAction);
end;

procedure TSQLRestCache.Notify(aRecord: TSQLRecord; aAction: TSQLOccasion);
var aTableIndex: cardinal;
begin
  if (self=nil) or (aRecord=nil) or (aRecord.fID<=0) or
     not (aAction in [soInsert,soUpdate]) then
    exit;
  aTableIndex := fRest.Model.GetTableIndex(PSQLRecordClass(aRecord)^);
  if aTableIndex<Cardinal(Length(fCache)) then
    with fCache[aTableIndex] do
      if CacheEnable then
        SetJSON(aRecord);
end;

procedure TSQLRestCache.Notify(aTableIndex: integer; aID: integer;
  const aJSON: RawUTF8; aAction: TSQLOccasion);
begin
  if (self<>nil) and (aID>0) and (aAction in [soSelect,soInsert,soUpdate]) and
     (aJSON<>'') and (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
      if CacheEnable then
        SetJSON(aID,aJSON);
end;

procedure TSQLRestCache.NotifyDeletion(aTableIndex, aID: integer);
begin
  if (self<>nil) and (aID>0) and
     (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
    if CacheEnable then begin
      EnterCriticalSection(Mutex);
      try
        FlushCacheEntry(Value.Find(aID));
      finally
        LeaveCriticalSection(Mutex);
      end;
    end;
end;

procedure TSQLRestCache.NotifyDeletion(aTable: TSQLRecordClass; aID: integer);
begin
  if (self<>nil) and (aTable<>nil) and (aID>0) then
    NotifyDeletion(fRest.Model.GetTableIndex(aTable),aID);
end;

function TSQLRestCache.Retrieve(aID: Integer; aValue: TSQLRecord): boolean;
var TableIndex: cardinal;
begin
  result := false;
  if (self=nil) or (aValue=nil) or (aID<=0) then
    exit;
  TableIndex := fRest.Model.GetTableIndex(PSQLRecordClass(aValue)^);
  if TableIndex<Cardinal(Length(fCache)) then
    with fCache[TableIndex] do
    if CacheEnable and RetrieveJSON(aID,aValue) then
      result := true;
end;

function TSQLRestCache.Retrieve(aTableIndex, aID: integer): RawUTF8;
begin
  result := '';
  if (self<>nil) and (aID>0) and
     (Cardinal(aTableIndex)<Cardinal(Length(fCache))) then
    with fCache[aTableIndex] do
    if CacheEnable then
      RetrieveJSON(aID,result);
end;


{ TSQLRestClientURI }

function TSQLRestClientURI.EngineExecute(const SQL: RawUTF8): boolean;
begin
  result := URI(Model.Root,'POST',nil,nil,@SQL).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.URIGet(Table: TSQLRecordClass; ID: integer;
  var Resp: RawUTF8; ForUpdate: boolean=false): Int64Rec;
const METHOD: array[boolean] of RawUTF8 = ('GET','LOCK');
begin
  result := URI(Model.getURIID(Table,ID),METHOD[ForUpdate],@Resp,nil,nil);
end;

function TSQLRestClientURI.UnLock(Table: TSQLRecordClass; aID: integer): boolean;
begin
  if (self=nil) or not Model.UnLock(Table,aID) then
    result := false else // was not locked by the client
    result := URI(Model.getURIID(Table,aID),'UNLOCK').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.ExecuteList(const Tables: array of TSQLRecordClass;
  const SQL: RawUTF8): TSQLTableJSON;
var Resp: RawUTF8;
begin
  if self=nil then
    result := nil else
  with URI(Model.Root,'GET',@Resp,nil,@SQL) do
    if Lo=HTML_SUCCESS then begin // GET with SQL sent
      if high(Tables)=0 then
        result := TSQLTableJSON.Create([Tables[0]],SQL,Resp) else
        result := TSQLTableJSON.Create(RecordClassesToClasses(Tables),SQL,Resp);
      result.fInternalState := Hi;
    end else // get data
    result := nil;
end;

function TSQLRestClientURI.ServerInternalState: cardinal;
begin
  if (Self=nil) or (Model=nil) then // avoid GPF
    result := cardinal(-1) else
    result := URI(Model.Root,'STATE').Hi;
end;

function TSQLRestClientURI.ServerCacheFlush(aTable: TSQLRecordClass; aID: integer): boolean;
var aResp: RawUTF8;
begin
  if (Self=nil) or (Model=nil) then // avoid GPF
    result := false else
    result := CallBackGet('CacheFlush',[],aResp,aTable,aID)=HTML_SUCCESS;
end;

function TSQLRestClientURI.UpdateFromServer(const Data: array of TObject; out Refreshed: boolean;
  PCurrentRow: PInteger): boolean;
// notes about refresh mechanism:
// - if server doesn't implement InternalState, its value is 0 -> always refresh
// - if any TSQLTableJSON or TSQLRecord belongs to a TSQLRestServerStatic,
// the Server stated fInternalState=cardinal(-1) for them -> always refresh
var i: integer;
    State: cardinal;
    Resp: RawUTF8;
    T: TSQLTableJSON;
    TRefreshed: boolean; // to check for each Table refresh
const TState: array[boolean] of TOnTableUpdateState = (tusNoChange,tusChanged);
begin
  result := self<>nil;
  Refreshed := false;
  if not result then
    exit; // avoid GPF
  State := ServerInternalState; // get revision state from server
  for i := 0 to high(Data) do
    if Data[i]<>nil then
    if TObject(Data[i]).InheritsFrom(TSQLTableJSON) then begin
      T := TSQLTableJSON((Data[i]));
      if (T.QuerySQL<>'') and (T.InternalState<>State) then begin // refresh needed?
        with URI(Model.Root,'GET',@Resp,nil,@T.QuerySQL) do
          if Lo=HTML_SUCCESS then begin // GET with SQL sent
            if Assigned(OnTableUpdate) then
              OnTableUpdate(T,tusPrepare);
            TRefreshed := false;
            if not T.UpdateFrom(Resp,TRefreshed,PCurrentRow) then
              result := false else // mark error retrieving new content
              T.fInternalState := Hi;
            if TRefreshed then
              Refreshed := true;
            if Assigned(OnTableUpdate) then
              OnTableUpdate(T,TState[TRefreshed]);
          end
          else result := false; // mark error retrieving new content
        end;
    end else
    if TObject(Data[i]).InheritsFrom(TSQLRecord) then
    with TSQLRecord(Data[i]) do
      if (fID<>0) and (InternalState<>State) then begin // refresh needed?
        if not Refresh(fID,TSQLRecord(Data[i]),Refreshed) then
          result := false; // mark error retrieving new content
      end;
end;

function RecordClassesToClasses(const Tables: array of TSQLRecordClass): TClasses;
var n, i: integer;
begin
  n := length(Tables);
  SetLength(result,n);
  for i := 0 to n-1 do
    result[i] := Tables[i];
end;

function TSQLRestClientURI.List(const Tables: array of TSQLRecordClass;
  const SQLSelect, SQLWhere: RawUTF8): TSQLTableJSON;
var Resp, SQL: RawUTF8;
    U: RawUTF8;
    InternalState: cardinal;
begin
  result := nil;
  if high(Tables)<0 then exit;
  // GET Collection
  SQL := SQLFromSelectWhere(Tables,SQLSelect,SQLWhere);
  if high(Tables)=0 then begin
    // one Table -> use REST protocol (SQL as parameters)
    if not IsRowID(pointer(SQLSelect)) then
      // ID selected by default
      U := '?select='+UrlEncode(SQLSelect) else
      U := '';
    if SQLWhere<>'' then begin
      if U<>'' then
        U := U+'&where=' else
        U := U+'?where=';
      U := U+UrlEncode(SQLWhere);
    end;
    with URI(Model.URI[TSQLRecordClass(Tables[0])]+U,'GET',@Resp) do
      if Lo<>HTML_SUCCESS then
        exit else
        InternalState := Hi;
    result := TSQLTableJSON.Create([Tables[0]],SQL,Resp); // get data
  end else begin
    // multiple tables -> send SQL statement as HTTP body
    with URI(Model.Root,'GET',@Resp,nil,@SQL) do
      if Lo<>HTML_SUCCESS then
        exit else
        InternalState := Hi;
    result := TSQLTableJSON.Create(RecordClassesToClasses(Tables),SQL,Resp); // get data
  end;
  result.fInternalState := InternalState;
end;

function TSQLRestClientURI.InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
begin
  result := ExecuteList([Table],SQL);
end;

procedure TSQLRestClientURI.SessionClose;
var tmp: RawUTF8;
begin
  if (self<>nil) and (fSessionUser<>nil) and (fSessionID<>0) then begin
    // notify session closed to server
    CallBackGet('auth',['UserName',fSessionUser.LogonName,'Session',fSessionID],tmp);
    fSessionID := CONST_AUTHENTICATION_SESSION_NOT_STARTED;
  end;
end;

destructor TSQLRestClientURI.Destroy;
var t,i,aID: integer;
    Table: TSQLRecordClass;
begin
  SessionClose; // if not already notified
  fBatch.Free;
  try
    // unlock all still locked records by this client
    if Model<>nil then
    for t := 0 to high(Model.Locks) do begin
      Table := Model.Tables[t];
      with Model.Locks[t] do
      for i := 0 to Count-1 do begin
        aID := ID[i];
        if aID<>0 then // 0 is empty after unlock
          self.UnLock(Table,aID);
      end;
    end;
  finally
    // release memory and associated classes
    fSessionUser.Free;
    inherited;
  end;
end;

procedure TSQLRestClientURI.Commit(SessionID: cardinal);
begin
  inherited; // reset fTransactionActive flag
  URI(Model.Root,'END');
end;

procedure TSQLRestClientURI.RollBack(SessionID: cardinal);
begin
  inherited; // reset fTransactionActive flag
  URI(Model.Root,'ABORT');
end;

function TSQLRestClientURI.TransactionBegin(aTable: TSQLRecordClass;
  SessionID: cardinal): boolean;
begin
  result := inherited TransactionBegin(aTable,CONST_AUTHENTICATION_NOT_USED);
  if result then
    // fTransactionActive flag was not already set
    if aTable=nil then
      result := URI(Model.Root,'BEGIN').Lo=HTML_SUCCESS else
      result := URI(Model.URI[aTable],'BEGIN').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.TransactionBeginRetry(aTable: TSQLRecordClass;
  Retries: integer): boolean;
begin
  if Retries>50 then
    Retries := 50; // avoid loop for more than 10 seconds
  repeat
    result := TransactionBegin(aTable);
    if result then
      exit;
    dec(Retries);
    if Retries<=0 then break;
    sleep(100);
  until false;
end;

function TSQLRestClientURI.CallBackGet(const aMethodName: RawUTF8;
  const aParameters: array of const; out aResponse: RawUTF8;
  aTable: TSQLRecordClass; aID: integer; aResponseHead: PRawUTF8): integer;
var params: RawUTF8;
begin
  if self=nil then
    result := HTML_UNAVAILABLE else begin
{$ifdef WITHLOG}
    SQLite3Log.Enter(Self,pointer(aMethodName));
{$endif}
    params := UrlEncode(aParameters);
    result := URI(Model.getURICallBack(aMethodName,aTable,aID)+params,'GET',
      @aResponse,aResponseHead).Lo;
{$ifdef WITHLOG}
    SQLite3Log.Add.Log(sllServiceReturn,aResponse);
{$endif}
  end;
end;

function TSQLRestClientURI.SetUser(const aUserName, aPassword: RawUTF8;
  aHashedPassword: Boolean=false): boolean;
var aNonce, aClientNonce, aSessionKey: RawUTF8;
    i: integer;
    U: TSQLAuthUser;
begin
  result := false;
  if self=nil then
    exit;
  fSessionID := 0;
  fSessionIDHexa8 := '';
  fSessionPrivateKey := 0;
  FreeAndNil(fSessionUser);
  try
    if aUserName='' then
      exit;
    U := TSQLAuthUser.Create;
    try
      U.LogonName := trim(aUserName);
      if aHashedPassword then
        U.PasswordHashHexa := aPassword else
        U.PasswordPlain := aPassword; // PasswordHashHexa := SHA256('salt'+aPassword);
      aNonce := CallBackGetResult('auth',['UserName',U.LogonName]);
      if aNonce='' then
        exit;
      aClientNonce := SHA256(NowToString);
      aSessionKey := CallBackGetResult('auth',['UserName',U.LogonName,'Password',
         Sha256(Model.Root+aNonce+aClientNonce+U.LogonName+U.PasswordHashHexa),
         'ClientNonce',aClientNonce]);
      i := PosEx(RawUTF8('+'),aSessionKey,1);
      if i=0 then
        exit; // expect SessionID+HexaSessionPrivateKey
      fSessionID := GetCardinal(pointer(aSessionKey));
      if fSessionID=0 then
        exit;
      fSessionIDHexa8 := CardinalToHex(fSessionID);
      fSessionPrivateKey := crc32(crc32(0,Pointer(aSessionKey),length(aSessionKey)),
        pointer(U.PasswordHashHexa),length(U.PasswordHashHexa));
      fSessionUser := U;
      U := nil;
      result := true;
    finally
      U.Free;
    end;
  finally
    if Assigned(OnSetUser) then
      OnSetUser(self); // always notify of user change, even if failed
   end;
end;

function TSQLRestClientURI.URI(const url, method: RawUTF8;
  Resp, Head, SendData: PRawUTF8): Int64Rec;
var Retry: integer;
    aUserName, aPassword: string;
    aResp: RawUTF8;
begin
  if self=nil then begin
    Int64(result) := HTML_UNAVAILABLE;
    exit;
  end;
  if fServerTimeStampOffset=0 then begin
    fServerTimeStampOffset := 0.0001; // avoid endless recursive call
    if CallBackGet('TimeStamp',[],aResp)=HTML_SUCCESS then
      SetServerTimeStamp(GetInt64(pointer(aResp)));
  end;
  for Retry := -1 to MaximumAuthentificationRetry do begin
    result := InternalURI(SessionSign(url),method,Resp,Head,SendData);
    if (result.Lo<>HTML_FORBIDDEN) or not Assigned(OnAuthentificationFailed) then
      break;
    // "403 Forbidden" in case of authentication failure -> try relog
    if not OnAuthentificationFailed(Retry+2,aUserName,aPassword) or
       not SetUser(StringToUTF8(aUserName),StringToUTF8(aPassword)) then
      break;
  end;
end;

function TSQLRestClientURI.SessionSign(const url: RawUTF8): RawUTF8;
  procedure Sign; // avoid try..finally if authentication is not needed
  var Nonce: RawUTF8;
      Tix: cardinal;
  begin // timestamps have 256 ms resolution
    if PosEx(RawUTF8('?'),url,1)=0 then
      result := url+'?session_signature=' else
      result := url+'&session_signature=';
    Tix := GetTickCount;
    if Tix<fSessionLastTickCount then // wrap around 0 after 49.7 days
      inc(fSessionTickCountOffset,1 shl(32-8)); // allows 35 years timing
    fSessionLastTickCount := Tix;
    Nonce := CardinalToHex(Tix shr 8+fSessionTickCountOffset);
    result := result+fSessionIDHexa8+Nonce+CardinalToHex(
      crc32(crc32(fSessionPrivateKey,Pointer(Nonce),length(Nonce)),Pointer(url),length(url)));
    // Hexa8(SessionID)+Hexa8(TimeStamp)+
    // Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
    //   Hexa8(TimeStamp)+url))
  end;
begin
  if (fSessionID=0) or (fSessionUser=nil) then
    result := url else
    Sign;
end;

function TSQLRestClientURI.CallBackGetResult(const aMethodName: RawUTF8;
  const aParameters: array of const; aTable: TSQLRecordClass; aID: integer): RawUTF8;
var aResponse: RawUTF8;
begin
  if CallBackGet(aMethodName,aParameters,aResponse,aTable,aID)=HTML_SUCCESS then
    result := JSONDecode(aResponse) else
    result := '';
end;

function TSQLRestClientURI.CallBackPut(const aMethodName,
  aSentData: RawUTF8; out aResponse: RawUTF8; aTable: TSQLRecordClass;
  aID: integer; aResponseHead: PRawUTF8): integer;
begin
  if self=nil then
    result := HTML_UNAVAILABLE else begin
{$ifdef WITHLOG}
    SQLite3Log.Enter(self,pointer(aMethodName));
{$endif}
    result := URI(Model.getURICallBack(aMethodName,aTable,aID),
      'PUT',@aResponse,aResponseHead,@aSentData).Lo;
{$ifdef WITHLOG}
    SQLite3Log.Add.Log(sllServiceReturn,'result=%',result);
{$endif}
  end;
end;

function TSQLRestClientURI.ServiceRegister(const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation=sicSingle;
  const aContractExpected: RawUTF8=''): boolean;
begin
  result := False;
  if (self=nil) or (high(aInterfaces)<0) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerClient.Create(self);
  result := (fServices as TServiceContainerClient).AddInterface(
    aInterfaces,aInstanceCreation,aContractExpected);
end;

procedure TSQLRestClientURI.BatchAbort;
begin
  if self<>nil then begin
    fBatchCount := 0;
    fBatchTable := nil;
    FreeAndNil(fBatch);
  end;
end;

function TSQLRestClientURI.BatchAdd(Value: TSQLRecord; SendData: boolean;
  ForceID: boolean=false): integer;
var Props: TSQLRecordProperties;
begin
  result := -1;
  if (self=nil) or (Value=nil) or (fBatch=nil) then
    exit; // invalid parameters, or not opened BATCH sequence
  Props := Value.RecordProps;
  if fBatchTable<>nil then
    if Value.RecordClass<>fBatchTable then
      exit else // '{"Table":[...,"POST":{object},...]}'
      fBatch.AddShort('"POST":') else begin
      fBatch.AddShort('"POST@'); // '[...,"POST@Table":{object}',...]'
      fBatch.AddString(Props.SQLTableName);
      fBatch.Add('"',':');
    end;
  if SendData then begin
    if Props.Kind in INSERT_WITH_ID then
      ForceID := true; // same format as TSQLRestClient.Add
    Props.SetSimpleFieldsExpandedJSONWriter(fBatch,(Value.fID<>0) and ForceID,soInsert);
    Value.ComputeFieldsBeforeWrite(self,seAdd); // update TModTime/TCreateTime fields
    Value.GetJSONValues(fBatch);
    if ForceID then
      fCache.Notify(Value,soInsert);
  end else
    fBatch.Add('{','}'); // '{"Table":[...,"POST":{},...]}'
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRestClientURI.BatchCount: integer;
begin
  if self=nil then
    result := 0 else
    result := fBatchCount;
end;

function TSQLRestClientURI.BatchDelete(ID: integer): integer;
begin
  if (self=nil) or (fBatchTable=nil) or
     (ID<=0) or not RecordCanBeUpdated(fBatchTable,ID,seDelete) then begin
    result := -1; // invalid parameters, or not opened BATCH sequence
    exit;
  end;
  fCache.NotifyDeletion(fBatchTable,ID);
  fBatch.AddShort('"DELETE":'); // '{"Table":[...,"DELETE":ID,...]}'
  fBatch.Add(ID);
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRestClientURI.BatchDelete(Table: TSQLRecordClass; ID: integer): integer;
begin
  if (self=nil) or (fBatch=nil) or (Table=nil) or
     (ID<=0) or not RecordCanBeUpdated(Table,ID,seDelete) then begin
    result := -1; // invalid parameters, or not opened BATCH sequence
    exit;
  end;
  fCache.NotifyDeletion(Table,ID);
  fBatch.AddShort('"DELETE@'); // '[...,"DELETE@Table":ID,...]}'
  fBatch.AddString(Table.RecordProps.SQLTableName);
  fBatch.Add('"',':');
  fBatch.Add(ID);
  fBatch.Add(',');
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRestClientURI.BatchSend(var Results: TIntegerDynArray): integer;
var Data, Resp: RawUTF8;
    R: PUTF8Char;
    i: integer;
begin
  if (self=nil) or (fBatch=nil) then begin // no opened BATCH sequence
    result := HTML_BADREQUEST;
    exit;
  end;
  try
    fBatch.CancelLastComma;
    fBatch.Add(']');
    if fBatchTable<>nil then
      fBatch.Add('}'); // end sequence array '{"Table":["cmd":values,...]}'
    Data := fBatch.Text;
    if fBatchTable<>nil then
      // URI is 'ModelRoot/TableName/0' with POST method
      result := URI(Model.URI[fBatchTable]+'/0','POST',@Resp,nil,@Data).Lo else
      // URI is 'ModelRoot/Batch' with PUT method
      result := URI(Model.Root+'/Batch','PUT',@Resp,nil,@Data).Lo;
    if result<>HTML_SUCCESS then
      exit;
    // returned Resp shall be an array of integers: '[200,200,...]'
    R := pointer(Resp);
    if R<>nil then
      while R^<>'[' do inc(R);
    result := HTML_BADREQUEST;
    if (R=nil) or (R^<>'[') then
      // invalid response
      exit;
    SetLength(Results,fBatchCount);
    if IdemPChar(R,'["OK"]') then begin // to save bandwith if no adding
      for i := 0 to fBatchCount-1 do
        Results[i] := HTML_SUCCESS;
    end else begin
      inc(R); // jump first '['
      for i := 0 to fBatchCount-1 do begin
        Results[i] := GetJSONIntegerVar(R);
        while R^ in [#1..' '] do inc(R);
        case R^ of
          ',': inc(R);
          ']': break;
          else exit;
        end;
      end;
      if R^<>']' then
        exit;
    end;
    result := HTML_SUCCESS; // returns OK
  finally
    BatchAbort;
  end;
end;

function TSQLRestClientURI.BatchStart(aTable: TSQLRecordClass): boolean;
begin
  if (self=nil) or (fBatchCount>0) or (fBatch<>nil) then begin
    // already opened BATCH sequence
    result := false;
    exit;
  end;
  fBatch := TJSONSerializer.CreateOwnedStream;
  if aTable<>nil then begin
    fBatch.Add('{'); // sending data is '{"Table":["cmd":values,...]}'
    fBatch.AddFieldName(aTable.SQLTableName);
  end;
  fBatch.Add('[');
  fBatchTable := aTable;
  fBatchCount := 0;
  result := true;
end;

function TSQLRestClientURI.BatchUpdate(Value: TSQLRecord): integer;
var FillPrepareFields: boolean;
    Props: TSQLRecordProperties;
begin
  result := -1;
  if (self=nil) or (Value=nil) or (fBatch=nil) or (Value.fID<=0) or
     not RecordCanBeUpdated(Value.RecordClass,Value.fID,seUpdate) or
     not BeforeUpdateEvent(Value) then
    exit; // invalid parameters, or not opened BATCH sequence
  Props := Value.RecordProps;
  if fBatchTable<>nil then
    if Value.RecordClass<>fBatchTable then
      exit else // '{"Table":[...,"PUT":{object},...]}'
      fBatch.AddShort('"PUT":') else begin
      fBatch.AddShort('"PUT@'); // '[...,"PUT@Table":{object}',...]'
      fBatch.AddString(Props.SQLTableName);
      fBatch.Add('"',':');
    end;
  // same format as TSQLRestClientURI.Update, BUT including the ID
  FillPrepareFields := (Value.fFill<>nil) and (Value.fFill.Table<>nil) and
     (Value.fFill.fTableMapRecordManyInstances=nil);
  if FillPrepareFields then
    // update ID, TModTime and FillPrepare-mapped fields
    Value.fFill.SetMappedFieldsExpandedJSONWriter(Value.RecordClass,fBatch) else
    // update all simple fields (also for FillPrepareMany)
    Value.RecordClass.RecordProps.SetSimpleFieldsExpandedJSONWriter(fBatch,true,soUpdate);
  Value.ComputeFieldsBeforeWrite(self,seUpdate); // update sftModTime fields
  Value.GetJSONValues(fBatch);
  fBatch.Add(',');
  if FillPrepareFields then // may not contain all fields -> delete from cache
    fCache.NotifyDeletion(Value.RecordClass,Value.fID) else
    fCache.Notify(Value,soUpdate);
  result := fBatchCount;
  inc(fBatchCount);
end;

function TSQLRestClientURI.EngineAdd(Table: TSQLRecordClass;
  const SentData: RawUTF8): integer;
var P: PUTF8Char;
    Head: RawUTF8;
begin
  result := 0;
  if URI(Model.URI[Table],'POST',nil,@Head,@SentData).Lo<>HTML_CREATED then
    exit; // response must be '201 Created'
  P := pointer(Head); // we need to check the headers
  if P<>nil then
  repeat
    // find ID from 'Location: Member Entry URI' header entry
    if IdemPChar(P,'LOCATION:') then begin // 'Location: root/People/11012' e.g.
      inc(P,9);
      while P^>#13 do inc(P); // go to end of line
      P^ := #0; // make line asciiz, even if ended with #13
      while P[-1] in ['0'..'9'] do dec(P); // get all number chars
      if P[-1]='-' then dec(P); 
      result := GetInteger(P); // get numerical value at the end of the URI
      exit;
    end;
    while not (P^ in [#0,#13]) do inc(P);
    if P^=#0 then break else inc(P);
    if P^=#10 then inc(P);
  until false;
end;

function TSQLRestClientURI.EngineDelete(Table: TSQLRecordClass; ID: integer): boolean;
begin
  result := URI(Model.getURIID(Table,ID),'DELETE').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineDeleteWhere(Table: TSQLRecordClass;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
begin  // ModelRoot/TableName?WhereClause to delete members
  result := URI(Model.getURI(Table)+'?'+UrlEncode(SQLWhere),'DELETE').Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8;
begin
  if (self=nil) or (SQL='') or (ReturnedRowCount<>nil) or
     (URI(Model.Root,'GET',@result,nil,@SQL).Lo<>HTML_SUCCESS) then
    result := ''
end;

function TSQLRestClientURI.EngineRetrieve(TableModelIndex, ID: integer;
  ForUpdate: boolean; var InternalState: cardinal; var Resp: RawUTF8): boolean;
begin
  with URIGet(Model.Tables[TableModelIndex],ID,Resp,ForUpdate) do
    if Lo=HTML_SUCCESS then begin
      InternalState := Hi;
      result := true;
    end else
      result := false;
end;

function TSQLRestClientURI.EngineRetrieveBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
begin
  if (self=nil) or (aID<=0) or (BlobField=nil) then
    result := false else
    // URI is 'ModelRoot/TableName/ID/BlobFieldName' with GET method
    result := URI(Model.getURICallBack(BlobField^.Name,Table,aID),
      'GET',@BlobData).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineUpdate(Table: TSQLRecordClass;
  ID: integer; const SentData: RawUTF8): boolean;
begin
  result := URI(Model.getURIID(Table,ID),'PUT',nil,nil,@SentData).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineUpdateBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo;
  const BlobData: TSQLRawBlob): boolean;
var Head: RawUTF8;
begin
  Head := 'Content-Type: application/octet-stream';
  if (self=nil) or (aID<=0) or (BlobField=nil) then
    result := false else
    // PUT ModelRoot/TableName/ID/BlobFieldName 
    result := URI(FormatUTF8('%/%/%',[Model.URI[Table],aID,BlobField^.Name]),
       'PUT',nil,@Head,@BlobData).Lo=HTML_SUCCESS;
end;

function TSQLRestClientURI.EngineUpdateField(Table: TSQLRecordClass;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  if (self=nil) or (Table=nil) then
    result := false else
    // PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..
    result := URI(FormatUTF8('%?setname=%&set=%&wherename=%&where=%',
      [Model.URI[Table],SetFieldName,UrlEncode(SetValue),WhereFieldName,UrlEncode(WhereValue)]),
        'PUT').Lo=HTML_SUCCESS;
end;


{ TSQLRestServer }

{$ifdef MSWINDOWS}
const
  // UnicodeString since Delphi 2009 (filenames are wide)
  ServerPipeNamePrefix: string = '\\.\pipe\Sqlite3_';

var
  GlobalURIRequestServer: TSQLRestServer = nil;

function URIRequest(url, method, SendData: PUTF8Char; Resp, Head: PPUTF8Char): Int64Rec; cdecl;
function StringToPChar(const s: RawUTF8): PUTF8Char;
var L: integer;
begin
  L := length(s);
  if L=0 then
    result := nil else begin
    inc(L); // copy also last #0 from s
    if USEFASTMM4ALLOC then
      GetMem(result,L) else
      result := pointer(GlobalAlloc(GMEM_FIXED,L));
    move(pointer(s)^,result^,L);
  end;
end;
var sResp, sHead: RawUTF8;
begin
  if GlobalURIRequestServer=nil then begin
    Int64(result) := HTML_NOTIMPLEMENTED; // 501 
    exit;
  end;
  result := GlobalURIRequestServer.URI(url,method,SendData,sResp,sHead,
    @SUPERVISOR_ACCESS_RIGHTS);
  if Resp<>nil then
    Resp^ := StringToPChar(sResp); // make result copy as PAnsiChar
  if Head<>nil then
    Head^ := StringToPChar(sHead);
end;

function ReadString(Handle: cardinal): RawUTF8;
var L, Read: cardinal;
    P: PUTF8Char;
begin
  result := '';
  if (FileRead(Handle,L,4)=4) and (L<>0) then begin
    SetLength(result,L);
    P := pointer(result);
    repeat
      Read := FileRead(Handle,P^,L);
      if Read=0 then begin
        sleep(100); // nothing available -> wait a little and retry
        Read := FileRead(Handle,P^,L);
        if Read=0 then begin // server may be down -> abort
          raise ECommunicationException.Create('ReadString');
          exit;
        end;
      end;
      inc(P,Read);
      dec(L,Read);
    until L=0; // loop until received all expected data
  end;
end;

procedure WriteString(Handle: cardinal; const Text: RawUTF8);
var L: cardinal;
begin
  L := length(Text);
  if L=0 then
    // write cardinal 0 if Text=''
    FileWrite(Handle,L,4) else
    // write length+content at once
    FileWrite(Handle,pointer(PtrInt(Text)-4)^,L+4);
end;

function TSQLRestServer.ExportServerNamedPipe(const ServerApplicationName: TFileName): boolean;
var PipeName: TFileName;
    Pipe: cardinal;
begin
  result := false;
  if fExportServerNamedPipeThread<>nil then
    exit; // only one ExportServer() by running process
  if {$ifdef UNICODE}IdemPCharW{$else}IdemPChar{$endif}(pointer(ServerApplicationName),'\\') then
    PipeName := ServerApplicationName else
    PipeName := ServerPipeNamePrefix+ServerApplicationName;
  Pipe := FileOpen(PipeName,fmOpenReadWrite); // is this pipe existing?
  if Pipe<>Invalid_Handle_Value then begin
    WriteString(Pipe,''); // send integer=0 -> force server disconnect
    FileClose(Pipe);
    exit; // only one pipe server with this name at once
  end;
  fExportServerNamedPipeThread := TSQLRestServerNamedPipe.Create(self, PipeName);
  NoAJAXJSON := true; // use smaller JSON size in this not HTTP use (never AJAX)
  result := true; // success
end;

function TSQLRestServer.ExportServerMessage(const ServerWindowName: string): boolean;
begin
  result := false;
  if (self=nil) or (fServerWindow<>0) or (GlobalURIRequestServer=self)  or
     (fExportServerNamedPipeThread<>nil) then
    exit;
  fServerWindow := CreateInternalWindow(ServerWindowName,self);
  if fServerWindow=0 then
    exit; // impossible to create window -> fail
  fServerWindowName := ServerWindowName;
  result := true;
end;

const
  MAGIC_SYN: cardinal = $A5ABA5AB;

procedure TSQLRestServer.AnswerToMessage(var Msg: TWMCopyData);
var url, method: RawUTF8;
    SentData: RawUTF8;
    Resp, Head, ResStr: RawUTF8;
    P: PUTF8Char;
    Res: record
      Magic: cardinal;
      LoHi: Int64Rec;
    end;
    Data: TCopyDataStruct;
begin
  Msg.Result := HTML_NOTFOUND;
  if (self=nil) or (Msg.From=0) then
    exit;
  P := Msg.CopyDataStruct^.lpData;
  if (P=nil) or (Msg.CopyDataStruct^.cbData<=7) then
    exit;
  if PCardinal(P)^<>MAGIC_SYN then
    exit; // invalid layout: a broadcasted WM_COPYDATA message? :(
  inc(P,4);
  // #1 is a field delimiter below, since Get*Item() functions return nil for #0
  Msg.Result := HTML_SUCCESS; // Send something back
  url := GetNextItem(P,#1);
  method := GetNextItem(P,#1);
  Head := GetNextItem(P,#1);
  SetString(SentData,P,
    PtrInt(Msg.CopyDataStruct^.cbData)-(P-Msg.CopyDataStruct^.lpData));
  Res.Magic := MAGIC_SYN;
  Res.LoHi := URI(url,method,SentData,Resp,Head,@SUPERVISOR_ACCESS_RIGHTS);
  // note: it's up to URI overriden method to implement access rights
  SetString(ResStr,PAnsiChar(@Res),sizeof(Res));
  Resp := ResStr+Head+#1+Resp;
  Data.dwData := fServerWindow;
  Data.cbData := length(Resp);
  Data.lpData := pointer(Resp);
  { TODO : 64-bits windows: can we store a PtrInt value in WM_COPYDATA? }
  SendMessage(Msg.From,WM_COPYDATA,fServerWindow,PtrInt(@Data));
end;

function TSQLRestServer.CloseServerNamedPipe: boolean;
begin
  if fExportServerNamedPipeThread<>nil then begin
    fExportServerNamedPipeThread.Terminate;
    Sleep(200); // we have sleep(128) in TSQLRestServerNamedPipe.EngineExecute
    FreeAndNil(fExportServerNamedPipeThread);
    result := true;
  end else
    result := false;
end;

function TSQLRestServer.CloseServerMessage: boolean;
begin
  result := ReleaseInternalWindow(fServerWindowName,fServerWindow);
end;

function TSQLRestServer.ExportServer: boolean;
begin
  if (fServerWindow<>0) or (fExportServerNamedPipeThread<>nil) then
    result := false else // another server was running
  if (GlobalURIRequestServer=nil) or (GlobalURIRequestServer=self) then begin
    GlobalURIRequestServer := self;
    result := true;
  end else
    result := false;
end;

{$endif MSWINDOWS}

constructor TSQLRestServer.Create(aModel: TSQLModel; aHandleUserAuthentication: boolean);
var i,n: integer;
    C: PtrInt;
    M: PMethodInfo;
//    RI: PReturnInfo; // such RTTI info not available at least in Delphi 7
begin
  // specific server initialization
  fVirtualTableDirect := true; // faster direct Static call by default
  fAuthUserIndex := aModel.GetTableIndex(TSQLAuthUser);
  fAuthGroupIndex := aModel.GetTableIndex(TSQLAuthGroup);
  fHandleAuthentication := (fAuthUserIndex>=0) and (fAuthGroupIndex>=0);
  if aHandleUserAuthentication and (not fHandleAuthentication) then begin
    // we need both AuthUser+AuthGroup tables for authentication -> create now
    if fAuthUserIndex<0 then
      aModel.AddTable(TSQLAuthUser,@fAuthUserIndex);
    if fAuthGroupIndex<0 then
      aModel.AddTable(TSQLAuthGroup,@fAuthGroupIndex);
    fHandleAuthentication := true;
  end;
  // abstract MVC initalization
  inherited Create(aModel);
  fStats := TSQLRestServerStats.Create;
  InitializeCriticalSection(fSessionCriticalSection);
  // retrieve published methods
  fPublishedMethods.Init(false);
  C := PtrInt(ClassType);
  while C<>0 do begin
    M := PPointer(C+vmtMethodTable)^;
    if M<>nil then begin
      {$ifdef FPC}
      n := PCardinal(M)^;
      inc(PCardinal(M));
      for i := 1 to n do begin
        fPublishedMethods.Add(M^.Name^,'',PtrInt(M^.Addr));
        inc(M);
      end;
      {$else}
      n := PWord(M)^;
      inc(PWord(M));
      for i := 1 to n do begin
{        RI := M^.ReturnInfo;
        if (RI=nil) or
           ((RI<>nil) and (RI^.ParamCount=1) and (RI^.CallingConvention=ccRegister) and
            (RI^.ReturnType<>nil) and (RI^.ReturnType^.Kind=tkInteger) and
            (RI^.Param^.ParamType^=TypeInfo(TSQLRestServerCallBackParams)) and
            (pfVar in RI^.Param^.Flags)) then }
        fPublishedMethods.Add(M^.Name,'',PtrInt(M^.Addr));
        inc(PByte(M),M^.Len);
      end;
      {$endif}
    end;
    C := PPtrInt(C+vmtParent)^;
    if C=0 then
      break else
      C := PPtrInt(C)^;
  end;
  ServiceMethodByPassAuthentication('Auth');
  ServiceMethodByPassAuthentication('TimeStamp');
end;

destructor TSQLRestServer.Destroy;
var i: integer;
begin
{$ifdef WITHLOG}
  if not InheritsFrom(TSQLRestServerStatic) then
    SQLite3Log.Add.Log(sllInfo,Stats.DebugMessage,self);
{$endif}
{$ifdef MSWINDOWS}
  if GlobalURIRequestServer=self then begin
    GlobalURIRequestServer := nil;
    sleep(200); // way some time any request is finished in another thread
  end;
  // close any opened server
  CloseServerNamedPipe;
  CloseServerMessage;
{$endif}
  for i := 0 to high(fStaticData) do
    // free all TSQLRestServerStatic objects and update file if necessary
    fStaticData[i].Free;
  fSessions.Free;
  DeleteCriticalSection(fSessionCriticalSection);
  fStats.Free;
  inherited;
end;

function TSQLRestServer.GetStaticDataServer(aClass: TSQLRecordClass): TSQLRestServerStatic;
var i: integer;
begin
  result := nil;
  if fStaticData<>nil then begin
    i := Model.GetTableIndex(aClass);
    if i>=0 then
      result := fStaticData[i];
  end;
end;

function TSQLRestServer.GetStaticDataServerOrVirtualTable(aClass: TSQLRecordClass): TSQLRestServerStatic;
begin
  if (fStaticData=nil) and (fStaticVirtualTable=nil) then
    result := nil else
    result := GetStaticDataServerOrVirtualTable(Model.GetTableIndex(aClass));
end;

function TSQLRestServer.GetStaticDataServerOrVirtualTable(aTableIndex: integer): TSQLRestServerStatic;
begin
  result := nil;
  if aTableIndex>=0 then begin
    if fStaticData<>nil then
      result := fStaticData[aTableIndex];
    if (result=nil) and fVirtualTableDirect and (fStaticVirtualTable<>nil) then
      result := fStaticVirtualTable[aTableIndex];
  end;
end;

function TSQLRestServer.GetVirtualTable(aClass: TSQLRecordClass): TSQLRestServerStatic;
var i: integer;
begin
  result := nil;
  if fStaticVirtualTable<>nil then begin
    i := Model.GetTableIndex(aClass);
    if (i>=0) and (Model.TableProps[i].Kind in IS_CUSTOM_VIRTUAL) then
      result := fStaticVirtualTable[i];
  end;
end;

function TSQLRestServer.StaticDataCreate(aClass: TSQLRecordClass;
  const aFileName: TFileName; aBinaryFile: boolean;
  aServerClass: TSQLRestServerStaticClass): TSQLRestServerStatic;
var i: integer;
begin
  result := nil;
  i := Model.GetTableIndex(aClass);
  if i<0 then
    exit; // this class is not in the current database Model
  if fStaticData<>nil then
    result := fStaticData[i];
  if result<>nil then
    // class already registered -> update file name
    result.fFileName := aFileName else begin
    // class not already registered -> register now
    if aServerClass=nil then
      aServerClass := TSQLRestServerStaticInMemory; // default in-memory engine
    result := aServerClass.Create(aClass,self,aFileName,aBinaryFile);
    if fStaticData=nil then
      SetLength(fStaticData,length(Model.Tables));
    fStaticData[i] := result;
  end;
end;

procedure TSQLRestServer.FlushInternalDBCache;
begin
  // do nothing by default
end;

function SQLGetOrder(const SQL: RawUTF8): RawUTF8;
var P: PUTF8Char;
    i: integer;
begin
  i := PosI('ORDER BY ',SQL);
  if i>0 then begin
    inc(i,9);
    while SQL[i] in [#1..' '] do inc(i); // trim left
    result := copy(SQL,i,maxInt);
    P := PosChar(Pointer(Result),' ');
    if P=nil then
      P := PosChar(Pointer(Result),';');
    if P<>nil then
      SetLength(result,P-pointer(Result)); // trim right
  end;
  if result='' then // by default, a SQLite3 query is ordered by ID
    result := 'RowID';
end;

function ExtractInlineParameters(const SQL: RawUTF8;
  var Types: TSQLFieldTypeArray; var Values: TRawUTF8DynArray; var maxParam: integer): RawUTF8;
var ppBeg: integer;
    P, Gen: PUTF8Char;
begin
  maxParam := 0;
  SetString(result,PAnsiChar(pointer(SQL)),length(SQL));
  ppBeg := PosEx(RawUTF8(':('),SQL,1);
  if (ppBeg=0) or (PosEx(RawUTF8('):'),SQL,ppBeg+2)=0) then
    // SQL code with no valid :(...): internal parameters -> leave maxParam=0
    exit;
  // compute GenericSQL from SQL, converting :(...): into ?
  Gen := PUTF8Char(pointer(result))+ppBeg-1; // Gen^ just before :(
  P := PUTF8Char(pointer(SQL))+ppBeg+1; // P^ just after :(
  repeat
    Gen^ := '?'; // replace :(...): by ?
    inc(Gen);
    if length(Values)<=maxParam then
      SetLength(Values,maxParam+8);
    P := SQLParamContent(P,Types[maxParam],Values[maxParam]);
    if P=nil then begin
      maxParam := 0;
      result := SQL;
      exit; // any invalid parameter -> try direct SQL
    end;
    while (P^<>#0) and (PWord(P)^<>Ord(':')+Ord('(')shl 8) do begin
      Gen^ := P^;
      inc(Gen);
      inc(P);
    end;
    if P^=#0 then
      Break;
    inc(P,2);
    inc(maxParam);
    if maxParam>high(Types) then
      raise EParsingException.Create('Too many :(): params');
  until false;
  // return the correct SQL statement, with params in Values[]
  SetLength(result,Gen-pointer(result));
  inc(maxParam);
end;

procedure TSQLRestServer.SetNoAJAXJSON(const Value: boolean);
var i: integer;
begin
  fNoAJAXJSON := Value;
  for i := 0 to high(fStaticData) do
    if fStaticData[i]<>nil then
      fStaticData[i].NoAJAXJSON := Value; // set JSON format for static also
end;

function TSQLRestServer.InternalListJSON(Table: TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
var JSON: RawUTF8;
    Static: TSQLRestServerStatic;
begin
  result := nil;
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    JSON := Static.EngineList(SQL) else
    JSON := EngineList(SQL);
  if (JSON<>'') and (JSON<>'[]'#$A) then
    result := TSQLTableJSON.Create([Table],SQL,JSON);
end;

function TSQLRestServer.Retrieve(aID: integer; Value: TSQLRecord;
  ForUpdate: boolean): boolean;
var TableIndex: integer; // used by EngineRetrieve() for SQL statement caching
    Resp: RawUTF8;
    Static: TSQLRestServerStatic;
begin // this version handles locking and use fast EngineRetrieve() method
  // check parameters
  result := false;
  if Value=nil  then
    exit; // avoid GPF
  Value.fID := 0;
  if (self=nil) or (aID=0) then
    exit;
  TableIndex := Model.GetTableIndex(PSQLRecordClass(Value)^);
  if TableIndex<0 then
    exit;
  // try to lock before retrieval (if ForUpdate)
  if ForUpdate and not Model.Lock(TableIndex,aID) then
    exit;
  // retrieve from internal cache
  if fCache.Retrieve(aID,Value) then begin
    result := True;
    exit;
  end;
  // get JSON object '{...}' in Resp from corresponding EngineRetrieve() method
  Static := GetStaticDataServerOrVirtualTable(TableIndex);
  if Static<>nil then
    Resp := Static.EngineRetrieve(TableIndex,aID) else
    Resp := EngineRetrieve(TableIndex,aID);
  if Resp='' then
    exit;
  // fill Value from JSON if was correctly retrieved
  Value.FillFrom(Resp);
  result := true;
end;

function TSQLRestServer.ExecuteList(const Tables: array of TSQLRecordClass; const SQL: RawUTF8): TSQLTableJSON;
var JSON: RawUTF8;
begin
  JSON := EngineList(SQL,false);
  if JSON<>'' then
    result := TSQLTableJSON.Create(RecordClassesToClasses(Tables),SQL,JSON) else
    result := nil;
end;

function TSQLRestServer.UnLock(Table: TSQLRecordClass; aID: integer): boolean;
begin
  result := Model.UnLock(Table,aID);
end;

procedure TSQLRestServer.Commit(SessionID: cardinal);
var i: integer;
begin
  inherited Commit(SessionID);
  if self<>nil then
    for i := 0 to high(fStaticVirtualTable) do
    if fStaticVirtualTable[i]<>nil then
    with TSQLRestServerStaticInMemory(fStaticVirtualTable[i]) do 
      if InheritsFrom(TSQLRestServerStaticInMemory) and not CommitShouldNotUpdateFile then
        UpdateFile; // will do nothing if not Modified
end;

function TSQLRestServer.Add(Value: TSQLRecord; SendData: boolean;
  ForceID: boolean=false): integer;
var JSONValues: RawUTF8;
    Static: TSQLRestServerStatic;
begin
  if (self=nil) or (Value=nil) then begin
    result := 0;
    exit;
  end;
  if SendData then begin
    Value.ComputeFieldsBeforeWrite(self,seAdd); // update TModTime/TCreateTime fields
    if Value.RecordProps.Kind in INSERT_WITH_ID then
      ForceID := true;
    JSONValues := Value.GetJSONValues(true, // true=expanded
      (Value.fID<>0) and ForceID,soInsert);
  end else
    JSONValues := '';
  // on success, returns the new ROWID value; on error, returns 0
  Static := GetStaticDataServerOrVirtualTable(PSQLRecordClass(Value)^);
  if Static<>nil then // faster direct call
    result := Static.EngineAdd(PSQLRecordClass(Value)^,JSONValues) else
    result := EngineAdd(PSQLRecordClass(Value)^,JSONValues);
  // on success, Value.ID is updated with the new ROWID
  Value.fID := result;
  if SendData then
    fCache.Notify(PSQLRecordClass(Value)^,result,JSONValues,soInsert);
end;

function TSQLRestServer.Update(Value: TSQLRecord): boolean;
var JSONValues: RawUTF8;
    Static: TSQLRestServerStatic;
begin
  if (self=nil) or (Value=nil) or not inherited Update(Value) then begin
    result := false; // current user don't have enough right to update this record 
    exit;
  end;
  Value.ComputeFieldsBeforeWrite(self,seUpdate); // update sftModTime fields
  JSONValues := Value.GetJSONValues(true,false,soUpdate); // expanded + without ID
  fCache.Notify(Value,soUpdate); // JSONValues on update may not be enough for cache
  Static := GetStaticDataServerOrVirtualTable(PSQLRecordClass(Value)^);
  if Static<>nil then // faster direct call
    result := Static.EngineUpdate(PSQLRecordClass(Value)^,Value.fID,JSONValues) else
    result := EngineUpdate(PSQLRecordClass(Value)^,Value.fID,JSONValues);
end;

function TSQLRestServer.Delete(Table: TSQLRecordClass; ID: integer): boolean;
var Static: TSQLRestServerStatic;
begin
  if not inherited Delete(Table,ID) then begin  // call RecordCanBeUpdated()
    result := false;
    exit;
  end;
  fCache.NotifyDeletion(Table,ID);
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    result := Static.EngineDelete(Table,ID) else
    result := EngineDelete(Table,ID);
  if result then
    // force relational database coherency (i.e. our FOREIGN KEY implementation)
    AfterDeleteForceCoherency(Table,ID);
end;

function TSQLRestServer.Delete(Table: TSQLRecordClass; const SQLWhere: RawUTF8): boolean;
var IDs: TIntegerDynArray;
    i: integer;
    Static: TSQLRestServerStatic;
begin
  result := false;
  if not InternalDelete(Table,SQLWhere,IDs) then
    exit;
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
    result := Static.EngineDeleteWhere(Table,SQLWhere,IDs) else
    result := EngineDeleteWhere(Table,SQLWhere,IDs);
  if result then
    // force relational database coherency (i.e. our FOREIGN KEY implementation)
    for i := 0 to high(IDs) do
      AfterDeleteForceCoherency(Table,IDs[i]);
end;

function TSQLRestServer.RetrieveBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; out BlobData: TSQLRawBlob): boolean;
var Static: TSQLRestServerStatic;
    BlobField: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) then
    exit;
  BlobField := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if BlobField=nil then
    exit;
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
     result := Static.EngineRetrieveBlob(Table,aID,BlobField,BlobData) else
     result := EngineRetrieveBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServer.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean;
var Static: TSQLRestServerStatic;
    BlobField: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) or not RecordCanBeUpdated(Table,aID,seUpdate) then
    exit;
  BlobField := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if BlobField=nil then
    exit;
  Static := GetStaticDataServerOrVirtualTable(Table);
  if Static<>nil then // faster direct call
     result := Static.EngineUpdateBlob(Table,aID,BlobField,BlobData) else
     result := EngineUpdateBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServer.AfterDeleteForceCoherency(Table: TSQLRecordClass;
  aID: integer): boolean;
var T: integer;
    Tab: TSQLRecordClass;
    Where: PtrUInt;
    RecRef: TRecordReference;
    Static: TSQLRestServerStatic;
    FN, W: RawUTF8;
begin
  result := true; // success if no property found
  Where := 0; // make compiler happy
  RecRef := RecordReference(Model,Table,aID);
  if RecRef<>0 then
  for T := 0 to high(Model.RecordReferences) do
  with Model.RecordReferences[T] do begin
    case FieldType of
    sftRecord: // TRecordReference published field
      Where := RecRef;
    sftID:     // TSQLRecord published field
      if FieldRecordClass=Table then
        Where := aID else
        continue;
    else continue;
    end;
    // set Field=0 where Field references aID
    FN := RawUTF8(FieldName^);
    W := UInt32ToUTF8(Where);
    Tab := Model.Tables[TableIndex];
    Static := GetStaticDataServerOrVirtualTable(Tab);
    if Static<>nil then // fast direct call
       result := Static.EngineUpdateField(Tab,FN,'0',FN,W) else
       result := EngineUpdateField(Tab,FN,'0',FN,W);
  end;
end;

function TSQLRestServer.CreateSQLMultiIndex(Table: TSQLRecordClass;
  const FieldNames: array of RawUTF8; Unique: boolean; IndexName: RawUTF8=''): boolean;
var SQL: RawUTF8;
    i, TableIndex: integer;
    Props: TSQLRecordProperties;
    Static: TSQLRestServerStatic;
begin
  result := false;
  if (Self=nil) or InheritsFrom(TSQLRestServerStatic) then
    exit; // avoid endless loop for TSQLRestServerStatic with no overriden method
  TableIndex := Model.GetTableIndex(Table);
  if (TableIndex<0) or (high(FieldNames)<0) then
    exit; // invalid Table
  if fStaticVirtualTable<>nil then begin
    Static := fStaticVirtualTable[TableIndex];
    if Static<>nil then begin
      if not Static.InheritsFrom(TSQLRestServerStaticInMemory) then
         // will try to create an index on the static table (e.g. for external DB)
         result := Static.CreateSQLMultiIndex(Table,FieldNames,Unique,IndexName);
      exit;
    end;
  end;
  Props := Model.TableProps[TableIndex];
  for i := 0 to high(FieldNames) do
    if Props.FieldIndexFromRawUTF8(FieldNames[i])<0 then
      exit; // wrong field name
  if Unique then
    SQL := 'UNIQUE ' else
    SQL := '';
  if IndexName='' then
    IndexName := RawUTF8ArrayToCSV(FieldNames,'');
  SQL := FormatUTF8('CREATE %INDEX IF NOT EXISTS Index%% ON %(%);',
    [SQL,Props.SQLTableName,IndexName,Props.SQLTableName,RawUTF8ArrayToCSV(FieldNames,',')]);
  result := EngineExecuteAll(SQL);
end;

function TSQLRestServer.CreateSQLIndex(Table: TSQLRecordClass; const FieldName: RawUTF8;
  Unique: boolean; const IndexName: RawUTF8=''): boolean;
begin
  result := CreateSQLMultiIndex(Table,[FieldName],Unique,IndexName);
end;

function TSQLRestServer.CreateSQLIndex(Table: TSQLRecordClass;
  const FieldNames: array of RawUTF8; Unique: boolean): boolean;
var i: integer;
begin
  result := true;
  for i := 0 to high(FieldNames) do
    if not CreateSQLMultiIndex(Table,[FieldNames[i]],Unique) then
     result := false;
end;

class function TSQLRestServer.JSONEncodeResult(const OneValue: array of const): RawUTF8;
var W: TTextWriter;
    i,h: integer;
begin
  result := '';
  h := high(OneValue);
  if h<0 then
    exit;
  W := TTextWriter.CreateOwnedStream;
  try
    W.AddShort('{"result":');
    if h=0 then
      // result is one value
      W.AddJSONEscape(OneValue[0]) else begin
      // result is one array of values
      W.Add('[');
      i := 0;
      repeat
        W.AddJSONEscape(OneValue[i]);
        if i=h then break;
        W.Add(',');
        inc(i);
      until false;
      W.Add(']');
    end;
    W.Add('}');
    result := W.Text;
  finally
    W.Free;
  end;
end;

procedure TSQLRestServer.ServiceMethodByPassAuthentication(const aMethodName: RawUTF8);
var i: Integer;
begin
  if self=nil then
    exit;
  i :=  fPublishedMethods.Find(aMethodName);
  if i>=0 then
    AddInteger(fPublishedMethodsUnauthenticated,fPublishedMethodsUnauthenticatedCount,i,True);
end;

function TSQLRestServer.LaunchCallBack(var aParams: TSQLRestServerCallBackParams;
  var aResp: RawUTF8; var aResult: Cardinal): boolean;
var Method: TMethod;
    Invoke: TSQLRestServerCallBack absolute Method;
begin
  result := False;
  if (aParams.MethodIndex<0) or (self=nil) then
    exit;
  Method.Code := pointer(fPublishedMethods.List[aParams.MethodIndex].Tag);
  // launch the method found
{$ifdef WITHLOG}
  SQLite3Log.Enter(self,pointer(fPublishedMethods.List[aParams.MethodIndex].Name));
{$endif}
  try
    Method.Data := Self;
    aResult := Invoke(aParams);
    aResp := aParams.Resp;
    inc(fStats.fServices);
    result := true; // mark method found and execution OK
  except
    on Exception do; // ignore any exception (return false)
  end;
end;

type
  TServiceInternalMethod = (imFree, imContract, imSignature);
  
const
  SERVICE_PSEUDO_METHOD: array[TServiceInternalMethod] of RawUTF8 = (
    '_free_','_contract_','_signature_');

function TSQLRestServer.ServiceRegister(
  aImplementationClass: TClass; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation): TServiceFactoryServer;
begin
  result := nil;
  if (self=nil) or (aImplementationClass=nil) or (high(aInterfaces)<0) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerServer.Create(self);
  result := (fServices as TServiceContainerServer).
    AddImplementation(aImplementationClass,aInterfaces,aInstanceCreation);
end;

function TSQLRestServer.ServiceRegister(aClient: TSQLRest; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation=sicSingle;
  const aContractExpected: RawUTF8=''): boolean;
begin
  result := False;
  if (self=nil) or (high(aInterfaces)<0) or (aClient=nil) then
    exit;
  if fServices=nil then
    fServices := TServiceContainerServer.Create(self);
  result := (fServices as TServiceContainerServer).AddInterface(
    aInterfaces,aInstanceCreation,aContractExpected);
end;

function TSQLRestServer.LaunchService(const aParams: TSQLRestServerCallBackParams;
  var aResp: RawUTF8; var aResult: cardinal): boolean;
var Service: TServiceFactory;
    method, JSON: RawUTF8;
    Values: TPUtf8CharDynArray;
    ServiceParams: PUTF8Char;
    i, m, ServiceID: integer;
    internal: TServiceInternalMethod;
begin
  result := false;
  if Services=nil then
    exit;
  // 1. retrieve request parameters according to routing scheme
  ServiceID := aParams.Context.ID;
  case ServicesRouting of
  rmRest: begin
    i := Services.fListInterfaceMethod.IndexOf(aParams.URI);
    if i<0 then
      exit; // no specific message: it may be a valid request
  {$ifdef WITHLOG}
    SQLite3Log.Enter(self,pointer(aParams.URI));
  {$endif}
    i := PtrInt(Services.fListInterfaceMethod.Objects[i]);
    m := i shr 16;
    Service := Services.Index(i and $ffff);
    if aParams.SentData<>'' then  // parameters sent as JSON array (the Delphi/AJAX way)
      ServiceParams := pointer(aParams.SentData) else begin
      JSON := UrlDecode(aParams.Parameters); // optional URI decoding (the HTML way)
      ServiceParams := pointer(JSON);
    end;
    if ServiceID<0 then
      ServiceID := 0;
  end;
  rmJSON_RPC: begin
    Service := Services[aParams.URI];
    SetString(JSON,PAnsiChar(pointer(aParams.SentData)),length(aParams.SentData));
    JSONDecode(JSON,['method','params','id'],Values,True);
    if Values[0]=nil then begin
      aParams.ErrorMsg^ := 'Method name required';
      exit;
    end;
    method := Values[0];
    ServiceParams := Values[1];
    ServiceID := GetCardinal(Values[2]);
    m := -1;
    for internal := low(TServiceInternalMethod) to high(TServiceInternalMethod) do
      if IdemPropNameU(method,SERVICE_PSEUDO_METHOD[internal]) then begin
        m := ord(internal);
        break;
      end;
    if m<0 then begin
      m := Service.fMethod.FindHashed(method);
      if m<0 then begin
        aParams.ErrorMsg^ := 'Unknown method';
        exit;
      end;
      inc(m,length(SERVICE_PSEUDO_METHOD));
    end;
  {$ifdef WITHLOG}
    SQLite3Log.Enter(self,pointer(aParams.URI+'.'+method));
  {$endif}
  end;
  else Exit;
  end;
  // 2. handle request
  if ServiceParams=nil then begin
    aParams.ErrorMsg^ := 'Parameters required';
    exit;
  end;
  if Service=nil then
    exit;
  inc(fStats.fServices);
  case m of
  ord(imFree): // "method":"_free_" to release sicClientDriven..sicPerGroup
    if ServiceID<=0 then // expects an instance ID to be released
      exit else
      m := -1; // notify ExecuteMethod() to release the internal instance
  ord(imContract): begin // "method":"_contract_" to retrieve the implementation contract
    aResult := HTML_SUCCESS; // OK
    aResp := '{"result":['+Service.ContractExpected+'],"id":0}';
    result := true;
    exit; // "id":0 for this method -> no instance was created
  end;
  ord(imSignature): begin // "method":"_signature_" to retrieve the implementation signature
    if TServiceContainerServer(Services).PublishSignature then begin
      aResult := HTML_SUCCESS; // OK
      aResp := '{"result":['+Service.Contract+'],"id":0}';
      result := true; // "id":0 for this method -> no instance was created
    end;
    exit; // not allowed to publish signature
  end;
  else
    dec(m,length(SERVICE_PSEUDO_METHOD)); // index of operation in fMethods[]
  end;
  if (aParams.Context.Session>CONST_AUTHENTICATION_NOT_USED) and (m>=0) and
     (aParams.Context.Group-1 in Service.fMethods[m].ExecutionDenied) then begin
    aParams.ErrorMsg^ := 'Unauthorized method';
    exit;
  end;
  aResult := TServiceFactoryServer(Service).ExecuteMethod(
    aParams.Context,m,ServiceID,ServiceParams,aResp,aParams.Head^,aParams.ErrorMsg^);
  result := true; // notify method found (any error status is in aResult)
end;

function TSQLRestServer.RunBatch(aStatic: TSQLRestServerStatic;
  aTable: TSQLRecordClass; Sent: PUTF8Char; var Resp, ErrorMsg: RawUTF8): boolean;
var EndOfObject: AnsiChar;
    wasString, OK: boolean;
    TableName, Value: RawUTF8;
    URIMethod, RunningBatchURIMethod: TSQLURIMethod;
    RunningBatchStatic: TSQLRestServerStatic; { TODO: allow nested batch between tables? }
    Method, MethodTable: PUTF8Char;
    Props: TSQLRecordProperties;
    i, ID, Count: integer;
    Results: TIntegerDynArray;
    RunTable: TSQLRecordClass;
    RunStatic: TSQLRestServerStatic;
begin
  result := false;
  if (self=nil) or (Sent=nil) then
    exit;
  if aTable<>nil then begin
    // unserialize expected sequence array as '{"Table":["cmd":values,...]}'
    while Sent^<>'{' do inc(Sent);
    if Sent^<>'{' then
      exit;
    inc(Sent);
    TableName := GetJSONField(Sent,Sent,@wasString,@EndOfObject);
    Props := aTable.RecordProps;
    if not wasString or (EndOfObject<>':') or (Sent=nil) or
       not IdemPropNameU(Props.SQLTableName,TableName) then
      exit;
  end; // or '["cmd@Table":values,...]'
  while Sent^<>'[' do inc(Sent);
  if Sent^<>'[' then
    exit;
  inc(Sent);
  RunningBatchStatic := nil;
  RunningBatchURIMethod := mNone;
  Count := 0;
  try // to protect InternalBatchStart/Stop locking
    repeat
      // retrieve method name and associated (static) table
      Method := GetJSONField(Sent,Sent,@wasString,@EndOfObject);
      if not wasString or (EndOfObject<>':') or (Sent=nil) or (Method=nil) then
        exit;
      MethodTable := PosChar(Method,'@');
      if MethodTable=nil then begin // e.g. '{"Table":[...,"POST":{object},...]}'
        RunTable := aTable;
        RunStatic := aStatic;
      end else begin                // e.g. '[...,"POST@Table":{object},...]'
        i := Model.GetTableIndex(MethodTable+1);
        if i<0 then
          exit;
        RunTable := Model.Tables[i];
        RunStatic := GetStaticDataServerOrVirtualTable(i);
      end;
      if Count>=length(Results) then
        SetLength(Results,Count+256+Count shr 3);
      // get CRUD method (ignoring @ char if appended after method name)
      if IdemPChar(Method,'DELETE') then
        URIMethod := mDELETE else
      if IdemPChar(Method,'POST') then
        URIMethod := mPOST else
      if IdemPChar(Method,'PUT') then
        URIMethod := mPUT else
        URIMethod := mNone;
      // handle batch request sending (if any pending)
      if (RunningBatchStatic<>nil) and  
         ((RunStatic<>RunningBatchStatic) or (RunningBatchURIMethod<>URIMethod)) then begin
        RunningBatchStatic.InternalBatchStop; // send pending statements
        RunningBatchStatic := nil;
      end;
      if (RunStatic<>nil) and (RunStatic<>RunningBatchStatic) and
         RunStatic.InternalBatchStart(URIMethod) then begin
        RunningBatchStatic := RunStatic;
        RunningBatchURIMethod := URIMethod;
      end;
      // process CRUD method operation
      case URIMethod of
      mDELETE: begin // '{"Table":[...,"DELETE":ID,...]}' or '[...,"DELETE@Table":ID,...]'
        ID := GetInteger(GetJSONField(Sent,Sent,@wasString,@EndOfObject));
        if (ID<=0) or wasString or
           not RecordCanBeUpdated(RunTable,ID,seDelete,@ErrorMsg) then
          exit;
        if RunStatic<>nil then
          OK := RunStatic.EngineDelete(RunTable,ID) else
          OK := EngineDelete(RunTable,ID);
        if OK then begin
          fCache.NotifyDeletion(RunTable,ID);
          if (RunningBatchStatic<>nil) or
             AfterDeleteForceCoherency(RunTable,ID) then
            Results[Count] := HTML_SUCCESS; // 200 OK
        end;
      end;
      mPOST: begin // '{"Table":[...,"POST":{object},...]}' or '[...,"POST@Table":{object},...]'
        Value := JSONGetObject(Sent,nil,EndOfObject);
        if (Sent=nil) or
           not RecordCanBeUpdated(RunTable,0,seAdd,@ErrorMsg) then
          exit;
        if RunStatic<>nil then
          ID := RunStatic.EngineAdd(RunTable,Value) else
          ID := EngineAdd(RunTable,Value);
        Results[Count] := ID;
        fCache.Notify(RunTable,ID,Value,soInsert);
      end;
      mPUT: begin // '{"Table":[...,"PUT":{object},...]}' or '[...,"PUT@Table":{object},...]'
        Value := JSONGetObject(Sent,@ID,EndOfObject);
        if (Sent=nil) or (Value='') then
          exit;
        if RunStatic<>nil then
          OK := RunStatic.EngineUpdate(RunTable,ID,Value) else
          OK := EngineUpdate(RunTable,ID,Value);
        if OK then begin
          Results[Count] := HTML_SUCCESS; // 200 OK
          fCache.NotifyDeletion(RunTable,ID); // Value does not have CreateTime e.g.
          // or may be complete -> update won't work as expected -> delete from cache
        end;
      end;
      else exit; // unknown method
      end;
      inc(Count);
    until EndOfObject=']';
  finally
    if RunningBatchStatic<>nil then
      RunningBatchStatic.InternalBatchStop; // send pending statements
  end;
  if aTable<>nil then begin // '{"Table":["cmd":values,...]}' format
    if Sent=nil then
      exit;
    while Sent^<>'}' do inc(Sent);
    result := Sent^='}';
  end else
    result := true;
  // send back operation status array
  for i := 0 to Count-1 do
    if Results[i]<>HTML_SUCCESS then begin
      Resp := IntegerDynArrayToCSV(Results,Count,'[',']');
      exit;
    end;
  Resp := '["OK"]';  // to save bandwith if no adding
end;

procedure StatusCodeToErrorMsg(Code: integer; var result: RawUTF8);
begin
  case Code of
    100:             result := 'Continue';
    HTML_SUCCESS:    result := 'OK';
    HTML_CREATED:    result := 'Created';
    202:             result := 'Accepted';
    203:             result := 'Non-Authoritative Information';
    204:             result := 'No Content';
    300:             result := 'Multiple Choices';
    301:             result := 'Moved Permanently';
    302:             result := 'Found';
    303:             result := 'See Other';
    304:             result := 'Not Modified';
    307:             result := 'Temporary Redirect';
    HTML_BADREQUEST: result := 'Bad Request';
    401:             result := 'Unauthorized';
    HTML_FORBIDDEN:  result := 'Forbidden';
    HTML_NOTFOUND:   result := 'Not Found';
    405:             result := 'Method Not Allowed';
    406:             result := 'Not Acceptable';
    500:             result := 'Internal Server Error';
    HTML_UNAVAILABLE:result := 'Service Unavailable';
    else             result := 'Invalid Request';
  end;
end;

function StringToMethod(const method: RawUTF8): TSQLURIMethod;
const NAME: array[mGET..high(TSQLURIMethod)] of string[7] = (
  'GET','POST','PUT','DELETE','BEGIN','END','ABORT','LOCK','UNLOCK','STATE');
var URIMethodUp: string[7];
begin
  if Length(method)<7 then begin
    URIMethodUp[0] := AnsiChar(UpperCopy(@URIMethodUp[1],method)-@URIMethodUp[1]);
    for result := low(NAME) to high(NAME) do
      if URIMethodUp=NAME[result] then
        exit;
  end;
  result := mNone;
end;

function TSQLRestServer.URI(const url, method, SentData: RawUTF8;
      out Resp, Head: RawUTF8; RestAccessRights: PSQLAccessRights): Int64Rec;
var BlobFieldName: RawUTF8;
    Static: TSQLRestServerStatic;
    Engine: TSQLRestServer;
    i,j,L: PtrInt;
    SQLSelect, SQLWhere, SQLSort, SQLDir, SQL, ErrorMsg: RawUTF8;
    SQLStartIndex, SQLResults: integer;
    StaticKind: (sNone, sInMemory, sVirtual);
    SQLisSelect, OK: boolean;
    URI: TSQLRestServerCallBackParams;
    Session: TAuthSession;
    SessionAccessRights: TSQLAccessRights; // session may be deleted meanwhile
    P: PUTF8Char;
    Blob: PPropInfo;
{$ifdef WITHSTATPROCESS}
    timeStart,timeEnd: Int64;
{$endif}
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}

  procedure SetRespFromError;
  begin
     inc(fStats.fInvalid);
    if ErrorMsg='' then
      StatusCodeToErrorMsg(result.Lo,ErrorMsg);
    {$ifdef WITHLOG}
    Log.Log(sllServer,'% % ERROR=% (%)',[method,url,result.Lo,ErrorMsg],self);
    {$endif}
    if Resp='' then // return error content as JSON object
      Resp := FormatUTF8('{'#13#10'"ErrorCode":%,'#13#10'"ErrorText":%'#13#10'}',
        [result.Lo,QuotedStr(pointer(ErrorMsg),'"')]);
  end;

begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter;
{$endif}
  // 0. always return internal database state count (even if URI is '')
{$ifdef WITHSTATPROCESS}
  QueryPerformanceCounter(timeStart);
{$endif}
  result.Hi := InternalState; // get first, since other threads may change it
  L := length(url);
  inc(fStats.fIncomingBytes,L+length(method)+length(SentData)+12);
  // 1. retrieve URI expecting 'ModelRoot[/TableName[/ID[/BlobFieldName]]]' format
  i := 0;
  if (url<>'') and (url[1]='/') then inc(i); // URL may be '/path'
  j := length(Model.Root);
  if (i+j>L) or (not(url[i+j+1] in [#0,'/','?'])) or
     (StrCompIL(pointer(PtrInt(url)+i),pointer(Model.Root),j,0)<>0) then begin
    result.Lo := HTML_NOTFOUND; // server does not match the Request-URI
    ErrorMsg := 'Invalid Root';
    SetRespFromError;
    exit; // bad ModelRoot -> caller can try another TSQLRestServer
  end;
  result.Lo := HTML_BADREQUEST; // default error code is 400 BAD REQUEST
  URI.URI := copy(url,j+i+2,maxInt);
  i := PosEx(RawUTF8('/'),URI.URI,1);
  if i>0 then begin
    URI.Parameters := @URI.URI[i+1];
    URI.Context.ID := GetNextItemCardinal(URI.Parameters,'/');
    if (URI.Context.ID>0) and (URI.Parameters<>nil) then begin
      // for URL like "ModelRoot/TableName/ID/BlobFieldName"
      P := PosChar(URI.Parameters,'?');
      if P=nil then
        BlobFieldName := URI.Parameters else
        SetString(BlobFieldName,PAnsiChar(URI.Parameters),P-URI.Parameters);
    end;
    SetLength(URI.URI,i-1);
    j := PosEx(RawUTF8('?'),url,1);
    if j>0 then // '?select=...&where=...' or '?where=...'
      URI.Parameters := @url[j+1] else
      URI.Parameters := nil;
  end else begin
    URI.Context.ID := -1;
    i := PosEx(RawUTF8('?'),url,1);
    if i>0 then begin // '?select=...&where=...' or '?where=...'
      URI.Parameters := @url[i+1];
      i := PosEx(RawUTF8('?'),URI.URI);
      if i>0 then
        dec(i);
      SetLength(URI.URI,i);
    end else
      URI.Parameters := nil; // no parameter
  end;
  URI.TableIndex := Model.GetTableIndex(URI.URI);
  Engine := self;
  Static := nil;
  StaticKind := sNone;
  if URI.TableIndex<0 then begin
    URI.Table := nil;
    URI.MethodIndex := fPublishedMethods.Find(URI.URI);
  end else begin
    URI.MethodIndex := -1;
    URI.Table := Model.Tables[URI.TableIndex];
    if fStaticData<>nil then
      Static := fStaticData[URI.TableIndex]; // fast retrieve TSQLRestServerStatic
    if Static<>nil then
      StaticKind := sInMemory else
      if fVirtualTableDirect and (fStaticVirtualTable<>nil) then
        if fStaticVirtualTable[URI.TableIndex]<>nil then begin
          Static := fStaticVirtualTable[URI.TableIndex];
          StaticKind := sVirtual;
        end;
    if Static<>nil then
      Engine := Static;
  end;
  // 2. handle security
  Session := nil;
  if HandleAuthentication then begin
    URI.Context.Session := CONST_AUTHENTICATION_SESSION_NOT_STARTED;
    // check session_signature=... parameter
    if URI.Parameters<>nil then begin
      // expected format is 'session_signature='Hexa8(SessionID)+Hexa8(TimeStamp)+
      // Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
      //   Hexa8(TimeStamp)+url))
      i := L-(17+24);
      if (i>0) and // should be LAST parameter in URL
         IdemPChar(@url[i],'SESSION_SIGNATURE=') and
         HexDisplayToCardinal(@url[i+18],URI.Context.Session) then begin
        EnterCriticalSection(fSessionCriticalSection);
        try
          Session := SessionAccess(URI.Context);
          if Session.IsValidURL(url,i-2) then begin
            // supplied RestAccessRights is ignored and replaced by the user rights
            {$ifdef WITHLOG}
            Log.Log(sllUserAuth,'%/%',[Session.User.LogonName,URI.Context.Session],self);
            {$endif}
            move(Session.fAccessRights,SessionAccessRights,sizeof(TSQLAccessRights));
            RestAccessRights := @SessionAccessRights;
          end else
            // mark invalid query authentication
            Session := nil;
        finally
          LeaveCriticalSection(fSessionCriticalSection);
        end;
      end;
    end;
    if (Session=nil) and ((URI.MethodIndex<0) or
      not IntegerScanExists(pointer(fPublishedMethodsUnauthenticated),
        fPublishedMethodsUnauthenticatedCount,URI.MethodIndex)) then begin
      // /auth + /timestamp are e.g. allowed services without signature
      result.Lo := HTML_FORBIDDEN; // 403 in case of authentication failure
      // 401 Unauthorized response MUST include a WWW-Authenticate header,
      // which is not what we used, so we won't send 401 error code but 403
      SetRespFromError;
      exit; // authentication error -> caller can try to open another session
    end;
  end else begin // default unique session if authentication is not enabled
    URI.Context.Session := CONST_AUTHENTICATION_NOT_USED;
    URI.Context.User := 0;
    URI.Context.Group := 0;
  end;
  // 3. call appropriate database commands
  URI.Context.Method := StringToMethod(method);
  URI.SentData := SentData;
  URI.Head := @Head;
  URI.ErrorMsg := @ErrorMsg;
  with URI.Context do
  case Method of
  mLOCK,mGET: begin
    if URI.Table=nil then begin
      if (Method<>mLOCK) and
          // GET ModelRoot/MethodName + parameters sent in URI
         ((URI.MethodIndex<0) or not LaunchCallBack(URI,Resp,result.Lo)) then
        if (URI.URI='') or not (reService in RestAccessRights^.AllowRemoteExecute) or
           // GET ModelRoot/Service.Method[/ID] + parameters sent as JSON or in URI
           not LaunchService(URI,Resp,result.Lo) then begin
          if (SentData='') and (URI.Parameters<>nil) and
             (reUrlEncodedSQL in RestAccessRights^.AllowRemoteExecute) then begin
            // GET with a SQL statement sent in URI, as sql=....
            while not UrlDecodeValue(URI.Parameters,'SQL=',SQL,@URI.Parameters) do
              if URI.Parameters=nil then break;
          end else
            // GET with a SQL statement sent as UTF-8 body
            SQL := SentData;
          SQLisSelect := isSelect(pointer(SQL));
          if (SQL<>'') and
            (SQLisSelect or (reSQL in RestAccessRights^.AllowRemoteExecute)) then begin
            // no user check for SELECT: see TSQLAccessRights.GET comment
            URI.TableIndex := Model.GetTableIndexFromSQLSelect(SQL,false);
            if URI.TableIndex>=0 then begin  // SQL refers to this unique table
              if fStaticData<>nil then
                // no SQLite3 module available for fStaticData[] -> we need to
                // retrieve manualy any static table from the SQL SELECT statement
                Static := fStaticData[URI.TableIndex];
              if (Static=nil) and fVirtualTableDirect and (fStaticVirtualTable<>nil) then begin
                Static := fStaticVirtualTable[URI.TableIndex];
                // virtual table may need adaptation (e.g. RowID -> ID)
                if (Static<>nil) and not Static.AdaptSQLForEngineList(SQL) then
                    // complex request will use SQlite3 virtual engine module
                    Static := nil;
              end;
            end;
            if Static<>nil then
              Engine := Static;
            Resp := Engine.EngineList(SQL);
            // security note: only first statement is run by EngineList()
            if Resp<>'' then begin // got JSON list '[{...}]' ?
              result.Lo := HTML_SUCCESS;  // 200 OK
              if not SQLisSelect then
                inc(fStats.fModified);
            end;
          end;
        end;
    end else
    // here, Table<>nil and TableIndex in [0..MAX_SQLTABLES-1]
    if not (URI.TableIndex in RestAccessRights^.GET) then // check User Access
      result.Lo := HTML_FORBIDDEN else begin
      if ID>0 then begin
        // GET ModelRoot/TableName/ID[/BlobFieldName] to retrieve one member,
        // with or w/out locking, or a specified BLOB field content
        if Method=mLOCK then // LOCK is to be followed by PUT -> check user
          if not (URI.TableIndex in RestAccessRights^.PUT) then
            result.Lo := HTML_FORBIDDEN else
            if Model.Lock(URI.TableIndex,ID) then
              Method := mGET; // mark successfully locked
        if Method<>mLOCK then
          if BlobFieldName<>'' then begin
            // GET ModelRoot/TableName/ID/BlobFieldName: retrieve BLOB field content
            Blob := URI.Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
            if Blob<>nil then begin
              if Engine.EngineRetrieveBlob(URI.Table,ID,Blob,TSQLRawBlob(Resp)) then begin
                result.Lo := HTML_SUCCESS; // 200 OK
                Head := HEADER_CONTENT_TYPE+GetMimeContentType(pointer(Resp),Length(Resp));
              end;
            end else begin
              // GET ModelRoot/TableName/ID/MethodName: try MethodName
              URI.MethodIndex := fPublishedMethods.Find(BlobFieldName);
              if URI.MethodIndex>=0 then
                LaunchCallBack(URI,Resp,result.Lo);
            end;
          end else begin
            // GET ModelRoot/TableName/ID: retrieve a member content, JSON encoded
            Resp := fCache.Retrieve(URI.TableIndex,ID);
            if Resp='' then begin
              Resp := Engine.EngineRetrieve(URI.TableIndex,ID); // get JSON object '{...}'
              fCache.Notify(URI.TableIndex,ID,Resp,soSelect); // cache if expected
            end;
            if Resp<>'' then // if something was found
              result.Lo := HTML_SUCCESS; // 200 OK
          end;
      end else
      // ModelRoot/TableName with 'select=..&where=' or YUI paging
      if Method<>mLOCK then begin // LOCK not available here
        SQLSelect := 'RowID'; // if no select is specified (i.e. ModelRoot/TableName)
        // all IDs of this table are returned to the client
        SQLWhere := '';
        if URI.Parameters<>nil then begin // '?select=...&where=...' or '?where=...'
          SQLStartIndex := 0;
          SQLResults := 0;
          if URI.Parameters^<>#0 then
          repeat
            UrlDecodeValue(URI.Parameters,'SORT=',SQLSort);
            UrlDecodeValue(URI.Parameters,'DIR=',SQLDir);
            UrlDecodeInteger(URI.Parameters,'STARTINDEX=',SQLStartIndex);
            UrlDecodeInteger(URI.Parameters,'RESULTS=',SQLResults);
            UrlDecodeValue(URI.Parameters,'SELECT=',SQLSelect);
            UrlDecodeValue(URI.Parameters,'WHERE=',SQLWhere,@URI.Parameters);
          until URI.Parameters=nil;
          // let SQLite3 do the sort and the paging (will be ignored by Static)
          if (SQLSort<>'') and
             not ContainsUTF8(pointer(SQLWhere),'ORDER BY') then begin
            if SameTextU(SQLDir,'DESC') then
              SQLSort := SQLSort+' DESC'; // allow DESC, default is ASC
            SQLWhere := SQLWhere+' ORDER BY '+SQLSort;
          end;
          if (SQLResults<>0) and not ContainsUTF8(pointer(SQLWhere),'LIMIT ') then
            SQLWhere := FormatUTF8('% LIMIT % OFFSET %',[SQLWhere,SQLResults,SQLStartIndex]);
        end;
        SQL := URI.Table.RecordProps.SQLFromSelectWhere(SQLSelect,trim(SQLWhere));
        if (Static<>nil) and (StaticKind=sInMemory) then
          // manual retrieval (no SQLite3 module available for fStaticData[])
          Resp := Static.EngineList(SQL) else
          // TSQLVirtualTableJSON/External will rely on their SQLite3 module
          Resp := EngineList(SQL);
        if Resp<>'' then  // got JSON list '[{...}]' ?
          result.Lo := HTML_SUCCESS;  // 200 OK
      end;
    end;
  end;
  mUNLOCK: begin
    // ModelRoot/TableName/ID to unlock a member
    if not (URI.TableIndex in RestAccessRights^.PUT) then
      result.Lo := HTML_FORBIDDEN else
    if (URI.Table<>nil) and (ID>0) and
       Model.UnLock(URI.Table,ID) then
        result.Lo := HTML_SUCCESS; // 200 OK
  end;
  mSTATE: begin
    // STATE method for TSQLRestClientURI.ServerInternalState
    // this method is called with Root (-> Table=nil -> Static=nil)
    // we need a specialized method in order to avoid fStats.Invalid increase
    result.Lo := HTML_SUCCESS;
    for i := 0 to high(fStaticData) do
      if fStaticData[i]<>nil then
        if fStaticData[i].RefreshedAndModified then begin
          inc(InternalState); // force refresh
          break;
        end;
  end else
  // write methods (mPOST, mPUT, mDELETE...) are handled separately
  if (URI.Table<>nil) or (Method<>mPOST) or // check thread-safe call of service
     not (reService in RestAccessRights^.AllowRemoteExecute) or
     // POST ModelRoot/Service.Method[/ID] + parameters sent as JSON or in URI
     not LaunchService(URI,Resp,result.Lo) then
  // now we have to handle a write to the DB (POST/PUT/DELETE...)
  if AcquireWrite(URI.Context) then // make it thread-safe and transaction-safe
  try
    case Method of
    mPOST: begin       // POST=ADD=INSERT
      if URI.Table=nil then begin
        // ModelRoot with free SQL statement sent as UTF-8 (only for Admin group)
        // security note: multiple SQL statements can be run in EngineExecuteAll()
        if (reSQL in RestAccessRights^.AllowRemoteExecute) and (ErrorMsg='') and
           EngineExecuteAll(SentData) then begin
          result.Lo := HTML_SUCCESS; // 200 OK
          inc(fStats.fModified);
        end;
      end else
      // here, Table<>nil and TableIndex in [0..MAX_SQLTABLES-1]
      if not (URI.TableIndex in RestAccessRights^.POST) then // check User
        result.Lo := HTML_FORBIDDEN else
      if ID<0 then begin
        // ModelRoot/TableName with possible JSON SentData: create a new member
        ID := Engine.EngineAdd(URI.Table,SentData);
        if ID<>0 then begin
          result.Lo := HTML_CREATED; // 201 Created
          Head := 'Location: '+URI.URI+'/'+
            {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(ID);
          fCache.Notify(URI.TableIndex,ID,SentData,soInsert);
          inc(fStats.fModified);
        end;
      end else
        // ModelRoot/TableName/0 = BATCH sequence '{"Table":["cmd":values,...]}'
        if not (URI.TableIndex in RestAccessRights^.PUT) or
           not (URI.TableIndex in RestAccessRights^.DELETE) then // POST already checked
          result.Lo := HTML_FORBIDDEN else
          if RunBatch(Static,URI.Table,pointer(SentData),Resp,ErrorMsg) then
            result.Lo := HTML_SUCCESS;
    end;
    mPUT: begin        // PUT=UPDATE
      if URI.MethodIndex>=0 then
        // PUT ModelRoot/MethodName (e.g. ModelRoot/Batch)
        LaunchCallBack(URI,Resp,result.Lo) else
      if ID>0 then begin
        // PUT ModelRoot/TableName/ID[/BlobFieldName] to update member/BLOB content
        if not RecordCanBeUpdated(URI.Table,ID,seUpdate,@ErrorMsg) or
           not (URI.TableIndex in RestAccessRights^.PUT) then // check User
          result.Lo := HTML_FORBIDDEN else begin 
          OK := false;
          if BlobFieldName<>'' then begin
            // PUT ModelRoot/TableName/ID/BlobFieldName: update BLOB field content
            Blob := URI.Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
            if Blob<>nil then begin
              OK := Engine.EngineUpdateBlob(URI.Table,ID,Blob,SentData);
            end else begin
              // PUT ModelRoot/TableName/ID/MethodName: try MethodName
              URI.MethodIndex := fPublishedMethods.Find(BlobFieldName);
              if URI.MethodIndex>=0 then
                LaunchCallBack(URI,Resp,result.Lo);
            end;
          end else begin
            // ModelRoot/TableName/ID with JSON SentData: update a member
            OK := Engine.EngineUpdate(URI.Table,ID,SentData);
            if OK then
              fCache.NotifyDeletion(URI.TableIndex,ID); // flush (no CreateTime in JSON)
          end;
          if OK then begin
            result.Lo := HTML_SUCCESS; // 200 OK
            inc(fStats.fModified);
          end;
        end;
      end else
      if URI.Parameters<>nil then // e.g. from TSQLRestClient.EngineUpdateField
        // PUT ModelRoot/TableName?setname=..&set=..&wherename=..&where=..
        if not (URI.TableIndex in RestAccessRights^.PUT) then // check User
          result.Lo := HTML_FORBIDDEN else begin 
          repeat
            UrlDecodeValue(URI.Parameters,'SETNAME=',SQLSelect);
            UrlDecodeValue(URI.Parameters,'SET=',SQLDir);
            UrlDecodeValue(URI.Parameters,'WHERENAME=',SQLSort);
            UrlDecodeValue(URI.Parameters,'WHERE=',SQLWhere,@URI.Parameters);
          until URI.Parameters=nil;
          if (SQLSelect<>'') and (SQLDir<>'') and (SQLSort<>'') and (SQLWhere<>'') then
            if Engine.EngineUpdateField(URI.Table,SQLSelect,SQLDir,SQLSort,SQLWhere) then begin
              result.Lo := HTML_SUCCESS; // 200 OK
              inc(fStats.fModified);
            end;
        end;
    end;
    mDELETE:
      if URI.Table<>nil then
        if ID>0 then
          // ModelRoot/TableName/ID to delete a member
          if not RecordCanBeUpdated(URI.Table,ID,seDelete,@ErrorMsg) or
             not (URI.TableIndex in RestAccessRights^.DELETE) then // check User
            result.Lo := HTML_FORBIDDEN else begin
            if Engine.EngineDelete(URI.Table,ID) and
               AfterDeleteForceCoherency(URI.Table,ID) then begin
              result.Lo := HTML_SUCCESS; // 200 OK
              fCache.NotifyDeletion(URI.TableIndex,ID);
              inc(fStats.fModified);
            end;
          end else
        if URI.Parameters<>nil then
          if (not (URI.TableIndex in RestAccessRights^.DELETE)) or
             (not (reUrlEncodedDelete in RestAccessRights^.AllowRemoteExecute)) then
            result.Lo := HTML_FORBIDDEN else begin
            // ModelRoot/TableName?WhereClause to delete members
            SQLWhere := Trim(UrlDecode(URI.Parameters));
            if SQLWhere<>'' then begin
              if Delete(URI.Table,SQLWhere) then begin
                result.Lo := HTML_SUCCESS; // 200 OK
                inc(fStats.fModified);
              end;
            end;
          end;
    mBEGIN: begin      // BEGIN TRANSACTION
      // TSQLVirtualTableJSON/External will rely on SQLite3 module
      // and also TSQLRestServerStaticInMemory, since COMMIT/ROLLBACK have Static=nil
      if TransactionBegin(URI.Table,Session) then begin
        if (Static<>nil) and (StaticKind=sVirtual) then
          Static.TransactionBegin(URI.Table,Session);
        result.Lo := HTML_SUCCESS; // 200 OK
      end;
    end;
    mEND: begin        // END=COMMIT
      // this method is called with Root (-> Table=nil -> Static=nil)
      if fTransactionTable<>nil then
        Static := StaticVirtualTable[fTransactionTable];
      Commit(Session);
      if Static<>nil then
        Static.Commit(Session);
      result.Lo := HTML_SUCCESS; // 200 OK
    end;
    mABORT: begin      // ABORT=ROLLBACK
      // this method is called with Root (-> Table=nil -> Static=nil)
      if fTransactionTable<>nil then
        Static := StaticVirtualTable[fTransactionTable];
      RollBack(Session);
      if Static<>nil then
        Static.RollBack(Session);
      result.Lo := HTML_SUCCESS; // 200 OK
    end;
    end;
  finally
    ReleaseWrite;
  end else
    // AcquireWrite(SessionID) returned false (e.g. endless transaction)
    result.Lo := HTML_TIMEOUT; // 408 Request Time-out
  end;
  // 4. returns expected result to the client
  if result.Lo in [HTML_SUCCESS,HTML_CREATED] then begin
    inc(fStats.fResponses);
    {$ifdef WITHLOG}
    Log.Log(sllServer,'% % -> %',[method,url,result.Lo],self);
    {$endif}
  end else
    SetRespFromError;
  inc(fStats.fOutcomingBytes,length(Resp)+length(Head)+16);
  if (Static<>nil) and (StaticKind=sInMemory) then
    result.Hi := cardinal(-1) else // force always refresh for Static table
    result.Hi := InternalState;    // database state may have changed above
{$ifdef WITHSTATPROCESS}
  QueryPerformanceCounter(timeEnd);
  inc(fStats.ProcessTimeCounter,timeEnd-timeStart);
{$endif}
end;

function TSQLRestServer.Stat(var aParams: TSQLRestServerCallBackParams): Integer;
begin
  aParams.Resp := Stats.DebugMessage; // transmitted as JSON object
  result := HTML_SUCCESS;
end;

function TSQLRestServer.TimeStamp(var aParams: TSQLRestServerCallBackParams): Integer;
begin
  aParams.Head^ := TEXT_CONTENT_TYPE_HEADER;
  aParams.Resp := Int64ToUtf8(ServerTimeStamp);
  result := HTML_SUCCESS;
end;

function TSQLRestServer.CacheFlush(var aParams: TSQLRestServerCallBackParams): Integer;
begin
  if aParams.Table=nil then
    Cache.Flush else
    if aParams.Context.ID=0 then
      Cache.Flush(aParams.Table) else
      Cache.SetCache(aParams.Table,aParams.Context.ID);
  result := HTML_SUCCESS;
end;

function TSQLRestServer.Batch(var aParams: TSQLRestServerCallBackParams): Integer;
begin
  if (aParams.Context.Method=mPUT) and
     RunBatch(nil,nil,pointer(aParams.SentData),aParams.Resp,aParams.ErrorMsg^) then
    result := HTML_SUCCESS else
    result := HTML_BADREQUEST; 
end;

function Nonce(Previous: boolean): RawUTF8;
var Tix: cardinal;
    tmp: RawByteString;
begin
  Tix := GetTickCount div (1000*60*5); // valid for 5*60*1000 ms = 5 minutes
  if Previous then
    dec(Tix);
  SetString(tmp,PAnsiChar(@Tix),sizeof(Tix));
  result := SHA256(tmp);
end;

function TSQLRestServer.Auth(var aParams: TSQLRestServerCallBackParams): Integer;
var aUserName, aPassWord, aClientNonce, aSalt: RawUTF8;
    User: TSQLAuthUser;
    aSessionID: cardinal;
    Session: TAuthSession;
    i: integer;
begin
  result := HTML_NOTFOUND;
  if not UrlDecodeNeedParameters(aParams.Parameters,'UserName') then
    exit;
  EnterCriticalSection(fSessionCriticalSection);
  try
    if UrlDecodeNeedParameters(aParams.Parameters,'Session') then begin
      // GET ModelRoot/auth?UserName=...&Session=... -> release session
      while aParams.Parameters<>nil do begin
        UrlDecodeValue(aParams.Parameters,'USERNAME=',aUserName);
        UrlDecodeCardinal(aParams.Parameters,'SESSION=',aSessionID,@aParams.Parameters);
      end;
      if (fSessions<>nil) and (aSessionID>CONST_AUTHENTICATION_NOT_USED) then
      for i := 0 to fSessions.Count-1 do
        with TAuthSession(fSessions.List[i]) do
        if (fIDCardinal=aSessionID) and (fUser.LogonName=aUserName) then begin
          SessionDelete(i);
          result := HTML_SUCCESS; // mark success
          break;
        end;
      Exit; // unknown session -> error 404
    end else
    if UrlDecodeNeedParameters(aParams.Parameters,'PassWord,ClientNonce') then begin
      // GET ModelRoot/auth?UserName=...&PassWord=...&ClientNonce=... -> handshaking
      while aParams.Parameters<>nil do begin
        UrlDecodeValue(aParams.Parameters,'USERNAME=',aUserName);
        UrlDecodeValue(aParams.Parameters,'PASSWORD=',aPassWord);
        UrlDecodeValue(aParams.Parameters,'CLIENTNONCE=',aClientNonce,@aParams.Parameters);
      end;
      User := TSQLAuthUser.Create(self,'LogonName=?',[aUserName]);
      try
        if User.fID=0 then
          exit;
        // check if match TSQLRestClientURI.SetUser() algorithm
        aSalt := aClientNonce+User.LogonName+User.PasswordHashHexa;
        if (aPassWord<>SHA256(Model.Root+Nonce(false)+aSalt)) and
           // if didn't try with current nonce, try with previous 5 minutes nonce
           (aPassWord<>SHA256(Model.Root+Nonce(true)+aSalt)) then
          Exit;
        // now client is authenticated -> create a session
        Session := TAuthSession.Create(self,User);
        try
          User := nil; // will be freed by TAuthSession.Destroy
          aParams.Resp := JSONEncodeResult([Session.fPrivateSalt]);
          if fSessions=nil then
            fSessions := TObjectList.Create;
          fSessions.Add(Session);
          Session := nil; // will be freed by fSessions
        finally
          Session.Free;
        end;
      finally
        User.Free;
      end;
    end else
      // only UserName=... -> return hexadecimal nonce content valid for 5 minutes
      aParams.Resp := JSONEncodeResult([Nonce(false)]);
  finally
    LeaveCriticalSection(fSessionCriticalSection);
  end;
  result := HTML_SUCCESS;
end;

procedure TSQLRestServer.SessionDelete(aSessionIndex: integer);
begin
  if (self<>nil) and (Cardinal(aSessionIndex)<Cardinal(fSessions.Count)) then
  with TAuthSession(fSessions.List[aSessionIndex]) do begin
    if Services is TServiceContainerServer then
      TServiceContainerServer(Services).OnCloseSession(IDCardinal);
    {$ifdef WITHLOG}
    SQLite3Log.Family.SynLog.Log(sllUserAuth,'Deleted session %/%',[User.LogonName,IDCardinal],self);
    {$endif}
    fSessions.Delete(aSessionIndex);
  end;
end;

function TSQLRestServer.SessionAccess(var aContext: TSQLRestServerSessionContext): TAuthSession;
var i: integer;
    Now: cardinal;
begin
  if (self<>nil) and (fSessions<>nil) then begin
    // first check for outdated sessions to be deleted
    Now := GetTickCount;
    for i := fSessions.Count-1 downto 0 do
      with TAuthSession(fSessions.List[i]) do
        if Now<LastAccess then // 32 bit overflow occured
          fLastAccess := Now else
        if QWord(Now)>QWord(LastAccess)+QWord(TimeOut) then
          SessionDelete(i);
    // retrieve session
    for i := 0 to fSessions.Count-1 do begin
      result := TAuthSession(fSessions.List[i]);
      if result.IDCardinal=aContext.Session then begin
        result.fLastAccess := Now; // refresh session access timestamp
        aContext.User := result.User.fID;
        aContext.Group := result.User.GroupRights.fID;
        exit;
      end;
    end;
  end;
  result := nil;
end;

function TSQLRestServer.SessionGetUser(aSessionID: Cardinal): TSQLAuthUser;
var i: integer;
begin
  result := nil;
  if (self=nil) or (fSessions=nil) then
    exit;
  EnterCriticalSection(fSessionCriticalSection);
  try
    for i := 0 to fSessions.Count-1 do
      with TAuthSession(fSessions.List[i]) do
      if IDCardinal=aSessionID then begin
        if User<>nil then begin
          result := TSQLAuthUser.Create; // manual copy excluding GroupRights
          result.fID := User.fID;
          result.LogonName := User.LogonName;
          result.DisplayName := User.DisplayName;
          result.PasswordHashHexa := User.PasswordHashHexa;
          result.Data := User.Data;
        end;
        Break;  
      end;
  finally
    LeaveCriticalSection(fSessionCriticalSection);
  end;
end;

function TSQLRestServer.CacheWorthItForTable(aTableIndex: cardinal): boolean;
begin
  if self=nil then
    result := false else
    result := (aTableIndex>=cardinal(length(fStaticData))) or
      (not fStaticData[aTableIndex].InheritsFrom(TSQLRestServerStaticInMemory));
end;

procedure TSQLRestServer.EndCurrentThread(Sender: TObject);
var i: integer;
begin
 if fStaticVirtualTable<>nil then
   for i := 0 to high(fStaticVirtualTable) do
     if fStaticVirtualTable[i]<>nil then
       fStaticVirtualTable[i].EndCurrentThread(self);
end;

procedure TSQLRestServer.BeginCurrentThread(Sender: TThread);
var i: integer;
begin
 ServiceContext.RunningThread := Sender;
 if fStaticVirtualTable<>nil then
   for i := 0 to high(fStaticVirtualTable) do
     if fStaticVirtualTable[i]<>nil then
       fStaticVirtualTable[i].BeginCurrentThread(Sender);
end;


{$ifdef MSWINDOWS}

{ TSQLRestClientURIDll }

constructor TSQLRestClientURIDll.Create(aModel: TSQLModel; const DllName: TFileName);
var aRequest: TURIMapRequest;
    aDLL: cardinal;
begin
  aDLL := LoadLibrary(pointer(DllName));
  if aDLL=0 then
    raise ECommunicationException.Create(DllName);
  aRequest := GetProcAddress(aDLL,'URIRequest');
  if (@aRequest=nil) or (aRequest(nil,nil,nil,nil,nil).Lo<>HTML_NOTFOUND) then begin
    FreeLibrary(aDLL);
    raise ECommunicationException.CreateFmt('%s doesn''t export a valid URIRequest function',[DllName]);
  end;
  Create(aModel,aRequest);
  fLibraryHandle := aDLL;
end;

constructor TSQLRestClientURIDll.Create(aModel: TSQLModel; aRequest: TURIMapRequest);
begin
  inherited Create(aModel);
  Func := aRequest;
end;

destructor TSQLRestClientURIDll.Destroy;
begin
  if fLibraryHandle<>0 then
    FreeLibrary(fLibraryHandle);
  inherited;
end;

function TSQLRestClientURIDll.InternalURI(const url, method: RawUTF8;
  Resp, Head, SendData: PRawUTF8): Int64Rec;
var pSend, pResp, pHead: PUTF8Char;
    ppHead, ppResp: PPUTF8Char;
begin
  if @Func=nil then begin
    Int64(result) := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
    exit;
  end;
  pResp := nil;
  pHead := nil;
  if SendData=nil then
    pSend := nil else
    pSend := pointer(SendData^);
  try
    // initialize response pointers if necessary
    if Resp<>nil then
      ppResp := @pResp else
      ppResp := nil;
    if Head<>nil then
      ppHead := @pHead else
      ppHead := nil;
    // call the server
    result := Func(pointer(url),pointer(method),pSend,ppResp,ppHead);
    // copy the pResp,pHead PAnsiChar response into local ansistrings
    if Resp<>nil then
      Resp^ := pResp;
    if Head<>nil then
      Head^ := pHead;
  finally // always release response memory allocated by the server
    if pResp<>nil then
      if USEFASTMM4ALLOC then
        Freemem(pResp) else
        GlobalFree(cardinal(pResp));
    if pHead<>nil then
      if USEFASTMM4ALLOC then
        Freemem(pHead) else
        GlobalFree(cardinal(pHead));
  end;
end;

{$endif MSWINDOWS}


{$ifdef MSWINDOWS}

{$ifdef ANONYMOUSNAMEDPIPE}

// it should be necessary to Edit settings under Local Security Policy -> Local
// policies -> Security options -> Edit settings under "Network access" to allow
// for anonymous connections.

// BUT even with the pipe name added to the
//  SYSTEM\CurrentControlSet\Services\lanmanserver\parameters\NullSessionPipes
// registry key, code below didn't work

function GetUserSid(var SID: PSID; var Token: THandle): boolean;
var TokenUserSize: DWORD;
    TokenUserP: PSIDAndAttributes;
begin
  result := false;
  if not OpenThreadToken(GetCurrentThread, TOKEN_QUERY, True, Token) then
    if (GetLastError <> ERROR_NO_TOKEN) or
       not OpenProcessToken(GetCurrentProcess, TOKEN_QUERY, Token) then
      Exit;
  TokenUserP := nil;
  TokenUserSize := 0;
  try
    if not GetTokenInformation(Token, TokenUser, nil, 0, TokenUserSize) and
       (GetLastError <> ERROR_INSUFFICIENT_BUFFER) then
      Exit;
    TokenUserP := AllocMem(TokenUserSize);
    if not GetTokenInformation(Token, TokenUser, TokenUserP,
       TokenUserSize, TokenUserSize) then
      Exit;
    SID := TokenUserP^.Sid;
    result := true;
  finally
    FreeMem(TokenUserP);
  end;
end;

{$ALIGN ON}
type
    ACE_HEADER = record
      AceType: BYTE;
      AceFlags: BYTE;
      AceSize: WORD;
    end;
    ACCESS_ALLOWED_ACE = record
      Header: ACE_HEADER;
      Mask: ACCESS_MASK;
      SidStart: DWORD;
    end;
{$A8}

procedure InitializeSecurity(var SA: TSecurityAttributes; var SD);
const
  SECURITY_NT_AUTHORITY: TSIDIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 5));
  SECURITY_ANONYMOUS_LOGON_RID = ($00000007);
  ACL_REVISION = 2;
var pSidAnonymous, pSidOwner: PSID;
    dwAclSize: integer;
    ACLP: PACL;
    Token: THandle;
begin
  fillchar(SD,SECURITY_DESCRIPTOR_MIN_LENGTH,0);
  // Initialize the new security descriptor
  if InitializeSecurityDescriptor(@SD, SECURITY_DESCRIPTOR_REVISION) and
      GetUserSid(pSidOwner,Token) then begin
    AllocateAndInitializeSid(SECURITY_NT_AUTHORITY,1,
      SECURITY_ANONYMOUS_LOGON_RID,0,0,0,0,0,0,0,pSidAnonymous);
    try
      dwAclSize := sizeof(TACL) +
        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(pSidAnonymous) + GetLengthSid(pSidOwner) ;
      ACLP := AllocMem(dwAclSize);
      try
        InitializeAcl(ACLP^,dwAclSize,ACL_REVISION);
        if not AddAccessAllowedAce(ACLP^,ACL_REVISION,
           GENERIC_ALL,pSidOwner) then
          exit;
        if not AddAccessAllowedAce(ACLP^,ACL_REVISION,
           GENERIC_READ or GENERIC_WRITE,pSidAnonymous) then
          exit;
        if SetSecurityDescriptorDacl(@SD,true,ACLP,false) then begin
           // Set up the security attributes structure
           SA.nLength := sizeof(TSecurityAttributes);
           SA.lpSecurityDescriptor := @SD;
           SA.bInheritHandle := true;
           exit; // mark OK
        end;
      finally
        FreeMem(ACLP);
      end;
    finally
      FreeSid(pSidAnonymous);
      CloseHandle(Token);
    end;
  end;
  fillchar(SA,sizeof(SA),0); // mark error: no security
end;

{$else}

{$if CompilerVersion >= 22.0} // fix Delphi XE imcompatilibility
function InitializeSecurityDescriptor(pSecurityDescriptor: PSecurityDescriptor;
  dwRevision: DWORD): BOOL; stdcall; external advapi32;
function SetSecurityDescriptorDacl(pSecurityDescriptor: PSecurityDescriptor;
  bDaclPresent: BOOL; pDacl: PACL; bDaclDefaulted: BOOL): BOOL; stdcall; external advapi32;
{$ifend}

procedure InitializeSecurity(var SA: TSecurityAttributes; var SD);
begin
  fillchar(SD,SECURITY_DESCRIPTOR_MIN_LENGTH,0);
  // Initialize the new security descriptor
  if InitializeSecurityDescriptor(@SD, SECURITY_DESCRIPTOR_REVISION) then begin
     // Add a NULL descriptor ACL to the security descriptor
     if SetSecurityDescriptorDacl(@SD, true, nil, false) then begin
        // Set up the security attributes structure
        SA.nLength := sizeof(TSecurityAttributes);
        SA.lpSecurityDescriptor := @SD;
        SA.bInheritHandle := true;
        exit; // mark OK
     end;
  end;
  fillchar(SA,sizeof(SA),0); // mark error: no security
end;

{$endif ANONYMOUSNAMEDPIPE}


{ TSQLRestServerNamedPipe }

constructor TSQLRestServerNamedPipe.Create(aServer: TSQLRestServer;
  const PipeName: TFileName);
begin
  inherited Create(false);
  fServer := aServer;
  fPipeName := PipeName;
  fChild := TList.Create;
//  writeln('TSQLRestServerNamedPipe ',PipeName,' ThreadID=',ThreadID);
end;

destructor TSQLRestServerNamedPipe.Destroy;
var i: integer;
begin
  //writeln('TSQLRestServerNamedPipe.Destroy');
  for i := 0 to fChild.Count-1 do // close any still opened pipe
    if fChild[i]<>nil then begin
      {writeln('fChildCount=',fChildCount,' TSQLRestServerNamedPipeResponse=',
        integer(TSQLRestServerNamedPipeResponse),'.Terminated=',
        BoolToStr(TSQLRestServerNamedPipeResponse(fChild[i]).Terminated,true));}
      TSQLRestServerNamedPipeResponse(fChild[i]).Terminate;
    end;
  while fChildCount>0 do
    Sleep(64); // wait for all TSQLRestServerNamedPipeResponse.Destroy
  fChild.Free;
  inherited;
end;

procedure TSQLRestServerNamedPipe.Execute;
var aPipe: cardinal;
    Available: cardinal;
    fPipeSecurityAttributes: TSecurityAttributes;
    fPipeSecurityDescriptor: array[0..SECURITY_DESCRIPTOR_MIN_LENGTH] of byte;
begin // see http://msdn.microsoft.com/en-us/library/aa365588(v=VS.85).aspx
  //writeln('TSQLRestServerNamedPipe=',integer(TSQLRestServerNamedPipe),'.Execute');
  InitializeSecurity(fPipeSecurityAttributes,fPipeSecurityDescriptor);
  while not Terminated do begin
    //writeln('TSQLRestServerNamedPipe.CreateNamedPipe(',fPipeName,')');
    aPipe := CreateNamedPipe(pointer(fPipeName),
      PIPE_ACCESS_DUPLEX,
      PIPE_TYPE_BYTE or PIPE_READMODE_BYTE or PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES, 0, 0, 0, @fPipeSecurityAttributes);
    if aPipe=INVALID_HANDLE_VALUE then
      break;
    while not Terminated do
      if PeekNamedPipe(aPipe,nil,0,nil,@Available,nil) then
        if (Available>=4) then begin
          fServer.Stats.ClientConnect;
          // PeekNamedPipe() made an implicit ConnectNamedPipe(aPipe,nil)
          InterlockedIncrement(fChildCount);
          TSQLRestServerNamedPipeResponse.Create(fServer,self,aPipe);
          aPipe := 0; // aPipe will be closed in TSQLRestServerNamedPipeResponse
          break;
        end
        else break // invalid request
      else Sleep(128); // doesn't slow down connection but decreases CSwitch
    if aPipe<>0 then begin
      DisconnectNamedPipe(aPipe);
      CloseHandle(aPipe);
    end;
  end;
end;


{ TSQLRestServerNamedPipeResponse }

constructor TSQLRestServerNamedPipeResponse.Create(aServer: TSQLRestServer;
  aMasterThread: TSQLRestServerNamedPipe; aPipe: cardinal);
begin
  inherited Create(false);
  fServer := aServer;
  fMasterThread := aMasterThread;
  with fMasterThread.fChild do begin
    fMasterThreadChildIndex := IndexOf(nil); // get free position in fChild[]
    if fMasterThreadChildIndex<0 then
      fMasterThreadChildIndex := Add(self) else
      Items[fMasterThreadChildIndex] := self;
  end;
  fPipe := aPipe;
  FreeOnTerminate := true;
{$ifdef LVCL}
  OnTerminate := fServer.EndCurrentThread;
{$endif}
end;

{$ifndef LVCL}
procedure TSQLRestServerNamedPipeResponse.DoTerminate;
begin
  fServer.EndCurrentThread(self); // will release any thread-specific resource
end;
{$endif}

destructor TSQLRestServerNamedPipeResponse.Destroy;
begin
  if fMasterThread<>nil then
    with fMasterThread do begin
      fChild[fMasterThreadChildIndex] := nil;
      InterlockedDecrement(fChildCount);
    end;
  inherited;
end;

procedure TSQLRestServerNamedPipeResponse.Execute;
var url, method: RawUTF8;
    SentData: RawUTF8;
    Resp, Head: RawUTF8;
    Code: integer;
    Ticks, Sleeper, ClientTimeOut: cardinal;
    Available: cardinal;
    Res: Int64Rec;
begin
  if (fPipe=0) or (fPipe=INVALID_HANDLE_VALUE) or (fServer=nil) then
    exit;
  fServer.BeginCurrentThread(self);
  Ticks := 0;
  Sleeper := 0;
  ClientTimeOut := GetTickCount+30*60*1000; // disconnect client after 30 min of inactivity
  try
    while not Terminated do
    if // (WaitForSingleObject(fPipe,200)=WAIT_OBJECT_0) and  = don't wait
       PeekNamedPipe(fPipe,nil,0,nil,@Available,nil) and (Available>=4) then begin
      FileRead(fPipe,Code,4);
      if (Code=integer(MAGIC_SYN)) // magic word for URI like request
        and not Terminated then
        try
          url := ReadString(fPipe);
          method := ReadString(fPipe);
          SentData := ReadString(fPipe);
          //writeln('TSQLRestServerNamedPipeResponse.EngineExecute ',method,' ',url);
          Res := fServer.URI(url,method,SentData,Resp,Head,@SUPERVISOR_ACCESS_RIGHTS);
          // it's up to URI overriden method to implement access rights
          FileWrite(fPipe,Res,sizeof(Res));
          WriteString(fPipe,Head);
          WriteString(fPipe,Resp);
          FlushFileBuffers(fPipe); // Flush the pipe to allow the client to read
//        if (Win32Platform=VER_PLATFORM_WIN32_NT) and (Win32MajorVersion<6) then
          Ticks := GetTickCount+20; // start sleeping after 20 ms
          ClientTimeOut := Ticks+30*60*1000;
          if ClientTimeOut<Ticks then // avoid 32 bits overflow
            ClientTimeOut := 30*60*1000;
          Sleeper := 0;
          Sleep(0);
        except
          on Exception do // error in ReadString() or fServer.URI()
            break; // disconnect client
        end else
          break; // invalid magic word: disconnect client
    end else
    if (Ticks=0) or (GetTickCount>Ticks) then begin
      if Sleeper<128 then
        inc(Sleeper,16);
      Sleep(Sleeper); // doesn't slow down connection but decreases CSwitch
      Ticks := 0;
      if GetTickCount>ClientTimeOut then
        break; // disconnect client after 30 min of inactivity
    end else
      Sleep(0);
  finally
    DisconnectNamedPipe(fPipe);
    CloseHandle(fPipe);
  end;
end;


{ TSQLRestClientURINamedPipe }

function ImpersonateAnonymousToken(ThreadHandle: THANDLE): BOOL; stdcall; external advapi32;

constructor TSQLRestClientURINamedPipe.Create(aModel: TSQLModel;
  const ApplicationName: TFileName);
var Pipe: cardinal;
procedure CreatePipe;
begin
  Pipe := CreateFile(pointer(fPipeName), GENERIC_READ or GENERIC_WRITE,
{$ifdef ANONYMOUSNAMEDPIPE}
    FILE_SHARE_READ or FILE_SHARE_WRITE,
    nil, OPEN_EXISTING, SECURITY_SQOS_PRESENT or SECURITY_ANONYMOUS, 0);
{$else}
    0, @fPipeSecurityAttributes, OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL or FILE_FLAG_OVERLAPPED, 0);
{$endif}
end;
begin
  if {$ifdef UNICODE}IdemPCharW{$else}IdemPChar{$endif}(pointer(ApplicationName),'\\') then
    fPipeName := ApplicationName else // caller specified a full path
    fPipeName := ServerPipeNamePrefix+ApplicationName;
{$ifdef ANONYMOUSNAMEDPIPE}
  if not ImpersonateAnonymousToken(GetCurrentThread) then
     raise Exception.Create('ImpersonateAnonymousToken');
{$else}
  InitializeSecurity(fPipeSecurityAttributes,fPipeSecurityDescriptor);
{$endif}
  CreatePipe;
  if Pipe=Invalid_Handle_Value then begin
    sleep(200); // wait for TSQLRestServerNamedPipe.EngineExecute to be reached
    if WaitNamedPipe(pointer(fPipeName),1000) then
      // 1000 since we have sleep(128) in TSQLRestServerNamedPipe.EngineExecute
      CreatePipe;
  end;
  if Pipe=Invalid_Handle_Value then begin // server must exist
    if (aModel<>nil) and (aModel.Owner=self) then
      aModel.Free; // avoid memory leak
    raise ECommunicationException.CreateFmt(
      '%s can''t connect to server "%s"'#13'via "%s":'#13'%s',
      [ClassName,ApplicationName,fPipeName,SysErrorMessage(GetLastError)]);
  end;
{$ifdef ANONYMOUSNAMEDPIPE}
  RevertToSelf; // we just needed to be anonymous during pipe connection
{$endif}
  inherited Create(aModel);
  fServerPipe := Pipe;
end;

destructor TSQLRestClientURINamedPipe.Destroy;
begin
  inherited;
  if fServerPipe<>0 then begin   // inherited; may use pipe -> close after
    WriteString(fServerPipe,''); // send integer=0 -> force server disconnect
    FileClose(fServerPipe);
  end;
end;

function TSQLRestClientURINamedPipe.InternalURI(const url, method: RawUTF8;
  Resp, Head, SendData: PRawUTF8): Int64Rec;
var s: RawUTF8;
    Card: cardinal;
{.$define TSQLRestClientURIDll_TIMEOUT} // to be tried over slow networks if errors
{$ifdef TSQLRestClientURIDll_TIMEOUT}
    i: integer;
{$endif}
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}
begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter(self);
{$endif}
  Int64(result) := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
  if fServerPipe<>0 then
  try
    Card := MAGIC_SYN; // magic word
    if FileWrite(fServerPipe,Card,4)<>4 then begin // "The pipe is being closed"
      WaitNamedPipe(pointer(fPipeName),500);
      if FileWrite(fServerPipe,Card,4)<>4 then begin
        FileClose(fServerPipe);
        WaitNamedPipe(pointer(fPipeName),500);
        fServerPipe := FileOpen(fPipeName,fmOpenReadWrite); // recreate connection
        if (fServerPipe=Invalid_Handle_Value) or
           (FileWrite(fServerPipe,Card,4)<>4) then begin
          Card := GetLastError;
          {$ifdef WITHLOG}
          Log.Log(sllLastError,'PipeName=%',[fPipeName],self);
          {$endif}
          if fServerPipe<>Invalid_Handle_Value then
            FileClose(fServerPipe);
          fServerPipe := 0;
          exit; // no existing pipe
        end;
      end;
    end;
    // send the request
    if url='' then
      s := '';
    WriteString(fServerPipe,url);
    WriteString(fServerPipe,method);
    if SendData=nil then
      WriteString(fServerPipe,'') else
      WriteString(fServerPipe,SendData^);
    FlushFileBuffers(fServerPipe);
    // receive the answer
{$ifdef TSQLRestClientURIDll_TIMEOUT}
    for i := 0 to 25 do // wait up to 325 ms
      if PeekNamedPipe(fServerPipe,nil,0,nil,@Card,nil) and
         (Card>=sizeof(result)) then begin
        FileRead(fServerPipe,result,sizeof(result));
        s := ReadString(fServerPipe);
        if Head<>nil then
          Head^ := s;
        s := ReadString(fServerPipe);
        if Resp<>nil then
          Resp^ := s;
        exit;
      end else
      Sleep(i);
    Int64(result) := HTML_TIMEOUT; // 408 Request Timeout Error
{$else}
    if FileRead(fServerPipe,result,sizeof(result))=sizeof(result) then begin
      // FileRead() waits till response arrived
      s := ReadString(fServerPipe);
      if Head<>nil then
        Head^ := s;
      s := ReadString(fServerPipe);
      if Resp<>nil then
        Resp^ := s;
    end else
      Int64(result) := HTML_NOTFOUND;
{$endif}
   except
     on E: Exception do begin // error in ReadString()
       {$ifdef WITHLOG}
       Log.Log(sllLastError,'% for PipeName=%',[E,fPipeName],self);
       {$endif}
       Int64(result) := HTML_NOTIMPLEMENTED; // 501 (no valid application or library)
       WriteString(fServerPipe,''); // try to notify the server of client logout
       FileClose(fServerPipe);
       fServerPipe := 0;
     end;
   end;
{$ifdef WITHLOG}
  Log.Log(sllClient,'% % result.Lo=% .Hi=%',[method,url,result.Lo,result.Hi],self);
{$endif}
end;

{$endif MSWINDOWS}


{ TSQLRestServerStats }

function TSQLRestServerStats.Changed: boolean;
begin
  result := fLastIncomingBytes<>IncomingBytes;
  if result then
    fLastIncomingBytes := IncomingBytes;
end;

procedure TSQLRestServerStats.ClientConnect;
begin
  inc(fClientsCurrent);
  if fClientsCurrent>fClientsMax then
    fClientsMax := fClientsCurrent;
  inc(fIncomingBytes,4); // change IncomingBytes to trigger message update
end;

procedure TSQLRestServerStats.ClientDisconnect;
begin
  if fClientsCurrent>0 then
    dec(fClientsCurrent);
  inc(fIncomingBytes,4); // change IncomingBytes to trigger message update
end;

function TSQLRestServerStats.DebugMessage: RawUTF8;
begin
  result := ObjectToJSON(self,True);
end;

function TSQLRestServerStats.ModifPercent: cardinal;
begin
  if Responses=0 then
    result := 0 else
    result := (Modified*100)div Responses;
end;

{$ifdef WITHSTATPROCESS}
function TSQLRestServerStats.GetProcessTimeString: RawUTF8;
var Freq: Int64;
begin
  QueryPerformanceFrequency(Freq); // performance-counter frequency in counts per second
  if (self=nil) or (Freq=0) then
    result := '0' else
    result := MicroSecToString((ProcessTimeCounter*(1000*1000))div Freq);
end;
{$endif}


{ TSQLRestServerStaticRecordBased }

function TSQLRestServerStaticRecordBased.EngineAdd(Table: TSQLRecordClass;
  const SentData: RawUTF8): integer;
var Rec: TSQLRecord;
begin
  if (self=nil) or (Table<>fStoredClass) then begin
    result := 0; // mark error
    exit;
  end;
  Lock(true);
  try
    Rec := fStoredClass.Create;
    Rec.FillFrom(SentData);
    result := AddOne(Rec);
    if result<=0 then
      Rec.Free; // on success, will be freed by fValue TObjectList
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticRecordBased.EngineUpdate(
  Table: TSQLRecordClass; ID: integer; const SentData: RawUTF8): boolean;
var Rec: TSQLRecord;
begin
  // this implementation won't handle partial fields update (e.g. BatchUpdate
  // after FillPrepare) - but TSQLRestServerStaticInMemory.EngineUpdate will
  if (self=nil) or (Table<>fStoredClass) then begin
    result := false; // mark error
    exit;
  end;
  Lock(true);
  try
    Rec := fStoredClass.Create;
    try
      Rec.FillFrom(SentData);
      result := UpdateOne(Rec);
    finally
      Rec.Free;
    end;
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticRecordBased.UpdateOne(ID: integer;
  const Values: TVarDataDynArray): boolean;
var Rec: TSQLRecord;
begin
  if self=nil then begin
    result := false; // mark error
    exit;
  end;
  Lock(true);
  try
    Rec := fStoredClass.Create;
    try
      Rec.SetFieldVarDatas(Values);
      Rec.fID := ID;
      result := UpdateOne(Rec);
    finally
      Rec.Free;
    end;
  finally
    UnLock;
  end;
end;


{ TSQLRestServerStatic }

function TSQLRestServerStaticInMemory.AddOne(Rec: TSQLRecord): integer;
var ndx,i: integer;
begin
  if (self=nil) or (Rec=nil) then begin
    result := -1; // mark error
    exit;
  end;
  if fValue.Count=0 then
    result := 1 else // default ID for a void table
    result := TSQLRecord(fValue[fValue.Count-1]).fID+1; // new ID compute
  Rec.fID := result;
  ndx := fValue.Add(Rec);
  if fUniqueFields<>nil then
    for i := 0 to fUniqueFields.Count-1 do
    if not TListFieldHash(fUniqueFields.List[i]).JustAdded then begin
      fValue.List[ndx] := nil; // avoid GPF within Delete()
      fValue.Delete(ndx);
      result := -1; // duplicate unique fields -> error
      exit;
    end;
  fModified := true;
  if (Owner<>nil) and Assigned(Owner.OnUpdateEvent) then
     Owner.OnUpdateEvent(self,seAdd,PSQLRecordClass(Rec)^,result);
end;

function TSQLRestServerStaticInMemory.UniqueFieldsUpdateOK(aRec: TSQLRecord; aUpdateIndex: integer): boolean;
var i,ndx: integer;
begin
  if fUniqueFields<>nil then begin
    result := false;
    with fUniqueFields do
      for i := 0 to Count-1 do begin
        ndx := TListFieldHash(List[i]).Find(aRec);
        if (ndx>=0) and (ndx<>aUpdateIndex) then
          exit; // duplicate found at another entry
      end;
  end;
  result := true;
end;

function TSQLRestServerStaticInMemory.UniqueFieldHash(aFieldIndex: integer): TListFieldHash;
var i: integer;
begin
  if (fUniqueFields<>nil) and
     (cardinal(aFieldIndex)<cardinal(length(fStoredClassProps.Fields))) then
    with fUniqueFields do
      for i := 0 to Count-1 do begin
        result := List[i];
        if result.FieldIndex=aFieldIndex then
          exit;
      end;
  result := nil;
end;

constructor TSQLRestServerStaticInMemory.Create(aClass: TSQLRecordClass; aServer: TSQLRestServer;
  const aFileName: TFileName = ''; aBinaryFile: boolean=false);
var JSON: RawUTF8;
    Stream: TStream;
    F: integer;
begin
  inherited Create(aClass,aServer,aFileName,aBinaryFile);
  if fStoredClassProps.Kind in INSERT_WITH_ID then
    raise EModelException.CreateFmt('%s: %s virtual table can''t be static',
      [fStoredClassProps.SQLTableName,aClass.ClassName]);
  fBinaryFile := aBinaryFile;
  fValue := TObjectList.Create;
  fSearchRec := fStoredClass.Create;
  fIDSorted := true; // sorted by design of this class (may change in children)
  if ClassType<>TSQLRestServerStaticInMemory then
    with fStoredClassProps do begin // used by AdaptSQLForEngineList() method
      fBasicUpperSQLWhere := UpperCase(SQLSelectAll[false]);
      fBasicUpperSQLWhere[length(fBasicUpperSQLWhere)] := ' '; // ';' -> ' '
      fBasicUpperSQLWhere := fBasicUpperSQLWhere+'WHERE ';
    end;
  if not IsZero(fIsUnique) then begin
    fUniqueFields := TObjectList.Create;
    with fStoredClassProps do
    for F := 0 to high(Fields) do
      if F in fIsUnique then
        // CaseInsensitive=true just like 
        fUniqueFields.Add(TListFieldHash.Create(fValue,F,Fields[F],true));
  end;
  if (fFileName<>'') and FileExists(fFileName) then begin
    if aBinaryFile then begin
      Stream := TSynMemoryStreamMapped.Create(fFileName);
      try
        LoadFromBinary(Stream)
      finally
        Stream.Free;
      end;
    end else begin
      Stream := TFileStream.Create(fFileName,fmOpenRead);
      try
        SetLength(JSON,Stream.Size);
        Stream.Read(pointer(JSON)^,length(JSON));
        LoadFromJSON(JSON);
      finally
        Stream.Free;
      end;
    end;
  end;
end;

function TSQLRestServerStaticInMemory.EngineDelete(Table: TSQLRecordClass; ID: integer): boolean;
var i,F: integer;
begin
  if (self=nil) or (ID<=0) or (Table<>fStoredClass) or
     not RecordCanBeUpdated(Table,ID,seDelete) then begin
    result := false;
    exit;
  end;
  i := IDToIndex(ID);
  if i<0 then
    result := false else begin
    if fUniqueFields<>nil then
      for F := 0 to fUniqueFields.Count-1 do
        TListFieldHash(fUniqueFields.List[F]).Invalidate;
    if (Owner<>nil) and Assigned(Owner.OnUpdateEvent) then
       Owner.OnUpdateEvent(self,seDelete,Table,ID); // notify BEFORE deletion
    fValue.Delete(i); // TObjectList.Delete() will Free record
    fModified := true;
    result := true;
  end;
end;

function TSQLRestServerStaticInMemory.EngineDeleteWhere(Table: TSQLRecordClass;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
var ndx: TIntegerDynArray;
    n,i: integer;
begin // RecordCanBeUpdated() has already been called
  result := false;
  n := length(IDs);
  SetLength(ndx,n);
  dec(n);
  for i := 0 to n do begin
    ndx[i] := IDToIndex(IDs[i]);
    if ndx[i]<0 then
      exit;
  end;
  if fUniqueFields<>nil then
    for i := 0 to fUniqueFields.Count-1 do
      TListFieldHash(fUniqueFields.List[i]).Invalidate;
  if (Owner<>nil) and Assigned(Owner.OnUpdateEvent) then
    for i := 0 to n do
      Owner.OnUpdateEvent(self,seDelete,Table,IDs[i]); // notify BEFORE deletion
  QuickSortInteger(pointer(ndx),0,n); // deletion a bit faster in reverse order
  for i := n downto 0 do
    fValue.Delete(ndx[i]);
  fModified := true;
  result := true;
end;

destructor TSQLRestServerStaticInMemory.Destroy;
begin
  UpdateFile;
  fValue.Free; // TObjectList.Destroy will free all stored TSQLRecord instances
  fUniqueFields.Free;
  fSearchRec.Free;
  inherited Destroy;
end;

function TSQLRestServerStaticInMemory.GetCount: integer;
begin
  if Self<>nil then
    result := fValue.Count else
    result := 0;
end;

function TSQLRestServerStaticInMemory.GetID(Index: integer): integer;
begin
  with fValue do
    if (self=nil) or (cardinal(Index)>=cardinal(Count)) then
      result := 0 else
      result := TSQLRecord(List[Index]).fID;
end;

function TSQLRestServerStaticInMemory.GetItem(Index: integer): TSQLRecord;
begin
  if self<>nil then
    with fValue do
      if cardinal(Index)>=cardinal(Count) then
        raise EORMException.Create('GetItem out of range') else
        result := List[Index] else
    result := nil;
end;

procedure TSQLRestServerStaticInMemory.GetJSONValuesEvent(aDest: pointer;
  aRec: TSQLRecord; aIndex: integer);
var W: TJSONSerializer absolute aDest;
begin
  aRec.GetJSONValues(W);
  W.Add(',');
end;

procedure TSQLRestServerStaticInMemory.GetJSONValuesEventExpand(aDest: pointer;
  aRec: TSQLRecord; aIndex: integer);
var W: TJSONSerializer absolute aDest;
begin
  W.Add('{');
  aRec.GetJSONValues(W);
  W.Add('}',',');
end;

procedure TSQLRestServerStaticInMemory.AddIntegerDynArrayEvent(
  aDest: pointer; aRec: TSQLRecord; aIndex: integer);
var Ints: TList absolute aDest;
begin
  Ints.Add(pointer(aIndex));
end;

function TSQLRestServerStaticInMemory.AdaptSQLForEngineList(var SQL: RawUTF8): boolean;
var P: PUTF8Char;
    Prop: ShortString;
begin
  result := inherited AdaptSQLForEngineList(SQL);
  if result or (fBasicUpperSQLWhere='') or
     not IdemPChar(pointer(SQL),pointer(fBasicUpperSQLWhere)) then
    exit;
  P := pointer(SQL);
  inc(P,length(fBasicUpperSQLWhere));
  P := GotoNextNotSpace(P);
  GetNextItemShortString(P,Prop,'=');
  if (P=nil) or (fStoredClassProps.FieldIndex(Prop)<0) then
    exit;
  if PWord(P)^=ord(':')+ord('(') shl 8 then
    inc(P,2); // +2 to ignore :(...): parameter
  if P^ in ['''','"'] then
    P := GotoEndOfQuotedString(P) else
    repeat inc(P) until P^ in [#0..' ',';',')']; // go to end of value
  if PWord(P)^=ord(')')+ord(':')shl 8 then
    inc(P,2); // ignore :(...): parameter
  P := GotoNextNotSpace(P);
  if (P^ in [#0,';']) or IdemPChar(P,'LIMIT 1;') then
    result := true; // properly ended the WHERE clause as 'FIELDNAME=value'
end;

function TSQLRestServerStaticInMemory.FindWhereEqual(WhereField: integer;
  const WhereValue: RawUTF8; OnFind: TFindWhereEqualEvent; Dest: pointer;
  FoundLimit: integer): PtrInt;
var i, aInteger, ndx: PtrInt; // use PtrInt for CPU64 compatibility
    err: integer;
    P: PPropInfo;
    Rec: TSQLRecord;
    Value,tmp: RawUTF8;
    Hash: TListFieldHash;
{$ifndef USETYPEINFO}
    Offs: PtrInt;
{$endif}
begin
  result := 0;
  if FoundLimit<=0 then
    FoundLimit := maxInt;
  if Assigned(OnFind) then
  if WhereField=SYNTABLESTATEMENTWHEREID then begin 
    aInteger := GetInteger(pointer(WhereValue),err);
    if (err=0) and (aInteger>0) then begin
      ndx := IDToIndex(aInteger); // use fast binary search
      if ndx>=0 then begin
        OnFind(Dest,TSQLRecord(fValue.List[ndx]),ndx);
        result := 1;
      end;
    end;
  end else
  if cardinal(WhereField)<=cardinal(Length(fStoredClassProps.Fields)) then begin
    dec(WhereField); // WHERE WhereField=WhereValue (WhereField=RTTIfield+1)
    // use fUniqueFields[] hash array for O(1) search if available
    Hash := UniqueFieldHash(WhereField);
    if Hash<>nil then
    with Hash do begin
      Field^.SetValue(fSearchRec,pointer(WhereValue));
      ndx := Find(fSearchRec);
      if ndx>=0 then begin
        OnFind(Dest,fValue.List[ndx],ndx);
        inc(result);
      end;
      exit;
    end;
    // generic code below is as fast as possible, and works for all field types
    P := fStoredClassProps.Fields[WhereField];
    case fStoredClassProps.FieldType[WhereField] of
    sftUnknown, sftMany: ; // not handled field -> fast exit
    {$ifndef CPU64}sftID,{$endif} // TSQLRecord field value is pointer(RecordID)
    sftRecord, sftInteger, sftEnumerate, sftSet: begin // optimized version
      aInteger := GetInteger(pointer(WhereValue),err);
      if err=0 then begin
{$ifndef USETYPEINFO}
        if P^.PropType^.OrdType in [otSLong, otULong] then
          if LongRec(P^.GetProc).Bytes[3]=$ff then begin
            // optimized version for fast retrieval of Integer32 field value
            Offs := P^.GetProc and $00ffffff; // no getter -> use PInteger()
            for i := 0 to fValue.Count-1 do begin
              Rec := TSQLRecord(fValue.List[i]);
              if PInteger(PtrInt(Rec)+Offs)^=aInteger then begin
                OnFind(Dest,Rec,i);
                inc(result);
                if result>=FoundLimit then
                  exit;
              end;
            end;
          end else
{$endif}  // not a Int32, or there is a getter procedure -> use GetOrdProp()
        for i := 0 to fValue.Count-1 do begin
          Rec := TSQLRecord(fValue.List[i]);
          if GetOrdProp(Rec,pointer(P))=aInteger then begin
            OnFind(Dest,Rec,i);
            inc(result);
            if result>=FoundLimit then
              exit;
          end;
        end;
      end;
    end;
    sftAnsiText, sftUTF8Text, sftBoolean, sftFloat, sftDateTime, sftCurrency,
    {$ifdef CPU64}sftID, {$endif} sftObject, sftBlob, sftBlobDynArray,
    sftTimeLog, sftModTime, sftCreateTime: begin
      P^.SetValue(fSearchRec,pointer(WhereValue));
      for i := 0 to fValue.Count-1 do  // ..,true)=SYSTEMNOCASE
        if P^.SameValue(fValue.List[i],fSearchRec,true) then begin
          OnFind(Dest,fValue.List[i],i);
          inc(result);
          if result>=FoundLimit then
            exit;
        end;
    end;
     else begin
      // search with UTF-8 converted value: always works, but brute force search
      Value := WhereValue;
      P^.NormalizeValue(Value); // force the same format as P^.GetValue()
      if Value<>'' then
      for i := 0 to fValue.Count-1 do begin
        Rec := TSQLRecord(fValue.List[i]);
        P^.GetValueVar(Rec,true,tmp,nil);
        if tmp=Value then begin
          OnFind(Dest,Rec,i);
          inc(result);
          if result>=FoundLimit then
            exit;
        end;
      end;
    end;
    end;
  end;
end;
                        
function TSQLRestServerStaticInMemory.GetJSONValues(Stream: TStream; Expand, withID: boolean;
  const Fields: TSQLFieldBits; WhereField: integer; const WhereValue: RawUTF8): PtrInt;
var i, KnownRowsCount: integer;
    W: TJSONSerializer;
begin // exact same format as TSQLTable.GetJSONValues()
  result := 0;
  if WhereField<0 then // no WHERE statement -> get all rows -> get rows count
    KnownRowsCount := fValue.Count else
    KnownRowsCount := 0;
  W := fStoredClassProps.CreateJSONWriter(Stream,Expand,withID,Fields,KnownRowsCount);
  if W<>nil then
  try
    if Expand then
      W.Add('[');
    if WhereField<0 then begin
      // no WHERE statement -> all rows
      for i := 0 to fValue.Count-1 do begin
        if Expand then
          W.AddCR; // for better readibility
        TSQLRecord(fValue.List[i]).GetJSONValues(W);
        W.Add(',');
      end;
      result := fValue.Count;
    end else
      if Expand then
        result := FindWhereEqual(WhereField,WhereValue,GetJSONValuesEventExpand,W) else
        result := FindWhereEqual(WhereField,WhereValue,GetJSONValuesEvent,W);
    if (result=0) and W.Expand then begin
      // we want the field names at least, even with no data
      Expand := false; //  {"fieldCount":2,"values":["col1","col2"]}
      W.Expand := false;
      W.CancelAll;
      fStoredClassProps.SetJSONWriterColumnNames(W,0);
    end;
    W.CancelLastComma; // cancel last ','
    // end the JSON object
    W.Add(']');
    if not Expand then
      W.Add('}');
    W.Add(#10);
    W.Flush;
  finally
    W.Free;
  end;
end;

function TSQLRestServerStaticInMemory.IDToIndex(ID: integer): integer;
var L, R, cmp: integer;
begin
  if self<>nil then begin
    R := fValue.Count-1;
    if fIDSorted and (R>=8) then begin
      // IDs are sorted -> use fast binary search algorithm
      L := 0;
      repeat
        result := (L + R) shr 1;
        cmp := TSQLRecord(fValue.List[result]).fID-ID;
        if cmp=0 then
          exit;
        if cmp<0 then
          L := result + 1 else
          R := result - 1;
      until (L > R);
    end else
      // IDs are not sorted -> compare all from beginning to end
      for result := 0 to R do
        if TSQLRecord(fValue.List[result]).fID=ID then
          exit;
  end;
  result := -1;
end;

function TSQLRestServerStaticInMemory.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8;
// - GetJSONValues/FindWhereEqual will handle basic REST commands (not all SQL)
// only valid SQL command is "SELECT Field1,Field2 FROM Table WHERE ID=120;",
// i.e one Table SELECT with one optional "WHERE fieldname = value" statement
// - handle also basic "SELECT Count(*) FROM TableName;" SQL statement
// Note: this is sufficient for OneFieldValue() and MultiFieldValue() to work
var MS: TRawByteStringStream;
    ResCount: PtrInt;
begin
  if self=nil then
    result := '' else begin
    Lock(false);
    try
      with TSynTableStatement.Create(SQL,fStoredClassProps.FieldIndex,
        fStoredClassProps.SimpleFieldsBits[soSelect]) do
      try
        if (WhereValue='') or
           not IdemPropNameU(TableName,fStoredClassProps.SQLTableName) then
          // invalid request -> return ''
          result := '' else
        if WhereField=SYNTABLESTATEMENTWHERECOUNT then begin
          // was "SELECT Count(*) FROM TableName;"
          result := FormatUTF8('[{"Count(*)":%}]'#$A,[fValue.Count]);
          if ReturnedRowCount<>nil then
            ReturnedRowCount^ := 1;
        end else begin
          // save rows as JSON, with appropriate search according to Where* arguments
          MS := TRawByteStringStream.Create;
          try
            ResCount := GetJSONValues(MS,ForceAJAX or (not NoAJAXJSON),
              withID,Fields,WhereField,WhereValue);
            if ReturnedRowCount<>nil then
              ReturnedRowCount^ := ResCount;
            result := MS.DataString;
          finally
            MS.Free;
          end;
        end;
      finally
        Free;
      end;
    finally
      UnLock;
    end;
  end;
end;

procedure TSQLRestServerStaticInMemory.LoadFromJSON(const aJSON: RawUTF8);
begin
  LoadFromJSON(Pointer(aJSON),length(aJSON));
end;

procedure TSQLRestServerStaticInMemory.LoadFromJSON(JSONBuffer: PUTF8Char; JSONBufferLen: integer);
  function IsSorted(U: PPUTF8Char; RowCount, FieldCount: integer): boolean;
  var i, aID, lastID: integer;
  begin
    result := false;
    lastID := 0;
    for i := 1 to RowCount do begin
      aID := GetInteger(U^);
      if aID<=lastID then
        exit else
        lastID := aID;
      inc(U,FieldCount);
    end;
    result := true;
  end;
var T: TSQLTableJSON;
    R: TSQLRecord;
    V: ^TSQLRecord;
    Row: PPUtf8Char;
    i, IDndx: integer;
begin
  fModified := false;
  fValue.Clear;
  T := TSQLTableJSON.Create([fStoredClass],'',JSONBuffer,JSONBufferLen);
  if T<>nil then  // use a temporary table
  try
    IDndx := T.FieldIndexID;
    if IDndx<0 then
      exit; // no ID field -> load is impossible -> error
    // ensure ID were stored in an increasing order
    if not IsSorted(@T.fResults[IDndx+T.FieldCount], T.RowCount, T.FieldCount) then begin
      // force sorted by ID -> faster IDToIndex()
      T.SortFields(IDndx,true,nil,sftInteger);
      // if data is corrupted, IDs may not be unique -> check it now
      if not IsSorted(@T.fResults[IDndx+T.FieldCount], T.RowCount, T.FieldCount) then
        exit; // some duplicated ID fields -> error
    end;
    // create TSQLRecord instances with data from T
    R := fStoredClass.Create; // a temp record to be used for FillPrepare()
    try
      R.FillPrepare(T); // init R.TableMap[] for R.FillRow() below
      fValue.Count := T.RowCount; // faster than fValue.Add() in loop
      V := @fValue.List[0];
      Row := @T.fResults[T.FieldCount]; // R^ points to first row of data
      for i := 1 to T.RowCount do begin
        V^ := fStoredClass.Create; // TObjectList will free each instance
        R.fFill.Fill(pointer(Row),V^);
        Inc(Row,T.FieldCount);
        inc(V);
      end;
    finally
      R.Free;
    end;
  finally
    T.Free;
  end;
end;

procedure TSQLRestServerStaticInMemory.SaveToJSON(Stream: TStream; Expand: Boolean);
begin
  if self<>nil then
    GetJSONValues(Stream,Expand,true,ALL_FIELDS,-1,'');
end;

function TSQLRestServerStaticInMemory.SaveToJSON(Expand: Boolean): RawUTF8;
var MS: TRawByteStringStream;
begin
  if self=nil then
    result := '' else begin
    MS := TRawByteStringStream.Create;
    try
      SaveToJSON(MS,Expand);
      result := MS.DataString;
    finally
      MS.Free;
    end;
  end;
end;

const
  TSQLRESTSERVERSTATICINMEMORY_MAGIC = $A5ABA5A5;

function TSQLRestServerStaticInMemory.LoadFromBinary(Stream: TStream): boolean;
var R: TFileBufferReader;
    MS: TMemoryStream;
    n, i, f: integer;
    FieldNames: TRawUTF8DynArray;
    IDs: TIntegerDynArray;
    P: PAnsiChar;
    aRecord: TSQLRecord;
    FieldTypes: array[0..MAX_SQLFIELDS-1] of TSQLFieldType;
begin
  result := false;
  if self=nil then
    exit;
  MS := StreamUnSynLZ(Stream,TSQLRESTSERVERSTATICINMEMORY_MAGIC);
  if MS<>nil then
  try
    // check header
    R.OpenFrom(MS.Memory,MS.Size);
    if (R.ReadRawUTF8<>RawUTF8(ClassName)) or
       (R.ReadRawUTF8<>StoredClassProps.SQLTableName) or
       (R.ReadVarRawUTF8DynArray(FieldNames)=0) or
       not RawUTF8DynArrayEquals(FieldNames,StoredClassProps.FieldsName) then
      exit;
    n := length(FieldNames);
    if n>MAX_SQLFIELDS then
      exit; // avoid buffer overflow
    n := sizeof(TSQLFieldType)*n;
    if (R.Read(@FieldTypes,n)<>n) or
       not CompareMem(@FieldTypes,pointer(StoredClassProps.FieldType),n) then
      exit;
    // read IDs
    fModified := false;
    fValue.Clear;
    fValue.Count := R.ReadVarUInt32Array(IDs); // faster than fValue.Add()
    for i := 0 to high(IDs) do begin
      aRecord := fStoredClass.Create;
      aRecord.fID := IDs[i];
      fValue.List[i] := aRecord;
    end;
    // read content, grouped by field (for better compression)
    P := R.CurrentMemory;
    for f := 0 to high(fStoredClassProps.Fields) do
      with fStoredClassProps.Fields[f]^, fValue do
        for i := 0 to Count-1 do begin
          P := SetBinary(TSQLRecord(List[i]),P);
          if P=nil then begin
            fValue.Clear; // on error, reset whole 
            exit;
          end;
        end;
    Result := true;
  finally
    R.Close;
    MS.Free;
  end;
end;

function TSQLRestServerStaticInMemory.SaveToBinary(Stream: TStream): integer;
var W: TFileBufferWriter;
    MS: THeapMemoryStream;
    IDs: TIntegerDynArray;
    i, n, f: integer;
begin
  result := 0;
  if (self=nil) or (Stream=nil) then
    exit;
  MS := THeapMemoryStream.Create;
  W := TFileBufferWriter.Create(MS);
  try
    // primitive magic and fields signature for file type identification
    W.Write(RawUTF8(ClassName));
    W.Write(StoredClassProps.SQLTableName);
    n := Length(StoredClassProps.FieldsName);
    W.WriteRawUTF8DynArray(StoredClassProps.FieldsName,n);
    W.Write(pointer(StoredClassProps.FieldType),sizeof(TSQLFieldType)*n);
    // write IDs
    SetLength(IDs,Count);
    with fValue do
      for i := 0 to Count-1 do
        IDs[i] := TSQLRecord(List[i]).fID;
    W.WriteVarUInt32Array(IDs,Count,wkSorted); // efficient ID storage
    // write content, grouped by field (for better compression)
    for f := 0 to High(fStoredClassProps.Fields) do
      with fStoredClassProps.Fields[f]^, fValue do
        for i := 0 to Count-1 do
          GetBinary(TSQLRecord(List[i]),W);
    W.Flush;
    result := StreamSynLZ(MS,Stream,TSQLRESTSERVERSTATICINMEMORY_MAGIC);
  finally
    W.Free;
    MS.Free;
  end;
end;

function TSQLRestServerStaticInMemory.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
var i: integer;
begin // TableModelIndex is not usefull here
  Lock(false);
  try
    i := IDToIndex(ID);
    if i<0 then
      result := '' else
      result := TSQLRecord(fValue.List[i]).GetJSONValues(true,true,soSelect);
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.GetOne(aID: integer): TSQLRecord;
var i: integer;
begin
  i := IDToIndex(aID);
  if i<0 then
    result := nil else begin
    result := StoredClass.Create;
    CopyObject(fValue.List[i],Result);
    result.fID := aID;
  end;
end;

function TSQLRestServerStaticInMemory.EngineUpdate(Table: TSQLRecordClass; ID: integer;
  const SentData: RawUTF8): boolean;
var i: integer;
    Orig,Rec: TSQLRecord;
begin
  // this implementation will handle partial fields update (e.g.
  // FillPrepare+BatchUpdate or TSQLRestServerRemoteDB.UpdateField)
  // but TSQLRestServerStaticRecordBased.EngineUpdate won't
  result := false;
  if (self=nil) or (Table<>fStoredClass) or (SentData='') then
    exit;
  Lock(true);
  try
    i := IDToIndex(ID);
    if (i<0) or not RecordCanBeUpdated(Table,ID,seUpdate) then
      exit;
    if fUniqueFields<>nil then begin
      Orig := TSQLRecord(fValue.List[i]);
      Rec := Orig.CreateCopy; // copy since can be a partial update
      Rec.FillFrom(SentData); // overwrite updated properties
      if not UniqueFieldsUpdateOK(Rec,i) then begin
        Rec.Free; // stored false property duplicated value -> error
        exit;
      end;
      Orig.Free; // avoid memory leak
      TSQLRecord(fValue.List[i]) := Rec; // update item in list
    end else
      // direct in-place partial update
      TSQLRecord(fValue.List[i]).FillFrom(SentData);
    fModified := true;
    result := true;
    if (Owner<>nil) and Assigned(Owner.OnUpdateEvent) then
       Owner.OnUpdateEvent(self,seUpdate,Table,ID);
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.UpdateOne(Rec: TSQLRecord): boolean;
var i: integer;
begin
  result := false;
  if (Rec=nil) or (PSQLRecordClass(Rec)^<>fStoredClass) or (Rec.fID<=0) then
    exit;
  Lock(true);
  try
    i := IDToIndex(Rec.fID);
    if (i<0) or not RecordCanBeUpdated(fStoredClass,Rec.fID,seUpdate) then
      exit;
    if (fUniqueFields<>nil) and not UniqueFieldsUpdateOK(Rec,i) then
      exit; // stored false property duplicated value -> error
    CopyObject(Rec,fValue.List[i]);
    fModified := true;
    result := true;
    if (Owner<>nil) and Assigned(Owner.OnUpdateEvent) then
       Owner.OnUpdateEvent(self,seUpdate,fStoredClass,Rec.fID);
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.UpdateOne(ID: integer;
  const Values: TVarDataDynArray): boolean;
var i: integer;
    Orig,Rec: TSQLRecord;
begin
  result := false;
  if ID<=0 then
    exit;
  i := IDToIndex(ID);
  if (i<0) or not RecordCanBeUpdated(fStoredClass,ID,seUpdate) then
    exit;
  if fUniqueFields<>nil then begin
    Orig := TSQLRecord(fValue.List[i]);
    Rec := Orig.CreateCopy; // copy since can be a partial update
    if (not Rec.SetFieldVarDatas(Values)) or
       (not UniqueFieldsUpdateOK(Rec,i)) then begin
      Rec.Free; // stored false property duplicated value -> error
      exit;
    end;
    Orig.Free; // avoid memory leak
    TSQLRecord(fValue.List[i]) := Rec;
  end else
  if not TSQLRecord(fValue.List[i]).SetFieldVarDatas(Values) then
    exit;
  fModified := true;
  result := true;
  if (Owner<>nil) and Assigned(Owner.OnUpdateEvent) then
     Owner.OnUpdateEvent(self,seUpdate,fStoredClass,ID);
end;

function TSQLRestServerStaticInMemory.EngineRetrieveBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (Table<>fStoredClass) or not BlobField^.IsBlob then
    exit;
  Lock(false);
  try
    i := IDToIndex(aID);
    if i<0 then
      exit;
    // get result blob directly from RTTI property description
    GetLongStrProp(fValue.List[i],BlobField,RawByteString(BlobData));
    result := true;
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.EngineUpdateBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo;
  const BlobData: TSQLRawBlob): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or  (Table<>fStoredClass) or not BlobField^.IsBlob then
    exit;
  Lock(true);
  try
    i := IDToIndex(aID);
    if i<0 then
      exit;
    if not RecordCanBeUpdated(Table,aID,seUpdate) then
      exit;
    // set blob value directly from RTTI property description
    SetLongStrProp(fValue.List[i],BlobField,BlobData);
    result := true;
  finally
    UnLock;
  end;
end;

function TSQLRestServerStaticInMemory.EngineUpdateField(Table: TSQLRecordClass;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
var SetField: PPropInfo;
    WhereValueString, SetValueString: RawUTF8;
    IsSetInteger: boolean;
    Where: TList;
    i, ndx, err, WhereFieldIndex: integer;
    VSet: PtrInt;
    Rec: TSQLRecord;
begin
  result := false;
  if (self=nil) or (Table<>fStoredClass) or (SetFieldName='') or (SetValue='') or
     (WhereFieldName='') or (WhereValue='') then
    exit;
  // handle destination field RTTI
  SetField := fStoredClassProps.FieldPropFromRawUTF8(SetFieldName);
  if SetField=nil then
    exit; // don't allow setting ID field, which is Read Only
  IsSetInteger := SetField^.PropType^^.Kind in [tkClass,tkInteger];
  if IsSetInteger then begin
    VSet := GetInteger(pointer(SetValue),err);
    if err<>0 then
      exit;
  end else begin
    VSet := 0;
    if SetValue[1]='"' then
      UnQuoteSQLString(pointer(SetValue),SetValueString) else
      SetValueString := SetValue;
  end;
  // handle search field RTTI
  if IsRowID(pointer(WhereFieldName)) then begin
    WhereFieldIndex := 0;
    WhereValueString := WhereValue;
  end else begin
    WhereFieldIndex := fStoredClassProps.FieldIndexFromRawUTF8(WhereFieldName);
    if WhereFieldIndex<0  then
      exit;
    inc(WhereFieldIndex); // FindWhereEqual() expects index = RTTI+1
  end;
  if WhereValue[1]='"' then
    UnQuoteSQLString(pointer(WhereValue),WhereValueString) else
    WhereValueString := WhereValue;
  // search indexes, then apply updates
  Where := TList.Create;
  Lock(true);
  try 
    // find matching Where[]
    if FindWhereEqual(WhereFieldIndex,WhereValueString,AddIntegerDynArrayEvent,Where)=0 then
      exit; // Where.Count=0 -> nothing to update
    // check that all records can be updated
    for i := 0 to Where.Count-1 do
      if not RecordCanBeUpdated(Table,TSQLRecord(fValue.List[PtrInt(Where.List[i])]).fID,seUpdate) then
        exit; // one record update fails -> abort all
    if fUniqueFields<>nil then
      for i := 0 to fUniqueFields.Count-1 do
      with TListFieldHash(fUniqueFields.List[i]) do
        if Field=SetField then
          if Where.Count>1 then // unique field can't allow multiple sets
            exit else begin
            if IsSetInteger then
              SetField^.SetOrdValue(fSearchRec,VSet) else
              SetField^.SetValue(fSearchRec,pointer(SetValueString));
            ndx := Find(fSearchRec);
            if (ndx>=0) and (ndx<>PtrInt(Where.List[0])) then
              exit; // duplicated entry error
          end;
    // update field value
    for i := 0 to Where.Count-1 do begin
      Rec := fValue.List[PtrInt(Where.List[i])];
      if IsSetInteger then
        SetField^.SetOrdValue(Rec,VSet) else
        SetField^.SetValue(Rec,pointer(SetValueString));
      fModified := true;
      if (Owner<>nil) and Assigned(Owner.OnUpdateEvent) then
         Owner.OnUpdateEvent(self,seUpdate,Table,Rec.fID);
      result := true;
    end;
  finally
    UnLock;
    Where.Free;
  end;
end;

procedure TSQLRestServerStaticInMemory.UpdateFile;
var F: TFileStream;
begin
  if (self=nil) or not Modified or (FileName='') then
    exit;
  if fValue.Count=0 then
    DeleteFile(FileName) else begin
    F := TFileStream.Create(FileName,fmCreate);
    try
      if BinaryFile then
        SaveToBinary(F) else
        GetJSONValues(F,fExpandedJSON,true,ALL_FIELDS,-1,'');
      F.Size := F.Position; // truncate file
    finally
      F.Free;
    end;
  end;
  fModified := false;
end;

function TSQLRestServerStaticInMemory.SearchField(const FieldName: ShortString;
  const FieldValue: RawUTF8; var ResultID: TIntegerDynArray): boolean;
var n, WhereField: integer;
    {$ifdef CPU64}i: integer;{$endif}
    Where: TList;
begin
  result := false;
  SetLength(ResultID,0);
  if (self=nil) or (fValue.Count=0) then
    exit;
  if IsRowID(FieldName) then
    WhereField := SYNTABLESTATEMENTWHEREID else begin
    WhereField := fStoredClassProps.FieldIndex(FieldName);
    if WhereField<0 then
      exit;
    inc(WhereField); // FindWhereEqual() expects index = RTTI+1
  end;
  Where := TList.Create;
  try
    n := FindWhereEqual(WhereField,FieldValue,AddIntegerDynArrayEvent,Where);
    if n=0 then
      exit;
    SetLength(ResultID,n);
    {$ifdef CPU64}
    with Where do
      for i := 0 to Count-1 do
        ResultID[i] := PPtrIntArray(List)^[i];
    {$else}
    move(Where.List[0],ResultID[0],n*sizeof(Integer));
    {$endif}
  finally
    Where.Free;
  end;
end;


{ TSQLRestServerStaticInMemoryExternal }

procedure TSQLRestServerStaticInMemoryExternal.FlushInternalDBCache;
begin
  if Owner<>nil then
    Owner.FlushInternalDBCache;
end;


{ TListFieldHash }

function TListFieldHash.Compare(Item1,Item2: TObject): boolean;
begin
  result := fProp.SameValue(Item1,Item2,CaseInsensitive);
end;

function TListFieldHash.Count: integer;
begin
  result := fValues.Count;
end;

constructor TListFieldHash.Create(aValues: TList; aFieldIndex: integer;
  aField: PPropInfo; aCaseInsensitive: boolean);
begin
  fValues := aValues;
  fField := aFieldIndex;
  fProp := aField;
  fCaseInsensitive := aCaseInsensitive;
end;

function TListFieldHash.Hash(Item: TObject): cardinal;
begin
  result := fProp.GetHash(Item,CaseInsensitive);
  if result=0 then
    result := 1; // HASH=0 is used to indicate a void slot in fHash[]
end;

function TListFieldHash.Get(Index: integer): TObject;
begin
  with fValues do
    if cardinal(Index)<cardinal(Count) then
      result := List[Index] else
      result := nil;
end;


{ TSQLRestServerStatic }

constructor TSQLRestServerStatic.Create(aClass: TSQLRecordClass;
  aServer: TSQLRestServer; const aFileName: TFileName; aBinaryFile: boolean);
begin
  inherited Create(nil,false);
  if aClass=nil then
    raise EBusinessLayerException.CreateFmt('%s.Create expect a class',[ClassName]);
  fStoredClass := aClass;
  fStoredClassProps := aClass.RecordProps;
  fIsUnique := fStoredClassProps.IsUniqueFieldsBits;
  if aServer<>nil then begin
    fOwner := aServer;
    fModel := aServer.Model;
    fNoAJAXJSON := aServer.fNoAJAXJSON; // expanded as main Server
  end;
  fFileName := aFileName;
end;

function TSQLRestServerStatic.EngineExecuteAll(const aSQL: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST static class
end;

function TSQLRestServerStatic.EngineUpdateField(Table: TSQLRecordClass;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST static class
end;

function TSQLRestServerStatic.SearchField(const FieldName: ShortString;
  const FieldValue: Integer; var ResultID: TIntegerDynArray): boolean;
begin
  result := SearchField(FieldName,Int32ToUTF8(FieldValue),ResultID);
end;

function TSQLRestServerStatic.RecordCanBeUpdated(Table: TSQLRecordClass;
  ID: integer; Action: TSQLEvent; ErrorMsg: PRawUTF8 = nil): boolean;
begin
  result := (self<>nil) and
    ((Owner=nil) or Owner.RecordCanBeUpdated(Table,ID,Action,ErrorMsg));
end;

function TSQLRestServerStatic.RefreshedAndModified: boolean;
begin
  result := false; // no refresh necessary with "normal" static tables
end;

procedure TSQLRestServerStatic.Lock(WillModifyContent: boolean);
begin
  if self<>nil then begin
    EnterCriticalSection(fSessionCriticalSection);
    if WillModifyContent then
      FlushInternalDBCache;
  end;
end;

procedure TSQLRestServerStatic.UnLock;
begin
  if self<>nil then
    LeaveCriticalSection(fSessionCriticalSection);
end;

function TSQLRestServerStatic.InternalBatchStart(Method: TSQLURIMethod): boolean;
begin
  result := false;
end;

procedure TSQLRestServerStatic.InternalBatchStop;
begin
  // do nothing method
end;

function TSQLRestServerStatic.AdaptSQLForEngineList(var SQL: RawUTF8): boolean; 
begin
  result := fStoredClassProps.SQLSelectAll[false]=SQL;
  if result then
    SQL := fStoredClassProps.SQLSelectAll[true];
end;


{ TSQLRestServerFullMemory }

constructor TSQLRestServerFullMemory.Create(aModel: TSQLModel;
  const aFileName: TFileName; aBinaryFile, aHandleUserAuthentication: boolean);
var t: integer;
begin
  fFileName := aFileName;
  fBinaryFile := aBinaryFile;
  inherited Create(aModel,aHandleUserAuthentication);
  fStaticDataCount := length(fModel.Tables);
  for t := 0 to fStaticDataCount-1 do
    StaticDataCreate(fModel.Tables[t]);
  LoadFromFile;
  for t := 0 to fStaticDataCount-1 do
    with TSQLRestServerStaticInMemory(fStaticData[t]) do
    if Count=0 then // emulates TSQLRestServerDB.CreateMissingTables
      StoredClass.InitializeTable(Self,'');
end;

destructor TSQLRestServerFullMemory.Destroy;
begin
  UpdateToFile;
  inherited;
end;

procedure TSQLRestServerFullMemory.LoadFromFile;
var JSON: RawUTF8;
    P, TableName, Data: PUTF8Char;
    t: integer;
    S: TFileStream;
    wasString: boolean;
begin
  if (self=nil) or (fFileName='') or not FileExists(fFileName) then
    exit;
  for t := 0 to fStaticDataCount-1 do
    TSQLRestServerStaticInMemory(fStaticData[t]).fValue.Clear;
  if fBinaryFile then begin
    S := TFileStream.Create(FileName,fmOpenRead or fmShareDenyNone);
    try
      if ReadStringFromStream(S)=RawUTF8(ClassName)+'00' then
      repeat
        t := Model.GetTableIndex(ReadStringFromStream(S));
      until (t<0) or not TSQLRestServerStaticInMemory(fStaticData[t]).LoadFromBinary(S);
    finally
      S.Free;
    end;
  end else begin // [{"AuthUser":[{....},{...}]},{"AuthGroup":[{...},{...}]}]
    JSON := StringFromFile(fFileName);
    if JSON='' then
      exit;
    P := pointer(JSON);
    while (P^<>'[') do if P^=#0 then exit else inc(P);
    inc(P);
    repeat
      while (P^<>']') and (P^<>'{') do if P^=#0 then exit else inc(P);
      if P^=']' then break else inc(P);
      TableName := GetJSONField(P,P,@wasString);
      if not wasString or (P=nil) then
        exit;
      t := Model.GetTableIndex(TableName);
      if t<0 then
        exit;
      Data := P;
      P := GotoNextJSONObjectOrArray(P);
      if P=nil then
        break else
        TSQLRestServerStaticInMemory(fStaticData[t]).LoadFromJSON(Data,P-Data);
    until false;
  end;
end;

procedure TSQLRestServerFullMemory.UpdateToFile;
const CHARS: array[0..6] of AnsiChar = '[{":,}]';
var S: TFileStream;                //   0123456
    t: integer;
    Modified: boolean;
begin
  if (self=nil) or (FileName='') then
    exit;
  Modified := false;
  for t := 0 to fStaticDataCount-1 do
    if TSQLRestServerStaticInMemory(fStaticData[t]).Modified then begin
      Modified := true;
      break;
    end;
  if not Modified then
    exit;
  S := TFileStream.Create(FileName,fmCreate);
  try
    if fBinaryFile then begin
      WriteStringToStream(S,RawUTF8(ClassName)+'00');
      for t := 0 to fStaticDataCount-1 do
      with TSQLRestServerStaticInMemory(fStaticData[t]) do begin
        WriteStringToStream(S,StoredClassProps.SQLTableName);
        SaveToBinary(S);
      end;
    end else begin
      S.Write(CHARS[0],1);
      for t := 0 to fStaticDataCount-1 do
      with TSQLRestServerStaticInMemory(fStaticData[t]) do begin
        S.Write(CHARS[1],2);
        S.Write(pointer(StoredClassProps.SQLTableName)^,length(StoredClassProps.SQLTableName));
        S.Write(CHARS[2],2);
        SaveToJSON(S,true);
        S.Write(CHARS[5],1);
        if t<integer(fStaticDataCount-1) then
          S.Write(CHARS[4],1);
      end;
      S.Write(CHARS[6],1);
    end;
  finally
    S.Free;
  end;
end;

function TSQLRestServerFullMemory.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
begin
  if cardinal(TableModelIndex)>=fStaticDataCount then
    result := '' else
    result := TSQLRestServerStaticInMemory(fStaticData[TableModelIndex]).EngineRetrieve(0,ID);
end;

function TSQLRestServerFullMemory.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean=false; ReturnedRowCount: PPtrInt=nil): RawUTF8;
var TableIndex: integer;
begin
  TableIndex := Model.GetTableIndexFromSQLSelect(SQL,true);
  if TableIndex<0 then
    result := '' else
    result := TSQLRestServerStaticInMemory(fStaticData[TableIndex]).
      EngineList(SQL,ForceAJAX,ReturnedRowCount);
end;

function TSQLRestServerFullMemory.GetStatic(Table: TSQLRecordClass): TSQLRestServerStaticInMemory;
var t: cardinal;
begin
  t := fModel.GetTableIndex(Table);
  if t<fStaticDataCount then
    result := TSQLRestServerStaticInMemory(fStaticData[t]) else
    result := nil;
end;

function TSQLRestServerFullMemory.EngineUpdate(Table: TSQLRecordClass; ID: integer;
  const SentData: RawUTF8): boolean;
begin
  result := GetStatic(Table).EngineUpdate(Table,ID,SentData);
end;

function TSQLRestServerFullMemory.EngineDelete(Table: TSQLRecordClass; ID: integer): boolean;
begin
  result := GetStatic(Table).EngineDelete(Table,ID);
end;

function TSQLRestServerFullMemory.EngineDeleteWhere(Table: TSQLRecordClass;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
begin
  result := GetStatic(Table).EngineDeleteWhere(Table,SQLWhere,IDs);
end;

function TSQLRestServerFullMemory.EngineRetrieveBlob(Table: TSQLRecordClass; aID: integer;
  BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
begin
  result := GetStatic(Table).EngineRetrieveBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServerFullMemory.EngineUpdateBlob(Table: TSQLRecordClass; aID: integer;
  BlobField: PPropInfo; const BlobData: TSQLRawBlob): boolean;
begin
  result := GetStatic(Table).EngineUpdateBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServerFullMemory.EngineAdd(Table: TSQLRecordClass; const SentData: RawUTF8): integer;
begin
  result := GetStatic(Table).EngineAdd(Table,SentData);
end;

function TSQLRestServerFullMemory.EngineUpdateField(Table: TSQLRecordClass;
      const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  result := GetStatic(Table).EngineUpdateField(Table,SetFieldName,SetValue,
    WhereFieldName,WhereValue);
end;

function TSQLRestServerFullMemory.EngineExecuteAll(const aSQL: RawUTF8): boolean;
begin
  result := false; // not implemented in this basic REST server class
end;



{ TSQLRestServerRemoteDB }

constructor TSQLRestServerRemoteDB.Create(aRemoteClient: TSQLRestClient;
  aHandleUserAuthentication: boolean);
begin
  if aRemoteClient=nil then
    raise EORMException.CreateFmt('%s creation with no remote client',[ClassName]);
  inherited Create(aRemoteClient.Model,aHandleUserAuthentication);
  fClient := aRemoteClient;
end;

function TSQLRestServerRemoteDB.EngineAdd(Table: TSQLRecordClass;
  const SentData: RawUTF8): integer;
begin
  result := fClient.EngineAdd(Table,SentData);
end;

function TSQLRestServerRemoteDB.EngineDelete(Table: TSQLRecordClass;
  ID: integer): boolean;
begin
  result := fClient.EngineDelete(Table,ID);
end;

function TSQLRestServerRemoteDB.EngineDeleteWhere(Table: TSQLRecordClass;
  const SQLWhere: RawUTF8; const IDs: TIntegerDynArray): boolean;
begin
  result := fClient.EngineDeleteWhere(Table,SQLWhere,IDs);
end;

function TSQLRestServerRemoteDB.EngineExecuteAll(const aSQL: RawUTF8): boolean;
begin
  result := fClient.EngineExecute(aSQL);
end;

function TSQLRestServerRemoteDB.ExecuteList(const Tables: array of TSQLRecordClass;
  const SQL: RawUTF8): TSQLTableJSON;
begin
  result := fClient.ExecuteList(Tables,SQL);
end;

function TSQLRestServerRemoteDB.EngineList(const SQL: RawUTF8;
  ForceAJAX: Boolean; ReturnedRowCount: PPtrInt): RawUTF8;
begin
  result := fClient.EngineList(SQL,ForceAJAX,ReturnedRowCount);
end;

function TSQLRestServerRemoteDB.EngineRetrieve(TableModelIndex, ID: integer): RawUTF8;
var Dummy: cardinal;
begin
  if not fClient.EngineRetrieve(TableModelIndex,ID,False,Dummy,result) then
    result := '';
end;

function TSQLRestServerRemoteDB.EngineRetrieveBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo; out BlobData: TSQLRawBlob): boolean;
begin
  if (self=nil) or (BlobField=nil) then
    result := false else
    result := fClient.EngineRetrieveBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServerRemoteDB.EngineUpdate(Table: TSQLRecordClass;
  ID: integer; const SentData: RawUTF8): boolean;
begin
  result := fClient.EngineUpdate(Table,ID,SentData);
end;

function TSQLRestServerRemoteDB.EngineUpdateBlob(Table: TSQLRecordClass;
  aID: integer; BlobField: PPropInfo;
  const BlobData: TSQLRawBlob): boolean;
begin
  if (self=nil) or (BlobField=nil) then
    result := false else
    result := fClient.EngineUpdateBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestServerRemoteDB.EngineUpdateField(Table: TSQLRecordClass;
  const SetFieldName, SetValue, WhereFieldName, WhereValue: RawUTF8): boolean;
begin
  if (self=nil) or (Table.RecordProps.FieldIndexFromRawUTF8(SetFieldName)<0) then
    result := false else
    result := fClient.EngineUpdateField(Table,SetFieldName,SetValue,WhereFieldName,WhereValue);
end;

function TSQLRestServerRemoteDB.AfterDeleteForceCoherency(Table: TSQLRecordClass;
  aID: integer): boolean;
begin
  result := true; // coherency will be performed on the server side
end;


{ TSQLRestClient }

function TSQLRestClient.Add(Value: TSQLRecord; SendData: boolean; ForceID: boolean=false): integer;
var Data: RawUTF8;
begin
  result := 0;
  if (Value=nil) or (self=nil) then
    exit;
  if SendData then begin // send content of Value to the server as JSON
    Value.ComputeFieldsBeforeWrite(self,seAdd); // update TModTime/TCreateTime fields
    if Value.RecordProps.Kind in INSERT_WITH_ID then
      ForceID := true;
    Data := Value.GetJSONValues(True, // Expanded=true
      (Value.fID<>0) and ForceID,soInsert);
  end;
  // POST/Insert Collection
  result := EngineAdd(PSQLRecordClass(Value)^,Data);
  if result<=0 then
    exit;
  if SendData then
    fCache.Notify(PSQLRecordClass(Value)^,result,Data,soInsert);
  Value.fID := result;
  if ForceBlobTransfert then
    UpdateBlobFields(Value);
end;

function TSQLRestClient.Delete(Table: TSQLRecordClass; ID: integer): boolean;
begin
  if not inherited Delete(Table,ID) then
    result := false else begin
    fCache.NotifyDeletion(Table,ID);
    result := EngineDelete(Table,ID);
  end;
end;

function TSQLRestClient.Retrieve(aID: integer; Value: TSQLRecord;
      ForUpdate: boolean=false): boolean;
var Resp: RawUTF8;
begin
  result := false;
  if (self=nil) or (aID<=0) or (Value=nil) then
    exit;
  if ForUpdate then begin
    if not Model.Lock(PSQLRecordClass(Value)^,aID) then
      exit; // error marking as locked by the client
  end else begin
    result := fCache.Retrieve(aID,Value);
    if result then
      exit; // fast retrieved from internal Client cache
  end;
  try
    if EngineRetrieve(Model.GetTableIndex(PSQLRecordClass(Value)^),aID,
       ForUpdate,Value.fInternalState,Resp) then begin
      Value.FillFrom(Resp);
      Value.fID := aID; // JSON object may not contain the ID
      if ForceBlobTransfert then
        result := RetrieveBlobFields(Value) else
        result := true;
      ForUpdate := false; // any exception shall unlock the record
    end;
  finally
    if ForUpdate then
      Model.UnLock(PSQLRecordClass(Value)^,aID);
  end;
end;

function TSQLRestClient.Update(Value: TSQLRecord): boolean;
var JSON: RawUTF8;
begin
  if (self=nil) or not inherited Update(Value) or
     not BeforeUpdateEvent(Value) then begin
    result := false;
    exit;
  end;
  Value.ComputeFieldsBeforeWrite(self,seUpdate); // update sftModTime fields
  JSON := Value.GetJSONValues(true,false,soUpdate); // expanded + without ID
  result := EngineUpdate(PSQLRecordClass(Value)^,Value.fID,JSON);
  if result then begin
    if ForceBlobTransfert then
      result := UpdateBlobFields(Value);
    fCache.Notify(Value,soUpdate); // JSON may not include all fields on update
    if result and assigned(OnRecordUpdate) then
      OnRecordUpdate(Value);
  end;
end;

function TSQLRestClient.RetrieveBlob(Table: TSQLRecordClass;
  aID: integer; const BlobFieldName: RawUTF8;
  out BlobData: TSQLRawBlob): boolean;
var P: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) then
    exit;
  P := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if P<>nil then
    result := EngineRetrieveBlob(Table,aID,P,BlobData);
end;

function TSQLRestClient.RetrieveBlobFields(Value: TSQLRecord): boolean;
var BlobData: TSQLRawBlob;
    i: integer;
begin
  result := false;
  if (Self=nil) or (Value=nil) or (Value.fID<=0) then
    exit;
  with Value.RecordProps do
  if BlobFields<>nil then
    for i := 0 to high(BlobFields) do
      if EngineRetrieveBlob(PSQLRecordClass(Value)^,Value.fID,BlobFields[i],BlobData) then
        SetLongStrProp(Value,BlobFields[i],BlobData) else
        exit;
  result := true;
end;

function TSQLRestClient.UpdateBlob(Table: TSQLRecordClass; aID: integer;
  const BlobFieldName: RawUTF8; const BlobData: TSQLRawBlob): boolean;
var BlobField: PPropInfo;
begin
  result := false;
  if (self=nil) or (aID<=0) or not RecordCanBeUpdated(Table,aID,seUpdate) then
    exit;
  BlobField := Table.RecordProps.BlobFieldPropFromRawUTF8(BlobFieldName);
  if BlobField<>nil then
    result := EngineUpdateBlob(Table,aID,BlobField,BlobData);
end;

function TSQLRestClient.UpdateBlobFields(Value: TSQLRecord): boolean;
var BlobData: RawByteString;
    i: integer;
begin
  result := false;
  if (Self=nil) or (Value=nil) or (Value.fID<=0) then
    exit;
  with Value.RecordProps do
  if BlobFields<>nil then
    for i := 0 to high(BlobFields) do begin
      GetLongStrProp(Value,BlobFields[i],BlobData);
      if not EngineUpdateBlob(PSQLRecordClass(Value)^,Value.fID,BlobFields[i],BlobData) then
        exit;
    end;
  result := true;
end;

function TSQLRestClient.BeforeUpdateEvent(Value: TSQLRecord): Boolean;
begin
  Result := true; // by default, just allow the update to proceed
end;

function TSQLRestClient.Refresh(aID: integer; Value: TSQLRecord;
  var Refreshed: boolean): boolean;
var Resp, Original: RawUTF8;
begin
  result := false;
  if (aID>0) and (self<>nil) and (Value<>nil) then
    if EngineRetrieve(Model.GetTableIndex(PSQLRecordClass(Value)^),aID,False,
       Value.fInternalState,Resp) then begin
      Original := Value.GetJSONValues(IsNotAjaxJSON(pointer(Resp)),true,soSelect);
      Resp := trim(Resp);
      if (Resp<>'') and (Resp[1]='[') then // '[{....}]' -> '{...}'
        Resp := copy(Resp,2,length(Resp)-2);
      if Original<>Resp then begin // did the content really change?
        Refreshed := true;
        Value.FillFrom(Resp);
      end;
      result := true;
    end;
end;

procedure TSQLRestClient.Commit(SessionID: cardinal);
begin
  inherited;
end;

function TSQLRestClient.TransactionBegin(aTable: TSQLRecordClass;
  SessionID: cardinal): boolean;
begin
  result := inherited TransactionBegin(aTable,SessionID);
end;

procedure TSQLRestClient.RollBack(SessionID: cardinal);
begin
  inherited;
end;

function TSQLRestClient.EngineExecuteFmt(SQLFormat: PUTF8Char;
  const Args: array of const): boolean;
begin
  result := EngineExecute(FormatUTF8(SQLFormat,Args));
end;

function TSQLRestClient.EngineExecuteFmt(SQLFormat: PUTF8Char;
  const Args, Bounds: array of const): boolean;
begin
  result := EngineExecute(FormatUTF8(SQLFormat,Args,Bounds));
end;

function TSQLRestClient.ListFmt(const Tables: array of TSQLRecordClass; const SQLSelect: RawUTF8;
  SQLWhereFormat: PUTF8Char; const Args: array of const): TSQLTableJSON;
begin
  result := List(Tables,SQLSelect,FormatUTF8(SQLWhereFormat,Args));
end;

function TSQLRestClient.ListFmt(const Tables: array of TSQLRecordClass;
  const SQLSelect: RawUTF8; SQLWhereFormat: PUTF8Char;
  const Args, Bounds: array of const): TSQLTableJSON;
begin
  result := List(Tables,SQLSelect,FormatUTF8(SQLWhereFormat,Args,Bounds));
end;

function TSQLRestClient.RTreeMatch(DataTable: TSQLRecordClass;
  const DataTableBlobFieldName: RawUTF8; RTreeTable: TSQLRecordRTreeClass;
  const DataTableBlobField: RawByteString; var DataID: TIntegerDynArray): boolean;
var Blob: PPropInfo;
    Res: TSQLTableJSON;
    B: TSQLRecordTreeCoords;
    Where: RawUTF8;
    Data, RTree: TSQLRecordProperties;
    i: integer;
begin
  result := false;
  if (self=nil) or (DataTable=nil) or (RTreeTable=nil) or (DataTableBlobField='') then
    exit;
  RTree := RTreeTable.RecordProps;
  Data := DataTable.RecordProps;
  Blob :=  Data.BlobFieldPropFromRawUTF8(DataTableBlobFieldName);
  if Blob=nil then
    exit;
  for i := 0 to (length(RTree.Fields)shr 1)-1 do
    Where := FormatUTF8('%% >= :(%): AND % <= :(%): AND ',
      [Where,RTree.FieldsName[i*2],B[i].Min,RTree.FieldsName[i*2+1],B[i].Max]);
  RTreeTable.BlobToCoord(DataTableBlobField[1],B);
  Res := ListFmt([DataTable,RTreeTable],Data.SQLTableName+'.RowID',
    'WHERE %.RowID=%.RowID AND %%(%,:(%):);',
      [Data.SQLTableName,RTree.SQLTableName,Where,
       RTreeTable.RTreeSQLFunctionName,Data.SQLTableName,
       BinToBase64WithMagic(DataTableBlobField)]);
  if Res<>nil then
  try
    if (Res.FieldCount<>1) or (Res.RowCount<=0) then
      exit;
    Res.GetRowValues(0,DataID);
    result := true;
  finally
    Res.Free;
  end;
end;


{ TSQLRecordLog }

destructor TSQLRecordLog.Destroy;
begin
  fLogTableWriter.Free;
  fLogTableStorage.Free;
  inherited;
end;

constructor TSQLRecordLog.CreateFrom(OneLog: TSQLRecord; const aJSON: RawUTF8);
var L,FieldCount: integer;
    P: PUTF8Char;
begin
  inherited Create;
  L := length(aJSON);
  if (L<10) or (Copy(aJSON,L-1,2)<>']}') then
    exit;
  fLogTableStorage := THeapMemoryStream.Create;
  fLogTableWriter := OneLog.RecordProps.CreateJSONWriter(
    fLogTableStorage,false,true,ALL_ACCESS_RIGHTS,0);
  fLogTableWriter.Flush;
  P := pointer(aJSON);
  if not CompareMem(fLogTableStorage.Memory,P,fLogTableStorage.Position) or
     not IsNotExpanded(P,FieldCount,fLogTableRowCount) then begin // field format changed or invalid
    FreeAndNil(fLogTableWriter);
    FreeAndNil(fLogTableStorage);
    exit;
  end;
  if fLogTableRowCount=0 then // if not already computed in IsNotExpanded()
    GetRowCountNotExpanded(P,FieldCount,fLogTableRowCount);
  fLogTableStorage.Seek(0,soFromBeginning);
  fLogTableStorage.Write(Pointer(aJSON)^,L-2);
end;

procedure TSQLRecordLog.Log(OneLog: TSQLRecord);
begin
  if OneLog=nil then
    exit;
  // simulate adding a row: compute new ID
  inc(OneLog.fID);
  // adding a row, in not-expanded format
  if not Assigned(fLogTableStorage) then begin
    fLogTableStorage := THeapMemoryStream.Create;
    fLogTableWriter := OneLog.RecordProps.CreateJSONWriter(
      fLogTableStorage,false,true,ALL_ACCESS_RIGHTS,0);
    fLogTableRowCount := 1;
  end else begin
    fLogTableWriter.Add(',');
    if (fMaxLogTableRowCount<>0) and (fLogTableRowCount>=fMaxLogTableRowCount) then
      fLogTableWriter.TrimFirstRow else
      inc(fLogTableRowCount);
  end;
  OneLog.GetJSONValues(fLogTableWriter)
end;

function TSQLRecordLog.LogCurrentPosition: integer;
begin
  if not Assigned(fLogTableStorage) then
    result := 0 else begin
    fLogTableWriter.Flush;
    result := fLogTableStorage.Position;
  end;
end;

function TSQLRecordLog.LogTableJSON: RawUTF8;
begin
  result := LogTableJSONFrom(0);
end;

function TSQLRecordLog.LogTableJSONFrom(StartPosition: integer): RawUTF8;
var JSONStart: RawUTF8;
    Data: PAnsiChar;
begin
  if not Assigned(fLogTableStorage) or (StartPosition<0) then
    result := '' else begin
    fLogTableWriter.Flush;
    Data := fLogTableStorage.Memory;
    SetString(result,Data+StartPosition,fLogTableStorage.Position-StartPosition);
    // format as valid not expanded JSON table content:
    if StartPosition<>0 then begin
      SetString(JSONStart,Data,fLogTableWriter.StartDataPosition);
      result := JSONStart+result;
    end;
    result := result+']}';
  end;
end;


{ RecordRef }

function RecordReference(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer): TRecordReference;
begin
  if aID=0 then
    result := 0 else begin
    result := Model.GetTableIndex(aTable);
    if result>63 then // TRecordReference handle up to 64=1 shl 6 tables
      result := 0 else
      inc(result,aID shl 6); // 64=1 shl 6
  end;
end;

procedure RecordRefToID(var aArray: TIntegerDynArray);
var i: Integer;
begin
  for i := 0 to high(aArray) do
    aArray[i] := aArray[i] shr 6;
end;

procedure RecordRef.From(Model: TSQLModel; aTable: TSQLRecordClass; aID: integer);
begin
  Value := Model.GetTableIndex(aTable);
  if Value>63 then // TRecordReference handle up to 64=1 shl 6 tables
    Value := 0 else
    inc(Value,aID shl 6); // 64=1 shl 6
end;

function RecordRef.ID: integer;
begin
  result := Value shr 6;  // 64=1 shl 6
end;

function RecordRef.Table(Model: TSQLModel): TSQLRecordClass;
var V: integer;
begin
  if (Model=nil) or (Value=0) then
    result := nil else begin
    V := Value and 63;
    if V>high(Model.Tables) then
      result := nil else
      result := Model.Tables[V];
  end;
end;

function RecordRef.TableIndex: integer;
begin
  result := Value and 63;
end;

function RecordRef.Text(Model: TSQLModel): RawUTF8;
var aTable: TSQLRecordClass;
begin
  if ((Value shr 6)=0) then
    // Value=0 or no valid ID
    result := '' else begin
    aTable := Table(Model);
    if aTable=nil then
      result := '' else
      result := Model.TableProps[Value and 63].SQLTableName+' '+
        {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(Value shr 6);
  end;
end;

function RecordRef.Text(Rest: TSQLRest): RawUTF8;
var T: TSQLRecordClass;
    aID: integer;
begin
  result := '';
  if ((Value shr 6)=0) or (Rest=nil) then
    exit;
  T := Table(Rest.Model);
  if T=nil then
    exit;
  aID := ID;
  with Rest.Model.TableProps[Value and 63] do
  if aID<=0 then
    result := SQLTableName else begin
    result := Rest.MainFieldValue(T,aID,true);
    if result='' then
      result := FormatUTF8('% %',[SQLTableName,aID]) else
      result := FormatUTF8('% "%"',[SQLTableName,result]);
  end;
end;

{ TSQLLocks }

function TSQLLocks.isLocked(aID: integer): boolean;
begin
  result := (@self<>nil) and (Count<>0) and (aID<>0) and
    IntegerScanExists(@ID,Count,aID);
end;

function TSQLLocks.Lock(aID: integer): boolean;
var P: PCardinal;
begin
  if (@self=nil) or (Count=MAX_SQLLOCKS) or (aID=0) then
    // void or full
    result := false else begin
    P := IntegerScan(@ID,Count,aID);
    if P<>nil then
      // already locked
      result := false else begin
      // add to ID[] and Ticks[]
      P := IntegerScan(@ID,Count,0);
      if P=nil then begin
        // no free entry -> add at the end
        ID[Count] := aID;
        Ticks[Count] := GetTickCount;
        inc(Count);
      end else begin
        // store at free entry
        P^ := aID;
        Ticks[(PtrUInt(P)-PtrUInt(@ID))shr 2] := GetTickCount;
      end;
      result := true;
    end;
  end;
end;

procedure TSQLLocks.PurgeOlderThan(MinutesFromNow: cardinal);
var Now,OK: cardinal;
    i, LastEntry: integer;
begin
  if (@self=nil) or (Count=0) then
    exit; // nothing to purge
  MinutesFromNow := MinutesFromNow*(1000*60); // GetTickCount unit is ms
  Now := GetTickCount;
  OK  := Now-MinutesFromNow;
  LastEntry := -1;
  for i := 0 to Count-1 do
    if (ID[i]<>0) then
    if ((Ticks[i]>Now) or   // GetTickCount wrap around to zero after 49.7 days
        (Ticks[i]<OK)) then // too old
      ID[i] := 0 else    // 0 frees entry
      LastEntry := i; // refresh last existing entry
  Count := LastEntry+1; // update count (may decrease list length)
end;

function TSQLLocks.UnLock(aID: integer): boolean;
var P: PCardinal;
begin
  if (@self=nil) or (Count=0) or (aID=0) then
    result := false else begin
    P := IntegerScan(@ID,Count,aID);
    if P=nil then
      result := false else begin
      P^ := 0; // 0 marks free entry
      if ((PtrUInt(P)-PtrUInt(@ID))shr 2>=PtrUInt(Count-1)) then
        dec(Count); // freed last entry -> decrease list length
      result := true;
    end;
  end;
end;

procedure CopyObject(aFrom, aTo: TObject);
var P: PPropInfo;
    i: integer;
    C: TClass;
    CP: PClassProp;
label I64;
begin
  if (aFrom=nil) or (aTo=nil) then
    exit;
  {$ifndef LVCL}
  if aFrom.InheritsFrom(TCollection) then begin
    CopyCollection(TCollection(aFrom),TCollection(aTo));
    exit;    
  end;
  {$endif}
  C := PPointer(aFrom)^;
  if aTo.InheritsFrom(C) then
  while C<>nil do begin
    CP := InternalClassProp(C);
    if CP=nil then
      break; // no more RTTI information available
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      P^.CopyValue(aFrom,aTo); // shortstring and WideString not handled
      P := P^.Next;
    end;
    C := C.ClassParent;
  end;
end;

procedure WriteObject(Value: TObject; var IniContent: RawUTF8; const Section: RawUTF8;
  const SubCompName: RawUTF8=''); overload;
var P: PPropInfo;
    i, V: integer;
{$ifdef UNICODE}
    VV: RawUTF8;
{$endif}
    Obj: TObject;
    CP: PClassProp;
begin
  if Value=nil then
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    case P^.PropType^^.Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}:
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          {$ifndef ENHANCEDRTL}Int64ToUtf8{$else}IntToStr{$endif}(
            GetInt64Prop(Value,pointer(P))));
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger: begin
        V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
        //if V<>P^.Default then NO DEFAULT: update INI -> must override previous
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(V));
      end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),
          P^.GetLongStrValue(Value));
      {$ifdef UNICODE}
      tkUString: begin
        VV := UnicodeStringToUtf8(GetUnicodeStrProp(Value,pointer(P)));
        UpdateIniEntry(IniContent,Section,SubCompName+RawUTF8(P^.Name),VV);
      end;
      {$endif}
      tkClass:
      if Section='' then begin // recursive call works only as plain object
        Obj := pointer(GetOrdProp(Value,pointer(P)));  // GetOrdProp() is OK for CPU64
        if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
          WriteObject(Value,IniContent,Section,SubCompName+RawUTF8(P^.Name)+'.');
      end;
      // tkString (shortstring) and tkWString are not handled
    end;
    P := P^.Next;
  end;
end;

function WriteObject(Value: TObject): RawUTF8; overload;
begin
  if Value<>nil then
    with TIniWriter.CreateOwnedStream do
    try
      WriteObject(Value,'');
      result := Text;
    finally
      Free;
    end else
    result := '';
end;

function ObjectToJSON(Value: TObject; HumanReadable: boolean=false;
  DontStoreDefault: boolean=true): RawUTF8;
begin
  with TJSONSerializer.CreateOwnedStream do
  try
    WriteObject(Value,HumanReadable,DontStoreDefault);
    result := Text;
  finally
    Free;
  end;
end;

function UrlEncode(const NameValuePairs: array of const): RawUTF8;
// (['select','*','where','ID=12','offset',23,'object',aObject]);
var A, n: PtrInt;
    name, value: RawUTF8;
  function Invalid(P: PAnsiChar): boolean;
  begin
    result := true;
    if P<>nil then begin
      repeat
        if not (P^ in ['a'..'z','A'..'Z']) then
          exit else
          inc(P);
      until P^=#0;
      result := false;
    end;
  end;
begin
  result := '';
  n := high(NameValuePairs);
  if n>0 then begin
    for A := 0 to n shr 1 do begin
      VarRecToUTF8(NameValuePairs[A*2],name);
      if Invalid(pointer(name)) then
        continue;
      with NameValuePairs[A*2+1] do
        if VType=vtObject then
          value := ObjectToJSON(VObject,false,false) else
          VarRecToUTF8(NameValuePairs[A*2+1],value);
      result := result+'&'+name+'='+UrlEncode(value);
    end;
    result[1] := '?';
  end;
end;

var
  JSONCustomParsers: array of record
    Kind: TClass;
    Reader: TJSONSerializerCustomReader;
    Writer: TJSONSerializerCustomWriter;
  end;

type
  TJSONCustomParserExpectedDirection = (cpRead, cpWrite);
  TJSONCustomParserExpectedDirections = set of TJSONCustomParserExpectedDirection;

function JSONCustomParsersIndex(aClass: TClass;
  aExpectedReadWriteTypes: TJSONCustomParserExpectedDirections): integer; {$ifdef HASINLINE}inline;{$endif}
begin
  if JSONCustomParsers<>nil then
    for result := 0 to length(JSONCustomParsers)-1 do
      with JSONCustomParsers[result] do
      if Kind=aClass then
        if ((cpRead in aExpectedReadWriteTypes) and not Assigned(Reader)) or
           ((cpWrite in aExpectedReadWriteTypes) and not Assigned(Writer)) then
          break
        else
          exit;
  result := -1;
end;

class procedure TJSONSerializer.RegisterCustomSerializer(aClass: TClass;
  aReader: TJSONSerializerCustomReader; aWriter: TJSONSerializerCustomWriter);
var i: integer;
begin
  i := JSONCustomParsersIndex(aClass,[]);
  if i<0 then begin
    i := length(JSONCustomParsers);
    SetLength(JSONCustomParsers,i+1);
  end;
  with JSONCustomParsers[i] do begin
    Kind := aClass;
    Writer := aWriter;
    Reader := aReader;
  end;
end;

type
  TJSONObject =
    (oNone, oList, oCollection, oUtfs, oStrings, oSQLRecord, oSQLMany,
     oPersistent, oCustom);

function JSONObject(aClassType: TClass; out aCustomIndex: integer;
  aExpectedReadWriteTypes: TJSONCustomParserExpectedDirections): TJSONObject;
begin
  // guess class type (faster than multiple InheritsFrom calls)
  result := oNone;
  repeat
    if aClassType<>TList then
    if aClassType<>TPersistent then
    if aClassType<>TSQLRecordMany then
    if aClassType<>TSQLRecord then
    if aClassType<>TStrings then
    if aClassType<>TRawUTF8List then
{$ifndef LVCL}
    if aClassType<>TCollection then
{$endif} begin
      aCustomIndex := JSONCustomParsersIndex(aClassType,aExpectedReadWriteTypes);
      if aCustomIndex<0 then
        if PPointer(PtrInt(aClassType)+vmtParent)^<>nil then begin
          aClassType := PPointer(PPointer(PtrInt(aClassType)+vmtParent)^)^;
          if aClassType<>nil then
            continue else
            break;
        end else
        break else
      result := oCustom;
    end else
{$ifndef LVCL}
      result := oCollection else
{$endif}
      result := oUtfs else
      result := oStrings else
      result := oSQLRecord else
      result := oSQLMany else
      result := oPersistent else
      result := oList;
    break;
  until false;
end;

function JSONToObject(var ObjectInstance; From: PUTF8Char; var Valid: boolean;
  TObjectListItemClass: TClass): PUTF8Char;
var P: PPropInfo;
    Value: TObject absolute ObjectInstance;
{$ifndef LVCL}
    Coll: TCollection absolute ObjectInstance;
    CollItem: TObject;
{$endif}
    Str: TStrings absolute ObjectInstance;
    Utf: TRawUTF8List absolute ObjectInstance;
    Lst: TObjectList absolute ObjectInstance;
    Item: TObject;
    V: PtrInt;
    ndx,err: integer;
    E: extended;
    V64: Int64 absolute E;
    Obj: TObject absolute V;
    PropName: PUTF8Char;
    PropValue: PUTF8Char;
    EndOfObject: AnsiChar;
    Kind: TTypeKind;
    wasString, NestedValid: boolean;
    IsObj: TJSONObject;
    IsObjCustomIndex: integer;
begin
  Valid := false;
  result := From;
  if (Value=nil) or (PPointer(Value)^=nil) then
    exit;
  IsObj := JSONObject(PPointer(Value)^,IsObjCustomIndex,[cpRead]); 
  if From=nil then begin
    case IsObj of // handle '' as Clear for arrays
{$ifndef LVCL}
    oCollection: Coll.Clear;
{$endif}
    oStrings:    Str.Clear;
    oUTfs:       Utf.Clear;
    oList: if Lst.InheritsFrom(TObjectList) then Lst.Clear;
    end;
    exit;
  end;
  if PInteger(From)^ and $DFDFDFDF=NULL_DF then begin
    if (IsObj=oCustom) and Assigned(JSONCustomParsers[IsObjCustomIndex].Reader) then
      // custom JSON reader expect its execution even if value is null
      result := JSONCustomParsers[IsObjCustomIndex].Reader(Value,From,Valid) else begin
      FreeAndNil(Value);
      result := From+4;
      Valid := true; // null is a valid JSON object
    end;
    exit;
  end;
  while From^ in [#1..' '] do inc(From);
  if IsObj=oCustom then
  with JSONCustomParsers[IsObjCustomIndex] do begin
    if Assigned(Reader) then // leave Valid=false if Reader=nil
      result := Reader(Value,From,Valid);
    exit;
  end;
  if From^='[' then begin
    // nested array = TCollection, TRawUTF8List or TStrings
    inc(From);
    case IsObj of
    oList: if Lst.InheritsFrom(TObjectList) then begin
      Lst.Clear;
      if TObjectListItemClass<>nil then
      repeat
        while From^ in [#1..' '] do inc(From);
        case From^ of
        #0: exit;
        ']': begin
          inc(From);
          break;
        end;
        ',':
          inc(From); // valid delimiter between objects
        '{': begin
          result := From;
          Item := TObjectListItemClass.Create;
          From := JSONToObject(Item,From,NestedValid);
          if not NestedValid then begin
            result := From;
            exit;
          end else
          if From=nil then
            exit;
          Lst.Add(Item);
        end;
        else exit;
        end;
      until false;
      // only way of being here is to have an ending ] at expected place
      Valid := true;
    end;
{$ifndef LVCL}
    oCollection: begin
      Coll.BeginUpdate;  // Coll: TCollection absolute Value
      try
        Coll.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          ',':
            inc(From); // valid delimiter between objects
          '{': begin
            result := From;
            CollItem := Coll.Add;
            From := JSONToObject(CollItem,From,NestedValid);
            if not NestedValid then begin
              result := From;
              exit;
            end else
            if From=nil then
              exit;
          end;
          else exit;
          end;
        until false;
        // only way of being here is to have an ending ] at expected place
        Valid := true;
      finally
        Coll.EndUpdate;
      end;
    end;
{$endif}
    oStrings: begin
{$ifndef LVCL}
      Str.BeginUpdate; // Str: TStrings absolute Value
      try
{$endif}
        Str.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          '"': begin
            result := From;
            PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
            if (PropValue=nil) or not wasString then
              exit;
            Str.Add(UTF8DecodeToString(PropValue,StrLen(PropValue)));
            case EndOfObject of
              ']': break;
              ',': continue;
              else exit;
            end;
          end;
          else exit;
          end;
        until false;
        Valid := true;
{$ifndef LVCL}
      finally
        Str.EndUpdate;
      end;
{$endif}
    end;
    oUTfs: begin
      utf.BeginUpdate; // utf: TStrings absolute Value
      try
        utf.Clear;
        repeat
          while From^ in [#1..' '] do inc(From);
          case From^ of
          #0: exit;
          ']': begin
            inc(From);
            break;
          end;
          '"': begin
            result := From;
            PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
            if (PropValue=nil) or not wasString then
              exit;
            utf.Add(PropValue);
            case EndOfObject of
              ']': break;
              ',': if From=nil then exit else continue;
              else exit;
            end;
          end;
          else exit;
          end;
        until false;
        Valid := true;
      finally
        utf.EndUpdate;
      end;
    end;
    end; // case IsObj of
    // Valid=false if not TCollection, TRawUTF8List nor TStrings
    if Valid and (From<>nil) then begin
      while From^ in [#1..' '] do inc(From);
      if From^=#0 then
        From := nil;
    end;
    result := From;
    exit; // a JSON array begin with [
  end else
  if From^<>'{' then begin
    result := From;
    exit; // a JSON object MUST begin with {
  end;
  repeat inc(From) until (From^=#0) or (From^>' ');
  EndOfObject := #0;
  if From^='}' then begin
    // empty JSON object like {} (e.g. all properties having default values)
    EndOfObject := '}';
    Inc(From);
  end else
  repeat
    wasString := false;
    result := From;
    PropName := GetJSONField(From,From,@wasString,@EndOfObject);  // get property name
    if (From=nil) or (EndOfObject<>':') or not wasString then
      exit; // invalid JSON content
    if (IsObj=oSQLRecord) and IsRowID(PropName) then begin
      // manual handling of TSQLRecord.ID property unserialization
      PropValue := GetJSONField(From,From,@wasString,@EndOfObject); // get value
      if (PropValue=nil) or wasString or not (EndOfObject in ['}',',']) then
        exit; // invalid JSON content
      V := GetInteger(PropValue,err);
      if err<>0 then
        exit;
      TSQLRecord(Value).fID := V;
      continue;
    end;
    P := ClassFieldPropWithParentsFromUTF8(PPointer(Value)^,PropName);
    if P=nil then
      exit; // unknwown property
    Kind := P^.PropType^^.Kind;
    while From^ in [#1..' '] do inc(From);
    result := From;
    if PInteger(result)^ and $DFDFDFDF=NULL_DF then begin
      // nested null object
      if (IsObj=oSQLRecord) or (Kind<>tkClass) then
        exit; // null expect a TObject
      V := GetOrdProp(Value,pointer(P));
      if Obj<>nil then begin
        // null -> FreeAndNil(Obj)
        Obj.Free;
        SetOrdProp(Value,pointer(P),0);
      end;
    end else
    if From^ in ['[','{'] then begin
      // nested array or object
      if Kind=tkDynArray then begin
        From := P^.GetDynArray(Value).LoadFromJSON(From);
        if From=nil then
          exit; // invalid '[dynamic array]' content
      end else
      if (Kind=tkSet) and (From^='[') then begin // set as string array
        repeat inc(From) until From^<>' ';
        V := 0;
        EndOfObject := From^;
        while EndOfObject<>']' do begin
          PropValue := GetJSONField(From,From,@wasString,@EndOfObject);
          if (PropValue=nil) or (not wasString) then
            exit;
          ndx := P^.PropType^^.SetEnumType^.GetEnumNameValue(PropValue);
          if ndx<0 then
            exit; // invalid enum string value
          SetBit(V,ndx);
        end;
        SetOrdProp(Value,pointer(P),V);
      end else begin
        if (IsObj=oSQLRecord) or (Kind<>tkClass) then
          exit; // true nested object is expected here
        // will handle '[TCollection...' '[TStrings...' '{TObject...'
        From := JSONToObject(PObject(P^.GetFieldAddr(Value))^,From,NestedValid);
        if not NestedValid then begin
          result := From;
          exit;
        end else
        if From=nil then
          exit; // invalid JSON content: we expect at least a last '}'
      end;
      while From^ in [#1..' '] do inc(From);
      EndOfObject := From^;
      if From^ in EndOfJSONField then
        inc(From);
    end else begin
      // normal property value
      PropValue := GetJSONField(From,From,@wasString,@EndOfObject); // get value
      if (PropValue=nil) or not (EndOfObject in ['}',',']) then
        exit; // invalid JSON content
      case Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}:
        if wasString then
          exit else begin
          V64 := GetInt64(PropValue,err);
          if err<>0 then
            exit;
          SetInt64Prop(Value,pointer(P),V64);
        end;
      tkClass: begin
        if wasString or (IsObj<>oSQLRecord) then // should have been handled above
          exit;
        V := GetInteger(PropValue,err);
        if err<>0 then
          exit; // invalid value
        SetOrdProp(Value,pointer(P),V);
      end;
      tkEnumeration: begin
        if wasString then begin // in case enum stored as string
          V := P^.PropType^^.EnumBaseType^.GetEnumNameValue(PropValue);
          if V<0 then
            exit;
        end else begin
          V := GetInteger(PropValue,err);
          if err<>0 then
            exit; // invalid value
        end;
        SetOrdProp(Value,pointer(P),V);
      end;
      {$ifdef FPC} tkBool, {$endif}
      tkInteger, tkSet:
        if wasString then
          exit else begin
          // From='true' or From='false' were converted into '1 or '0'
          V := GetInteger(PropValue,err);
          if err<>0 then
            exit; // invalid value
          SetOrdProp(Value,pointer(P),V);
        end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        if not wasString then
          exit else
          P^.SetLongStrValue(Value,RawUTF8(PropValue));
      {$ifdef UNICODE}
      tkUString:
        if not wasString then
          exit else
          SetUnicodeStrProp(Value,pointer(P),UTF8DecodeToUnicodeString(PropValue,0));
      {$endif}
{$ifdef PUBLISHRECORD}
      tkRecord:
        if not wasString then
          exit else
          RecordLoad(P^.GetFieldAddr(Value)^,pointer(BlobToTSQLRawBlob(PropValue)),P^.PropType^);
{$endif PUBLISHRECORD}
      tkFloat:
        if P^.PropType^=TypeInfo(Currency) then
          if wasString then
            exit else
            SetInt64Prop(Value,pointer(P),StrToCurr64(PropValue)) else
        if P^.PropType^=TypeInfo(TDateTime) then
          if wasString then
            SetFloatProp(Value,pointer(P),Iso8601ToDateTimePUTF8Char(PropValue,0)) else
            exit else begin
          E := GetExtended(pointer(PropValue),err);
          if (err<>0) or wasString then
            exit else // invalid JSON content
            SetFloatProp(Value,pointer(P),E);
        end;
      end;
    end;
  until (From=nil) or (EndOfObject='}');
  if From<>nil then begin
    while From^ in [#1..' '] do inc(From);
    if From^=#0 then
      From := nil;
  end;
  Valid := (EndOfObject='}'); // mark parsing success
  result := From;
end;

function UrlDecodeObject(U, Upper: PUTF8Char; var ObjectInstance; Next: PPUTF8Char=nil): boolean;
var tmp: RawUTF8;
begin
  result := UrlDecodeValue(U, Upper, tmp, Next);
  if result then
    JSONToObject(ObjectInstance,Pointer(tmp),result);
end;

procedure ReadObject(Value: TObject; From: PUTF8Char; const SubCompName: RawUTF8=''); overload;
var P: PPropInfo;
    i, V, err: integer;
    V64: Int64;
    E: extended;
    Obj: TObject;
    UpperName: array[byte] of AnsiChar;
    U: RawUTF8;
    CP: PClassProp;
begin
  if Value=nil then // allow From=nil -> default values
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    PWord(UpperCopyShort(UpperCopy255(UpperName,SubCompName),P^.Name))^ := ord('=');
    U := FindIniNameValue(From,UpperName);
    case P^.PropType^^.Kind of
      tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
        V64 := GetInt64(pointer(U),err);
        if err=0 then
          SetInt64Prop(Value,pointer(P),V64); // pointer() to call typinfo
      end;
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger: begin
        V := GetInteger(pointer(U),err);
        if err=0 then
          SetOrdProp(Value,pointer(P),V) else // pointer() to call typinfo
          if P^.Default<>longint($80000000) then
            SetOrdProp(Value,pointer(P),P^.Default);
      end;
      tkFloat:
      if U<>'' then
        if P^.PropType^=TypeInfo(Currency) then
          SetInt64Prop(Value,pointer(P),StrToCurr64(pointer(U))) else begin
          E := GetExtended(pointer(U),err);
          if err=0 then
            SetFloatProp(Value,pointer(P),E);
        end;
      {$ifdef FPC}tkAString,{$endif} tkLString:
        P^.SetLongStrValue(Value,U);
      {$ifdef UNICODE}
      tkUString:
        SetUnicodeStrProp(Value,Pointer(P),UTF8ToString(U));
      {$endif}
      tkDynArray:
        P^.GetDynArray(Value).LoadFrom(pointer(BlobToTSQLRawBlob(pointer(U))));
{$ifdef PUBLISHRECORD}
      tkRecord:
        RecordLoad(P^.GetFieldAddr(Value)^,pointer(BlobToTSQLRawBlob(pointer(U))),P^.PropType^);
{$endif PUBLISHRECORD}
      tkClass: begin
        Obj := pointer(GetOrdProp(Value,pointer(P))); // GetOrdProp() is OK for CPU64
        if (PtrUInt(Obj)>=PtrUInt(SystemInfo.lpMinimumApplicationAddress)) and
           Obj.InheritsFrom(TPersistent) then
          ReadObject(Obj,From,SubCompName+RawUTF8(P^.Name)+'.');
      end;
      // tkString (shortstring) and tkWString are not handled
    end;
    P := P^.Next; 
  end;
end;

procedure ReadObject(Value: TObject; const FromContent: RawUTF8;
  const SubCompName: RawUTF8=''); overload;
var source: PUTF8Char;
    UpperSection: array[byte] of AnsiChar;
begin
  if Value=nil then
    exit; // avoid GPF
  PWord(UpperCopyShort(UpperSection,PShortString(PPointer(
    PPtrInt(Value)^ + vmtClassName)^)^))^ := ord(']');
  source := pointer(FromContent);
  if FindSectionFirstLine(source,UpperSection) then
    ReadObject(Value,source,SubCompName);
end;

procedure SetDefaultValuesObject(Value: TObject);
var P: PPropInfo;
    i: integer;
    Obj: TObject;
    CP: PClassProp;
begin
  if Value=nil then
    exit;
  CP := InternalClassProp(PPointer(Value)^);
  if CP=nil then
    exit; // no RTTI available
  P := @CP^.PropList;
  for i := 1 to CP^.PropCount do begin
    case P^.PropType^^.Kind of
      {$ifdef FPC}tkBool,{$endif} tkEnumeration, tkSet, tkInteger:
      if P^.Default<>longint($80000000) then
        SetOrdProp(Value,pointer(P),P^.Default); // pointer() to call typinfo
      tkClass: begin
        Obj := pointer(GetOrdProp(Value,pointer(P))); // GetOrdProp() is OK for CPU64
        if (Obj<>nil) and Obj.InheritsFrom(TPersistent) then
          SetDefaultValuesObject(Obj);
      end;
    end;
    P := P^.Next;
  end;
end;

{$ifdef MSWINDOWS}

{ TSQLRestClientURIMessage }

constructor TSQLRestClientURIMessage.Create(aModel: TSQLModel;
  const ServerWindowName: string; ClientWindow: HWND; TimeOutMS: cardinal);
begin
  inherited Create(aModel);
  fServerWindow := FindWindow(pointer(ServerWindowName),nil);
  if fServerWindow=0 then
    raise ECommunicationException.CreateFmt('No "%s" window available - server may be down',
      [ServerWindowName]);
  fClientWindow := ClientWindow;
  fTimeOutMS := TimeOutMS;
end;

constructor TSQLRestClientURIMessage.Create(aModel: TSQLModel;
  const ServerWindowName, ClientWindowName: string; TimeOutMS: cardinal);
var H: HWND;
begin
  H := CreateInternalWindow(ClientWindowName,self);
  if H=0 then
    raise ECommunicationException.CreateFmt('Impossible to create "%s" client window',
      [ClientWindowName]);
  fClientWindowName := ClientWindowName;
  Create(aModel,ServerWindowName,H,TimeOutMS);
end;

destructor TSQLRestClientURIMessage.Destroy;
begin
  ReleaseInternalWindow(fClientWindowName,fClientWindow);
  inherited;
end;

function TSQLRestClientURIMessage.InternalURI(const url, method: RawUTF8; Resp,
  Head, SendData: PRawUTF8): Int64Rec;
var Msg, aHead: RawUTF8;
    Data: TCopyDataStruct;
    Ticks, Start, Finished: cardinal;
    P: PUTF8Char;
    aMsg: TMsg;
{$ifdef WITHLOG}
    Log: ISynLog;
{$endif}
begin
{$ifdef WITHLOG}
  Log := SQLite3Log.Enter(self);
{$endif}
  if (fServerWindow=0) or (fClientWindow=0) then begin
    Int64(result) := HTML_NOTIMPLEMENTED; // 501 
    {$ifdef WITHLOG}
    Log.Log(sllClient,'501',self);
    {$endif}
    exit;
  end;
  // 1. send request
  // #1 is a field delimiter below, since Get*Item() functions return nil for #0
  SetString(Msg,PAnsiChar(@MAGIC_SYN),4);
  Msg := Msg+url+#1+method+#1;
  if Head<>nil then
    Msg := Msg+Head^+#1 else
    Msg := Msg+#1;
  if SendData<>nil then
    Msg := Msg+SendData^;
  Data.dwData := fClientWindow;
  Data.cbData := length(Msg);
  Data.lpData := pointer(Msg);
  fCurrentResponse := #0; // mark expect some response
  Int64(result) := SendMessage(fServerWindow,WM_COPYDATA,fClientWindow,PtrInt(@Data));
  if not (result.Lo in [HTML_SUCCESS,HTML_CREATED]) then begin
    fCurrentResponse := '';
{$ifdef WITHLOG}
    Log.Log(sllError,'% % result.Lo=%',[method,url,result.Lo],self);
{$endif}
    exit;
  end;
  // 2. expect answer from server
  if fCurrentResponse=#0 then begin
    // in practice, we never reach here since SendMessage() did wait for the
    // message to be processed by the receiver, so the Server should have
    // already answered and fCurrentResponse field should have been set
    Start := GetTickCount; // (Ticks<Start) will avoid cardinal overflow
    Finished := Start+fTimeOutMS;
    repeat
      // incoming WM_COPYDATA will set fCurrentResponse in WMCopyData() method
      while PeekMessage(aMsg,0,0,0,PM_REMOVE) do begin
        TranslateMessage(aMsg);
        DispatchMessage(aMsg);
      end;
      Sleep(0);
      Ticks := GetTickCount;
      if (Ticks>Finished) or (Ticks<Start) then begin
        result.Lo := HTML_TIMEOUT; // 408 Request Timeout Error
        exit;
      end;
    until fCurrentResponse<>#0;
  end;
  // 3. return answer to caller
  if length(fCurrentResponse)<=sizeof(result) then
    result.Lo := HTML_NOTIMPLEMENTED else begin
    P := pointer(fCurrentResponse);
    if PCardinal(P)^<>MAGIC_SYN then // broadcasted WM_COPYDATA message? :(
      Int64(result) := 0 else
      Int64(result) := PInt64(P+4)^;
    if result.Lo=0 then
      result.Lo := HTML_NOTFOUND else begin
      inc(P,4+sizeof(result));
      aHead := GetNextItem(P,#1);
      if Head<>nil then
        Head^ := aHead;
      if Resp<>nil then
        if P=nil then
          Resp^ := '' else
          SetString(Resp^,P,length(fCurrentResponse)-(P-pointer(fCurrentResponse)));
    end;
  end;
{$ifdef WITHLOG}
  Log.Log(sllClient,'% % result.Lo=% .Hi=%',[method,url,result.Lo,result.Hi],self);
{$endif}
end;

procedure TSQLRestClientURIMessage.WMCopyData(var Msg: TWMCopyData);
begin
  if (self=nil) or (Msg.From<>fServerWindow) or
     (Msg.CopyDataStruct^.dwData<>fServerWindow) then
    exit;
  Msg.Result := HTML_SUCCESS; // Send something back
  if fCurrentResponse=#0 then // expect some response?
    SetString(fCurrentResponse,PAnsiChar(Msg.CopyDataStruct^.lpData),
      Msg.CopyDataStruct^.cbData);
end;

{$endif}


{ ************ Unit-Testing class and functions }

{ TTestLowLevelTypes }

type
 TSQLRecordTest = class(TSQLRecord)
 private
    fTest: RawUTF8;
    fValfloat: double;
    fValWord: word;
    fNext: TSQLRecordTest;
    fInt: int64;
    fValDate: TDateTime;
    fData: TSQLRawBlob;
    fAnsi: WinAnsiString;
    fUnicode: RAWUNICODE;
    procedure SetInt(const Value: int64);
//    fEnum: TOrdType;
//    fBool: boolean;
 public
 published
   // add properties here
   property Int: int64 read fInt write SetInt default 12;
   property Test: RawUTF8 read fTest write fTest;
   property Unicode: RAWUNICODE read fUnicode write fUnicode;
   property Ansi: WinAnsiString read fAnsi  write fAnsi;
   property ValFloat: double read fValfloat write fValFloat;
   property ValWord: word read fValWord write fValWord;
   property ValDate: tdatetime read fValDate write fValDate;
   property Next: TSQLRecordTest read fNext write fNext;
   property Data: TSQLRawBlob read fData write fData;
//   property Bool: boolean read fBool;
 end;

procedure TSQLRecordTest.SetInt(const Value: int64);
begin
  fInt := Value;
end;

{$ifdef UNICODE}
{$WARNINGS OFF} // don't care about implicit string cast in tests
{$endif}

{$ifndef LVCL}

type
  TCollTest = class(TCollectionItem)
  private
    FLength: Integer;
    FColor: Integer;
    FName: RawUTF8;
  published
    property Color: Integer read FColor write FColor;
    property Length: Integer read FLength write FLength;
    property Name: RawUTF8 read FName write FName;
  end;

  TCollTests = class(TCollection)
  private
    function GetCollItem(Index: Integer): TCollTest;
  public
    function Add: TCollTest;
    property Item[Index: Integer]: TCollTest read GetCollItem; default;
  end;

  TCollTst = class(TPersistent)
  private
    fColl: TCollTests;
    fTCollTest: TCollTest;
    fStr: TStringList;
  public
    constructor Create;
    destructor Destroy; override;
  published
    property One: TCollTest read fTCollTest write fTCollTest;
    property Coll: TCollTests read fColl write fColl;
    property Str: TStringList read fStr write fStr;
  end;

  TFV = packed record
    Major, Minor, Release, Build: integer;
    Main, Detailed: string;
  end;
  TFVs = array of TFV;

  TCollTstDynArray = class(TCollTst)
  private
    fInts: TIntegerDynArray;
    fTimeLog: TTimeLogDynArray;
    fFileVersions: TFVs;
    class function FVReader(P: PUTF8Char; var aValue;
      out aValid: Boolean): PUTF8Char;
    class procedure FVWriter(const aWriter: TTextWriter; const aValue);
    class function FVReader2(P: PUTF8Char; var aValue;
      out aValid: Boolean): PUTF8Char;
    class procedure FVWriter2(const aWriter: TTextWriter; const aValue);
    class function FVClassReader(const aValue: TObject; aFrom: PUTF8Char;
      var aValid: Boolean): PUTF8Char;
    class procedure FVClassWriter(const aSerializer: TJSONSerializer;
      aValue: TObject; aHumanReadable, aDontStoreDefault, aFullExpand: Boolean);
  published
    property Ints: TIntegerDynArray read fInts write fInts;
    property TimeLog: TTimeLogDynArray read fTimeLog write fTimeLog;
    property FileVersion: TFVs read fFileVersions write fFileVersions;
  end;


{ TCollTstDynArray}

class function TCollTstDynArray.FVReader(P: PUTF8Char; var aValue;
  out aValid: Boolean): PUTF8Char;
var V: TFV absolute aValue;
begin // '[1,2001,3001,4001,"1","1001"],[2,2002,3002,4002,"2","1002"],...'
  aValid := false;
  result := nil;
  if (P=nil) or (P^<>'[') then
    exit;
  inc(P);
  V.Major := GetNextItemCardinal(P);
  V.Minor := GetNextItemCardinal(P);
  V.Release := GetNextItemCardinal(P);
  V.Build := GetNextItemCardinal(P);
  V.Main := UTF8ToString(GetJSONField(P,P));
  V.Detailed := UTF8ToString(GetJSONField(P,P));
  if P=nil then
    exit;
  aValid := true;
  result := P; // ',' or ']' for last item of array
end;

class procedure TCollTstDynArray.FVWriter(const aWriter: TTextWriter; const aValue);
var V: TFV absolute aValue;
begin
  aWriter.Add('[%,%,%,%,"%","%"]',
    [V.Major,V.Minor,V.Release,V.Build,V.Main,V.Detailed],twJSONEscape);
end;

class function TCollTstDynArray.FVReader2(P: PUTF8Char; var aValue;
  out aValid: Boolean): PUTF8Char;
var V: TFV absolute aValue;
    Values: TPUtf8CharDynArray;
begin // '{"Major":1,"Minor":2001,"Release":3001,"Build":4001,"Main":"1","Detailed":"1001"},..
  aValid := false;
  result := JSONDecode(P,['Major','Minor','Release','Build','Main','Detailed'],Values);
  if result=nil then
    exit; // result^ = ',' or ']' for last item of array
  V.Major := GetInteger(Values[0]);
  V.Minor := GetInteger(Values[1]);
  V.Release := GetInteger(Values[2]);
  V.Build := GetInteger(Values[3]);
  V.Main := UTF8DecodeToString(Values[4],StrLen(Values[4]));
  V.Detailed := UTF8DecodeToString(Values[5],StrLen(Values[5]));
  aValid := true;
end;

class procedure TCollTstDynArray.FVWriter2(const aWriter: TTextWriter; const aValue);
var V: TFV absolute aValue;
begin
  aWriter.AddJSONEscape(['Major',V.Major,'Minor',V.Minor,'Release',V.Release,
    'Build',V.Build,'Main',V.Main,'Detailed',V.Detailed]);
end;

class function TCollTstDynArray.FVClassReader(const aValue: TObject; aFrom: PUTF8Char;
  var aValid: Boolean): PUTF8Char;
var V: TFileVersion absolute aValue;
    Values: TPUtf8CharDynArray;
begin // '{"Major":2,"Minor":2002,"Release":3002,"Build":4002,"Main":"2","BuildDateTime":"1911-03-15"}'
  result := JSONDecode(aFrom,['Major','Minor','Release','Build','Main','BuildDateTime'],Values);
  aValid := (result<>nil);
  if aValid then begin
    V.Major := GetInteger(Values[0]);
    V.Minor := GetInteger(Values[1]);
    V.Release := GetInteger(Values[2]);
    V.Build := GetInteger(Values[3]);
    V.Main := UTF8DecodeToString(Values[4],StrLen(Values[4]));
    V.BuildDateTime := Iso8601ToDateTimePUTF8Char(Values[5]);
  end;
end;

class procedure TCollTstDynArray.FVClassWriter(const aSerializer: TJSONSerializer;
  aValue: TObject; aHumanReadable, aDontStoreDefault, aFullExpand: Boolean);
var V: TFileVersion absolute aValue;
begin
  aSerializer.AddJSONEscape(['Major',V.Major,'Minor',V.Minor,'Release',V.Release,
    'Build',V.Build,'Main',V.Main,'BuildDateTime',DateTimeToIso8601Text(V.BuildDateTime)]);
end;


{ TCollTests }

function TCollTests.Add: TCollTest;
begin
  result := inherited Add as TCollTest;
end;

function TCollTests.GetCollItem(Index: Integer): TCollTest;
begin
  result := Items[Index] as TCollTest;
end;

{ TCollTst }

constructor TCollTst.Create;
begin
  inherited;
  fColl := TCollTests.Create(TCollTest);
end;

destructor TCollTst.Destroy;
begin
  fColl.Free;
  fTCollTest.Free;
  fStr.Free;
  inherited;
end;

{$endif LVCL}

procedure TTestLowLevelTypes.EncodeDecodeJSON;
var J,K,U: RawUTF8;
    V: TPUtf8CharDynArray;
    i, a, err: integer;
    r: Double;
{$ifndef LVCL}
    Coll, C2: TCollTst;
    Valid: boolean;
    DA: TDynArray;
    F: TFV;
    TLNow: TTimeLog;
procedure TCollTstDynArrayTest;
var CA: TCollTstDynArray;
    i: integer;
    tmp: RawByteString;
begin
  CA := TCollTstDynArray.Create;
  try
    CA.One := TCollTest.Create(nil);
    CA.Str := TStringList.Create;
    tmp := J;
    Check(JSONToObject(CA,@tmp[1],Valid)=nil);
    Check(Valid);
    Check(CA.Str.Count=10000);
    for i := 1 to CA.Str.Count do
      Check(CA.Str[i-1]=IntToStr(i));
    SetLength(CA.fInts,20000);
    for i := 0 to high(CA.Ints) do
      CA.Ints[i] := i;
    U := ObjectToJSON(CA);
  finally
    CA.Free;
  end;
  CA := TCollTstDynArray.Create;
  try
    CA.One := TCollTest.Create(nil);
    CA.Str := TStringList.Create;
    Check(JSONToObject(CA,pointer(U),Valid)=nil);
    Check(Valid);
    Check(CA.Str.Count=10000);
    for i := 1 to CA.Str.Count do
      Check(CA.Str[i-1]=IntToStr(i));
    Check(length(CA.Ints)=20000);
    for i := 0 to high(CA.Ints) do
      CA.Ints[i] := i;
    SetLength(CA.fTimeLog,CA.Str.Count);
    TLNow := Iso8601Now and (not 63);
    for i := 0 to high(CA.TimeLog) do
      CA.TimeLog[i] := TLNow+i and 31; // and 31 to avoid min:sec rounding
    U := ObjectToJSON(CA);
    SetLength(CA.fInts,2);
    SetLength(CA.fTimeLog,2);
    Check(JSONToObject(CA,pointer(U),Valid)=nil);
    Check(Valid);
    Check(Length(CA.Ints)=20000);
    Check(Length(CA.TimeLog)=CA.Str.Count);
    for i := 0 to high(CA.Ints) do
      Check(CA.Ints[i]=i);
    for i := 0 to high(CA.TimeLog) do
      Check(CA.TimeLog[i]=TLNow+i and 31);
    DA.Init(TypeInfo(TFVs),CA.fFileVersions);
    for i := 1 to 1000 do begin
      F.Major := i;
      F.Minor := i+2000;
      F.Release := i+3000;
      F.Build := i+4000;
      str(i,F.Main);
      str(i+1000,F.Detailed);
      DA.Add(F);
    end;
    U := ObjectToJSON(CA);
    DA.Clear;
    Check(Length(CA.FileVersion)=0);
    Check(JSONToObject(CA,pointer(U),Valid)=nil);
    Check(Valid);
    Check(Length(CA.Ints)=20000);
    Check(Length(CA.TimeLog)=CA.Str.Count);
    Check(Length(CA.FileVersion)=1000);
    for i := 1 to 1000 do
    with CA.FileVersion[i-1] do begin
      Check(Major=i);
      Check(Minor=i+2000);
      Check(Release=i+3000);
      Check(Build=i+4000);
      Check(Main=IntToStr(i));
      Check(Detailed=IntToStr(i+1000));
    end;
  finally
    CA.Free;
  end;
end;
procedure TFileVersionTest(Full: boolean);
var V,F: TFileVersion;
    J: RawUTF8;
    i: integer;
    Valid: boolean;
begin
  V := TFileVersion.Create('',0);
  F := TFileVersion.Create('',0);
  try
    for i := 1 to 1000 do begin
      if Full then begin
        V.Major := i;
        V.Minor := i+2000;
        V.Release := i+3000;
        V.Build := i+4000;
        str(i,V.Main);
      end;
      V.BuildDateTime := 4090.0+i;
      J := ObjectToJSON(V);
      JSONToObject(F,pointer(J),Valid);
      if CheckFailed(Valid) then
        continue;
      if Full then begin
        Check(F.Major=i);
        Check(F.Minor=V.Minor);
        Check(F.Release=V.Release);
        Check(F.Build=V.Build);
        Check(F.Main=V.Main);
      end;
      CheckSame(V.BuildDateTime,F.BuildDateTime);
    end;
  finally
    F.Free;
    V.Free;
  end;
end;
{$endif}
begin
  Check(IsString('abc'));
  Check(IsString('NULL'));
  Check(IsString('null'));
  Check(IsString('false'));
  Check(IsString('FALSE'));
  Check(IsString('true'));
  Check(IsString('TRUE'));
  Check(not IsString('123'));
  Check(not IsString('0123'));
  Check(not IsString('0.123'));
  Check(not IsString('1E19'));
  Check(not IsString('1.23E1'));
  Check(not IsString('+0'));
  Check(IsString('1.23E'));
  Check(IsString('+'));
  Check(IsString('-'));
  Check(IsStringJSON('abc'));
  Check(not IsStringJSON('NULL'));
  Check(not IsStringJSON('null'));
  Check(not IsStringJSON('false'));
  Check(not IsStringJSON('FALSE'));
  Check(not IsStringJSON('true'));
  Check(not IsStringJSON('TRUE'));
  Check(not IsStringJSON('123'));
  Check(IsStringJSON('0123'));
  Check(not IsStringJSON('0.123'));
  Check(not IsStringJSON('1E19'));
  Check(not IsStringJSON('1.23E1'));
  Check(not IsStringJSON('0'));
  Check(not IsStringJSON('0.1'));
  Check(not IsStringJSON('-0'));
  Check(not IsStringJSON('-0.1'));
  Check(IsStringJSON('+0'));
  Check(IsStringJSON('1.23E'));
  Check(IsStringJSON('+'));
  Check(IsStringJSON('-'));
  J := JSONEncode(['name','john','year',1982,'pi',3.14159]);
  Check(Hash32(J)=$266CB31F);
  JSONDecode(J,['year','pi','john','name'],V);
  Check(length(V)=4);
  Check(V[0]='1982');
  Check(V[1]='3.14159');
  Check(V[2]=nil);
  Check(V[3]='john');
  for i := 1 to 100 do begin
    a := Random(maxInt);
    r := Random;
    U := RandomUTF8(i);
    J := JSONEncode(['a',a,'r',r,'u',U]);
    JSONDecode(J,['U','R','A','FOO'],V);
    Check(Length(V)=4);
    Check(RawUTF8(V[0])=U);
    Check(SameValue(GetExtended(V[1],err),r));
    Check(not IsString(V[2]));
    Check(not IsStringJSON(V[2]));
    Check(GetInteger(V[2])=a);
    Check(V[3]=nil);
    J := BinToBase64WithMagic(U);
    check(PInteger(J)^ and $00ffffff=JSON_BASE64_MAGIC);
    check(BlobToTSQLRawBlob(pointer(J))=U);
    Base64MagicToBlob(@J[4],K);
    check(BlobToTSQLRawBlob(pointer(K))=U);
    J := TSQLRestServer.JSONEncodeResult([r]);
    Check(SameValue(GetExtended(pointer(JSONDecode(J)),err),r));
  end;
  J := GetJSONObjectAsSQL('{"ID":  1 ,"Name":"Alice","Role":"User","Last Login":null,'+
    '"First Login" :   null  ,  "Department"  :  "Sales" } ]', false, true);
  U := ' (ID,Name,Role,Last Login,First Login,Department) VALUES '+
    '(:(1):,:(''Alice''):,:(''User''):,:(null):,:(null):,:(''Sales''):)';
  Check(J=U);
{$ifndef LVCL}
  C2 := TCollTst.Create;
  Coll := TCollTst.Create;
  try
     U := ObjectToJSON(Coll);
     Check(Hash32(U)=$3446EC42);
     Check(ObjectToJSON(C2)=U);
     Coll.One := TCollTest.Create(nil);
     U := ObjectToJSON(Coll);
     Check(Hash32(U)=$95B54414);
     Coll.One.Name := 'test"\2';
     Coll.One.Color := 1;
     U := ObjectToJSON(Coll);
     Check(Hash32(U)=$CE2C2DED);
     C2.One := TCollTest.Create(nil);
     Check(JSONToObject(C2,pointer(U),Valid)=nil);
     Check(Valid);
     U := ObjectToJSON(C2);
     Check(Hash32(U)=$CE2C2DED);
     Coll.Coll.Add.Color := 10;
     Coll.Coll.Add.Name := 'name';
     Check(Coll.Coll.Count=2);
     U := ObjectToJSON(Coll);
     Check(Hash32(U)=$36B02F0E);
     Check(JSONToObject(C2,pointer(U),Valid)=nil);
     Check(Valid);
     Check(C2.Coll.Count=2);
     U := ObjectToJSON(C2);
     Check(Hash32(U)=$36B02F0E);
     U := ObjectToJSON(Coll,true);
     Check(Hash32(U)=$2369512C);
     C2.Coll.Clear;
     U := ObjectToJSON(C2);
     Check(Hash32(U)=$CE2C2DED);
     Coll.Coll.BeginUpdate;
     for i := 1 to 10000 do
       with Coll.Coll.Add do begin
         Color := i*3;
         Length := i*5;
         Name := Int32ToUtf8(i);
       end;
     Coll.Coll.EndUpdate;
     U := ObjectToJSON(Coll.Coll);
     Check(Hash32(U)=$DB782098);
     C2.Coll.Clear;
     Check(JSONToObject(C2.fColl,pointer(U),Valid)=nil);
     Check(Valid);
     Check(C2.Coll.Count=Coll.Coll.Count);
     for i := 1 to C2.Coll.Count-2 do
       with C2.Coll[i+1] do begin
         Check(Color=i*3);
         Check(Length=i*5);
         Check(Name=Int32ToUtf8(i));
       end;
     U := ObjectToJSON(Coll);
     Check(length(U)=443103);
     Check(Hash32(U)=$7EACF12A);
     C2.One.Name := '';
     C2.Coll.Clear;
     Check(JSONToObject(C2,pointer(U),Valid)=nil);
     Check(Valid);
     Check(C2.Coll.Count=Coll.Coll.Count);
     U := ObjectToJSON(C2);
     Check(length(U)=443103);
     Check(Hash32(U)=$7EACF12A);
     for i := 1 to C2.Coll.Count-2 do
       with C2.Coll[i+1] do begin
         Check(Color=i*3);
         Check(Length=i*5);
         Check(Name=Int32ToUtf8(i));
       end;
     Coll.Coll.Clear;
     Coll.Str := TStringList.Create;
     Coll.Str.BeginUpdate;
     for i := 1 to 10000 do
       Coll.Str.Add(IntToStr(i));
     Coll.Str.EndUpdate;
     U := ObjectToJSON(Coll);
     Check(Hash32(U)=$85926050);
     U := ObjectToJSON(Coll,true);
     Check(Hash32(U)=$E5598679);
     C2.Str := TStringList.Create;
     Check(JSONToObject(C2,pointer(U),Valid)=nil);
     Check(Valid);
     Check(C2.Str.Count=Coll.Str.Count);
     for i := 1 to C2.Str.Count do
       Check(C2.Str[i-1]=IntToStr(i));
     J := ObjectToJSON(C2);
     Check(Hash32(J)=$85926050);
     U := '{"One":{"Color":1,"Length":0,"Name":"test\"\\2},"Coll":[]}';
     Check(IdemPChar(JSONToObject(C2,@U[1],Valid),'"TEST'),'invalid JSON');
     Check(not Valid);
     U := '{"One":{"Color":1,"Length":0,"Name":"test\"\\2"},"Coll":[]';
     Check(JSONToObject(C2,@U[1],Valid)<>nil);
     Check(not Valid);
     U := '{"One":{"Color":,"Length":0,"Name":"test\"\\2"},"Coll":[]';
     Check(IdemPChar(JSONToObject(C2,@U[1],Valid),',"LENGTH'),'invalid JSON');
     Check(not Valid);
  finally
    C2.Free;
    Coll.Free;
  end;
  TCollTstDynArrayTest;
  TTextWriter.RegisterCustomJSONSerializer(TypeInfo(TFVs),
    TCollTstDynArray.FVReader,TCollTstDynArray.FVWriter);
  TCollTstDynArrayTest;
  TTextWriter.RegisterCustomJSONSerializer(TypeInfo(TFVs),
    TCollTstDynArray.FVReader2,TCollTstDynArray.FVWriter2);
  TCollTstDynArrayTest;
  TFileVersionTest(false);
  TJSONSerializer.RegisterCustomSerializer(TFileVersion,
    TCollTstDynArray.FVClassReader,TCollTstDynArray.FVClassWriter);
  TFileVersionTest(true);
  TJSONSerializer.RegisterCustomSerializer(TFileVersion,nil,nil);
  TFileVersionTest(false);
{$endif LVCL}
end;

type TOrdTypeSet = set of TOrdType;

procedure TTestLowLevelTypes.RTTI;
var i: Integer;
begin
  with PTypeInfo(TypeInfo(TOrdType))^.EnumBaseType^ do
    for i := 0 to integer(high(TOrdType)) do begin
{$ifdef VERBOSE}writeln(i,' ',GetEnumName(i)^, ' ',GetEnumNameTrimed(i));{$endif}
     Check(GetEnumNameValue(GetEnumName(i)^)=i);
     Check(GetEnumNameTrimedValue(pointer(GetEnumNameTrimed(i)))=i);
     Check(GetEnumNameTrimedValue(GetEnumNameTrimed(i))=i);
  end;
  Check(PTypeInfo(TypeInfo(TOrdTypeSet))^.SetEnumType=
    PTypeInfo(TypeInfo(TOrdType))^.EnumBaseType);
  with PTypeInfo(TypeInfo(TSQLRecordTest))^ do begin
    Check(InheritsFrom(TSQLRecordTest));
    Check(InheritsFrom(TSQLRecord));
    Check(not InheritsFrom(TSQLRecordPeople));
  end;
  Check(GetDisplayNameFromClass(nil)='');
  Check(GetDisplayNameFromClass(TSQLRecord)='Record');
  Check(GetDisplayNameFromClass(TSQLRecordPeople)='People');
  Check(GetDisplayNameFromClass(TObject)='Object');
  Check(GetDisplayNameFromClass(TSQLTable)='Table');
  Check(GetDisplayNameFromClass(TSynValidateRest)='ValidateRest');
  Check(InternalMethodInfo(TSQLRecord,'ABC')=nil);
  Check(InternalMethodInfo(TSQLRestServer,'ABC')=nil);
  Check(InternalMethodInfo(TSQLRestServer,'STAT')<>nil);
  Check(InternalMethodInfo(TSQLRestServer,'stat')^.MethodAddr=
    TSQLRestServer.MethodAddress('STAT'));
  Check(InternalMethodInfo(TSQLRestServer,'timestamp')<>nil);
  Check(InternalMethodInfo(TSQLRestServer,'timestamp')^.MethodAddr=
    TSQLRestServer.MethodAddress('TIMEstamp'));
end;

procedure TTestLowLevelTypes.UrlEncoding;
var i: integer;
    s,t,d: RawUTF8;
begin
  for i := 1 to 100 do begin
    s := RandomUTF8(i);
    t := UrlEncode(s);
    Check(UrlDecode(t)=s);
    d := 'seleCT='+t+'&where='+
      {$ifndef ENHANCEDRTL}Int32ToUtf8{$else}IntToStr{$endif}(i);
    Check(UrlEncode(['seleCT',s,'where',i])='?'+d);
  end;
end;


{ TTestBasicClasses }

procedure TTestBasicClasses._TSQLModel;
var M: TSQLModel;
begin
  M := TSQLModel.Create([TSQLRecordTest]);
  try
    Check(M['Test']<>nil);
    Check(M['Test2']=nil);
    Check(M['TEST']=TSQLRecordTest);
  finally
    M.Free;
  end;
end;

procedure TTestBasicClasses._TSQLRecord;
var i: integer;
    P: PPropInfo;
    s: RawUTF8;
    T,T2: TSQLRecordTest;
{$ifndef LVCL}
    valid: boolean;
{$endif}
begin
  T := TSQLRecordTest.Create;
  with InternalClassProp(TSQLRecordTest)^ do begin
    P := @PropList;
    for i := 0 to PropCount-1 do begin
      Check(TSQLRecordTest.RecordProps.FieldIndex(P^.Name)=i);
      Check(T.RecordProps.FieldIndex(P^.Name)=i);
{$ifdef VERBOSE}writeln(i,' ',P^.Name,' is of kind ',integer(P^.PropType^^.Kind),
  ' i.e. ',P^.PropType^^.Name,' ordtype=',integer(P^.PropType^^.OrdType)); {$endif}
      P := P^.Next;
    end;
  end;
  s := TSQLRecordTest.GetSQLCreate(nil);
  {$ifdef VERBOSE}writeln(s);{$endif}
  Check(Hash32(s)=$43FAB8CB);
  s := TSQLRecordTest.RecordProps.SQLAddField(0);
  Check(Hash32(s)=$3BAF1B7);
  s := TSQLRecordTest.RecordProps.SQLAddField(1000);
  Check(s='');
  T2 := TSQLRecordTest.Create;
  try
    Check(T.RecordProps.SQLTableName='Test');
    Check(T.SQLTableName='Test');
    Check(GetCaptionFromClass(T.RecordClass)='Record test');
    s := T.GetSQLSet;
    Check(Hash32(s)=$52D24C65);
    {$ifdef VERBOSE}writeln(s);{$endif}
    s := T.GetSQLValues;
    {$ifdef VERBOSE}writeln(s);{$endif}
    Check(Hash32(s)=$9AA3470C);
{$ifndef LVCL}
    s := ObjectToJSON(T);
    Check(Hash32(s)=$6A739928);
{$endif}
    T.ValDate := 39882.888612; // a fixed date and time
    T.Ansi := 'abcde'+chr(233)+'ef'+chr(224)+chr(233);
    T.Test := WinAnsiToUTF8('abcde'+chr(233)+'ef'+chr(224)+chr(233));
    T.Unicode := Utf8DecodeToRawUnicode(T.fTest);
    Check(RawUnicodeToWinAnsi(T.fUnicode)=T.fAnsi);
    // the same string is stored with some Delphi types, but will remain
    // identical in UTF-8 SQL, as all will be converted into UTF-8
    T.Valfloat := 3.141592653;
    T.ValWord := 1203;
    s := T.GetSQLSet;
    {$ifdef VERBOSE}writeln(s);{$endif}
    Check(Hash32(s)=$C18C26D);
    s := T.GetSQLValues;
    {$ifdef VERBOSE}writeln(s);{$endif}
    Check(Hash32(s)=$6DE61E87);
    s := T.GetJSONValues(false,true,soSelect);
    {$ifdef VERBOSE}writeln(s);{$endif}
    Check(T.SameValues(T));
    Check(not T.SameValues(T2));
    T2.FillFrom(s);
    Check(T.SameValues(T2));
    Check(T2.GetJSONValues(false,true,soSelect)=s);
    T.ID := 10;
    s := T.GetJSONValues(true,true,soSelect);
    {$ifdef VERBOSE}writeln(s);{$endif}
    T2.ClearProperties;
    Check(not T.SameValues(T2));
    T2.FillFrom(s);
    Check(T.SameValues(T2));
    Check(T2.GetJSONValues(true,true,soSelect)=s);
{$ifndef LVCL}
    s := ObjectToJSON(T);
    Check(Hash32(s)=$DDAF2211);
    T2.ClearProperties;
    Check(not T.SameValues(T2));
    Check(JSONToObject(T2,pointer(s),valid)=nil);
    Check(valid);
    Check(T.SameValues(T2));
{$endif}
    T.Int := 1234567890123456;
    s := T.GetJSONValues(true,true,soSelect);
    Check(Hash32(s)=$A332BEF1);
    T2.ClearProperties;
    Check(not T.SameValues(T2));
    T2.FillFrom(s);
    Check(T.SameValues(T2));
    Check(T2.GetJSONValues(true,true,soSelect)=s);
    Check(T2.Int=1234567890123456);
  finally
    T2.Free;
    T.Free;
  end;
end;

procedure TTestBasicClasses._TSQLRecordSigned;
var R: TSQLRecordSigned;
    i: integer;
    Content: RawByteString;
begin
  R := TSQLRecordSigned.Create;
  try
    for i := 1 to 50 do begin
      Content := RandomString(5*Random(1000));
      Check(R.SetAndSignContent('User',Content));
      Check(R.SignedBy='User');
      Check(R.CheckSignature(Content));
      Content := Content+'?'; // invalidate content
      Check(not R.CheckSignature(Content));
      R.UnSign;
    end;
  finally
    R.Free;
  end;
end;

{$ifdef UNICODE}
{$WARNINGS ON} // don't care about implicit string cast in tests
{$endif}


{ TSQLRecordSigned }

function TSQLRecordSigned.CheckSignature(const Content: RawByteString): boolean;
var tmp: RawUTF8;
    i: integer;
    SHA: TSHA256;
    Digest: TSHA256Digest;
begin
  result := false;
  i := PosEx(RawUTF8('/'),fSignature,1);
  if i=0 then exit;
  tmp := Iso8601(fSignatureTime).Text(false)+RawUTF8(ClassName)+copy(fSignature,1,i-1);
  SHA.Init;
  SHA.Update(pointer(tmp),length(tmp));
  SHA.Update(pointer(Content),length(Content)); // hash in place: no Content copy
  SHA.Final(Digest);
  if SHA256DigestToString(Digest)=copy(fSignature,i+1,sizeof(Digest)*2) then
    result := true;
end;

function TSQLRecordSigned.SetAndSignContent(const UserName: RawUTF8;
  const Content: RawByteString; ForcedSignatureTime: Int64): boolean;
var tmp: RawUTF8;
    SHA: TSHA256;
    Digest: TSHA256Digest;
begin
  result := (fSignature='') and (fSignatureTime=0);
  if not result then
    exit; // sign is allowed only once
  if ForcedSignatureTime<>0 then
    fSignatureTime := ForcedSignatureTime else
    fSignatureTime := Iso8601Now;
  { content is hashed with User Name value }
  tmp := Iso8601(fSignatureTime).Text(false)+RawUTF8(ClassName)+UserName;
  SHA.Init;
  SHA.Update(pointer(tmp),length(tmp));
  SHA.Update(pointer(Content),length(Content)); // hash in place: no Content copy
  SHA.Final(Digest);
  fSignature := UserName+'/'+SHA256DigestToString(Digest);
end;

function TSQLRecordSigned.SignedBy: RawUTF8;
var i: integer;
begin
  i := PosEx(RawUTF8('/'),fSignature,1);
  if i=0 then
    result := '' else
    result := copy(fSignature,1,i-1);
end;

procedure TSQLRecordSigned.UnSign;
begin
  fSignature := '';
  fSignatureTime := 0;
end;


{ TSQLRecordFTS3 }

class function TSQLRecordFTS3.OptimizeFTS3Index(Server: TSQLRestServer): boolean;
begin
  if (self=nil) or (Server=nil) then
    Result:= false else
    with RecordProps do
      Result := Server.EngineExecuteAll(FormatUTF8(
        'INSERT INTO %(%) VALUES(''optimize'');',[SQLTableName,SQLTableName]));
end;


{ TSQLRecordRTree }

class procedure TSQLRecordRTree.BlobToCoord(const InBlob;
  var OutCoord: TSQLRecordTreeCoords);
begin // direct memory copy with no memory check
  move(InBlob,OutCoord,(length(RecordProps.Fields)shr 1)*sizeof(double));
end;

class function TSQLRecordRTree.ContainedIn(const BlobA,BlobB): boolean;
var A,B: TSQLRecordTreeCoords;
    i: integer;
begin
  BlobToCoord(BlobA,A);
  BlobToCoord(BlobB,B);
  result := false;
  for i := 0 to (length(RecordProps.Fields)shr 1)-1 do
    if (A[i].max<B[i].min) or (A[i].min>B[i].max) then
      exit; // no match
  result := true; // box match
end;

class function TSQLRecordRTree.RTreeSQLFunctionName: RawUTF8;
begin
  with RecordProps do
    if Kind=rRTree then
      result := SQLTableName+'_in' else
      result := '';
end;


{ TSQLRecordMany }

constructor TSQLRecordMany.Create;
begin
  inherited Create;
  with RecordProps do
    if (fRecordManySourceProp<>nil) and (fRecordManyDestProp<>nil) then begin
      fSourceID := fRecordManySourceProp^.GetFieldAddr(Self);
      fDestID := fRecordManyDestProp^.GetFieldAddr(Self);
    end;
end;

function TSQLRecordMany.ManyAdd(aClient: TSQLRest; aSourceID, aDestID: Integer;
  NoDuplicates: boolean): boolean;
begin
  result := false;
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) or
     (fSourceID=nil) or (fDestID=nil) then
    exit; // invalid parameters
  if NoDuplicates and
     (InternalIDFromSourceDest(aClient,aSourceID,aDestID)<>0) then
      exit; // this TRecordReference pair already exists
  fSourceID^ := aSourceID;
  fDestID^ := aDestID;
  if aClient.Add(self,true)<>0 then
    result := true;
end;

function TSQLRecordMany.ManyAdd(aClient: TSQLRest; aDestID: Integer;
  NoDuplicates: boolean): boolean;
begin
  if (self=nil) or (fSourceID=nil) then
    result := false else // avoid GPF
    result := ManyAdd(aClient,fSourceID^,aDestID,NoDuplicates);
end;

function TSQLRecordMany.DestGet(aClient: TSQLRest; aSourceID: integer;
  out DestIDs: TIntegerDynArray): Boolean;
var Where: RawUTF8;
begin
  Where := IDWhereSQL(aClient,aSourceID,False);
  if Where='' then
    result := False else
    result := aClient.OneFieldValues(RecordClass,'Dest',Where,DestIDs);
end;

function TSQLRecordMany.DestGetJoined(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer;
  out DestIDs: TIntegerDynArray): boolean;
var aTable: TSQLTable;
begin
  aTable := DestGetJoinedTable(aClient,aDestWhereSQL,aSourceID,jkDestID);
  if aTable=nil then
    Result := False else
    try
      aTable.GetRowValues(0,DestIDs);
      Result := true;
    finally
      aTable.Free;
    end;
end;

function TSQLRecordMany.DestGetJoined(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer): TSQLRecord;
var aTable: TSQLTable;
begin
  aTable := DestGetJoinedTable(aClient,aDestWhereSQL,aSourceID,jkDestFields);
  if aTable=nil then
    Result := nil else begin
    Result := RecordProps.fRecordManyDestClass.Create;
    aTable.OwnerMustFree := true;
    Result.FillPrepare(aTable,ctnTrimExisting); 
  end;
end;

function TSQLRecordMany.DestGetJoinedTable(aClient: TSQLRest;
  const aDestWhereSQL: RawUTF8; aSourceID: Integer; JoinKind: TSQLRecordManyJoinKind;
  const aCustomFieldsCSV: RawUTF8): TSQLTable;
var Select, SQL: RawUTF8;
    SelfProps, DestProps: TSQLRecordProperties;
procedure SelectFields(const Classes: array of TSQLRecordProperties);
var i: integer;
begin
  for i := 0 to high(Classes) do begin
    Select := Select+Classes[i].SQLTableSimpleFields[True,True];
    if i<high(Classes) then
      Select := Select+',';
  end;
end;
begin
  result := nil;
  if (Self=nil) or (fSourceID=nil) or (fDestID=nil) or (aClient=nil) then
    exit;
  if aSourceID=0 then
    if fSourceID<>nil then
      aSourceID := fSourceID^;
  if aSourceID=0 then
    exit;
  SelfProps := self.RecordProps;
  DestProps := SelfProps.fRecordManyDestClass.RecordProps;
  case JoinKind of
    jkDestID:
      Select := DestProps.SQLTableName+'.RowID';
    jkPivotID:
      Select := SelfProps.SQLTableName+'.RowID';
    jkDestFields:
      if aCustomFieldsCSV='' then
        SelectFields([DestProps]) else
        Select := AddPrefixToCSV(pointer(aCustomFieldsCSV),DestProps.SQLTableName+'.');
    jkPivotFields:
      if aCustomFieldsCSV='' then
        SelectFields([SelfProps]) else
        Select := AddPrefixToCSV(pointer(aCustomFieldsCSV),SelfProps.SQLTableName+'.');
    jkPivotAndDestFields:
      if aCustomFieldsCSV='' then
        SelectFields([SelfProps,DestProps]) else
        Select := aCustomFieldsCSV;
  end;
  if aDestWhereSQL='' then
    // fast inlined prepared statement
    SQL := 'SELECT % FROM %,% WHERE %.Source=:(%): AND %.Dest=%.RowID' else
    if PosEx(RawUTF8(':('),aDestWhereSQL,1)>0 then
      // statement is globaly inlined -> cache prepared statement
      SQL := 'SELECT % FROM %,% WHERE %.Source=:(%): AND %.Dest=%.RowID AND %' else
      // statement is not globaly inlined -> no caching of prepared statement
      SQL := 'SELECT % FROM %,% WHERE %.Source=% AND %.Dest=%.RowID AND %';
  result := aClient.ExecuteList([PPointer(Self)^,SelfProps.fRecordManyDestClass],
    FormatUTF8(pointer(SQL),
      [Select, DestProps.SQLTableName,SelfProps.SQLTableName,
       SelfProps.SQLTableName,aSourceID, SelfProps.SQLTableName,
       DestProps.SQLTableName, aDestWhereSQL]));
end;

function TSQLRecordMany.DestGet(aClient: TSQLRest;
  out DestIDs: TIntegerDynArray): boolean;
begin
  if fSourceID=nil then
    result := false else // avoid GPF
    result := DestGet(aClient,fSourceID^,DestIDs);
   // fSourceID has been set by TSQLRecord.Create
end;

function TSQLRecordMany.ManyDelete(aClient: TSQLRest; aSourceID, aDestID: Integer;
  aUseBatchMode: boolean=false): boolean;
var aID: integer;
begin
  result := false;
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) then
    exit;
  aID := InternalIDFromSourceDest(aClient,aSourceID,aDestID);
  if aID<>0 then
    if aUseBatchMode and aClient.InheritsFrom(TSQLRestClientURI) then
      result := TSQLRestClientURI(aClient).BatchDelete(RecordClass,aID)>=0 else
      result := aClient.Delete(RecordClass,aID);
end;

function TSQLRecordMany.ManyDelete(aClient: TSQLRest; aDestID: Integer;
  aUseBatchMode: boolean=false): boolean;
begin
  if fSourceID=nil then
    result := false else // avoid GPF
    result := ManyDelete(aClient,fSourceID^,aDestID,aUseBatchMode);
end;

function TSQLRecordMany.ManySelect(aClient: TSQLRest; aSourceID, aDestID: Integer): boolean;
begin
  if (self=nil) or (aClient=nil) or (aSourceID=0) or (aDestID=0) then
    result := false else // invalid parameters
    result := aClient.Retrieve(FormatUTF8('Source=:(%): AND Dest=:(%):',
      [aSourceID,aDestID]),Self);
end;

function TSQLRecordMany.ManySelect(aClient: TSQLRest; aDestID: Integer): boolean;
begin
  if (self=nil) or (fSourceID=nil) then
    result := false else // avoid GPF
    result := ManySelect(aClient,fSourceID^,aDestID);
end;

function TSQLRecordMany.InternalFillMany(aClient: TSQLRest;
  aID: integer; const aAndWhereSQL: RawUTF8; isDest: boolean): integer;
var aTable: TSQLTable;
    Where: RawUTF8;
begin
  result := 0;
  if self=nil then
    exit;
  if not isDest and (aID=0)then
    if fSourceID<>nil then
      aID := fSourceID^; // has been set by TSQLRecord.Create
  Where := IDWhereSQL(aClient,aID,isDest,aAndWhereSQL);
  if Where='' then
    exit;
  aTable := aClient.InternalListRecordsJSON(RecordClass,Where);
  if aTable=nil then
    exit;
  aTable.OwnerMustFree := true;
  FillPrepare(aTable); // temporary storage for FillRow, FillOne and FillRewind
  result := aTable.RowCount;
end;

function TSQLRecordMany.FillMany(aClient: TSQLRest; aSourceID: integer;
  const aAndWhereSQL: RawUTF8): integer;
begin
  result := InternalFillMany(aclient,aSourceID,aAndWhereSQL,false);
end;

function TSQLRecordMany.FillManyFromDest(aClient: TSQLRest; aDestID: integer;
  const aAndWhereSQL: RawUTF8): integer;
begin
  result := InternalFillMany(aclient,aDestID,aAndWhereSQL,true);
end;

function TSQLRecordMany.IDWhereSQL(aClient: TSQLRest; aID: integer; isDest: boolean;
  const aAndWhereSQL: RawUTF8=''): RawUTF8;
const FieldName: array[boolean] of RawUTF8 = ('Source=','Dest=');
begin
  if (self=nil) or (aID=0) or (fSourceID=nil) or (fDestID=nil) or
     (aClient=nil) then
    Result := '' else begin
    if aAndWhereSQL<>'' then
      if PosEx(RawUTF8(':('),aAndWhereSQL,1)>0 then
        Result := '%:(%): AND %' else // inlined parameters
        Result := '%% AND %' else // no inlined parameters -> not cached
      Result := '%:(%):'; // no additional where clause -> inline ID
    Result := FormatUTF8(pointer(result),[FieldName[isDest],aID,aAndWhereSQL]);
  end;
end;

function TSQLRecordMany.SourceGet(aClient: TSQLRest; aDestID: integer;
  out SourceIDs: TIntegerDynArray): boolean;
var Where: RawUTF8;
begin
  Where := IDWhereSQL(aClient,aDestID,True);
  if Where='' then
    Result := false else
    Result := aClient.OneFieldValues(RecordClass,'Source',Where,SourceIDs);
end;

function TSQLRecordMany.InternalIDFromSourceDest(aClient: TSQLRest; aSourceID, aDestID: integer): integer;
begin
  result := GetInteger(Pointer(aClient.OneFieldValue(RecordClass,'RowID',
    FormatUTF8('Source=:(%): AND Dest=:(%):',[aSourceID,aDestID]))));
end;



{ TSQLRecordPeople }

function TSQLRecordPeople.DataAsHex(aClient: TSQLRestClientURI): RawUTF8;
begin
  Result := aClient.CallBackGetResult('DataAsHex',[],RecordClass,fID);
end;

class function TSQLRecordPeople.Sum(aClient: TSQLRestClientURI; a, b: double): double;
var err: integer;
begin
  Result := GetExtended(pointer(aClient.CallBackGetResult('sum',['a',a,'b',b])),err);
end;


{ TSQLRecordProperties }

constructor TSQLRecordProperties.Create(aTable: TSQLRecordClass);
var nMany, nSimple, nDynArray, nBlob, f, nProps: integer;

  procedure AddParentsFirst(aClassType: TClass);
  var CP: PClassProp;
      P: PPropInfo;
      Unique: boolean;
      pi, j: integer;
      FieldName: RawUTF8;
  label Simple;
  begin
    if aClassType=nil then
      exit; // no RTTI information (e.g. reached TObject level)
    AddParentsFirst(aClassType.ClassParent);
    CP := InternalClassProp(aClassType);
    if CP=nil then
      exit;
    P := @CP^.PropList;
    for pi := 0 to CP^.PropCount-1 do begin
      // 0. check that this property is not an ID/RowID (handled separately)
      if IsRowID(P^.Name) then
        raise EModelException.CreateFmt('%s should not include a %s published property',
          [aTable.ClassName,P^.Name]);
      // 1. store RTTI for this property
      FieldType[f] := P^.PropType^^.SQLFieldType;
      Fields[f] := P;
      FieldName := RawUTF8(P^.Name);
      for j := 0 to f-1 do
        if IdemPropNameU(FieldsName[j],FieldName) then
          raise EModelException.CreateFmt('dup property name %s in %s',
            [FieldName,aTable.ClassName]);
      FieldsName[f] := FieldName;
      fFieldsNameSorted[f] := FieldName;
      fFieldsNameIndex[f] := f; 
      // 2. handle unique fields, i.e. if marked as "stored false"
      Unique := not P^.IsStored;
      if Unique then begin
        include(IsUniqueFieldsBits,f);
        // must trim() text value before storage, and validate for unicity
        if FieldType[f] in [sftUTF8Text,sftAnsiText] then
          AddFilterOrValidate(f,TSynFilterTrim.Create);
        AddFilterOrValidate(f,TSynValidateUniqueField.Create);
      end;
      // 3. get corresponding properties content
      case FieldType[f] of
        sftUnknown: ;
        sftUTF8Text: begin
          if Unique then
            if MainField[false]<0 then
              MainField[false] := f;
          if MainField[true]<0 then
            MainField[true] := f;
          goto Simple;
        end;
        sftBlob: begin
          BlobFields[nBlob] := P;
          inc(nBlob);
        end;
        sftMany: begin
          ManyFields[nMany] := P;
          inc(nMany);
        end;
        sftBlobDynArray: begin
          if P^.Index<>0 then
            for j := 0 to nDynArray-1 do
            if DynArrayFields[j]^.Index=P^.Index then
              raise EModelException.CreateFmt('dup index %d for %s.%s and %s properties',
                [P^.Index,aTable.ClassName,P^.Name,DynArrayFields[j]^.Name]);
          DynArrayFields[nDynArray] := P;
          inc(nDynArray);
          goto Simple;
        end;
        else begin
          // this code follows NOT_SIMPLE_FIELDS const 
  Simple: SimpleFields[nSimple] := P;
          inc(nSimple);
          include(SimpleFieldsBits[soSelect],f);
        end;
      end;
      // 4. go to next field
      P := P^.Next;
      inc(f);
    end;
  end;

var i: integer;
    isTSQLRecordMany: boolean;
    P: PPropInfo;
    T: TSQLFieldType;
begin
  assert(aTable<>nil); // should not be called directly, but via PropsCreate()
  Table := aTable;
  SQLTableName := GetDisplayNameFromClass(aTable);
  ExternalTableName := SQLTableName;
  SQLTableNameUpperWithDot := UpperCase(SQLTableName)+'.';
  ClassProp := InternalClassProp(aTable);
  assert(ClassProp<>nil);
  nProps := PClassProp(aTable)^.FieldCountWithParents;
  if nProps>=MAX_SQLFIELDS then // sometimes, the ID field is included in bits
    raise EModelException.CreateFmt('%s has too many fields: %d>=%d',
      [SQLTableName,nProps,MAX_SQLFIELDS]);
  SetLength(FieldType,nProps);
  SetLength(Fields,nProps);
  SetLength(FieldsName,nProps);
  SetLength(fFieldsNameSorted,nProps);
  SetLength(fFieldsNameIndex,nProps);
  SetLength(ManyFields,nProps);
  SetLength(SimpleFields,nProps);
  SetLength(DynArrayFields,nProps);
  SetLength(BlobFields,nProps);
  MainField[false] := -1;
  MainField[true] := -1;
  f := 0;
  nMany := 0;
  nSimple := 0;
  nDynArray := 0;
  nBlob := 0;
  AddParentsFirst(aTable);
  assert(f=nProps);
  HasNotSimpleFields := nSimple<>nProps;
  SetLength(ManyFields,nMany);
  SetLength(SimpleFields,nSimple);
  SetLength(DynArrayFields,nDynArray);
  SetLength(BlobFields,nBlob);
  if nProps<>0 then begin
    for i := 0 to nProps-1 do begin
      Fields[i]^.AppendName(SQLUpdateSet[true],'=?,');
      Fields[i]^.AppendName(SQLInsertSet,',');
      include(HasTypeFields,FieldType[i]);
      case FieldType[i] of
      sftCreateTime:
        exclude(SimpleFieldsBits[soUpdate],i);
      end;
    end;
    SetLength(SQLInsertSet,length(SQLInsertSet)-1);
    SetLength(SQLUpdateSet[true],length(SQLUpdateSet[true])-1); // 'COL1=?,COL2=?'
    if nSimple<>0 then begin
      isTSQLRecordMany := aTable.InheritsFrom(TSQLRecordMany);
      for i := 0 to nSimple-1 do begin
        P := SimpleFields[i];
        T := P^.PropType^^.SQLFieldType;
        if T<>sftCreateTime then begin
          P^.AppendName(SQLUpdateSet[false],'=?,');
          if isTSQLRecordMany and (T=sftID) then
            if IdemPropName(P^.Name,'SOURCE') then begin
              fRecordManySourceProp := P;
              fRecordManySourceClass := TSQLRecordClass(P^.PropType^^.ClassType^.ClassType);
            end else
            if IdemPropName(P^.Name,'DEST') then begin
              fRecordManyDestProp := P;
              fRecordManyDestClass := TSQLRecordClass(P^.PropType^^.ClassType^.ClassType);
            end;
        end;
      end;
      if SQLUpdateSet[false]<>'' then
        SetLength(SQLUpdateSet[false],length(SQLUpdateSet[false])-1); // 'COL1=?,COL2=?'
      if isTSQLRecordMany then
        if fRecordManySourceProp=nil then
          raise EORMException.CreateFmt('%s=class(TSQLRecordMany) expects a SOURCE field',[ClassName]) else
        if fRecordManyDestProp=nil then
          raise EORMException.CreateFmt('%s=class(TSQLRecordMany) expects a DEST field',[ClassName]);
    end;
  end;
  SimpleFieldsBits[soInsert] := SimpleFieldsBits[soSelect];
  SimpleFieldsBits[soUpdate] := SimpleFieldsBits[soSelect];
  SimpleFieldsBits[soDelete] := SimpleFieldsBits[soSelect];
  if aTable.InheritsFrom(TSQLRecordFTS4) then
    Kind := rFTS4 else
  if aTable.InheritsFrom(TSQLRecordFTS3) then
    Kind := rFTS3 else
  if aTable.InheritsFrom(TSQLRecordVirtualTableForcedID) then
    Kind := rCustomForcedID else
  if aTable.InheritsFrom(TSQLRecordVirtual) then
    Kind := rCustomAutoID else
    Kind := rSQLite3;
  QuickSortRawUTF8(fFieldsNameSorted,nProps,@fFieldsNameIndex,StrIComp);
end;

function TSQLRecordProperties.FieldIndex(const PropName: shortstring): integer;
begin
  if self<>nil then
  for result := 0 to high(Fields) do
    if IdemPropName(Fields[result]^.Name,PropName) then
      exit;
  result := -1;
end;

function TSQLRecordProperties.FieldIndexFromRawUTF8(const PropName: RawUTF8): integer;
begin
  if self<>nil then
    for result := 0 to high(Fields) do
    if IdemPropNameU(FieldsName[result],PropName) then
      exit;
  result := -1;
end;

function TSQLRecordProperties.FieldProp(const PropName: shortstring): PPropInfo;
var i: integer;
begin
  if self<>nil then
  for i := 0 to high(Fields) do
    if IdemPropName(Fields[i]^.Name,PropName) then begin
      result := Fields[i];
      exit;
    end;
  result := nil;
end;

function TSQLRecordProperties.FieldPropFromRawUTF8(const PropName: RawUTF8): PPropInfo;
var i: integer;
begin
  if self<>nil then
  for i := 0 to high(Fields) do
    if IdemPropNameU(FieldsName[i],PropName) then begin
      result := Fields[i];
      exit;
    end;
  result := nil;
end;

function TSQLRecordProperties.BlobFieldPropFromRawUTF8(const PropName: RawUTF8): PPropInfo;
var i,L: integer;
begin
  L := length(PropName);
  if (self<>nil) and (L>0) then
  for i := 0 to high(BlobFields) do
    if IdemPropName(BlobFields[i].Name,pointer(PropName),L) then begin
      result := BlobFields[i];
      exit;
    end;
  result := nil;
end;

function TSQLRecordProperties.SQLAddField(FieldIndex: integer): RawUTF8;
begin
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(length(Fields))) then begin
    result := '';
    exit;
  end;
  result := SQLFieldTypeToSQL[FieldType[FieldIndex]];
  if result='' then
    exit; // some fields won't have any column created in the database
  result := FormatUTF8('ALTER TABLE % ADD COLUMN %%',
    [SQLTableName,FieldsName[FieldIndex],result]);
  if FieldIndex in IsUniqueFieldsBits then
    insert(' UNIQUE',result,length(result)-1);
  result[length(result)-1] := ';' // SQLFieldTypeToSQL[] ends with ','
end;

procedure TSQLRecordProperties.SetKind(Value: TSQLRecordVirtualKind);
function IntSQLTableSimpleFields(withID, withTableName: boolean): RawUTF8;
const IDComma: array[TSQLRecordVirtualKind] of rawUTF8 =
  ('ID,','RowID,','RowID,','ID,','RowID,','RowID,');
// rSQLite3, rFTS3, rFTS4, rRTree, rCustomForcedID, rCustomAutoID
var TableName: RawUTF8;
    i: integer;
begin
  if withTableName then
    TableName := SQLTableName+'.'; // calc TableName once
  if withID then
    if withTableName then
      result := TableName+IDComma[Kind] else
      result := IDComma[Kind] else
    result := '';
  for i := 0 to high(SimpleFields) do begin
    if withTableName then
      result := result+TableName;
    SimpleFields[i]^.AppendName(result,','); // valid simple field
  end;
  if (result='') or (withID and (result='ID,')) or
    ((Kind=rSQlite3) and not HasNotSimpleFields) then // use RowID for Virtual Tables
    if withTableName then
      result := TableName+'*' else
      result := '*' else
    SetLength(result,length(result)-1); // trim last ','
end;
begin
  fKind := Value;
  SQLTableSimpleFields[false,false] := IntSQLTableSimpleFields(false,false);
  SQLTableSimpleFields[false,true] := IntSQLTableSimpleFields(false,true);
  SQLTableSimpleFields[true,false] := IntSQLTableSimpleFields(true,false);
  SQLTableSimpleFields[true,true] := IntSQLTableSimpleFields(true,true);
  SQLSelectAll[false] := SQLFromSelectWhere('*','');
  SQLSelectAll[true] := SQLSelectAll[false];
  if IdemPChar(PUTF8Char(pointer(SQLSelectAll[true]))+7,'ROWID') then
    delete(SQLSelectAll[true],8,3); // 'SELECT RowID,..' -> 'SELECT ID,'
end;

procedure TSQLRecordProperties.SetJSONWriterColumnNames(W: TJSONSerializer;
  KnownRowsCount: integer);
var i,n: integer;
begin
  // get col count overhead
  if W.withID then
    n := 1 else
    n := 0;
  // set col names
  SetLength(W.ColNames,length(Fields)+n);
  if W.withID then
    W.ColNames[0] := 'RowID'; // works for both normal and FTS3 records
  for i := 0 to high(Fields) do
    if i in W.Fields then begin
      W.ColNames[n] := FieldsName[i];
      inc(n);
    end;
  // adjust col count
  if n<>length(W.ColNames) then
    SetLength(W.ColNames,n);
  W.AddColumns(KnownRowsCount); // write or init field names for appropriate JSON Expand
end;

function TSQLRecordProperties.SQLFromSelectWhere(const SQLSelect,
  SQLWhere: RawUTF8): RawUTF8;
begin
  if self=nil then
    result := '' else begin
    if SQLSelect='*' then
       // don't send BLOB values to query: retrieve all other fields
      result := 'SELECT '+SQLTableSimpleFields[true,false]  else
      result := 'SELECT '+SQLSelect;
    result := result+' FROM '+SQLTableName;
    if SQLWhere<>'' then
      if IdemPChar(pointer(SQLWhere),'ORDER BY ') or
         IdemPChar(pointer(SQLWhere),'GROUP BY ') or
         IdemPChar(pointer(SQLWhere),'LIMIT ') then
        result := result+' '+SQLWhere else
        result := result+' WHERE '+SQLWhere;
    result := result+';';
  end;
end;

function TSQLRecordProperties.CreateJSONWriter(JSON: TStream; Expand,
  withID: boolean; const aFields: TSQLFieldBits; KnownRowsCount: integer): TJSONSerializer;
begin
  if (self=nil) or ((Int64(Fields)=0) and not withID) then  // no data
    result := nil else begin
    result := TJSONSerializer.Create(JSON,Expand,withID,aFields);
    SetJSONWriterColumnNames(result,KnownRowsCount);
  end;
end;

procedure TSQLRecordProperties.SetSimpleFieldsExpandedJSONWriter(
  W: TJSONWriter; withID: boolean; Occasion: TSQLOccasion);
var i, id, n: integer;
begin
  if (self=nil) or (W=nil) then
    exit;
  if withID then
    id := 1 else
    id := 0;
  n := length(SimpleFields)+id;
  if W.Expand and (W.WithID=withID) and (length(W.ColNames)=n) then
    exit; // already set -> do not compute it again
  SetLength(W.ColNames,n);
  if withID then
    W.ColNames[0] := '"RowID":'; // works for both normal and FTS3 records
  W.Expand := true;
  W.WithID := withID;
  W.Fields := SimpleFieldsBits[Occasion];
  for i := 0 to high(Fields) do
    if i in W.Fields then begin
      W.ColNames[id] := '"'+FieldsName[i]+'":'; // as in TJSONWriter.AddColumns
      W.FieldMax := i;
      inc(id);
    end;
  assert(id=length(W.ColNames));
end;

function TSQLRecordProperties.IsFieldName(const PropName: RawUTF8): boolean;
begin
  result := (PropName<>'') and
    (isRowID(pointer(PropName)) or (FieldIndexFromRawUTF8(PropName)>=0));
end;

function TSQLRecordProperties.AddFilterOrValidate(aFieldIndex: integer;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  if (self=nil) or (cardinal(aFieldIndex)>=cardinal(length(Fields))) or
    (aFilter=nil) then
    result := nil else begin
    if Filters=nil then
      SetLength(Filters,length(Fields));
    if Filters[aFieldIndex]=nil then
      Filters[aFieldIndex] := TObjectList.Create;
    Filters[aFieldIndex].Add(aFilter);
    result := aFilter;
  end;
end;

function TSQLRecordProperties.AddFilterOrValidate(const aFieldName: RawUTF8;
  aFilter: TSynFilterOrValidate): TSynFilterOrValidate;
begin
  result := AddFilterOrValidate(FieldIndexFromRawUTF8(aFieldName),aFilter);
end;

destructor TSQLRecordProperties.Destroy;
var f: integer;
begin
  for f := 0 to high(Filters) do
    Filters[f].Free; // will free any created TSynFilter instances
  inherited;
end;

function TSQLRecordProperties.FieldIndexsFromRawUTF8(const aFields: array of RawUTF8;
  var Bits: TSQLFieldBits): boolean;
var f,ndx: integer;
begin
  fillchar(Bits,sizeof(TSQLFieldBits),0);
  result := false;
  if self=nil then
    exit;
  for f := 0 to high(aFields) do begin
    ndx := FieldIndexFromRawUTF8(aFields[f]);
    if ndx<0 then
      exit; // invalid field name
    include(Bits,ndx);
  end;
  result := true;
end;

function TSQLRecordProperties.AppendFieldName(FieldIndex: Integer;
  var Text: RawUTF8; ForceNoRowID: boolean): boolean;
begin
  if FieldIndex=VIRTUAL_TABLE_ROWID_COLUMN then begin
    if ForceNoRowID then
      Text := Text+'ID' else
      Text := Text+'RowID';
    result := false;
  end else
  if (self=nil) or (cardinal(FieldIndex)>=cardinal(length(FieldsName))) then
    result := true else begin 
    Text := Text+FieldsName[FieldIndex];
    result := false;
  end;
end;


{ TSynValidateUniqueField }

function TSynValidateUniqueField.Process(aFieldIndex: integer; const Value: RawUTF8;
  var ErrorMsg: string): boolean;
var aID: integer;
begin
  result := false;
  if Value='' then
    ErrorMsg := sValidationFieldVoid else
  if (fProcessRest=nil) or (fProcessRec=nil) then
    result := true else
  with fProcessRec.RecordProps do
    if cardinal(aFieldIndex)>=cardinal(length(Fields)) then
      result := true else begin
      aID := GetInteger(pointer(fProcessRest.OneFieldValue(Table,'RowID',
        FieldsName[aFieldIndex]+'=:('+QuotedStr(Value,'''')+'):')));
      if (aID>0) and (aID<>fProcessRec.fID) then
        ErrorMsg := sValidationFieldDuplicate else
        result := true;
    end;
end;


{ TJSONSerializer }

destructor TJSONSerializer.Destroy;
begin
  fInternalJSONWriter.Free;
  inherited;
end;

procedure TJSONSerializer.WriteObject(Value: TObject; HumanReadable: boolean=false;
  DontStoreDefault: boolean=true; FullExpand: boolean=false);
var Added: boolean;
procedure HR(P: PPropInfo=nil);
var i: integer;
begin
  if HumanReadable then begin
    AddCR;
    for i := 1 to fHumanReadableLevel do
      Add(#9);
  end;
  if P=nil then
    exit;
  AddPropName(P^.Name);
  if HumanReadable then
    Add(' ');
  Added := true;
end;
var P: PPropInfo;
    i, j, V, c: integer;
    Obj: TObject;
    List: TList absolute Value;
{$ifndef LVCL}
    Coll: TCollection absolute Value;
{$endif}
    Str: TStrings absolute Value;
    Utf: TRawUTF8List absolute Value;
    aClassType: TClass;
    CP: PClassProp;
    Kind: TTypeKind;
    PS: PShortString;
    UtfP: PPUtf8CharArray;
    IsObj: TJSONObject;
    IsObjCustomIndex: integer;
begin
  if not HumanReadable or (fHumanReadableLevel<0) then
    fHumanReadableLevel := 0;
  if (self=nil) or (Value=nil) then
    aClassType := nil else
    aClassType := PPointer(Value)^;
  if aClassType=nil then begin
    AddShort('null'); // return void object
    exit;
  end;
  if FullExpand then begin
    Add('{');
    AddInstanceName(Value,':');
  end;
  IsObj := JSONObject(aClassType,IsObjCustomIndex,[cpWrite]);
  case IsObj of
  // handle custom class serialization
  oCustom: with JSONCustomParsers[IsObjCustomIndex] do begin
    if Assigned(Writer) then
      Writer(self,Value,HumanReadable,DontStoreDefault,FullExpand);
    exit;
  end;
  // handle JSON arrays
  oList, oCollection, oUtfs, oStrings: begin
    HR;
    Add('['); // write as JSON array of JSON objects
    inc(fHumanReadableLevel);
    case IsObj of
    oList:
      for c := 0 to List.Count-1 do begin
        WriteObject(List.List[c],HumanReadable,DontStoreDefault,FullExpand);
        Add(',');
      end;
{$ifndef LVCL}
    oCollection:
      for c := 0 to Coll.Count-1 do begin
        WriteObject(Coll.Items[c],HumanReadable,DontStoreDefault,FullExpand);
        Add(',');
      end;
{$endif}
    oUtfs: begin
      UtfP := Utf.ListPtr;
      for c := 0 to Utf.Count-1 do begin
        HR;
        Add('"');
        AddJSONEscape(UtfP^[c]);
        Add('"',',');
      end;
    end;
    oStrings:
      for c := 0 to Str.Count-1 do begin
        HR;
        Add('"');
        AddJSONEscapeString(Str[c]);
        Add('"',',');
      end;
    end;
    CancelLastComma;
    dec(fHumanReadableLevel);
    HR;
    Add(']');
    if FullExpand then 
      Add('}');
    exit;
  end;
  end;
  // handle JSON object
  if fHumanReadableLevel>0 then
    HR;
  Add('{');
  inc(fHumanReadableLevel);
  if IsObj in [oSQLRecord,oSQLMany] then begin
    // manual handling of TSQLRecord.ID property serialization
    HR;
    AddPropName('ID');
    if HumanReadable then
      Add(' ');
    Add(TSQLRecord(Value).fID);
    Add(',');
  end;
  repeat
    CP := InternalClassProp(aClassType);
    if CP=nil then
      break; // no more RTTI information available
    P := @CP^.PropList;
    for i := 1 to CP^.PropCount do begin
      if ((IsObj=oSQLRecord) and not IsRowID(P^.Name)) or P^.IsStored then begin
        Added := false;
        Kind := P^.PropType^^.Kind;
        case Kind of
          tkInt64{$ifdef FPC}, tkQWord{$endif}: begin
            HR(P);
            Add(GetInt64Prop(Value,pointer(P)));
          end;
          {$ifdef FPC} tkBool, {$endif}
          tkEnumeration, tkInteger, tkSet: begin
            V := GetOrdProp(Value,pointer(P)); // pointer() to call typinfo
            if (V<>P^.Default) or not DontStoreDefault then begin
              HR(P);
              if {$ifdef FPC}(Kind=tkBool){$else}
                 (Kind=tkEnumeration) and (P^.PropType^=TypeInfo(boolean)){$endif} then
                AddString(JSON_BOOLEAN[boolean(V)]) else
                if FullExpand or HumanReadable then
                case Kind of
                tkEnumeration: begin
                   Add('"');
                   AddShort(P^.PropType^^.EnumBaseType^.GetEnumNameOrd(V)^);
                   Add('"');
                end;
                tkSet: begin
                  Add('[');
                  with P^.PropType^^.SetEnumType^ do begin
                    PS := @NameList;
                    for j := MinValue to MaxValue do begin
                      if GetBit(V,j) then begin
                        Add('"');
                        AddShort(PS^);
                        Add('"',',');
                      end;
                      inc(PtrUInt(PS),ord(PS^[0])+1); // next item
                    end;
                  end;
                  CancelLastComma;
                  Add(']');
                end;
                else
                  Add(V);
                end else
                  Add(V); // typecast enums and sets as plain integer by default
            end;
          end;
          {$ifdef FPC}tkAString,{$endif} tkLString: begin
            HR(P);
            Add('"');
            AddJSONEscape(pointer(P^.GetLongStrValue(Value)));
            Add('"');
          end;
          tkFloat: begin
            HR(P);
            if P^.PropType^=TypeInfo(Currency) then
              AddCurr64(GetInt64Prop(Value,pointer(P))) else
            if P^.PropType^=TypeInfo(TDateTime) then begin
              Add('"');
              AddDateTime(GetFloatProp(Value,pointer(P)));
              Add('"');
            end else
              Add(GetFloatProp(Value,pointer(P)));
          end;
          {$ifdef UNICODE}
          tkUString: begin // write converted to UTF-8
            HR(P);
            Add('"');
            AddJSONEscapeW(pointer(GetUnicodeStrProp(Value,pointer(P))));
            Add('"');
          end;
          {$endif}
          tkDynArray: begin
            HR(P);
            AddDynArrayJSON(P^.GetDynArray(Value));
          end;
{$ifdef PUBLISHRECORD}
          tkRecord: begin
            HR(P);
            WrRecord(P^.GetFieldAddr(Value)^,P^.PropType^);
          end;
{$endif PUBLISHRECORD}
          tkClass: begin
            Obj := pointer(GetOrdProp(Value,pointer(P)));  // works also for CPU64
            if IsObj=oSQLRecord then begin
              HR(P);
              Add(PtrInt(Obj));
            end else
            if Obj<>nil then begin
              HR(P);
              WriteObject(Obj,HumanReadable,DontStoreDefault,FullExpand);
            end;
          end;
          // tkString (shortstring) and tkWString are not handled
        end;
        if Added then
          Add(',');
      end;
      P := P^.Next;
    end;
    aClassType := aClassType.ClassParent;
  until aClassType=nil;
  CancelLastComma;
  dec(fHumanReadableLevel);
  HR;
  Add('}');
  if FullExpand then
    Add('}');
end;

procedure TJSONSerializer.WriteObjectAsString(Value: TObject;
  HumanReadable, DontStoreDefault, FullExpand: boolean);
begin
  Add('"');
  if fInternalJSONWriter=nil then
    fInternalJSONWriter := TJSONSerializer.CreateOwnedStream else
    fInternalJSONWriter.CancelAll;
  fInternalJSONWriter.WriteObject(Value,HumanReadable,DontStoreDefault,FullExpand);
  AddJSONEscape(Pointer(fInternalJSONWriter.Text),0);
  Add('"');
end;


{ TSQLVirtualTableModule }

constructor TSQLVirtualTableModule.Create(aTableClass: TSQLVirtualTableClass;
  aServer: TSQLRestServer);
begin
  fTableClass := aTableClass;
  fServer := aServer;
  fTableClass.GetTableModuleProperties(fFeatures);
  fModuleName := fTableClass.ModuleName;
  if fFeatures.FileExtension='' then // default extension is the module name 
    fFeatures.FileExtension := UTF8ToString(LowerCase(fModuleName));
end;

function TSQLVirtualTableModule.FileName(const aTableName: RawUTF8): TFileName;
begin
  result := UTF8ToString(aTableName)+'.'+FileExtension;;
  if fFilePath='' then
    result := ExtractFilePath(paramstr(0))+result else
    result := IncludeTrailingPathDelimiter(fFilePath)+result;
end;


{ TSQLVirtualTable }

constructor TSQLVirtualTable.Create(aModule: TSQLVirtualTableModule;
  const aTableName: RawUTF8; FieldCount: integer; Fields: PPUTF8CharArray);
var aTable: TSQLRecordClass;
    aTableIndex: integer;
begin
  if (aModule=nil) or (aTableName='') then
    raise EModelException.CreateFmt('Invalid parameters to %s.Create',[ClassName]);
  fModule := aModule;
  fTableName := aTableName;
  if fModule.fFeatures.StaticClass<>nil then
    // create no fStatic instance e.g. for TSQLVirtualTableLog
    if fModule.Server=nil then
      raise EModelException.CreateFmt('Missing aModule.Server for %s.Create',[ClassName]) else
    with fModule.Server do begin
      aTableIndex := Model.GetTableIndex(aTableName);
      if aTableIndex>=0 then begin
        aTable := Model.Tables[aTableIndex];
        fStatic := fModule.fFeatures.StaticClass.Create(aTable,fModule.Server,
          fModule.FileName(aTableName),self.InheritsFrom(TSQLVirtualTableBinary));
        if length(fStaticVirtualTable)<>length(Model.Tables) then
          SetLength(fStaticVirtualTable,length(Model.Tables));
        fStaticVirtualTable[aTableIndex] := fStatic;
      end;
    end;
end;

destructor TSQLVirtualTable.Destroy;
var aTableIndex: cardinal;
begin
  if fStatic<>nil then begin
    if (Module<>nil) and (Module.Server<>nil) then
      with Module.Server do begin
        aTableIndex := Model.GetTableIndex(TableName);
        if aTableIndex<cardinal(length(fStaticVirtualTable)) then
          fStaticVirtualTable[aTableIndex] := nil;
      end;
    fStatic.Free;
  end;
  inherited;
end;

function TSQLVirtualTable.Prepare(var Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := Self<>nil;
  if result then
    if (vtWhereIDPrepared in fModule.Features) and
       Prepared.IsWhereIDEquals(true) then
    with Prepared.Where[0] do begin // check ID=?
      Value.VType := varAny; // mark TSQLVirtualTableCursorJSON expects it
      OmitCheck := true;
      Prepared.EstimatedCost := 1;
    end else
      Prepared.EstimatedCost := 1E10; // generic high cost  
end;

function TSQLVirtualTable.Drop: boolean;
begin
  result := false;  // no DROP TABLE to be implemented here
end;

function TSQLVirtualTable.Delete(aRowID: Int64): boolean;
begin
  result := false;  // no DELETE to be implemented here
end;

function TSQLVirtualTable.Insert(aRowID: Int64;
  var Values: TVarDataDynArray; out insertedRowID: Int64): boolean;
begin
  result := false;  // no INSERT to be implemented here
end;

function TSQLVirtualTable.Update(oldRowID, newRowID: Int64;
  var Values: TVarDataDynArray): boolean;
begin
  result := false;  // no UPDATE to be implemented here
end;

function TSQLVirtualTable.Transaction(aState: TSQLVirtualTableTransaction;
  aSavePoint: integer): boolean;
begin
  result := (Module<>nil) and (vtWrite in Module.Features) and
    (aState in [vttBegin, vttSync, vttCommit, vttSavePoint, vttRelease]);
end;

function TSQLVirtualTable.Rename(const NewName: RawUTF8): boolean;
begin
  result := false;
end;

class function TSQLVirtualTable.ModuleName: RawUTF8;
begin
  if self=nil then
    result := '' else begin
    result := RawUTF8(ClassName);
    if IdemPChar(pointer(result),'TSQLVIRTUALTABLE') then
      system.delete(result,1,16) else
    if IdemPChar(pointer(result),'TSQLVIRTUAL') then
      system.delete(result,1,11) else
    if IdemPChar(pointer(result),'TSQL') then
      system.delete(result,1,4) else
      system.delete(result,1,1);
  end;
end;

class function TSQLVirtualTable.StructureFromClass(aClass: TSQLRecordClass;
  const aTableName: RawUTF8): RawUTF8;
begin
  result := FormatUTF8('CREATE TABLE % (%',[aTableName,
    GetVirtualTableSQLCreate(aClass.RecordProps)]);
end;

function TSQLVirtualTable.Structure: RawUTF8;
begin
  result := '';
  if Self<>nil then
    if Static<>nil then
      // e.g. for TSQLVirtualTableJSON or TSQLVirtualTableExternal
      Result := StructureFromClass(Static.StoredClass,TableName) else
    if (Module<>nil) and (Module.RecordClass<>nil) then
      // e.g. for TSQLVirtualTableLog
      Result := StructureFromClass(Module.RecordClass,TableName);
end;


{ TSQLVirtualTableCursor }

constructor TSQLVirtualTableCursor.Create(aTable: TSQLVirtualTable);
begin
  fTable := aTable;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TVarData;
  aValue: Int64);
begin
  aResult.VType := varInt64;
  aResult.VInt64 := aValue;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TVarData;
  const aValue: double);
begin
  aResult.VType := varDouble;
  aResult.VDouble := aValue;
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TVarData;
  const aValue: RawUTF8);
begin
  aResult.VType := varString;
  fColumnTemp := aValue; // temporary copy available until next Column() call
  aResult.VString := pointer(fColumnTemp);
end;

procedure TSQLVirtualTableCursor.SetColumn(var aResult: TVarData;
  aValue: PUTF8Char; aValueLength: integer);
begin
  aResult.VType := varString;
  SetString(fColumnTemp,PAnsiChar(aValue),aValueLength); // temporary copy 
  aResult.VString := pointer(fColumnTemp);
end;

procedure TSQLVirtualTableCursor.SetColumnBlob(var aResult: TVarData;
  aValue: pointer; aValueLength: integer);
begin
  aResult.VType := varAny;
  SetString(fColumnTemp,PAnsiChar(aValue),aValueLength); // temporary copy
  aResult.VPointer := pointer(fColumnTemp);
  aResult.VLongs[0] := aValueLength;
end;


{ TSQLLog }

procedure TSQLLog.AddTyped(aTypeInfo: pointer; var aValue);
var i: integer;
    PS: PShortString;
begin
  case PTypeInfo(aTypeInfo)^.Kind of
  tkSet: begin
    fWriter.Add('(');
    with PTypeInfo(aTypeInfo)^.SetEnumType^ do begin
      PS := @NameList;
      for i := MinValue to MaxValue do begin
        if GetBit(aValue,i) then begin
          fWriter.AddShort(PS^);
          fWriter.Add(',');
        end;
        inc(PtrUInt(PS),ord(PS^[0])+1);
      end;
    end;
    fWriter.CancelLastComma;
    fWriter.Add(')');
  end;
  else
    inherited; // handle tkEnumeration + tkDynArray
  end;
end;

procedure TSQLLog.CreateLogWriter;
begin
  fWriter := TJSONSerializer.Create(nil,fFamily.BufferSize);
  inherited;
  fWriter.Stream := fWriterStream;
end;



{ TSQLVirtualTableCursorIndex }

function TSQLVirtualTableCursorIndex.HasData: boolean;
begin
  result := (self<>nil) and (fCurrent<=fMax);
end;

function TSQLVirtualTableCursorIndex.Next: boolean;
begin
  if self=nil then
    result := false else begin
    if fCurrent<=fMax then
      inc(fCurrent);
    result := true;
  end;
end;

function TSQLVirtualTableCursorIndex.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
begin
  fCurrent := 0; // mark EOF by default
  fMax := -1;
  result := self<>nil;
end;


{ TSQLVirtualTablePrepared }

function TSQLVirtualTablePrepared.IsWhereIDEquals(CalledFromPrepare: Boolean): boolean;
begin
  result := (WhereCount=1) and (Where[0].Column=VIRTUAL_TABLE_ROWID_COLUMN) and
     (CalledFromPrepare or (Where[0].Value.VType=varInt64)) and
     (Where[0].Operator=soEqualTo);
end;

function TSQLVirtualTablePrepared.IsWhereOneFieldEquals: boolean;
begin
  result := (WhereCount=1) and (Where[0].Column>=0) and
     (Where[0].Operator=soEqualTo);
end;


{ TSQLVirtualTableJSON }


function TSQLVirtualTableJSON.Delete(aRowID: Int64): boolean;
begin
  result := (self<>nil) and (Static<>nil) and
            Static.Delete(Static.StoredClass,aRowID);
  if result and (Static.Owner<>nil) then
    Static.Owner.fCache.NotifyDeletion(Static.StoredClass,aRowID);
end;

function TSQLVirtualTableJSON.Drop: boolean;
begin
  if (self<>nil) and (Static<>nil) then
  with Static as TSQLRestServerStaticInMemory do begin
    RollBack(0); // close any pending transaction
    fValue.Clear;
    Modified := true; // force update file after clear
    UpdateFile;
    result := true;
  end else
    result := false;
end;

class procedure TSQLVirtualTableJSON.GetTableModuleProperties(
  var aProperties: TVirtualTableModuleProperties);
begin
  aProperties.Features := [vtWrite,vtWhereIDPrepared];
  aProperties.CursorClass := TSQLVirtualTableCursorJSON;
  aProperties.StaticClass := TSQLRestServerStaticInMemoryExternal; // will flush Cache
  if InheritsFrom(TSQLVirtualTableBinary) then
    aProperties.FileExtension := 'data';
  // default will follow the class name, e.g. '.json' for TSQLVirtualTableJSON
end;

function TSQLVirtualTableJSON.Insert(aRowID: Int64;
  var Values: TVarDataDynArray; out insertedRowID: Int64): boolean;
var aRecord: TSQLRecord;
begin // aRowID is just ignored here since IDs are always auto calculated
  result := false;
  if (self=nil) or (Static=nil) then
    exit;
  aRecord := Static.StoredClass.Create;
  try
    if aRecord.SetFieldVarDatas(Values) then begin
      insertedRowID := (Static as TSQLRestServerStaticInMemory).AddOne(aRecord);
      if insertedRowID>0 then begin
        if Static.Owner<>nil then
          Static.Owner.fCache.Notify(aRecord,soInsert);
        result := true;
      end;
    end;
  finally
    if not result then
      aRecord.Free; // on success, aRecord will stay in Values[]
  end;
end;

function TSQLVirtualTableJSON.Prepare(var Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := inherited Prepare(Prepared); // optimize ID=? WHERE clause
  if result and (Static<>nil) then
  with Static as TSQLRestServerStaticInMemory do begin
    if Prepared.IsWhereOneFieldEquals then
    with Prepared.Where[0] do
    if UniqueFieldHash(Column)<>nil then begin
      Value.VType := varAny; // mark TSQLVirtualTableCursorJSON expects it
      OmitCheck := true;
      Prepared.EstimatedCost := 1; 
    end;
    if Prepared.EstimatedCost>1E9 then
      Prepared.EstimatedCost := Count;
    if fIDSorted and (Prepared.OrderByCount=1) then // check ascending IDs
      with Prepared.OrderBy[0] do
        if (Column=VIRTUAL_TABLE_ROWID_COLUMN) and not Desc then
          Prepared.OmitOrderBy := true;
  end;
end;

function TSQLVirtualTableJSON.Update(oldRowID, newRowID: Int64;
  var Values: TVarDataDynArray): boolean;
var i: integer;
begin
  result := false;
  if (self=nil) or (Static=nil) or
     (oldRowID<>newRowID) or (newRowID<=0) then // don't allow ID change
    exit;
  with Static as TSQLRestServerStaticInMemory do
    if UpdateOne(newRowID,Values) then begin
      if Static.Owner<>nil then begin
        i := IDToIndex(newRowID);
        if i>=0 then
          Static.Owner.fCache.Notify(TSQLRecord(fValue.List[i]),soUpdate);
      end;
      result := true;
    end;
end;


{ TSQLVirtualTableCursorJSON }

function TSQLVirtualTableCursorJSON.Column(aColumn: integer;
  var aResult: TVarData): boolean;
begin
  if (self=nil) or (fCurrent>fMax) or
     (not Table.InheritsFrom(TSQLVirtualTableJSON)) or
     (TSQLVirtualTableJSON(Table).Static=nil) then
    result := false else
    with TSQLRestServerStaticInMemory(TSQLVirtualTableJSON(Table).Static).fValue do
    if Cardinal(fCurrent)>=Cardinal(Count) then
      result := False else begin
      // returns row ID for aColumn=VIRTUAL_TABLE_ROWID_COLUMN(-1)
      TSQLRecord(List[fCurrent]).GetFieldVarData(aColumn,aResult,fColumnTemp);
      result := true;
    end;
end;

function TSQLVirtualTableCursorJSON.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
var Hash: TListFieldHash;
begin
  result := inherited Search(Prepared); // mark EOF by default
  if (not result) or (not Table.InheritsFrom(TSQLVirtualTableJSON)) or
     (TSQLVirtualTableJSON(Table).Static=nil) then
    result := false else
    with TSQLRestServerStaticInMemory(TSQLVirtualTableJSON(Table).Static) do begin
      if Count>0 then // if something to search in
        if Prepared.IsWhereIDEquals(false) then begin // ID=?
          fMax := IDToIndex(Prepared.Where[0].Value.VInt64); // binary search
          if fMax>=0 then
            fCurrent := fMax; // ID found
        end else
        if Prepared.IsWhereOneFieldEquals then
        with Prepared.Where[0] do begin
          Hash := UniqueFieldHash(Column); // optimized hash-based search
          if Hash<>nil then begin
            fSearchRec.SetFieldVarData(Column,Value);
            fMax := Hash.Find(fSearchRec);
            if fMax>=0 then
              fCurrent := fMax; // value found with O(1) search
          end else
           fMax := Count-1; // loop all records in ID order
        end else
          fMax := Count-1; // loop all records in ID order
      result := true; // no DB error
    end;
end;


{ TSQLVirtualTableLog }

type
  {/ Record associated to Virtual Table implemented in Delphi, for Read/Only
    access to a .log file, as created by TSynLog
   - not used as real instances, but only used by the TSQLVirtualTableLog module
     to provide the field layout needed to create the column layout for the
     CREATE TABLE statement }
  TSQLRecordLogFile = class(TSQLRecordVirtualTableAutoID)
  protected
    fContent: RawUTF8;
    fDateTime: TDateTime;
    fLevel: TSynLogInfo;
  published
    /// the log event time stamp
    property DateTime: TDateTime read fDateTime;
    /// the log event level
    property Level: TSynLogInfo read fLevel;
    /// the textual message associated to the log event
    property Content: RawUTF8 read fContent;
  end;


constructor TSQLVirtualTableLog.Create(aModule: TSQLVirtualTableModule;
  const aTableName: RawUTF8; FieldCount: integer; Fields: PPUTF8CharArray);
var aFileName: TFileName;
begin
  inherited Create(aModule,aTableName,Fieldcount,Fields); 
  if (FieldCount=1) then
    aFileName := UTF8ToString(Fields[0]) else
    aFileName := aModule.FileName(aTableName);
  fLogFile := TSynLogFile.Create(aFileName);
end;

destructor TSQLVirtualTableLog.Destroy;
begin
  fLogFile.Free;
  inherited;
end;

class procedure TSQLVirtualTableLog.GetTableModuleProperties(
  var aProperties: TVirtualTableModuleProperties);
begin
  aProperties.Features := [vtWhereIDPrepared];
  aProperties.CursorClass := TSQLVirtualTableCursorLog;
  aProperties.RecordClass := TSQLRecordLogFile;
end;


{ TSQLVirtualTableCursorLog }

function TSQLVirtualTableCursorLog.Column(aColumn: integer;
  var aResult: TVarData): boolean;
var LogFile: TSynLogFile;
begin
  result := false;
  if (self=nil) or (fCurrent>fMax) then
    exit;
  LogFile := TSQLVirtualTableLog(Table).fLogFile;
  if LogFile=nil then
    exit;
  case aColumn of
   -1: SetColumn(aResult,fCurrent+1); // ID = row index + 1
    0: SetColumn(aResult,LogFile.EventDateTime(fCurrent));
    1: SetColumn(aResult,ord(LogFile.EventLevel[fCurrent]));
    2: SetColumn(aResult,LogFile.LinePointers[fCurrent],LogFile.LineSize(fCurrent));
    else exit;
  end;
  result := true;
end;

function TSQLVirtualTableCursorLog.Search(
  const Prepared: TSQLVirtualTablePrepared): boolean;
begin
  result := inherited Search(Prepared); // mark EOF by default
  if result then begin
    fMax := TSQLVirtualTableLog(Table).fLogFile.Count-1; // search all range
    if Prepared.IsWhereIDEquals(false) then begin
      fCurrent := Prepared.Where[0].Value.VInt64-1; // ID=? -> index := ID-1
      if cardinal(fCurrent)<=cardinal(fMax) then
        fMax := fCurrent else // found one
        fMax := fCurrent-1;   // out of range ID
    end;
  end;
end;


{ TAuthSession }

constructor TAuthSession.Create(aServer: TSQLRestServer; aUser: TSQLAuthUser);
var GID: TSQLAuthGroup;
begin
  fUser := aUser;
  if (aServer<>nil) and (User<>nil) and (User.fID<>0) then begin
    GID := User.GroupRights; // save pseudo TSQLAuthGroup = ID
    User.GroupRights := TSQLAuthGroup.Create(aServer,User.GroupRights);
    if User.GroupRights.fID<>0 then begin
      // compute the next Session ID
      if aServer.fSessionCounter>=cardinal(maxInt) then
        aServer.fSessionCounter := 10 else
        if aServer.fSessionCounter=76 then // avoid IDCardinal=0 (77) or 1 (76)
          aServer.fSessionCounter := 78 else
          inc(aServer.fSessionCounter);
      fIDCardinal := aServer.fSessionCounter xor 77;
      fID := UInt32ToUtf8(fIDCardinal);
      // set session parameters
      fTimeOut := User.GroupRights.SessionTimeout*(1000*60); // min to ms
      fAccessRights := User.GroupRights.SQLAccessRights;
      fPrivateKey := SHA256(NowToString+fID);
      fPrivateSalt := fID+'+'+fPrivateKey;
      fPrivateSaltHash :=
        crc32(crc32(0,pointer(fPrivateSalt),length(fPrivateSalt)),
          pointer(User.PasswordHashHexa),length(User.PasswordHashHexa));
      fLastAccess := GetTickCount;
      aServer.RetrieveBlob(TSQLAuthUser,User.fID,'Data',User.fData); 
      {$ifdef WITHLOG}
      SQLite3Log.Family.SynLog.Log(sllUserAuth,
        'New % session %/% created',[User.GroupRights.Ident,User.LogonName,fIDCardinal],self);
      {$endif}
      exit; // create successfull
    end;
    // on error: set GroupRights back to a pseudo TSQLAuthGroup = ID
    User.GroupRights.Free;
    User.GroupRights := GID;
  end;
  raise ESecurityException.Create('TAuthSession.Create');
end;

destructor TAuthSession.Destroy;
begin
  if User<>nil then begin
    User.GroupRights.Free;
    fUser.Free;
  end;
  inherited;
end;

function TAuthSession.IsValidURL(const aURL: RawUTF8; aURLlength: integer): boolean;
// expected format is 'session_signature='Hexa8(SessionID)+Hexa8(TimeStamp)+
// Hexa8(crc32('SessionID+HexaSessionPrivateKey'+Sha256('salt'+PassWord)+
//  Hexa8(TimeStamp)+url))
var aTimeStamp, aSignature: cardinal;
    PTimeStamp: PAnsiChar;
begin
  PTimeStamp := @aURL[aURLLength+(20+8)]; // P^ points to Hexa8(TimeStamp)
  result := (self<>nil) and
     HexDisplayToCardinal(PTimeStamp,aTimeStamp) and
     (aTimeStamp>=fLastTimeStamp) and // check time stamp coherency
     HexDisplayToCardinal(PTimeStamp+8,aSignature) and
     (crc32(crc32(fPrivateSaltHash,PTimeStamp,8),pointer(aURL),aURLlength)=aSignature);
  if result then
    fLastTimeStamp := aTimeStamp;
end;



{ TSQLAccessRights }

procedure TSQLAccessRights.Edit(aTableIndex: integer; C, R, U, D: Boolean);
begin
  if C then
    Include(POST,aTableIndex) else
    Exclude(POST,aTableindex);
  if R then
    Include(GET,aTableIndex) else
    Exclude(GET,aTableindex);
  if U then
    Include(PUT,aTableIndex) else
    Exclude(PUT,aTableindex);
  if D then
    Include(DELETE,aTableIndex) else
    Exclude(DELETE,aTableindex);
end;

procedure TSQLAccessRights.FromString(P: PUTF8Char);
begin
  fillchar(self,sizeof(self),0);
  if P=nil then
    exit;
  AllowRemoteExecute := TSQLAllowRemoteExecute(byte(GetNextItemCardinal(P)));
  SetBitCSV(GET,MAX_SQLTABLES,P);
  SetBitCSV(POST,MAX_SQLTABLES,P);
  SetBitCSV(PUT,MAX_SQLTABLES,P);
  SetBitCSV(DELETE,MAX_SQLTABLES,P);
end;

function TSQLAccessRights.ToString: RawUTF8;
begin
  result := FormatUTF8('%,%,%,%,%',
    [Byte(AllowRemoteExecute),
     GetBitCSV(GET,MAX_SQLTABLES), GetBitCSV(POST,MAX_SQLTABLES),
     GetBitCSV(PUT,MAX_SQLTABLES), GetBitCSV(DELETE,MAX_SQLTABLES)]);
end;


{ TSQLAuthGroup }

function TSQLAuthGroup.GetSQLAccessRights: TSQLAccessRights;
begin
  if self=nil then
    fillchar(result,sizeof(result),0) else
    result.FromString(pointer(AccessRights));
end;

class procedure TSQLAuthGroup.InitializeTable(Server: TSQLRestServer;
  const FieldName: RawUTF8);
var G: TSQLAuthGroup;
    A: TSQLAccessRights;
    U: TSQLAuthUser;
    AdminID, SupervisorID, UserID: PtrInt;
begin
  inherited; // will create any needed index
  if (Server<>nil) and (FieldName='') then
    if Server.HandleAuthentication then begin
      // create default Groups and Users (we are already in a Transaction) 
      G := TSQLAuthGroup.Create;
      try
        //            POST SQL  Service Auth R  Auth W  Tables R  Tables W
        // Admin        Yes       Yes    Yes     Yes      Yes      Yes
        // Supervisor   No        Yes    Yes     No       Yes      Yes
        // User         No        Yes    No      No       Yes      Yes
        // Guest        No        No     No      No       Yes      No
        A := FULL_ACCESS_RIGHTS;
        G.Ident := 'Admin';
        G.SQLAccessRights := A;
        G.SessionTimeout := 10;
        AdminID := Server.Add(G,true);
        G.Ident := 'Supervisor';
        A.AllowRemoteExecute := SUPERVISOR_ACCESS_RIGHTS.AllowRemoteExecute;
        A.Edit(Server.fAuthUserIndex, False,True,False,False); // AuthUser  R/O
        A.Edit(Server.fAuthGroupIndex,False,True,False,False); // AuthGroup R/O
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        SupervisorID := Server.Add(G,true);
        G.Ident := 'User';
        Exclude(A.GET,Server.fAuthUserIndex); // no Auth R
        Exclude(A.GET,Server.fAuthGroupIndex);
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        UserID := Server.Add(G,true);
        G.Ident := 'Guest';
        A.AllowRemoteExecute := [];
        fillchar(A.POST,sizeof(TSQLFieldTables),0); // R/O access
        fillchar(A.PUT,sizeof(TSQLFieldTables),0);
        fillchar(A.DELETE,sizeof(TSQLFieldTables),0);
        G.SQLAccessRights := A;
        G.SessionTimeout := 60;
        Server.Add(G,true);
      finally
        G.Free;
      end;
      U := TSQLAuthUser.Create;
      try
        U.LogonName := 'Admin';
        U.PasswordPlain := 'synopse';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(AdminID);
        Server.Add(U,true);
        U.LogonName := 'Supervisor';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(SupervisorID);
        Server.Add(U,true);
        U.LogonName := 'User';
        U.DisplayName := U.LogonName;
        U.GroupRights := TSQLAuthGroup(UserID);
        Server.Add(U,true);
      finally
        U.Free;
      end;
    end;
end;

procedure TSQLAuthGroup.SetSQLAccessRights(const Value: TSQLAccessRights);
begin
  if self<>nil then
    AccessRights := Value.ToString;
end;


{ TSQLAuthUser }

procedure TSQLAuthUser.SetPasswordPlain(const Value: RawUTF8);
begin
  if self<>nil then
    PasswordHashHexa := SHA256('salt'+Value);
end;


{ TServiceContainer }

type
  PInterfaceTypeData = ^TInterfaceTypeData;
  TInterfaceTypeData = packed record
    IntfParent : PPTypeInfo; // ancestor
    IntfFlags : set of (ifHasGuid, ifDispInterface, ifDispatch);
    IntfGuid : TGUID;
    IntfUnit : ShortString;
  end;

  TMethodKind = (mkProcedure, mkFunction, mkConstructor, mkDestructor,
    mkClassProcedure, mkClassFunction, { Obsolete } mkSafeProcedure, mkSafeFunction);

  TIntfMethodEntryTail = packed record
    Kind: TMethodKind;
    CC: TCallingConvention;
    ParamCount: Byte;
  end;

function TServiceContainer.AddInterface(
  const aInterfaces: array of PTypeInfo; aInstanceCreation: TServiceInstanceImplementation;
  aContractExpected: RawUTF8): boolean;
var i: integer;
    F: TServiceFactoryClient;
begin
  result := false;
  if (self=nil) or (high(aInterfaces)<0) then
    exit;
  CheckInterface(aInterfaces);
  for i := 0 to high(aInterfaces) do begin
    F := TServiceFactoryClient.Create(
      Rest,aInterfaces[i],aInstanceCreation,aContractExpected);
    AddServiceInternal(F);
    aContractExpected := ''; // supplied contract is only for the 1st interface
  end;
  result := true;
end;

function TServiceContainer.Count: integer;
begin
  if self=nil then
    result := 0 else
    result := fList.Count;
end;

constructor TServiceContainer.Create(aRest: TSQLRest);
begin
  fRest := aRest;
  fList := TRawUTF8ListHashed.Create;
  fList.CaseInsensitive := true;
  fListInterfaceMethod := TRawUTF8ListHashed.Create;
  fListInterfaceMethod.CaseInsensitive := true;
end;

destructor TServiceContainer.Destroy;
var i: integer;
begin
  for i := 0 to fList.Count-1 do
    fList.Objects[i].Free;
  fList.Free;
  fListInterfaceMethod.Free;
  inherited;
end;

function TServiceContainer.AddServiceInternal(aService: TServiceFactory): integer;
var aURI: RawUTF8;
    internal: TServiceInternalMethod;
    m: Integer;
begin
  if (self=nil) or (aService=nil) then
    result := 0 else
  with aService do begin
    // add service factory
    if ExpectMangledURI then
      aURI := fInterfaceMangledURI else
      aURI := fInterfaceURI;
    result := fList.AddObject(aURI,aService);
    // add associated methods
    aURI := aURI+'.';
    for internal := Low(TServiceInternalMethod) to High(TServiceInternalMethod) do
      fListInterfaceMethod.AddObject(aURI+SERVICE_PSEUDO_METHOD[internal],
        pointer(ord(internal) shl 16+result));
    for m := 0 to fMethodsCount-1 do
      fListInterfaceMethod.AddObject(aURI+fMethods[m].URI,
        pointer((m+length(SERVICE_PSEUDO_METHOD)) shl 16+result));
  end;
end;

procedure TServiceContainer.CheckInterface(const aInterfaces: array of PTypeInfo);
var i: integer;
begin
  for i := 0 to high(aInterfaces) do
    with aInterfaces[i]^, PInterfaceTypeData(ClassType)^ do
    if Kind<>tkInterface then
      raise EServiceException.CreateFmt('%s is not an interface',[Name]) else
    if not (ifHasGuid in IntfFlags) then
      raise EServiceException.CreateFmt('%s interface has no GUID',[Name]) else
    if Guid(IntfGuid)<>nil then
      raise EServiceException.CreateFmt('%s GUID already registered',[Name]);
end;

procedure TServiceContainer.SetExpectMangledURI(aValue: Boolean);
var f: Integer;
    Fac: array of TServiceFactory;
begin
  if aValue=fExpectMangledURI then
    exit;
  fExpectMangledURI := aValue;
  fList.CaseInsensitive := not aValue;
  fListInterfaceMethod.CaseInsensitive := not aValue;
  SetLength(Fac,fList.Count);
  for f := 0 to fList.Count-1 do
    Fac[f] := fList.Objects[f] as TServiceFactory;
  fList.Clear;
  fListInterfaceMethod.Clear;
  for f := 0 to High(Fac) do
    AddServiceInternal(Fac[f]);
end;

function TServiceContainer.GetService(const aURI: RawUTF8): TServiceFactory;
var i: Integer;
begin
  if (self<>nil) and (aURI<>'') then begin
    i := fList.IndexOf(aURI);
    if i>=0 then
      result := TServiceFactory(fList.Objects[i]) else
      result := nil;
  end else
    result := nil;
end;

function TServiceContainer.Info(aTypeInfo: PTypeInfo): TServiceFactory;
var i: Integer;
    Obj: PPointerArray;
begin
  if self<>nil then begin
    Obj := fList.ObjectPtr;
    for i := 0 to fList.Count-1 do begin
      result := Obj[i];
      if result.fInterfaceTypeInfo=aTypeInfo then
        exit;
    end;
  end;
  result := nil;
end;

function TServiceContainer.Index(aIndex: integer): TServiceFactory;
begin
  if Self=nil then
    result := nil else
    result := TServiceFactory(fList.Objects[aIndex]);
end;

function IsEqualGUID(const guid1, guid2: TGUID): Boolean; {$ifdef HASINLINE}inline;{$endif}
{$ifdef CPU64}
var a: array[0..1] of Int64 absolute guid1;
    b: array[0..1] of Int64 absolute guid2;
{$else}
var a: array[0..3] of integer absolute guid1;
    b: array[0..3] of integer absolute guid2;
{$endif}
begin // faster implementation than in SysUtils.pas
{$ifdef CPU64}
  Result := (a[0]=b[0]) and (a[1]=b[1]);
{$else}
  Result := (a[0]=b[0]) and (a[1]=b[1]) and (a[2]=b[2]) and (a[3]=b[3]);
{$endif}
end;

function TServiceContainer.GUID(const aGUID: TGUID): TServiceFactory;
var i: Integer;
    Obj: PPointerArray;
begin
  if self<>nil then begin
    Obj := fList.ObjectPtr;
    for i := 0 to fList.Count-1 do begin
      result := Obj[i];
      if IsEqualGUID(result.InterfaceIID,aGUID) then
        exit;
    end;
  end;
  result := nil;
end;


{ TServiceFactory }

function ServiceInstanceImplementationToText(aValue: TServiceInstanceImplementation): RawUTF8;
begin
  result := GetEnumNameTrimed(TypeInfo(TServiceInstanceImplementation),aValue);
end;

function TypeInfoToMethodValueType(P: PTypeInfo): TServiceMethodValueType;
var IsObjCustomIndex: integer;
begin
  result := smvNone;
  if P<>nil then
  case P^.Kind of
  tkInteger:
    case P^.OrdType of
    otSLong: result := smvInteger;
    otULong: result := smvCardinal;
    end;
  tkInt64{$ifdef FPC}, tkQWord{$endif}:
    result := smvInt64;
  {$ifdef FPC}
  tkBool:
    result := smvBoolean;
  tkEnumeration:
    result := smvEnum;
  {$else}
  tkEnumeration:
    if P=TypeInfo(boolean) then
      result := smvBoolean else
      result := smvEnum;
  {$endif}
  tkSet:
    result := smvSet;
  tkFloat:
    if P=TypeInfo(TDateTime) then
      result := smvDateTime else
    case P^.FloatType of
      ftDouble: result := smvDouble;
      ftCurr:   result := smvCurrency;
    end;
  tkLString:
    if P=TypeInfo(RawUTF8) then
      result := smvRawUTF8
{$ifndef UNICODE}
      else result := smvString;
{$else};
  tkUString:
    result := smvString;
{$endif}
  tkWString:
    result := smvWideString;
  tkClass:
    if JSONObject(P^.ClassType^.ClassType,IsObjCustomIndex,[cpRead,cpWrite]) in
       [oCollection,oUtfs,oStrings,oSQLRecord,oPersistent,oCustom] then
      result := smvObject; // JSONToObject/ObjectToJSON types
  tkRecord:   // Base64 encoding of our RecordLoad / RecordSave binary format
    result := smvRecord;
  tkDynArray: // TDynArray.LoadFromJSON / TTextWriter.AddDynArrayJSON type
    result := smvDynArray;
  end;
end;

// see http://docwiki.embarcadero.com/RADStudio/en/Program_Control

const
  // this is used to avoid creating dynamic arrays if not needed
  MAX_METHOD_ARGS = 32;

  // QueryInterface, _AddRef and _Release methods are hard-coded
  RESERVED_VTABLE_SLOTS = 3;

  REGEAX = -1;
  REGEDX = -2;
  REGECX = -3;
  PTRSIZ = sizeof(Pointer);

  // ordinal values are stored within 64 bit buffer, and records in a RawUTF8
  CONST_ARGS_TO_VAR: array[TServiceMethodValueType] of TServiceMethodValueVar = (
    smvvNone, smvvSelf, smvv64, smvv64, smvv64, smvv64, smvv64, smvv64, smvv64, smvv64, smvv64,
    smvvRawUTF8, smvvString, smvvWideString, smvvRecord, smvvObject, smvvDynArray);

  CONST_ARGS_IN_STACK_SIZE: array[TServiceMethodValueType] of Cardinal = (
     0,  PTRSIZ,  4,       4,   4,    4,       4,        8,     8,      8,        8,
 // None, Self, Boolean, Enum, Set, Integer, Cardinal, Int64, Double, DateTime, Currency,
     PTRSIZ,  PTRSIZ, PTRSIZ,    PTRSIZ, PTRSIZ, PTRSIZ);
 // RawUTF8, String, WideString, Record, Object, DynArray

  CONST_ARGS_RESULT_BY_REF: TServiceMethodValueTypes = [
    smvRawUTF8, smvString, smvWideString, smvRecord, smvDynArray];

  CONST_PSEUDO_RESULT_NAME: string[6] = 'Result';

constructor TInterfaceFactory.Create(aInterface: PTypeInfo);
var m,a,reg,offs: integer;
begin
  fInterfaceTypeInfo := aInterface;
  fInterfaceIID := PInterfaceTypeData(aInterface^.ClassType)^.IntfGuid;
  // retrieve all interface methods (recursively including ancestors)
  fMethod.Init(TypeInfo(TServiceMethodDynArray),fMethods,nil,nil,nil,@fMethodsCount,true);
  AddMethodsFromTypeInfo(aInterface);
  if fMethodsCount=0 then
    raise EServiceException.CreateFmt('%s interface has no RTTI',[fInterfaceTypeInfo^.Name]);
  SetLength(fMethods,fMethodsCount);
  // compute asm low-level layout of the parameters for each method
  for m := 0 to fMethodsCount-1 do
  with fMethods[m] do begin
    // prepare stack and register layout
    reg := REGEAX;
    for a := 0 to high(Args) do
    with Args[a] do begin
      ValueVar := CONST_ARGS_TO_VAR[ValueType];
      IndexVar := ArgsUsedCount[ValueVar];
      inc(ArgsUsedCount[ValueVar]);
      include(ArgsUsed,ValueType);
      ValueIsString := (ValueType in [smvRawUTF8..smvWideString]);
      case ValueType of
        smvBoolean: SizeInStorage := 1;
        smvInteger, smvCardinal: SizeInStorage := 4;
        smvInt64: SizeInStorage := 8;
        smvEnum:
          case TypeInfo^.EnumBaseType^.MaxValue of
          0..255:     SizeInStorage := 1;
          256..65535: SizeInStorage := 2;
          else        SizeInStorage := 4;
          end;
        smvSet:
          case TypeInfo^.SetEnumType^.MaxValue of
          0..7:   SizeInStorage := 1;
          8..15:  SizeInStorage := 2;
          16..31: SizeInStorage := 4;
          else raise EServiceException.CreateFmt('%s set too big in %s.%s method %s parameter',
            [TypeName^,fInterfaceTypeInfo^.Name,URI,ParamName^]);
          end;
        smvRecord:
          if TypeInfo^.RecordType^.Size<=PTRSIZ then
            raise EServiceException.CreateFmt('%s record too small in %s.%s method %s parameter',
              [TypeName^,fInterfaceTypeInfo^.Name,URI,ParamName^]) else
            SizeInStorage := PTRSIZ; // handle only records when passed by ref
        else SizeInStorage := PTRSIZ;
      end;
      if (ValueDirection=smdResult) and not(ValueType in CONST_ARGS_RESULT_BY_REF) then
        continue; // ordinal/real/class results are returned in CPU/FPU registers
      if ValueDirection=smdConst then
        SizeInStack := CONST_ARGS_IN_STACK_SIZE[ValueType] else
        SizeInStack := PTRSIZ;
      if (reg<REGECX) or (SizeInStack<>4) then begin
        OffsetInStack := ArgsSizeInStack;
        inc(ArgsSizeInStack,SizeInStack);
      end else begin
        OffsetInStack := reg;
        dec(reg);
      end;
    end;
    // pascal/register convention are passed left-to-right -> reverse order
    offs := ArgsSizeInStack;
    for a := 0 to high(Args) do
    with Args[a] do
      if OffsetInStack>=0 then begin
        dec(offs,SizeInStack);
        OffsetInStack := offs;
      end;
    assert(offs=0);
  end;
end;

procedure TInterfaceFactory.AddMethodsFromTypeInfo(aInterface: PTypeInfo);
var P: Pointer absolute aInterface;
    PB: PByte absolute aInterface;
    PI: PInterfaceTypeData absolute P;
    PW: PWord absolute P;
    PS: PShortString absolute P;
    PME: ^TIntfMethodEntryTail absolute P;
    PF: ^TParamFlags absolute P;
    PP: ^PPTypeInfo absolute P;
    Ancestor: PTypeInfo;
    wasAdded: boolean;
    Kind: TMethodKind;
    f: TParamFlags;
    i,j: integer;
    n: cardinal;
    aURI: RawUTF8;
begin
  // handle interface inheritance via recursive calls
  P := aInterface^.ClassType;
  if PI^.IntfParent<>nil then
    Ancestor := PI^.IntfParent^ else
    Ancestor := nil;
  if Ancestor<>nil then
    AddMethodsFromTypeInfo(Ancestor);
  P := @PI^.IntfUnit[ord(PI^.IntfUnit[0])+1];
  // retrieve methods for this interface level
  n := PW^; inc(PW);
  if (PW^=$ffff) or (n=0) then
    exit; // no RTTI or no method at this level of interface
  inc(PW);
  for i := fMethodsCount to fMethodsCount+n-1 do begin
    // retrieve method name, and add to the methods list (with hashing)
    SetString(aURI,PAnsiChar(@PS^[1]),ord(PS^[0]));
    if (fMethod.FindHashedForAdding(aURI,wasAdded)<>i) or not wasAdded then
      raise EServiceException.CreateFmt('%s.%s method: duplicated name',
        [fInterfaceTypeInfo^.Name,aURI]);
    with fMethods[i] do begin
      URI := aURI;
      MethodIndex := i+RESERVED_VTABLE_SLOTS;
      PS := @PS^[ord(PS^[0])+1];
      Kind := PME^.Kind;
      if PME^.CC<>ccRegister then
        raise EServiceException.CreateFmt('%s.%s method shall use register calling convention',
          [fInterfaceTypeInfo^.Name,URI]);
      // retrieve method call arguments
      n := PME^.ParamCount;
      inc(PME);
      if Kind=mkFunction then
        SetLength(Args,n+1) else
        SetLength(Args,n);
      if length(Args)>MAX_METHOD_ARGS then
        raise EServiceException.CreateFmt('%s.%s method has too many parameters: %d>%d',
          [fInterfaceTypeInfo^.Name,URI,Length(Args),MAX_METHOD_ARGS]);
      for j := 0 to n-1 do
      with Args[j] do begin
        f := PF^;
        inc(PF);
        if pfVar in f then
          ValueDirection := smdVar else
        if pfOut in f then
          ValueDirection := smdOut;
        ParamName := PS;
        PS := @PS^[ord(PS^[0])+1];
        TypeName := PS;
        PS := @PS^[ord(PS^[0])+1];
        if PP^=nil then
          raise EServiceException.CreateFmt('%s.%s: %s parameter has no information',
            [fInterfaceTypeInfo^.Name,URI,ParamName^]);
        TypeInfo := PP^^;
        inc(PP);
        {$ifdef ISDELPHIXE}
        inc(PW); // skip attributes
        {$endif}
        if j=0 then
          ValueType := smvSelf else
          ValueType := TypeInfoToMethodValueType(TypeInfo);
        case ValueType of
        smvNone:
          raise EServiceException.CreateFmt('%s.%s: %s parameter has unexpected type %s',
            [fInterfaceTypeInfo^.Name,URI,ParamName^,TypeInfo^.Name]);
        smvRecord: if f*[pfConst,pfVar,pfOut]=[] then
          raise EServiceException.CreateFmt(
            '%s.%s: %s record parameter should be declared as const, var or out',
            [fInterfaceTypeInfo^.Name,URI,ParamName^]);
        end;
      end;
      // add a pseudo argument after all arguments for functions
      if Kind=mkFunction then
      with Args[n] do begin
        ArgsResultIndex := n;
        ParamName := @CONST_PSEUDO_RESULT_NAME;
        ValueDirection := smdResult;
        TypeName := PS;
        PS := @PS^[ord(PS^[0])+1];
        TypeInfo := PP^^;
        inc(PP);
        ValueType := TypeInfoToMethodValueType(TypeInfo);
      end else
        ArgsResultIndex := -1;
      // go to next method
      {$ifdef ISDELPHIXE}
      inc(PW); // skip attributes
      {$endif}
    end;
  end;
end;

function TInterfaceFactory.FindMethodIndex(const aMethodName: RawUTF8): integer;
begin
  result := fMethod.FindHashed(aMethodName);
end;

constructor TServiceFactory.Create(aRest: TSQLRest;
  aInterface: PTypeInfo; aInstanceCreation: TServiceInstanceImplementation);
var P: Pointer absolute aInterface;
    PB: PByte absolute aInterface;
    PI: PInterfaceTypeData absolute P;
    PW: PWord absolute P;
    PS: PShortString absolute P;
    PME: ^TIntfMethodEntryTail absolute P;
    PF: ^TParamFlags absolute P;
    PP: ^PPTypeInfo absolute P;
    m,a,j: integer;
begin
  // check supplied interface
  if (aRest=nil) or (aInterface=nil) then
    raise EServiceException.Create('Invalid call');
  inherited Create(aInterface);
  fRest := aRest;
  fInstanceCreation := aInstanceCreation;
  fInterfaceURI := aInterface^.Name;
  fInterfaceMangledURI := BinToBase64URI(@fInterfaceIID,sizeof(TGUID));
  if fInterfaceURI[1] in ['I','i'] then
    Delete(fInterfaceURI,1,1);
  if fRest.Model.GetTableIndex(fInterfaceURI)>=0 then
    raise EServiceException.CreateFmt('"%s" interface name is already used by a SQL table name',
      [fInterfaceURI]);
  for m := 0 to fMethodsCount-1 do
  with fMethods[m] do begin
    {$ifndef LVCL}
    for j := 0 to high(Args) do
    with Args[j] do
    case ValueType of
      smvObject: with TypeInfo^.ClassType^.ClassType do
        if InheritsFrom(TCollection) and not InheritsFrom(TInterfacedCollection) then
          raise EServiceException.CreateFmt(
            '%s.%s: TCollection parameter "%s" should inherit from TInterfacedCollection',
            [fInterfaceTypeInfo^.Name,URI,Args[j].ParamName^]) else
    end;
    {$endif}
    if ArgsResultIndex>=0 then
    with Args[ArgsResultIndex] do
    case ValueType of
    smvNone, smvObject:
      raise EServiceException.CreateFmt('%s.%s: unexpected result type %s',
        [fInterfaceTypeInfo^.Name,URI,TypeName^]);
    smvRecord:
      if TypeInfo=System.TypeInfo(TServiceCustomAnswer) then
        if InstanceCreation=sicClientDriven then
          raise EServiceException.CreateFmt(
            '%s.%s: sicClientDriven mode not allowed with TServiceCustomAnswer result',
            [fInterfaceTypeInfo^.Name,URI]) else begin
        ArgsResultIsServiceCustomAnswer := true;
        for j := 0 to High(Args) do
          if Args[j].ValueDirection in [smdVar,smdOut] then
            raise EServiceException.CreateFmt(
              '%s.%s: var/out parameter "%s" not allowed with TServiceCustomAnswer result',
              [fInterfaceTypeInfo^.Name,URI,Args[j].ParamName^]);
      end;
    end;
  end;
  // compute interface signature (aka "contract"), serialized as a JSON object
  with TJSONWriter.CreateOwnedStream do
  try
    Add('{"contract":"%","implementation":"%","methods":[',
      [InterfaceURI,LowerCase(ServiceInstanceImplementationToText(InstanceCreation))]);
    for m := 0 to fMethodsCount-1 do
    with fMethods[m] do begin
      Add('{"method":"%","arguments":[',[URI]);
      for a := 0 to High(Args) do
        AddString(Args[a].SerializeToContract);
      CancelLastComma;
      AddShort(']},');
    end;
    CancelLastComma;
    Add(']','}');
    fContract := Text;
    fContractHash := '"'+CardinalToHex(Hash32(fContract))+
      CardinalToHex(CRC32string(fContract))+'"'; // 2 hashes to avoid collision
    fContractExpected := fContractHash; // for security
  finally
    Free;
  end;
end;


{ TServiceContainerServer }

function TServiceContainerServer.AddImplementation(
  aImplementationClass: TClass; const aInterfaces: array of PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation): TServiceFactoryServer;
var C: TClass;
    T: PInterfaceTable;
    i, j: integer;
    UID: array of ^TGUID;
    F: TServiceFactoryServer;
begin
  result := nil;
  // check input parameters
  if (self=nil) or (aImplementationClass=nil) or (high(aInterfaces)<0) then
    exit;
  CheckInterface(aInterfaces);
  SetLength(UID,length(aInterfaces));
  for j := 0 to high(aInterfaces) do
    UID[j] := @PInterfaceTypeData(aInterfaces[j]^.ClassType)^.IntfGuid;
  // check that all interfaces are implemented by this class
  C := aImplementationClass;
  repeat
    T := C.GetInterfaceTable;
    if T<>nil then
      for i := 0 to T^.EntryCount-1 do
        with T^.Entries[i] do
        for j := 0 to high(aInterfaces) do
          if (UID[j]<>nil) and IsEqualGUID(UID[j]^,IID) then begin
            UID[j] := nil;
            break;
          end;
    C := C.ClassParent;
  until C=nil;
  for j := 0 to high(aInterfaces) do
    if UID[j]<>nil then
      raise EServiceException.CreateFmt('Interface %s not found in %s implementation',
        [aInterfaces[j]^.Name,aImplementationClass.ClassName]);
  // register this implementation class
  for j := 0 to high(aInterfaces) do begin
    F := TServiceFactoryServer.Create(Rest as TSQLRestServer,aInterfaces[j],
      aInstanceCreation,aImplementationClass);
    if result=nil then
      result := F; // returns the first registered interface
    AddServiceInternal(F);
  end;
end;

procedure TServiceContainerServer.OnCloseSession(aSessionID: cardinal);
var i: Integer;
    Inst: TServiceFactoryServerInstance;
begin
  Inst.InstanceID := aSessionID;
  for i := 0 to Count-1 do
    with TServiceFactoryServer(Index(i)) do
    if InstanceCreation=sicPerSession then
      InternalInstanceRetrieve(Inst,-1);
end;


{ TServiceFactoryServer }

constructor TServiceFactoryServer.Create(aRestServer: TSQLRestServer; aInterface: PTypeInfo;
  aInstanceCreation: TServiceInstanceImplementation;
  aImplementationClass: TClass; aTimeOutSec: cardinal);
begin
  // extract RTTI from the interface
  inherited Create(aRestServer,aInterface,aInstanceCreation);
  if fRest.MethodAddress(ShortString(InterfaceURI))<>nil then
    raise EServiceException.CreateFmt('%s is already exposed as %s published method',
      [InterfaceURI,fRest.ClassName]) else
  fImplementationClass := aImplementationClass;
  // initialize the shared instance or client driven parameters
  case InstanceCreation of
  sicShared: begin
    fSharedInstance := CreateInstance;
    if (fSharedInstance=nil) or
       not fSharedInstance.GetInterface(fInterfaceIID,fSharedInterface) then
      raise EServiceException.CreateFmt('No implementation available for "%s" interface',
        [fInterfaceURI]);
  end;
  sicClientDriven, sicPerSession, sicPerUser, sicPerGroup:
    if aTimeOutSec=0 then
      fInstanceCreation := sicSingle else begin
      // only instances list is protected, since client calls shall be pipelined
      InitializeCriticalSection(fInstanceLock); 
      fInstanceTimeOut := aTimeOutSec*1000;
      fInstance.Init(TypeInfo(TServiceFactoryServerInstanceDynArray),
        fInstances,@fInstancesCount);
      fInstance.Compare := SortDynArrayInteger;
    end;
  end;
end;

destructor TServiceFactoryServer.Destroy;
var i: integer;
begin
  try // release any internal instance (should have been done by client)
    for i := 0 to fInstancesCount-1 do
      if fInstances[i].Instance<>nil then
        fInstances[i].Instance.Free;
  except
    ; // better ignore any error in business logic code
  end;
  DeleteCriticalSection(fInstanceLock);
  inherited;
end;

function TServiceFactoryServer.Get(out Obj): Boolean;
var O: TObject;
begin
  result := false;
  if Self<>nil then
    case fInstanceCreation of
    sicShared:
    if fSharedInterface<>nil then begin
      IInterface(Obj) := fSharedInterface; // copy implementation interface
      result := true;
    end;
    else begin
      O := CreateInstance;
      if O<>nil then
        result := O.GetInterface(fInterfaceIID,Obj);
    end;
    end;
end;

function TServiceFactoryServer.RetrieveSignature: RawUTF8;
begin
  if self=nil then
    result := '' else
    result := Contract; // just return the current value
end;

procedure TServiceFactoryServerInstance.SafeFreeInstance;
begin
  try
    InstanceID := 0;
    FreeAndNil(Instance);
  except
    ; // just ignore any error in customer code
  end;
end;

function TServiceFactoryServer.InternalInstanceRetrieve(
  var Inst: TServiceFactoryServerInstance; aMethodIndex: integer): boolean;
procedure AddNew;
var i: integer;
    P: ^TServiceFactoryServerInstance;
begin
  Inst.Instance := CreateInstance;
  if Inst.Instance=nil then
    exit;
  P := pointer(fInstances);
  for i := 1 to fInstancesCount do
    if P^.InstanceID=0 then begin
      P^ := Inst; // found an empty entry -> use it
      exit;
    end else
    inc(P);
  fInstance.Add(Inst); // append a new entry
end;
var i: integer;
begin
  result := false;
  Inst.LastAccess := GetTickCount;
  EnterCriticalSection(fInstanceLock);
  try
    // first release any deprecated instances
    for i := 0 to fInstancesCount-1 do
      with fInstances[i] do
      if (Inst.LastAccess<LastAccess) or
         (QWord(Inst.LastAccess)>QWord(LastAccess)+QWord(fInstanceTimeout)) then
        SafeFreeInstance; // mark this entry is empty
    // retrieve or initialize a sicClientDriven instance
    if Inst.InstanceID=0 then begin
      if (cardinal(aMethodIndex)>=fMethodsCount) or
         (InstanceCreation<>sicClientDriven) then
        exit;
      // initialize the new instance
      inc(fInstanceCurrentID);
      Inst.InstanceID := fInstanceCurrentID;
      AddNew;
    end else begin
      // search the given instance
      for i := 0 to fInstancesCount-1 do
        with fInstances[i] do
        if InstanceID=Inst.InstanceID then begin
          if aMethodIndex<0 then begin
            // aMethodIndex=-1 for {"method":"_free_", "params":[], "id":1234}
            SafeFreeInstance;
            result := true; // successfully released instance
            exit;
          end;
          LastAccess := Inst.LastAccess;
          Inst.Instance := Instance;
          exit;
        end;
      // add any new session/user/group instance if necessary
      if InstanceCreation<>sicClientDriven then
        AddNew;
    end;
  finally
    LeaveCriticalSection(fInstanceLock);
  end;
end;

function TServiceFactoryServer.RestServer: TSQLRestServer;
begin
  result := TSQLRestServer(Rest);
end;

function TServiceFactoryServer.CreateInstance: TObject;
begin
  result := fImplementationClass.Create;
end;

function TServiceFactoryServer.ExecuteMethod(const aContext: TSQLRestServerSessionContext;
  aMethodIndex, aInstanceID: cardinal; aParamsJSONArray: PUTF8Char;
  var aResp, aHead, aErrorMsg: RawUTF8): cardinal;
var Inst: TServiceFactoryServerInstance;
    WR: TTextWriter;
    entry: PInterfaceEntry;
    ThreadServer: PServiceRunningContext;
begin
  result := HTML_BADREQUEST;
  // 1. initialize Inst.Instance and Inst.InstanceID
  Inst.InstanceID := 0;
  Inst.Instance := nil;
  case InstanceCreation of
    sicSingle:
      if aMethodIndex>=fMethodsCount then
        exit else
        Inst.Instance := CreateInstance;
    sicShared:
      if aMethodIndex>=fMethodsCount then
        exit else
        Inst.Instance := fSharedInstance;
    sicClientDriven, sicPerSession, sicPerUser, sicPerGroup: begin
      if InstanceCreation=sicClientDriven then
        Inst.InstanceID := aInstanceID else
        if aContext.Session>CONST_AUTHENTICATION_NOT_USED then
          case InstanceCreation of // authenticated user -> handle context
          sicPerSession: Inst.InstanceID := aContext.Session;
          sicPerUser:    Inst.InstanceID := aContext.User;
          sicPerGroup:   Inst.InstanceID := aContext.Group;
          end else
         aErrorMsg := '% mode expects an authenticated session';
      if aErrorMsg='' then
        if InternalInstanceRetrieve(Inst,aMethodIndex) then begin
          result := HTML_SUCCESS;
          exit; // {"method":"_free_", "params":[], "id":1234}
        end;
    end;
  end;
  if Inst.Instance=nil then begin
    if aErrorMsg='' then
      aErrorMsg := '% instance id:% not found or deprecated';
    aErrorMsg := FormatUTF8(pointer(aErrorMsg),
      [UnCamelCase(ServiceInstanceImplementationToText(InstanceCreation)),
       Inst.InstanceID]);
    exit;
  end;
  // 2. call method implementation
  try
    entry := Inst.Instance.GetInterfaceEntry(fInterfaceIID);
    if entry=nil then
      exit;
    ThreadServer := @ServiceContext;
    WR := TJSONSerializer.CreateOwnedStream;
    try
      with ThreadServer^ do begin
        Factory := self;
        Session := @aContext;
      end; // RunningThread is already set at thread initialization
      // root/calculator {"method":"add","params":[1,2]} -> {"result":[3],"id":0}
      try
        WR.AddShort('{"result":[');
        if not fMethods[aMethodIndex].InternalExecute(
            [PAnsiChar(Inst.Instance)+entry^.IOffset],aParamsJSONArray,WR,aHead) then
          exit; // wrong request
        if aHead='' then begin // aHead<>'' for TServiceCustomAnswer
          WR.AddShort('],"id":');
          WR.Add(Inst.InstanceID); // only used in sicClientDriven mode
          WR.AddShort('}');
        end;
        aResp := WR.Text;
        result := HTML_SUCCESS; // success
      except
        on E: Exception do begin
          result := 500; // Internal Server Error
          aErrorMsg := FormatUTF8('%: %',[E.ClassName,E.Message]);
          exit;
        end;
      end;
    finally
      with ThreadServer^ do begin
        Factory := nil;
        Session := nil;
      end;
      WR.Free;
    end;
  finally
    if InstanceCreation=sicSingle then
      Inst.Instance.Free; // always release single shot instance
  end;
end;

function TServiceFactoryServer.AllowAll: TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to fMethodsCount-1 do
      fillchar(fMethods[m].ExecutionDenied,sizeof(fMethods[m].ExecutionDenied),0);
  result := self;
end;

function TServiceFactoryServer.AllowAllByID(const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then
    for m := 0 to fMethodsCount-1 do
    with fMethods[m] do
      for g := 0 to high(aGroupID) do
        exclude(ExecutionDenied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.AllowAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if Rest.MainFieldIDs(TSQLAuthGroup,aGroup,IDs) then
      AllowAllByID(IDs);
  result := self;
end;

function TServiceFactoryServer.DenyAll: TServiceFactoryServer;
var m: integer;
begin
  if self<>nil then
    for m := 0 to fMethodsCount-1 do
      fillchar(fMethods[m].ExecutionDenied,sizeof(fMethods[m].ExecutionDenied),255);
  result := self;
end;

function TServiceFactoryServer.DenyAllByID(const aGroupID: array of integer): TServiceFactoryServer;
var m,g: integer;
begin
  if self<>nil then
    for m := 0 to fMethodsCount-1 do
    with fMethods[m] do
      for g := 0 to high(aGroupID) do
        include(ExecutionDenied,aGroupID[g]-1);
  result := self;
end;

function TServiceFactoryServer.DenyAllByName(const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if Rest.MainFieldIDs(TSQLAuthGroup,aGroup,IDs) then
      DenyAllByID(IDs);
  result := self;
end;

function TServiceFactoryServer.Allow(const aMethod: array of RawUTF8): TServiceFactoryServer;
var m,i: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do begin
      i := fMethod.FindHashed(aMethod[m]);
      if i>=0 then
        fillchar(fMethods[i].ExecutionDenied,sizeof(fMethods[i].ExecutionDenied),0);
    end;
  result := self;
end;

function TServiceFactoryServer.AllowByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
var m,g,i: integer;
begin
  if self<>nil then begin
    if high(aGroupID)>=0 then
    for m := 0 to high(aMethod) do begin
      i := fMethod.FindHashed(aMethod[m]);
      if i>=0 then
        with fMethods[i] do
          for g := 0 to high(aGroupID) do
            exclude(ExecutionDenied,aGroupID[g]-1);
    end;
  end;
  result := self;
end;

function TServiceFactoryServer.AllowByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if Rest.MainFieldIDs(TSQLAuthGroup,aGroup,IDs) then
      AllowByID(aMethod,IDs);
  result := self;
end;

function TServiceFactoryServer.Deny(const aMethod: array of RawUTF8): TServiceFactoryServer;
var m,i: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do begin
      i := fMethod.FindHashed(aMethod[m]);
      if i>=0 then
        fillchar(fMethods[i].ExecutionDenied,sizeof(fMethods[i].ExecutionDenied),255);
    end;
  result := self;
end;

function TServiceFactoryServer.DenyByID(const aMethod: array of RawUTF8; const aGroupID: array of integer): TServiceFactoryServer;
var m,g,i: integer;
begin
  if self<>nil then
    for m := 0 to high(aMethod) do begin
      i := fMethod.FindHashed(aMethod[m]);
      if i>=0 then
        with fMethods[i] do
          for g := 0 to high(aGroupID) do
            include(ExecutionDenied,aGroupID[g]-1);
    end;
  result := self;
end;

function TServiceFactoryServer.DenyByName(const aMethod: array of RawUTF8; const aGroup: array of RawUTF8): TServiceFactoryServer;
var IDs: TIntegerDynArray;
begin
  if self<>nil then
    if Rest.MainFieldIDs(TSQLAuthGroup,aGroup,IDs) then
      DenyByID(aMethod,IDs);
  result := self;
end;

function TServiceFactoryServer.ExecuteInMainThread(const aMethod: array of RawUTF8; Enable: boolean=true): TServiceFactoryServer;
var m,i: integer;
begin
  if self<>nil then
    if high(aMethod)<0 then
      for i := 0 to fMethodsCount-1 do
        with fMethods[i] do
        if Enable then
          include(ExecutionOptions,execInMainThread) else
          exclude(ExecutionOptions,execInMainThread) else
    for m := 0 to high(aMethod) do begin
      i := fMethod.FindHashed(aMethod[m]);
      if i>=0 then
        with fMethods[i] do
        if Enable then
          include(ExecutionOptions,execInMainThread) else
          exclude(ExecutionOptions,execInMainThread);
    end;
  result := self;
end;

{ TServiceMethodArgument }

const
  CONST_METHODDIRTOJSON: array[TServiceMethodValueDirection] of RawUTF8 = (
    // convert into generic in/out direction (assume result is out)
    'in','both','out','out');

  // AnsiString (Delphi <2009) is handled with care (may loose data otherwise)
  CONST_METHODTYPETOJSON: array[TServiceMethodValueType] of RawUTF8 = (
    '??','self','boolean', '', '','integer','cardinal','int64',
    'double','datetime','currency','utf8',
    {$ifdef UNICODE}'utf8'{$else}''{$endif},'utf8','','','');

function TServiceMethodArgument.SerializeToContract: RawUTF8;
begin
  result := '{"argument":"'+RawUTF8(ParamName^)+'","direction":"'+
    CONST_METHODDIRTOJSON[ValueDirection]+'","type":"';
  {$ifndef UNICODE}
  if ValueType=smvString then // will specify the Ansi code page for no data loss
    result := result+'ansi'+Int32ToUTF8(CurrentAnsiConvert.CodePage) else
  {$endif}
  if CONST_METHODTYPETOJSON[ValueType]='' then
    result := result+RawUTF8(TypeInfo^.Name) else
    result := result+CONST_METHODTYPETOJSON[ValueType];
  result := result+'"},';
end;


{$ifndef LVCL}

{ TInterfacedCollection }

constructor TInterfacedCollection.Create;
begin
  inherited Create(GetClass);
end;

{$endif LVCL}

{ TServiceMethod }

procedure ValueAdd(ValueType: TServiceMethodValueType; WR: TTextWriter; V: Pointer;
  SizeInStorage: integer);
begin
  case ValueType of
  smvBoolean:   WR.AddString(JSON_BOOLEAN[PBoolean(V)^]);
  smvEnum..smvInt64:
  case SizeInStorage of
    1: WR.Add(PByte(V)^);
    2: WR.Add(PWord(V)^);
    4: if ValueType=smvInteger then
         WR.Add(PInteger(V)^) else
         WR.AddU(PCardinal(V)^);
    8: WR.Add(PInt64(V)^);
  end;
  smvDouble, smvDateTime: WR.Add(PDouble(V)^);
  smvCurrency:   WR.AddCurr64(PInt64(V));
  smvRawUTF8:    WR.AddJSONEscape(PPointer(V)^);
  smvString:     WR.AddJSONEscapeString(PString(V)^);
  smvWideString: WR.AddJSONEscapeW(PPointer(V)^);
  smvObject:     WR.WriteObject(PPointer(V)^,false,false);
  end;
end;

procedure IgnoreComma(var P: PUTF8Char);
begin
  if P^ in [#1..' '] then repeat inc(P) until not(P^ in [#1..' ']);
  if P^=',' then inc(P);
end;

type
  TDynArrayFake = record
    Wrapper: TDynArray;
    Value: Pointer;
  end;
  TCallMethodArgs = record
    StackSize, StackAddr, method, EAX, EDX, ECX: PtrInt;
    res64: Int64Rec;
    resKind: TServiceMethodValueType;
  end;

procedure CallMethod(var Params: TCallMethodArgs);
asm
    push esi
    push ebp
    mov ebp,esp
    mov esi,eax
    mov eax,[esi].TCallMethodArgs.StackSize
    mov edx,dword ptr [esi].TCallMethodArgs.StackAddr
    add edx,eax // pascal/register convention = left-to-right
    shr eax,2
    jz @z
@n: sub edx,4
    mov ecx,[edx]
    push ecx
    dec eax
    jnz @n
@z: mov eax,[esi].TCallMethodArgs.&EAX
    mov edx,[esi].TCallMethodArgs.&EDX
    mov ecx,[esi].TCallMethodArgs.&ECX
    call [esi].TCallMethodArgs.method
    mov cl,[esi].TCallMethodArgs.resKind
    cmp cl,smvDouble
    je @d
    cmp cl,smvDateTime
    je @d
    cmp cl,smvCurrency
    jne @i
    fistp qword [esi].TCallMethodArgs.res64
    jmp @e
@d: fstp qword [esi].TCallMethodArgs.res64
    jmp @e
@i: mov [esi].TCallMethodArgs.res64.Lo,eax
    mov [esi].TCallMethodArgs.res64.Hi,edx
@e: mov esp,ebp
    pop ebp
    pop esi
end;


{$ifndef LVCL}
type
  TCollectionClass = class of TInterfacedCollection;
{$endif}
  
function TServiceMethod.InternalExecute(Instances: array of pointer;
  Par: PUTF8Char; Res: TTextWriter; var aHead: RawUTF8): boolean;
var Stack: TByteDynArray;
    RawUTF8s: TRawUTF8DynArray;
    Strings: TStringDynArray;
    WideStrings: TWideStringDynArray;
    Records: array of TBytes;
    Value: pointer;
    i,a: integer;
    wasString, valid: boolean;
    Val: PUTF8Char;
    ClassType: TClass;
    r: TCallMethodArgs;
    SyncMethod: TMethod;
    Int64s: array[0..MAX_METHOD_ARGS-1] of Int64;
    Objects: array[0..MAX_METHOD_ARGS-1] of TObject;
    DynArrays: array[0..MAX_METHOD_ARGS-1] of TDynArrayFake;
    Values: array[0..MAX_METHOD_ARGS-1] of PPointer;
begin
  result := false;
  if high(Instances)<0 then
    exit;
  SetLength(Stack,ArgsSizeInStack);
  if ArgsUsedCount[smvvRawUTF8]>0 then
    SetLength(RawUTF8s,ArgsUsedCount[smvvRawUTF8]);
  if ArgsUsedCount[smvvString]>0 then
    SetLength(Strings,ArgsUsedCount[smvvString]);
  if ArgsUsedCount[smvvWideString]>0 then
    SetLength(WideStrings,ArgsUsedCount[smvvWideString]);
  if ArgsUsedCount[smvvRecord]>0 then
    SetLength(Records,ArgsUsedCount[smvvRecord]);
  if ArgsUsedCount[smvvObject]>0 then
    fillchar(Objects,ArgsUsedCount[smvvObject]*sizeof(TObject),0); // for finally
  if ArgsUsedCount[smvvDynArray]>0 then
    fillchar(DynArrays,ArgsUsedCount[smvvDynArray]*sizeof(TDynArrayFake),0);
  try
    // 1. read the parameters
    if Par^ in [#1..' '] then repeat inc(Par) until not(Par^ in [#1..' ']);
    if Par^<>'[' then
      Exit;
    inc(Par);
    for a:= 0 to high(Args) do
    with Args[a] do begin
      case ValueType of
      smvSelf:
        continue; // self parameter is never transmitted
      smvObject: begin
        ClassType := TypeInfo^.ClassType^.ClassType;
        {$ifndef LVCL}
        if ClassType.InheritsFrom(TCollection) then
          if ClassType.InheritsFrom(TInterfacedCollection) then
            Objects[IndexVar] := TCollectionClass(ClassType).Create else
            raise EServiceException.Create('TInterfacedCollection expected') else
        {$endif}
          Objects[IndexVar] := ClassType.Create;
        if ValueDirection in [smdConst,smdVar] then begin
          Par := JSONToObject(Objects[IndexVar],Par,valid);
          if not valid then
            exit;
          IgnoreComma(Par);
        end;
      end;
      smvDynArray:
      with DynArrays[IndexVar] do begin
        Wrapper.Init(TypeInfo,Value);
        if ValueDirection in [smdConst,smdVar] then begin
          Par := Wrapper.LoadFromJSON(Par);
          if Par=nil then
            exit;
          IgnoreComma(Par);
        end;
      end;
      smvRecord: begin
        SetLength(Records[IndexVar],TypeInfo^.RecordType^.Size);
        if ValueDirection in [smdConst,smdVar] then
          Par := RecordLoadJSON(pointer(Records[IndexVar])^,Par,TypeInfo);
      end;
      smvBoolean..smvWideString:
      if ValueDirection in [smdConst,smdVar] then begin
        Val := GetJSONField(Par,Par,@wasString);
        if (Val=nil) or (wasString<>ValueIsString) then
          exit;
        case ValueType of
        smvBoolean..smvInt64:  SetInt64(Val,Int64s[IndexVar]);
        smvDouble,smvDateTime: PDouble(@Int64s[IndexVar])^ := GetExtended(Val);
        smvCurrency:   Int64s[IndexVar] := StrToCurr64(Val);
        smvRawUTF8:    RawUTF8s[IndexVar] := Val;
        smvString:     Strings[IndexVar] := UTF8DecodeToString(Val,StrLen(Val));
        smvWideString: UTF8ToWideString(Val,StrLen(Val),WideStrings[IndexVar]);
        end;
      end;
      else exit; // unhandled type
      end;
    end;
    // 2. create the stack content
    r.StackAddr := PtrInt(Stack);
    r.StackSize := ArgsSizeInStack;
    for a:= 0 to high(Args) do
    with Args[a] do begin
      case ValueVar of
      smvvSelf:       continue; // REGEAX will set directly r.EAX := Instance[]
      smvv64:         Value := @Int64s[IndexVar];
      smvvRawUTF8:    Value := @RawUTF8s[IndexVar];
      smvvString:     Value := @Strings[IndexVar];
      smvvWideString: Value := @WideStrings[IndexVar];
      smvvObject:     Value := @Objects[IndexVar];
      smvvRecord:     Value := pointer(Records[IndexVar]);
      smvvDynArray:   Value := @DynArrays[IndexVar].Value;
      else raise EServiceException.CreateFmt('Invalid argument type %d',[ord(ValueType)]);
      end;
      Values[a] := Value;
      if (ValueDirection<>smdConst) or (ValueType in [smvRecord,smvSelf]) then
        case OffsetInStack of // pass by reference
        REGEDX: r.EDX := PtrInt(Value);
        REGECX: r.ECX := PtrInt(Value);
        else    move(Value,Stack[OffsetInStack],SizeInStack);
        end else
        case OffsetInStack of // pass by value
        REGEDX: r.EDX := PPtrInt(Value)^;
        REGECX: r.ECX := PPtrInt(Value)^;
        else    move(Value^,Stack[OffsetInStack],SizeInStack);
        end;
    end;
    // 3. execute the method
    for i := 0 to high(Instances) do begin
      r.EAX := PtrInt(Instances[i]);
      r.method := PPtrIntArray(PPointer(Instances[i])^)^[MethodIndex];
      if ArgsResultIndex>=0 then
      with Args[ArgsResultIndex] do begin
        r.resKind := ValueType;
        if ValueVar=smvv64 then
          Values[ArgsResultIndex] := @r.res64;
      end else
        r.resKind := smvNone;
      {$ifndef LVCL}
      if (execInMainThread in ExecutionOptions) and
         (GetCurrentThreadID<>MainThreadID) then begin
        SyncMethod.Code := @CallMethod;
        SyncMethod.Data := @r; // fake call: PCallMethodArgs(self)^=Params
        TThread.Synchronize(ServiceContext.RunningThread,TThreadMethod(SyncMethod));
      end else
      {$endif}
        CallMethod(r);
    end;
    // 4. send back any result
    if Res<>nil then begin
      // 4.1 handle custom content (not JSON object answer)
      if (r.resKind=smvRecord) and ArgsResultIsServiceCustomAnswer then
        with PServiceCustomAnswer(Values[ArgsResultIndex])^ do
        if Header<>'' then begin
          Res.CancelAll;
          aHead := Header;
          if Res.Stream.InheritsFrom(TRawByteStringStream) then
            TRawByteStringStream(Res.Stream).DataString := Content else
            Res.Stream.Write(pointer(Content)^,length(Content));
          Result := true;
          exit;
        end;
      // 4.2 write the '{"result":[...' array
      for a:= 0 to high(Args) do
      with Args[a] do
      if ValueDirection in [smdVar,smdOut,smdResult] then begin
        if ValueIsString then
          Res.Add('"');
        case ValueType of
        smvRecord:   Res.AddRecordJSON(Values[a]^,TypeInfo);
        smvDynArray: Res.AddDynArrayJSON(DynArrays[IndexVar].Wrapper);
        else ValueAdd(ValueType,Res,Values[a],SizeInStorage);
        end;
        if ValueIsString then
          Res.Add('"',',') else
          Res.Add(',');
      end;
      Res.CancelLastComma;
    end;
    Result := true;
  finally // manual release memory for Records[], Objects[] and DynArrays[]
    for i := 0 to ArgsUsedCount[smvvObject]-1 do
      Objects[i].Free;
    for i := 0 to ArgsUsedCount[smvvDynArray]-1 do
      DynArrays[i].Wrapper.Clear;
    if Records<>nil then begin
      i := 0;
      for a := 0 to high(Args) do
        with Args[a] do
        if ValueType=smvRecord then begin
          RecordClear(pointer(Records[i])^,TypeInfo);
          inc(i);
        end;
    end;
  end;
end;


{ TServiceContainerClient }

function TServiceContainerClient.Info(aTypeInfo: PTypeInfo): TServiceFactory;
begin
  result := inherited Info(aTypeInfo);
  if (result=nil) and AddInterface(aTypeInfo,sicClientDriven) then
    result := inherited Info(aTypeInfo);
end;


{ TInterfacedObjectFake (private for TServiceFactoryClient) }

type
  /// map the stack memory layout at TInterfacedObjectFake.FakeCall()
  TFakeCallStack = packed record
    EDX, ECX, MethodIndex, EBP, Ret: Cardinal;
    Stack: array[word] of byte;
  end;

  /// instances of this class will emulate a given interface
  TInterfacedObjectFake = class(TInterfacedObject)
  protected
    fVTable: PPointerArray;
    fFactory: TServiceFactoryClient;
    fClientDrivenID: Cardinal;
    function FakeCall(var aCall: TFakeCallStack): Int64;
    function FakeQueryInterface(const IID: TGUID; out Obj): HResult; stdcall;
    function Fake_AddRef: Integer; stdcall;
    function Fake_Release: Integer; stdcall;
    function SelfFromInterface: TInterfacedObjectFake;
      {$ifdef PUREPASCAL} {$ifdef HASINLINE}inline;{$endif} {$endif}
  public
    /// create an instance, using the specified interface
    constructor Create(aFactory: TServiceFactoryClient);
    /// release the remote server instance (in sicClientDriven mode);
    destructor Destroy; override;
    /// the associated interface factory
    property Factory: TServiceFactoryClient read fFactory;
    /// the ID used in sicClientDriven mode
    property ClientDrivenID: Cardinal read fClientDrivenID;
  end;

constructor TInterfacedObjectFake.Create(aFactory: TServiceFactoryClient);
begin
  inherited Create;
  fFactory := aFactory;
  fVTable := Pointer(aFactory.fFakeVTable);
end;

destructor TInterfacedObjectFake.Destroy;
begin
  if (fFactory<>nil) and (fFactory.InstanceCreation=sicClientDriven) and
     (fClientDrivenID<>0) then // fClientDrivenID=0 if no instance used
  try // release server instance
    fFactory.CallClient(SERVICE_PSEUDO_METHOD[imFree],nil,'',nil,@fClientDrivenID);
  except
    ; // ignore any exception here
  end;
  inherited;
end;

function TInterfacedObjectFake.SelfFromInterface: TInterfacedObjectFake;
{$ifdef PUREPASCAL}
begin
  result := pointer(PtrInt(self)-PtrInt(@TInterfacedObjectFake(nil).fVTable));
end;
{$else}
asm
  sub eax,TInterfacedObjectFake.fVTable
end;
{$endif}

function TInterfacedObjectFake.Fake_AddRef: Integer;
begin
  result := SelfFromInterface._AddRef;
end;

function TInterfacedObjectFake.Fake_Release: Integer;
begin
  result := SelfFromInterface._Release;
end;

function TInterfacedObjectFake.FakeQueryInterface(const IID: TGUID; out Obj): HResult;
begin
  self := SelfFromInterface;
  if (fFactory<>nil) and IsEqualGUID(IID,fFactory.fInterfaceIID) then begin
    pointer(Obj) := @fVTable;
    _AddRef;
    result := NOERROR;
  end else
  if GetInterface(IID,Obj) then
    result := NOERROR else
    result := E_NOINTERFACE;
end;

function TInterfacedObjectFake.FakeCall(var aCall: TFakeCallStack): Int64;
procedure RaiseError(const Msg: string);
begin
  raise EServiceException.CreateFmt('Invalid "%s" interface call: %s',
    [fFactory.InterfaceURI,Msg]);
end;
var Params: TJSONSerializer;
    method: ^TServiceMethod;
    Error, ResArray: RawUTF8;
    a: integer;
    V: PPointer;
    R, Val: PUTF8Char;
    valid, wasString: boolean;
    ServiceCustomAnswerPoint: PServiceCustomAnswer;
    DynArrays: array[0..MAX_METHOD_ARGS-1] of TDynArray;
    Value: array[0..MAX_METHOD_ARGS-1] of pointer;
    I64s: array[0..MAX_METHOD_ARGS-1] of Int64;
begin
  self := SelfFromInterface;
  result := 0;
  if aCall.MethodIndex>=fFactory.fMethodsCount then
    RaiseError('out of range method');
  method := @fFactory.fMethods[aCall.MethodIndex];
  Params := TJSONSerializer.CreateOwnedStream;
  try
    // create the parameters
    FillChar(I64s,method^.ArgsUsedCount[smvv64]*sizeof(Int64),0);
    for a := 0 to high(method^.Args) do
    with method^.Args[a] do
    if ValueType>smvSelf then begin
      case OffsetInStack of
      REGEAX: RaiseError('unexpected self');
      REGEDX: V := @aCall.EDX;
      REGECX: V := @aCall.ECX;
      else if SizeInStack>0 then
        V := @aCall.Stack[OffsetInStack] else
        V := @I64s[IndexVar]; // for results in CPU
      end;
      if (ValueType=smvRecord) or 
         (ValueDirection in [smdVar,smdOut]) or
         ((ValueDirection=smdResult) and (ValueType in CONST_ARGS_RESULT_BY_REF)) then
        V := PPointer(V)^; // passed by reference -> retrieve original var
      if ValueType=smvDynArray then
        DynArrays[IndexVar].Init(TypeInfo,V^);
      Value[a] := V;
      case ValueDirection of
      smdConst, smdVar: begin
        if ValueIsString then
          Params.Add('"');
        case ValueType of
        smvRecord:   Params.AddRecordJSON(V^,TypeInfo);
        smvDynArray: Params.AddDynArrayJSON(DynArrays[IndexVar]);
        else ValueAdd(ValueType,Params,V,SizeInStorage);
        end;
        if ValueIsString then
          Params.Add('"',',') else
          Params.Add(',');
      end;
      end;
    end;
    Params.CancelLastComma;
    // call remote server
    if method^.ArgsResultIsServiceCustomAnswer then
      ServiceCustomAnswerPoint := Value[method^.ArgsResultIndex] else
      ServiceCustomAnswerPoint := nil;
    if not fFactory.CallClient(method^.URI,@Error,
       Params.Text,@ResArray,@fClientDrivenID,ServiceCustomAnswerPoint) then
      raise EServiceException.CreateFmt('Error calling %s.%s remote method%s',
        [fFactory.fInterfaceURI,method^.URI,Error]);
  finally
    Params.Free;
  end;
  // retrieve method result and var/out parameters content
  if ServiceCustomAnswerPoint=nil then begin
    R := pointer(ResArray);
    if R^ in [#1..' '] then repeat inc(R) until not(R^ in [#1..' ']);
    if R^<>'[' then
      RaiseError('array result expected');
    inc(R);
    for a:= 0 to high(method^.Args) do
    with method^.Args[a] do
    if ValueDirection in [smdVar,smdOut,smdResult] then begin
      V := Value[a];
      case ValueType of
      smvObject: begin
        R := JSONToObject(V^,R,valid);
        if not valid then
          RaiseError('returned object');
        IgnoreComma(R);
      end;
      smvDynArray: begin
        R := DynArrays[IndexVar].LoadFromJSON(R);
        if R=nil then
          RaiseError('returned array');
        IgnoreComma(R);
      end;
      smvBoolean..smvWideString: begin
        Val := GetJSONField(R,R,@wasString);
        if (Val=nil) or (wasString<>ValueIsString) then
          RaiseError('returned item');
        case ValueType of
        smvBoolean, smvEnum, smvSet, smvCardinal:
          case SizeInStorage of
          1: PByte(V)^     := GetCardinal(Val);
          2: PWord(V)^     := GetCardinal(Val);
          4: PCardinal(V)^ := GetCardinal(Val);
          end;
        smvInteger:    PInteger(V)^ := GetInteger(Val);
        smvInt64:      SetInt64(Val,PInt64(V)^);
        smvDouble,smvDateTime: PDouble(V)^ := GetExtended(Val);
        smvCurrency:   PInt64(V)^   := StrToCurr64(Val);
        smvRawUTF8:    PRawUTF8(V)^ := Val;
        smvString:     PString(V)^  := UTF8DecodeToString(Val,StrLen(Val));
        smvWideString: UTF8ToWideString(Val,StrLen(Val),PWideString(V)^);
        end;
      end;
      smvRecord: begin
        R := RecordLoadJSON(V^,R,TypeInfo);
        if R=nil then
          RaiseError('returned record');
      end;
      end;
      if ValueDirection=smdResult then
      case ValueType of // ordinal/real result values to CPU/FPU registers
      smvBoolean..smvInt64: Move(V^,result,SizeInStorage);   // al/ax/eax/eax:edx
      smvDouble,smvDateTime: asm mov eax,V; fld  qword ptr [eax] end;  // in st(0)
      smvCurrency: asm mov eax,V; fild qword ptr [eax] end;  // in st(0)
      end;
    end;
  end;
end;


{ TServiceFactoryClient }

const
  // log up to 20 KB of JSON response, to save space
  MAX_SIZE_RESPONSE_LOG = 20*1024;
  
function TServiceFactoryClient.CallClient(const aMethod: RawUTF8;
  aErrorMsg: PRawUTF8; const aParams: RawUTF8; aResult: PRawUTF8;
  aClientDrivenID: PCardinal; aServiceCustomAnswer: PServiceCustomAnswer): boolean;
var uri,sent,resp,head: RawUTF8;
    Values: TPUtf8CharDynArray;
begin
  result := false;
  if Self=nil then
    exit;
  if fClient=nil then
    fClient := fRest as TSQLRestClientURI;
{$ifdef WITHLOG}
  SQLite3Log.Enter(Self,pointer(fInterfaceURI+'.'+aMethod));
{$endif}
  // compute URI according to current routing scheme
  uri := fClient.Model.Root+'/';
  if fRest.Services.ExpectMangledURI then
    uri := uri+fInterfaceMangledURI else
    uri := uri+fInterfaceURI;
  case fRest.ServicesRouting of
  rmREST: begin
    if (aClientDrivenID<>nil) and (aClientDrivenID^>0) then
      uri := FormatUTF8('%.%/%',[uri,aMethod,aClientDrivenID^]) else
      uri := uri+'.'+aMethod;
    sent := '['+aParams+']'; // we may also encode them within the URI 
  end;
  rmJSON_RPC: begin
    sent := '{"method":"'+aMethod+'","params":['+aParams;
    if aClientDrivenID=nil then
      sent := sent+']}' else
      sent := sent+'], "id":'+UInt32ToUTF8(aClientDrivenID^)+'}';
  end;
  else exit;
  end;
  // call remote server
  if fClient.URI(uri,'POST',@resp,@head,@sent).Lo<>HTML_SUCCESS then begin
    if aErrorMsg<>nil then
      aErrorMsg^ := ': '+resp;
    exit;
  end;
  // decode result
  if aServiceCustomAnswer=nil then begin // decode JSON object
  {$ifdef WITHLOG}
    with SQLite3Log.Family do
      if sllServiceReturn in Level then
        if length(resp)<=MAX_SIZE_RESPONSE_LOG then
          SynLog.Log(sllServiceReturn,resp) else begin
          SetString(uri,PAnsiChar(pointer(resp)),MAX_SIZE_RESPONSE_LOG);
          SynLog.Log(sllServiceReturn,uri); // truncate huge JSON response in log
        end;
  {$endif}
    JSONDecode(resp,['result','id'],Values,True);
    if (Values[0]=nil) or (Values[1]=nil) then
      exit;
    if aResult<>nil then
      aResult^ := Values[0];
    if aClientDrivenID<>nil then
      aClientDrivenID^ := GetCardinal(Values[1]);
  end else begin                         // BLOB answer
  {$ifdef WITHLOG}
    SQLite3Log.Add.Log(sllServiceReturn,'% length=%',[head,length(resp)]);
  {$endif}
    aServiceCustomAnswer^.Header := head;
    aServiceCustomAnswer^.Content := resp;
    if aClientDrivenID<>nil then
      aClientDrivenID^ := 0;
  end;
  result := true;
end;

constructor TServiceFactoryClient.Create(aRest: TSQLRest;
  aInterface: PTypeInfo; aInstanceCreation: TServiceInstanceImplementation;
  const aContractExpected: RawUTF8);
var i, siz: integer;
    P: PCardinal;
    Error, RemoteContract: RawUTF8;
begin
  // extract RTTI from the interface
  if not aRest.InheritsFrom(TSQLRestClientURI) then
    EServiceException.CreateFmt('%s interface needs a Client connection',
      [aInterface^.Name]);
  inherited Create(aRest,aInterface,aInstanceCreation);
  // check if this interface is supported on the server
  if aContractExpected<>'' then
    fContractExpected := aContractExpected; // override default contract
  if not CallClient(SERVICE_PSEUDO_METHOD[imContract],@Error,'',@RemoteContract) then
    raise EServiceException.CreateFmt('"%s" interface or %s routing not supported by server%s',
      [fInterfaceURI,GetEnumNameTrimed(TypeInfo(TServiceRoutingMode),fRest.ServicesRouting),Error]);
  if '['+ContractExpected+']'<>RemoteContract then
    raise EServiceException.CreateFmt(
      'Server''s %s contract differs from client''s: expected [%s], received %s',
      [fInterfaceURI,ContractExpected,RemoteContract]);
  // create the fake interface
  SetLength(fFakeVTable,fMethodsCount+RESERVED_VTABLE_SLOTS);
  fFakeVTable[0] := @TInterfacedObjectFake.FakeQueryInterface;
  fFakeVTable[1] := @TInterfacedObjectFake.Fake_AddRef;
  fFakeVTable[2] := @TInterfacedObjectFake.Fake_Release;
  siz := (((fMethodsCount*24) shr 12)+1) shl 12; // 4 KB granularity
  fFakeStub := VirtualAlloc(nil,siz,MEM_COMMIT,PAGE_EXECUTE_READWRITE);
  P := pointer(fFakeStub);
  for i := 0 to fMethodsCount-1 do begin
    fFakeVTable[i+RESERVED_VTABLE_SLOTS] := P;
    P^ := $68ec8b55; inc(P);                 // push ebp; mov ebp,esp
    P^ := i; inc(P);                         // push {MethodIndex}
    P^ := $e2895251; inc(P);                 // push ecx; push edx; mov edx,esp
    PByte(P)^ := $e8; inc(PByte(P));         // call FakeCall
    P^ := PtrUInt(@TInterfacedObjectFake.FakeCall)-PtrUInt(P)-4; inc(P);
    P^ := $c25dec89; inc(P);                 // mov esp,ebp; pop ebp
    P^ := fMethods[i].ArgsSizeInStack or $900000;  // ret {StackSize}; nop
    inc(PByte(P),3);
  end;
  // initialize a shared instance (if needed)
  if fInstanceCreation=sicShared then begin
    fSharedInstance := TInterfacedObjectFake.Create(self);
    TInterfacedObjectFake(fSharedInstance)._AddRef; // force stay alive
  end;
end;

function TServiceFactoryClient.Get(out Obj): Boolean;
var O: TInterfacedObjectFake;
begin
  result := false;
  if Self=nil then
    exit;
  case fInstanceCreation of
  sicShared:
    O := TInterfacedObjectFake(fSharedInstance);
  sicSingle, sicClientDriven:
    O := TInterfacedObjectFake.Create(self);
  else exit;
  end;
  pointer(Obj) := @O.fVTable;
  O._AddRef;
  result := true;
end;

function TServiceFactoryClient.RetrieveSignature: RawUTF8;
begin
  if CallClient(SERVICE_PSEUDO_METHOD[imSignature],nil,'',@result) and
     (result<>'') and (result[1]='[') then
    result := copy(result,2,length(result)-2) else
    result := '';
end;

destructor TServiceFactoryClient.Destroy;
begin
  if fSharedInstance<>nil then
  with TInterfacedObjectFake(fSharedInstance) do
    if fRefCount<>1 then
      raise EServiceException.CreateFmt(
        'RefCount=%d: shall release I%s interface (.. := nil) before Client.Free',
        [fRefCount,fInterfaceURI]) else
      _Release; // bonne nuit les petits
  if fFakeStub<>nil then
    VirtualFree(fFakeStub,0,MEM_RELEASE);
  inherited;
end;



function ObjectFromInterface(const aValue: IInterface): TObject;
{$ifndef ISDELPHI2010}
{$ifndef CPU64}
type
  TObjectFromInterfaceStub = packed record
    Stub: cardinal;
    case integer of
    0: (ShortJmp: shortint);
    1: (LongJmp:  longint)
  end;
  PObjectFromInterfaceStub = ^TObjectFromInterfaceStub;
{$endif}
{$endif}
begin
  if aValue=nil then
    result := nil else
    {$ifdef CPU64}
    result := aValue as TObject;
    {$else}
    {$ifdef ISDELPHI2010}
    result := aValue as TObject; // slower but always working
    {$else}
    with PObjectFromInterfaceStub(PPointer(PPointer(aValue)^)^)^ do
    case Stub of // address of VMT[0] entry, i.e. QueryInterface
      $04244483: result := pointer(PtrInt(aValue)+ShortJmp);
      $04244481: result := pointer(PtrInt(aValue)+LongJmp);
      else
      if Stub=PCardinal(@TInterfacedObjectFake.FakeQueryInterface)^ then
        result := TInterfacedObjectFake(pointer(aValue)).SelfFromInterface else
        result := nil;
    end;
    {$endif}
    {$endif}
end;

procedure SetWeak(aInterfaceField: PIInterface; const aValue: IInterface);
begin
  PPointer(aInterfaceField)^ := Pointer(aValue);
end;

type
  TSetWeakZeroInstance = class(TObjectListHashed)
  protected
    fInstance: TObject;
  public
    constructor Create(aObject: TObject; aReference: pointer);
    destructor Destroy; override;
    property Instance: TObject read fInstance;
  end;

  TSetWeakZeroClass = class(TObjectListPropertyHashed)
  protected
    fHookedFreeInstance: PtrUInt;
    procedure HookedFreeInstance;
  public
    constructor Create(aClass: TClass);
    function Find(aObject: TObject): TSetWeakZeroInstance;
    function FindOrAdd(aObject: TObject; aReference: pointer): TSetWeakZeroInstance;
  end;

var
  SetWeakZeroLock: TRTLCriticalSection;

  
{ TSetWeakZeroInstance }

constructor TSetWeakZeroInstance.Create(aObject: TObject; aReference: pointer);
var wasAdded: boolean;
begin
  inherited Create(false);
  fInstance := aObject;
  Add(aReference,wasAdded);
  //assert(IndexOf(aReference)>=0);
end;

destructor TSetWeakZeroInstance.Destroy;
var i: integer;
begin
  for i := 0 to Count-1 do
    PPointer(List[i])^ := nil;
  inherited;
end;


{ TSetWeakZeroClass }

function WeakZeroClassSubProp(aObject: TObject): TObject;
begin
  result := TSetWeakZeroInstance(aObject).fInstance;
end;

constructor TSetWeakZeroClass.Create(aClass: TClass);
var P: PPtrUInt;
begin
  inherited Create(@WeakZeroClassSubProp);
  GarbageCollector.Add(self);
  P := pointer(PtrInt(aClass)+vmtAutoTable);
  if P^=PtrUInt(self) then
    exit;
  if P^=0 then
    PatchCodePtrUInt(P,PtrUInt(self)) else
  if PPointer(P^)^=TSQLRecordProperties then
    TSQLRecordProperties(P^).fWeakZeroClass := self else
    raise EORMException.CreateFmt('%s class is not compatible with SetWeakZero: '+
      'vmtAutoTable slot used',[aClass.ClassName]);
  {$WARN SYMBOL_DEPRECATED OFF}
  P := pointer(PtrInt(aClass)+vmtFreeInstance);
  {$WARN SYMBOL_DEPRECATED ON}
  fHookedFreeInstance := P^;
  PatchCodePtrUInt(P,PtrUInt(@TSetWeakZeroClass.HookedFreeInstance));
end;

function GetWeakZeroClass(aObject: TObject): TSetWeakZeroClass; {$ifdef HASINLINE}inline;{$endif}
begin
  result := PPointer(PPtrInt(aObject)^+vmtAutoTable)^;
  if (result<>nil) and (PPointer(result)^=TSQLRecordProperties) then
    result := TSetWeakZeroClass(TSQLRecordProperties(result).fWeakZeroClass);
end;

function GetWeakZeroInstance(aObject: TObject): TSetWeakZeroInstance;
begin
  result := GetWeakZeroClass(aObject).Find(aObject);
end;

procedure TSetWeakZeroClass.HookedFreeInstance;
type Call = procedure(self: TObject);
begin
  with GetWeakZeroClass(self) do begin
    EnterCriticalSection(SetWeakZeroLock);
    try
      Delete(self);
    finally
      LeaveCriticalSection(SetWeakZeroLock);
    end;
    Call(fHookedFreeInstance)(self);
  end;
end;

function TSetWeakZeroClass.Find(aObject: TObject): TSetWeakZeroInstance;
var i: integer;
begin
  i := IndexOf(aObject); // search List[i].fInstance=aObject
  if i>=0 then
    result := TSetWeakZeroInstance(List[i]) else
    result := nil;
end;

function TSetWeakZeroClass.FindOrAdd(aObject: TObject; aReference: pointer): TSetWeakZeroInstance;
var wasAdded: boolean;
    i: integer;
begin
  if self=nil then
    self := TSetWeakZeroClass.Create(PPointer(aObject)^);
  i := inherited Add(aObject,wasAdded);
  if wasAdded then begin
    result := TSetWeakZeroInstance.Create(aObject,aReference);
    List[i] := result;
    //assert(IndexOf(aObject)>=0);
  end else begin
    result := TSetWeakZeroInstance(List[i]);
    result.Add(aReference,wasAdded);
  end;
  //assert(result.IndexOf(aReference)>=0);
  //assert(result.fInstance=aObject);
end;

procedure DeleteWeakZeroInstance(aObject: TObject; aObjectInterfaceField: pointer);
begin
  GetWeakZeroInstance(aObject).Delete(TObject(aObjectInterfaceField));
end;

procedure SetWeakZeroInstance(aObject: TObject; aObjectInterfaceField: pointer);
begin
  GetWeakZeroClass(aObject).FindOrAdd(aObject,aObjectInterfaceField);
end;
   
procedure SetWeakZero(aObject: TObject; aObjectInterfaceField: PIInterface;
  const aValue: IInterface);
begin
  if (aObjectInterfaceField=nil) or (aObject=nil) or (aObjectInterfaceField^=aValue) then
    exit;
  EnterCriticalSection(SetWeakZeroLock);
  try
    if aObjectInterfaceField^<>nil then begin
      if aValue=nil then
        DeleteWeakZeroInstance(aObject,aObjectInterfaceField);
      DeleteWeakZeroInstance(ObjectFromInterface(aObjectInterfaceField^),aObjectInterfaceField);
      SetWeak(aObjectInterfaceField,nil);
      if aValue=nil then
        exit;
    end;
    SetWeakZeroInstance(aObject,aObjectInterfaceField);
    SetWeakZeroInstance(ObjectFromInterface(aValue),aObjectInterfaceField);
    SetWeak(aObjectInterfaceField,aValue);
  finally
    LeaveCriticalSection(SetWeakZeroLock);
  end;
end;

{$ifdef ISDELPHIXE}
procedure TWeakZeroInterfaceHelper.SetWeak0(aObjectInterfaceField: PIInterface;
  const aValue: IInterface);
begin
  SetWeakZero(self,aObjectInterfaceField,aValue);
end;
{$endif}


initialization
  pointer(@SQLFieldTypeComp[sftAnsiText]) := @AnsiIComp;
{$ifndef USENORMTOUPPER}
  pointer(@SQLFieldTypeComp[sftUTF8Text]) := @AnsiIComp;
{$endif}
  DefaultHasher := @crc32; // faster and more accurate than kr32()
  InitializeCriticalSection(SetWeakZeroLock); // not to be cleaned (global to MM)

  assert(sizeof(TServiceMethod)and 3=0,'Adjust padding');

end.
